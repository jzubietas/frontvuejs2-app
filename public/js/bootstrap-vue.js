/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/bootstrap-vue/dist/bootstrap-vue.js":
/*!**********************************************************!*\
  !*** ./node_modules/bootstrap-vue/dist/bootstrap-vue.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n/*!\n * BootstrapVue 2.5.0\n *\n * @link https://bootstrap-vue.js.org\n * @source https://github.com/bootstrap-vue/bootstrap-vue\n * @copyright (c) 2016-2020 BootstrapVue\n * @license MIT\n * https://github.com/bootstrap-vue/bootstrap-vue/blob/master/LICENSE\n */\n\n(function (global, factory) {\n   true ? module.exports = factory(__webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm.js\")) :\n  0;\n}(this, (function (Vue) { 'use strict';\n\n  Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) _setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n\n    return _construct.apply(null, arguments);\n  }\n\n  function _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n  }\n\n  function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !_isNativeFunction(Class)) return Class;\n\n      if (typeof Class !== \"function\") {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n\n      if (typeof _cache !== \"undefined\") {\n        if (_cache.has(Class)) return _cache.get(Class);\n\n        _cache.set(Class, Wrapper);\n      }\n\n      function Wrapper() {\n        return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n      }\n\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      return _setPrototypeOf(Wrapper, Class);\n    };\n\n    return _wrapNativeSuper(Class);\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  function _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get(target, property, receiver || target);\n  }\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n      return;\n    }\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n\n  //\n\n  // --- Static ---\n  var from = function from() {\n    return Array.from.apply(Array, arguments);\n  };\n  var isArray = function isArray(val) {\n    return Array.isArray(val);\n  }; // --- Instance ---\n\n  var arrayIncludes = function arrayIncludes(array, value) {\n    return array.indexOf(value) !== -1;\n  };\n  var concat = function concat() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return Array.prototype.concat.apply([], args);\n  };\n\n  var assign = function assign() {\n    return Object.assign.apply(Object, arguments);\n  };\n  var create = function create(proto, optionalProps) {\n    return Object.create(proto, optionalProps);\n  };\n  var defineProperties = function defineProperties(obj, props) {\n    return Object.defineProperties(obj, props);\n  };\n  var defineProperty = function defineProperty(obj, prop, descr) {\n    return Object.defineProperty(obj, prop, descr);\n  };\n  var freeze = function freeze(obj) {\n    return Object.freeze(obj);\n  };\n  var getOwnPropertyNames = function getOwnPropertyNames(obj) {\n    return Object.getOwnPropertyNames(obj);\n  };\n  var keys = function keys(obj) {\n    return Object.keys(obj);\n  }; // --- \"Instance\" ---\n\n  var hasOwnProperty = function hasOwnProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  };\n  var toString = function toString(obj) {\n    return Object.prototype.toString.call(obj);\n  }; // --- Utilities ---\n\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   * Note object could be a complex type like array, date, etc.\n   */\n\n  var isObject = function isObject(obj) {\n    return obj !== null && _typeof(obj) === 'object';\n  };\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n\n  var isPlainObject = function isPlainObject(obj) {\n    return Object.prototype.toString.call(obj) === '[object Object]';\n  };\n  /**\n   * Shallow copy an object. If the passed in object\n   * is null or undefined, returns an empty object\n   */\n\n  var clone = function clone(obj) {\n    return _objectSpread2({}, obj);\n  };\n  /**\n   * Return a shallow copy of object with\n   * the specified properties omitted\n   * @link https://gist.github.com/bisubus/2da8af7e801ffd813fab7ac221aa7afc\n   */\n\n  var omit = function omit(obj, props) {\n    return keys(obj).filter(function (key) {\n      return props.indexOf(key) === -1;\n    }).reduce(function (result, key) {\n      return _objectSpread2({}, result, _defineProperty({}, key, obj[key]));\n    }, {});\n  };\n  /**\n   * Convenience method to create a read-only descriptor\n   */\n\n  var readonlyDescriptor = function readonlyDescriptor() {\n    return {\n      enumerable: true,\n      configurable: false,\n      writable: false\n    };\n  };\n  /**\n   * Deep-freezes and object, making it immutable / read-only.\n   * Returns the same object passed-in, but frozen.\n   * Freezes inner object/array/values first.\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n   * Note: this method will not work for property values using Symbol() as a key\n   */\n\n  var deepFreeze = function deepFreeze(obj) {\n    // Retrieve the property names defined on object/array\n    // Note: `keys` will ignore properties that are keyed by a `Symbol()`\n    var props = keys(obj); // Iterate over each prop and recursively freeze it\n\n    props.forEach(function (prop) {\n      var value = obj[prop]; // If value is a plain object or array, we deepFreeze it\n\n      obj[prop] = value && (isPlainObject(value) || isArray(value)) ? deepFreeze(value) : value;\n    });\n    return freeze(obj);\n  };\n\n  /**\n   * Utilities to get information about the current environment\n   */\n  // --- Constants ---\n  var hasWindowSupport = typeof window !== 'undefined';\n  var hasDocumentSupport = typeof document !== 'undefined';\n  var hasNavigatorSupport = typeof navigator !== 'undefined';\n  var hasPromiseSupport = typeof Promise !== 'undefined';\n  var hasMutationObserverSupport = typeof MutationObserver !== 'undefined' || typeof WebKitMutationObserver !== 'undefined' || typeof MozMutationObserver !== 'undefined';\n  var isBrowser = hasWindowSupport && hasDocumentSupport && hasNavigatorSupport; // Browser type sniffing\n\n  var userAgent = isBrowser ? window.navigator.userAgent.toLowerCase() : '';\n  var isJSDOM = userAgent.indexOf('jsdom') > 0;\n  var isIE = /msie|trident/.test(userAgent); // Determine if the browser supports the option passive for events\n\n  var hasPassiveEventSupport = function () {\n    var passiveEventSupported = false;\n\n    if (isBrowser) {\n      try {\n        var options = {\n          get passive() {\n            // This function will be called when the browser\n            // attempts to access the passive property.\n\n            /* istanbul ignore next: will never be called in JSDOM */\n            passiveEventSupported = true;\n          }\n\n        };\n        window.addEventListener('test', options, options);\n        window.removeEventListener('test', options, options);\n      } catch (err) {\n        /* istanbul ignore next: will never be called in JSDOM */\n        passiveEventSupported = false;\n      }\n    }\n\n    return passiveEventSupported;\n  }();\n  var hasTouchSupport = isBrowser && ('ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0);\n  var hasPointerEventSupport = isBrowser && Boolean(window.PointerEvent || window.MSPointerEvent);\n  var hasIntersectionObserverSupport = isBrowser && 'IntersectionObserver' in window && 'IntersectionObserverEntry' in window && // Edge 15 and UC Browser lack support for `isIntersecting`\n  // but we an use intersectionRatio > 0 instead\n  // 'isIntersecting' in window.IntersectionObserverEntry.prototype &&\n  'intersectionRatio' in window.IntersectionObserverEntry.prototype; // --- Getters ---\n\n  var getEnv = function getEnv(key) {\n    var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var env = typeof process !== 'undefined' && process ? process.env || {} : {};\n\n    if (!key) {\n      /* istanbul ignore next */\n      return env;\n    }\n\n    return env[key] || fallback;\n  };\n  var getNoWarn = function getNoWarn() {\n    return getEnv('BOOTSTRAP_VUE_NO_WARN');\n  };\n\n  var w = hasWindowSupport ? window : {};\n  var Element$1 = hasWindowSupport ? w.Element :\n  /*#__PURE__*/\n  function (_Object) {\n    _inherits(Element, _Object);\n\n    function Element() {\n      _classCallCheck(this, Element);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(Element).apply(this, arguments));\n    }\n\n    return Element;\n  }(_wrapNativeSuper(Object));\n  var HTMLElement = hasWindowSupport ? w.HTMLElement :\n  /*#__PURE__*/\n  function (_Element) {\n    _inherits(HTMLElement, _Element);\n\n    function HTMLElement() {\n      _classCallCheck(this, HTMLElement);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(HTMLElement).apply(this, arguments));\n    }\n\n    return HTMLElement;\n  }(Element$1);\n  var SVGElement = hasWindowSupport ? w.SVGElement :\n  /*#__PURE__*/\n  function (_Element2) {\n    _inherits(SVGElement, _Element2);\n\n    function SVGElement() {\n      _classCallCheck(this, SVGElement);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(SVGElement).apply(this, arguments));\n    }\n\n    return SVGElement;\n  }(Element$1);\n  var File = hasWindowSupport ? w.File :\n  /*#__PURE__*/\n  function (_Object2) {\n    _inherits(File, _Object2);\n\n    function File() {\n      _classCallCheck(this, File);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(File).apply(this, arguments));\n    }\n\n    return File;\n  }(_wrapNativeSuper(Object));\n\n  var toType = function toType(val) {\n    return _typeof(val);\n  };\n  var toRawType = function toRawType(val) {\n    return Object.prototype.toString.call(val).slice(8, -1);\n  };\n  var isUndefined = function isUndefined(val) {\n    return val === undefined;\n  };\n  var isNull = function isNull(val) {\n    return val === null;\n  };\n  var isUndefinedOrNull = function isUndefinedOrNull(val) {\n    return isUndefined(val) || isNull(val);\n  };\n  var isFunction = function isFunction(val) {\n    return toType(val) === 'function';\n  };\n  var isBoolean = function isBoolean(val) {\n    return toType(val) === 'boolean';\n  };\n  var isString = function isString(val) {\n    return toType(val) === 'string';\n  };\n  var isNumber = function isNumber(val) {\n    return toType(val) === 'number';\n  };\n  var isDate = function isDate(val) {\n    return val instanceof Date;\n  };\n  var isEvent = function isEvent(val) {\n    return val instanceof Event;\n  };\n  var isFile = function isFile(val) {\n    return val instanceof File;\n  };\n  var isRegExp = function isRegExp(val) {\n    return toRawType(val) === 'RegExp';\n  };\n  var isPromise = function isPromise(val) {\n    return !isUndefinedOrNull(val) && isFunction(val.then) && isFunction(val.catch);\n  }; // Extra convenience named re-exports\n\n  var cloneDeep = function cloneDeep(obj) {\n    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : obj;\n\n    if (isArray(obj)) {\n      return obj.reduce(function (result, val) {\n        return [].concat(_toConsumableArray(result), [cloneDeep(val, val)]);\n      }, []);\n    }\n\n    if (isPlainObject(obj)) {\n      return keys(obj).reduce(function (result, key) {\n        return _objectSpread2({}, result, _defineProperty({}, key, cloneDeep(obj[key], obj[key])));\n      }, {});\n    }\n\n    return defaultValue;\n  };\n\n  var identity = function identity(x) {\n    return x;\n  };\n\n  var RX_ARRAY_NOTATION = /\\[(\\d+)]/g;\n  /**\n   * Get property defined by dot/array notation in string.\n   *\n   * @link https://gist.github.com/jeneg/9767afdcca45601ea44930ea03e0febf#gistcomment-1935901\n   *\n   * @param {Object} obj\n   * @param {string|Array} path\n   * @param {*} defaultValue (optional)\n   * @return {*}\n   */\n\n  var get = function get(obj, path) {\n    var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    // Handle array of path values\n    path = isArray(path) ? path.join('.') : path; // If no path or no object passed\n\n    if (!path || !isObject(obj)) {\n      return defaultValue;\n    } // Handle edge case where user has dot(s) in top-level item field key\n    // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2762\n    // Switched to `in` operator vs `hasOwnProperty` to handle obj.prototype getters\n    // https://github.com/bootstrap-vue/bootstrap-vue/issues/3463\n\n\n    if (path in obj) {\n      return obj[path];\n    } // Handle string array notation (numeric indices only)\n\n\n    path = String(path).replace(RX_ARRAY_NOTATION, '.$1');\n    var steps = path.split('.').filter(identity); // Handle case where someone passes a string of only dots\n\n    if (steps.length === 0) {\n      return defaultValue;\n    } // Traverse path in object to find result\n    // We use `!=` vs `!==` to test for both `null` and `undefined`\n    // Switched to `in` operator vs `hasOwnProperty` to handle obj.prototype getters\n    // https://github.com/bootstrap-vue/bootstrap-vue/issues/3463\n\n\n    return steps.every(function (step) {\n      return isObject(obj) && step in obj && (obj = obj[step]) != null;\n    }) ? obj : defaultValue;\n  };\n\n  /**\n   * Log a warning message to the console with BootstrapVue formatting\n   * @param {string} message\n   */\n\n  var warn = function warn(message)\n  /* istanbul ignore next */\n  {\n    var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (!getNoWarn()) {\n      console.warn(\"[BootstrapVue warn]: \".concat(source ? \"\".concat(source, \" - \") : '').concat(message));\n    }\n  };\n  /**\n   * Warn when no Promise support is given\n   * @param {string} source\n   * @returns {boolean} warned\n   */\n\n  var warnNotClient = function warnNotClient(source) {\n    /* istanbul ignore else */\n    if (isBrowser) {\n      return false;\n    } else {\n      warn(\"\".concat(source, \": Can not be called during SSR.\"));\n      return true;\n    }\n  };\n  /**\n   * Warn when no Promise support is given\n   * @param {string} source\n   * @returns {boolean} warned\n   */\n\n  var warnNoPromiseSupport = function warnNoPromiseSupport(source) {\n    /* istanbul ignore else */\n    if (hasPromiseSupport) {\n      return false;\n    } else {\n      warn(\"\".concat(source, \": Requires Promise support.\"));\n      return true;\n    }\n  };\n  /**\n   * Warn when no MutationObserver support is given\n   * @param {string} source\n   * @returns {boolean} warned\n   */\n\n  var warnNoMutationObserverSupport = function warnNoMutationObserverSupport(source) {\n    /* istanbul ignore else */\n    if (hasMutationObserverSupport) {\n      return false;\n    } else {\n      warn(\"\".concat(source, \": Requires MutationObserver support.\"));\n      return true;\n    }\n  };\n\n  // NOTES\n  //\n  // The global config SHALL NOT be used to set defaults for Boolean props, as the props\n  // would loose their semantic meaning, and force people writing 3rd party components to\n  // explicity set a true or false value using the v-bind syntax on boolean props\n  //\n  // Supported config values (depending on the prop's supported type(s)):\n  // `String`, `Array`, `Object`, `null` or `undefined`\n  // BREAKPOINT DEFINITIONS\n  //\n  // Some components (`<b-col>` and `<b-form-group>`) generate props based on breakpoints,\n  // and this occurs when the component is first loaded (evaluated), which may happen\n  // before the config is created/modified\n  //\n  // To get around this we make these components' props async (lazy evaluation)\n  // The component definition is only called/executed when the first access to the\n  // component is used (and cached on subsequent uses)\n  // PROP DEFAULTS\n  //\n  // For default values on props, we use the default value factory function approach so\n  // that the default values are pulled in at each component instantiation\n  //\n  //  props: {\n  //    variant: {\n  //      type: String,\n  //      default: () => getConfigComponent('BAlert', 'variant')\n  //    }\n  //  }\n  //\n  // We also provide a cached getter for breakpoints, which are \"frozen\" on first access\n  // prettier-ignore\n\n  var DEFAULTS = deepFreeze({\n    // Breakpoints\n    breakpoints: ['xs', 'sm', 'md', 'lg', 'xl'],\n    // Form controls\n    formControls: {\n      size: null\n    },\n    // Component specific defaults are keyed by the component\n    // name (PascalCase) and prop name (camelCase)\n    BAlert: {\n      dismissLabel: 'Close',\n      variant: 'info'\n    },\n    BBadge: {\n      variant: 'secondary'\n    },\n    BButton: {\n      size: null,\n      variant: 'secondary'\n    },\n    BButtonClose: {\n      content: '&times;',\n      // `textVariant` is `null` to inherit the current text color\n      textVariant: null,\n      ariaLabel: 'Close'\n    },\n    BCalendar: {\n      // BFormDate will choose these first if not provided in BFormDate section\n      labelPrevYear: 'Previous year',\n      labelPrevMonth: 'Previous month',\n      labelCurrentMonth: 'Current month',\n      labelNextMonth: 'Next month',\n      labelNextYear: 'Next year',\n      labelToday: 'Today',\n      labelSelected: 'Selected date',\n      labelNoDateSelected: 'No date selected',\n      labelCalendar: 'Calendar',\n      labelNav: 'Calendar navigation',\n      labelHelp: 'Use cursor keys to navigate calendar dates'\n    },\n    BCardSubTitle: {\n      // `<b-card>` and `<b-card-body>` also inherit this prop\n      subTitleTextVariant: 'muted'\n    },\n    BCarousel: {\n      labelPrev: 'Previous Slide',\n      labelNext: 'Next Slide',\n      labelGotoSlide: 'Goto Slide',\n      labelIndicators: 'Select a slide to display'\n    },\n    BDropdown: {\n      toggleText: 'Toggle Dropdown',\n      size: null,\n      variant: 'secondary',\n      splitVariant: null\n    },\n    BFormDatepicker: {\n      // BFormDatepicker will choose from BCalendar first if not provided in BFormDatepicker section\n      labelPrevYear: null,\n      labelPrevMonth: null,\n      labelCurrentMonth: null,\n      labelNextMonth: null,\n      labelNextYear: null,\n      labelToday: null,\n      labelSelected: null,\n      labelNoDateSelected: null,\n      labelCalendar: null,\n      labelNav: null,\n      labelHelp: null,\n      // These props are specific to BFormDatepicker\n      labelTodayButton: 'Select today',\n      labelResetButton: 'Reset',\n      labelCloseButton: 'Close'\n    },\n    BFormFile: {\n      browseText: 'Browse',\n      // Chrome default file prompt\n      placeholder: 'No file chosen',\n      dropPlaceholder: 'Drop files here'\n    },\n    BFormSpinbutton: {\n      labelDecrement: 'Decrement',\n      labelIncrement: 'Increment'\n    },\n    BFormTag: {\n      removeLabel: 'Remove tag',\n      variant: 'secondary'\n    },\n    BFormTags: {\n      addButtonText: 'Add',\n      addButtonVariant: 'outline-secondary',\n      duplicateTagText: 'Duplicate tag(s)',\n      invalidTagText: 'Invalid tag(s)',\n      placeholder: 'Add tag...',\n      tagRemoveLabel: 'Remove tag',\n      tagRemovedLabel: 'Tag removed',\n      tagVariant: 'secondary'\n    },\n    BFormText: {\n      textVariant: 'muted'\n    },\n    BImg: {\n      blankColor: 'transparent'\n    },\n    BImgLazy: {\n      blankColor: 'transparent'\n    },\n    BInputGroup: {\n      size: null\n    },\n    BJumbotron: {\n      bgVariant: null,\n      borderVariant: null,\n      textVariant: null\n    },\n    BListGroupItem: {\n      variant: null\n    },\n    BModal: {\n      titleTag: 'h5',\n      size: 'md',\n      headerBgVariant: null,\n      headerBorderVariant: null,\n      headerTextVariant: null,\n      headerCloseVariant: null,\n      bodyBgVariant: null,\n      bodyTextVariant: null,\n      footerBgVariant: null,\n      footerBorderVariant: null,\n      footerTextVariant: null,\n      cancelTitle: 'Cancel',\n      cancelVariant: 'secondary',\n      okTitle: 'OK',\n      okVariant: 'primary',\n      headerCloseContent: '&times;',\n      headerCloseLabel: 'Close'\n    },\n    BNavbar: {\n      variant: null\n    },\n    BNavbarToggle: {\n      label: 'Toggle navigation'\n    },\n    BPagination: {\n      size: null\n    },\n    BPaginationNav: {\n      size: null\n    },\n    BPopover: {\n      boundary: 'scrollParent',\n      boundaryPadding: 5,\n      customClass: null,\n      delay: 50,\n      variant: null\n    },\n    BProgress: {\n      variant: null\n    },\n    BProgressBar: {\n      variant: null\n    },\n    BSpinner: {\n      variant: null\n    },\n    BTable: {\n      selectedVariant: 'active',\n      headVariant: null,\n      footVariant: null\n    },\n    BToast: {\n      toaster: 'b-toaster-top-right',\n      autoHideDelay: 5000,\n      variant: null,\n      toastClass: null,\n      headerClass: null,\n      bodyClass: null\n    },\n    BToaster: {\n      ariaLive: null,\n      ariaAtomic: null,\n      role: null\n    },\n    BTooltip: {\n      boundary: 'scrollParent',\n      boundaryPadding: 5,\n      customClass: null,\n      delay: 50,\n      variant: null\n    }\n  });\n\n  var NAME = 'BvConfig';\n  var PROP_NAME = '$bvConfig'; // Config manager class\n\n  var BvConfig =\n  /*#__PURE__*/\n  function () {\n    function BvConfig() {\n      _classCallCheck(this, BvConfig);\n\n      // TODO: pre-populate with default config values (needs updated tests)\n      // this.$_config = cloneDeep(DEFAULTS)\n      this.$_config = {};\n      this.$_cachedBreakpoints = null;\n    }\n\n    _createClass(BvConfig, [{\n      key: \"getDefaults\",\n      // Returns the defaults\n      value: function getDefaults()\n      /* istanbul ignore next */\n      {\n        return this.defaults;\n      } // Method to merge in user config parameters\n\n    }, {\n      key: \"setConfig\",\n      value: function setConfig() {\n        var _this = this;\n\n        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        if (!isPlainObject(config)) {\n          /* istanbul ignore next */\n          return;\n        }\n\n        var configKeys = getOwnPropertyNames(config);\n        configKeys.forEach(function (cmpName) {\n          /* istanbul ignore next */\n          if (!hasOwnProperty(DEFAULTS, cmpName)) {\n            warn(\"Unknown config property \\\"\".concat(cmpName, \"\\\"\"), NAME);\n            return;\n          }\n\n          var cmpConfig = config[cmpName];\n\n          if (cmpName === 'breakpoints') {\n            // Special case for breakpoints\n            var breakpoints = config.breakpoints;\n            /* istanbul ignore if */\n\n            if (!isArray(breakpoints) || breakpoints.length < 2 || breakpoints.some(function (b) {\n              return !isString(b) || b.length === 0;\n            })) {\n              warn('\"breakpoints\" must be an array of at least 2 breakpoint names', NAME);\n            } else {\n              _this.$_config.breakpoints = cloneDeep(breakpoints);\n            }\n          } else if (isPlainObject(cmpConfig)) {\n            // Component prop defaults\n            var props = getOwnPropertyNames(cmpConfig);\n            props.forEach(function (prop) {\n              /* istanbul ignore if */\n              if (!hasOwnProperty(DEFAULTS[cmpName], prop)) {\n                warn(\"Unknown config property \\\"\".concat(cmpName, \".\").concat(prop, \"\\\"\"), NAME);\n              } else {\n                // TODO: If we pre-populate the config with defaults, we can skip this line\n                _this.$_config[cmpName] = _this.$_config[cmpName] || {};\n\n                if (!isUndefined(cmpConfig[prop])) {\n                  _this.$_config[cmpName][prop] = cloneDeep(cmpConfig[prop]);\n                }\n              }\n            });\n          }\n        });\n      } // Clear the config. For testing purposes only\n\n    }, {\n      key: \"resetConfig\",\n      value: function resetConfig() {\n        this.$_config = {};\n      } // Returns a deep copy of the user config\n\n    }, {\n      key: \"getConfig\",\n      value: function getConfig() {\n        return cloneDeep(this.$_config);\n      }\n    }, {\n      key: \"getConfigValue\",\n      value: function getConfigValue(key) {\n        // First we try the user config, and if key not found we fall back to default value\n        // NOTE: If we deep clone DEFAULTS into config, then we can skip the fallback for get\n        return cloneDeep(get(this.$_config, key, get(DEFAULTS, key)));\n      }\n    }, {\n      key: \"defaults\",\n      get: function get()\n      /* istanbul ignore next */\n      {\n        return DEFAULTS;\n      }\n    }], [{\n      key: \"Defaults\",\n      get: function get()\n      /* istanbul ignore next */\n      {\n        return DEFAULTS;\n      }\n    }]);\n\n    return BvConfig;\n  }(); // Method for applying a global config\n\n\n  var setConfig = function setConfig() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var Vue$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Vue;\n    // Ensure we have a $bvConfig Object on the Vue prototype.\n    // We set on Vue and OurVue just in case consumer has not set an alias of `vue`.\n    Vue$1.prototype[PROP_NAME] = Vue.prototype[PROP_NAME] = Vue$1.prototype[PROP_NAME] || Vue.prototype[PROP_NAME] || new BvConfig(); // Apply the config values\n\n    Vue$1.prototype[PROP_NAME].setConfig(config);\n  }; // Method for resetting the user config. Exported for testing purposes only.\n\n  /**\n   * Checks if there are multiple instances of Vue, and warns (once) about possible issues.\n   * @param {object} Vue\n   */\n\n  var checkMultipleVue = function () {\n    var checkMultipleVueWarned = false;\n    var MULTIPLE_VUE_WARNING = ['Multiple instances of Vue detected!', 'You may need to set up an alias for Vue in your bundler config.', 'See: https://bootstrap-vue.js.org/docs#using-module-bundlers'].join('\\n');\n    return function (Vue$1) {\n      /* istanbul ignore next */\n      if (!checkMultipleVueWarned && Vue !== Vue$1 && !isJSDOM) {\n        warn(MULTIPLE_VUE_WARNING);\n      }\n\n      checkMultipleVueWarned = true;\n    };\n  }();\n  /**\n   * Plugin install factory function.\n   * @param {object} { components, directives }\n   * @returns {function} plugin install function\n   */\n\n  var installFactory = function installFactory() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        components = _ref.components,\n        directives = _ref.directives,\n        plugins = _ref.plugins;\n\n    var install = function install(Vue) {\n      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (install.installed) {\n        /* istanbul ignore next */\n        return;\n      }\n\n      install.installed = true;\n      checkMultipleVue(Vue);\n      setConfig(config, Vue);\n      registerComponents(Vue, components);\n      registerDirectives(Vue, directives);\n      registerPlugins(Vue, plugins);\n    };\n\n    install.installed = false;\n    return install;\n  };\n  /**\n   * Plugin object factory function.\n   * @param {object} { components, directives, plugins }\n   * @returns {object} plugin install object\n   */\n\n  var pluginFactory = function pluginFactory() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var extend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return _objectSpread2({}, extend, {\n      install: installFactory(options)\n    });\n  };\n  /**\n   * Load a group of plugins.\n   * @param {object} Vue\n   * @param {object} Plugin definitions\n   */\n\n  var registerPlugins = function registerPlugins(Vue) {\n    var plugins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var plugin in plugins) {\n      if (plugin && plugins[plugin]) {\n        Vue.use(plugins[plugin]);\n      }\n    }\n  };\n  /**\n   * Load a component.\n   * @param {object} Vue\n   * @param {string} Component name\n   * @param {object} Component definition\n   */\n\n  var registerComponent = function registerComponent(Vue, name, def) {\n    if (Vue && name && def) {\n      Vue.component(name, def);\n    }\n  };\n  /**\n   * Load a group of components.\n   * @param {object} Vue\n   * @param {object} Object of component definitions\n   */\n\n  var registerComponents = function registerComponents(Vue) {\n    var components = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var component in components) {\n      registerComponent(Vue, component, components[component]);\n    }\n  };\n  /**\n   * Load a directive.\n   * @param {object} Vue\n   * @param {string} Directive name\n   * @param {object} Directive definition\n   */\n\n  var registerDirective = function registerDirective(Vue, name, def) {\n    if (Vue && name && def) {\n      // Ensure that any leading V is removed from the\n      // name, as Vue adds it automatically\n      Vue.directive(name.replace(/^VB/, 'B'), def);\n    }\n  };\n  /**\n   * Load a group of directives.\n   * @param {object} Vue\n   * @param {object} Object of directive definitions\n   */\n\n  var registerDirectives = function registerDirectives(Vue) {\n    var directives = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var directive in directives) {\n      registerDirective(Vue, directive, directives[directive]);\n    }\n  };\n  /**\n   * Install plugin if window.Vue available\n   * @param {object} Plugin definition\n   */\n\n  var vueUse = function vueUse(VuePlugin) {\n    /* istanbul ignore next */\n    if (hasWindowSupport && window.Vue) {\n      window.Vue.use(VuePlugin);\n    }\n    /* istanbul ignore next */\n\n\n    if (hasWindowSupport && VuePlugin.NAME) {\n      window[VuePlugin.NAME] = VuePlugin;\n    }\n  };\n\n  var memoize = function memoize(fn) {\n    var cache = create(null);\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var argsKey = JSON.stringify(args);\n      return cache[argsKey] = cache[argsKey] || fn.apply(null, args);\n    };\n  };\n\n  var PROP_NAME$1 = '$bvConfig';\n  var VueProto = Vue.prototype; // --- Getter methods ---\n\n  var getConfigValue = function getConfigValue(key) {\n    return VueProto[PROP_NAME$1] ? VueProto[PROP_NAME$1].getConfigValue(key) : cloneDeep(get(DEFAULTS, key));\n  }; // Method to grab a config value for a particular component\n\n  var getComponentConfig = function getComponentConfig(cmpName) {\n    var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    // Return the particular config value for key for if specified,\n    // otherwise we return the full config (or an empty object if not found)\n    return key ? getConfigValue(\"\".concat(cmpName, \".\").concat(key)) : getConfigValue(cmpName) || {};\n  }; // Convenience method for getting all breakpoint names\n\n  var getBreakpoints = function getBreakpoints() {\n    return getConfigValue('breakpoints');\n  }; // Private function for caching / locking-in breakpoint names\n\n  var _getBreakpointsCached = memoize(function () {\n    return getBreakpoints();\n  }); // Convenience method for getting all breakpoint names.\n  // Caches the results after first access.\n\n\n  var getBreakpointsCached = function getBreakpointsCached() {\n    return cloneDeep(_getBreakpointsCached());\n  }; // Convenience method for getting breakpoints with\n  // the smallest breakpoint set as ''.\n  // Useful for components that create breakpoint specific props.\n  // Caches the results after first access.\n\n  var getBreakpointsUpCached = memoize(function () {\n    var breakpoints = getBreakpointsCached();\n    breakpoints[0] = '';\n    return breakpoints;\n  }); // Convenience method for getting breakpoints with\n\n  var w$1 = hasWindowSupport ? window : {};\n  var d = hasDocumentSupport ? document : {};\n  var elProto = typeof Element !== 'undefined' ? Element.prototype : {}; // --- Normalization utils ---\n  // See: https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\n\n  /* istanbul ignore next */\n\n  var matchesEl = elProto.matches || elProto.msMatchesSelector || elProto.webkitMatchesSelector; // See: https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n\n  /* istanbul ignore next */\n\n  var closestEl = elProto.closest || function (sel)\n  /* istanbul ignore next */\n  {\n    var el = this;\n\n    do {\n      // Use our \"patched\" matches function\n      if (matches(el, sel)) {\n        return el;\n      }\n\n      el = el.parentElement || el.parentNode;\n    } while (!isNull(el) && el.nodeType === Node.ELEMENT_NODE);\n\n    return null;\n  }; // `requestAnimationFrame()` convenience method\n\n  var requestAF = w$1.requestAnimationFrame || w$1.webkitRequestAnimationFrame || w$1.mozRequestAnimationFrame || w$1.msRequestAnimationFrame || w$1.oRequestAnimationFrame || // Fallback, but not a true polyfill\n  // Only needed for Opera Mini\n\n  /* istanbul ignore next */\n  function (cb) {\n    return setTimeout(cb, 16);\n  };\n  var MutationObs = w$1.MutationObserver || w$1.WebKitMutationObserver || w$1.MozMutationObserver || null; // --- Utils ---\n  // Remove a node from DOM\n\n  var removeNode = function removeNode(el) {\n    return el && el.parentNode && el.parentNode.removeChild(el);\n  }; // Determine if an element is an HTML element\n\n  var isElement = function isElement(el) {\n    return !!(el && el.nodeType === Node.ELEMENT_NODE);\n  }; // Determine if an HTML element is visible - Faster than CSS check\n\n  var isVisible = function isVisible(el) {\n    if (!isElement(el) || !el.parentNode || !contains(d.body, el)) {\n      // Note this can fail for shadow dom elements since they\n      // are not a direct descendant of document.body\n      return false;\n    }\n\n    if (el.style.display === 'none') {\n      // We do this check to help with vue-test-utils when using v-show\n\n      /* istanbul ignore next */\n      return false;\n    } // All browsers support getBoundingClientRect(), except JSDOM as it returns all 0's for values :(\n    // So any tests that need isVisible will fail in JSDOM\n    // Except when we override the getBCR prototype in some tests\n\n\n    var bcr = getBCR(el);\n    return !!(bcr && bcr.height > 0 && bcr.width > 0);\n  }; // Determine if an element is disabled\n\n  var isDisabled = function isDisabled(el) {\n    return !isElement(el) || el.disabled || hasAttr(el, 'disabled') || hasClass(el, 'disabled');\n  }; // Cause/wait-for an element to reflow its content (adjusting its height/width)\n\n  var reflow = function reflow(el) {\n    // Requesting an elements offsetHight will trigger a reflow of the element content\n\n    /* istanbul ignore next: reflow doesn't happen in JSDOM */\n    return isElement(el) && el.offsetHeight;\n  }; // Select all elements matching selector. Returns `[]` if none found\n\n  var selectAll = function selectAll(selector, root) {\n    return from((isElement(root) ? root : d).querySelectorAll(selector));\n  }; // Select a single element, returns `null` if not found\n\n  var select = function select(selector, root) {\n    return (isElement(root) ? root : d).querySelector(selector) || null;\n  }; // Determine if an element matches a selector\n\n  var matches = function matches(el, selector) {\n    return isElement(el) ? matchesEl.call(el, selector) : false;\n  }; // Finds closest element matching selector. Returns `null` if not found\n\n  var closest = function closest(selector, root) {\n    var includeRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (!isElement(root)) {\n      return null;\n    }\n\n    var el = closestEl.call(root, selector); // Native closest behaviour when `includeRoot` is truthy,\n    // else emulate jQuery closest and return `null` if match is\n    // the passed in root element when `includeRoot` is falsey\n\n    return includeRoot ? el : el === root ? null : el;\n  }; // Returns true if the parent element contains the child element\n\n  var contains = function contains(parent, child) {\n    return parent && isFunction(parent.contains) ? parent.contains(child) : false;\n  }; // Get an element given an ID\n\n  var getById = function getById(id) {\n    return d.getElementById(/^#/.test(id) ? id.slice(1) : id) || null;\n  }; // Add a class to an element\n\n  var addClass = function addClass(el, className) {\n    // We are checking for `el.classList` existence here since IE 11\n    // returns `undefined` for some elements (e.g. SVG elements)\n    // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713\n    if (className && isElement(el) && el.classList) {\n      el.classList.add(className);\n    }\n  }; // Remove a class from an element\n\n  var removeClass = function removeClass(el, className) {\n    // We are checking for `el.classList` existence here since IE 11\n    // returns `undefined` for some elements (e.g. SVG elements)\n    // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713\n    if (className && isElement(el) && el.classList) {\n      el.classList.remove(className);\n    }\n  }; // Test if an element has a class\n\n  var hasClass = function hasClass(el, className) {\n    // We are checking for `el.classList` existence here since IE 11\n    // returns `undefined` for some elements (e.g. SVG elements)\n    // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713\n    if (className && isElement(el) && el.classList) {\n      return el.classList.contains(className);\n    }\n\n    return false;\n  }; // Set an attribute on an element\n\n  var setAttr = function setAttr(el, attr, val) {\n    if (attr && isElement(el)) {\n      el.setAttribute(attr, val);\n    }\n  }; // Remove an attribute from an element\n\n  var removeAttr = function removeAttr(el, attr) {\n    if (attr && isElement(el)) {\n      el.removeAttribute(attr);\n    }\n  }; // Get an attribute value from an element\n  // Returns `null` if not found\n\n  var getAttr = function getAttr(el, attr) {\n    return attr && isElement(el) ? el.getAttribute(attr) : null;\n  }; // Determine if an attribute exists on an element\n  // Returns `true` or `false`, or `null` if element not found\n\n  var hasAttr = function hasAttr(el, attr) {\n    return attr && isElement(el) ? el.hasAttribute(attr) : null;\n  }; // Return the Bounding Client Rect of an element\n  // Returns `null` if not an element\n\n  /* istanbul ignore next: getBoundingClientRect() doesn't work in JSDOM */\n\n  var getBCR = function getBCR(el) {\n    return isElement(el) ? el.getBoundingClientRect() : null;\n  }; // Get computed style object for an element\n\n  /* istanbul ignore next: getComputedStyle() doesn't work in JSDOM */\n\n  var getCS = function getCS(el) {\n    return hasWindowSupport && isElement(el) ? w$1.getComputedStyle(el) : {};\n  }; // Returns a `Selection` object representing the range of text selected\n  // Returns `null` if no window support is given\n\n  /* istanbul ignore next: getSelection() doesn't work in JSDOM */\n\n  var getSel = function getSel() {\n    return hasWindowSupport && w$1.getSelection ? w$1.getSelection() : null;\n  }; // Return an element's offset with respect to document element\n  // https://j11y.io/jquery/#v=git&fn=jQuery.fn.offset\n\n  var offset = function offset(el)\n  /* istanbul ignore next: getBoundingClientRect(), getClientRects() doesn't work in JSDOM */\n  {\n    var _offset = {\n      top: 0,\n      left: 0\n    };\n\n    if (!isElement(el) || el.getClientRects().length === 0) {\n      return _offset;\n    }\n\n    var bcr = getBCR(el);\n\n    if (bcr) {\n      var win = el.ownerDocument.defaultView;\n      _offset.top = bcr.top + win.pageYOffset;\n      _offset.left = bcr.left + win.pageXOffset;\n    }\n\n    return _offset;\n  }; // Return an element's offset with respect to to its offsetParent\n  // https://j11y.io/jquery/#v=git&fn=jQuery.fn.position\n\n  var position = function position(el)\n  /* istanbul ignore next: getBoundingClientRect() doesn't work in JSDOM */\n  {\n    var _offset = {\n      top: 0,\n      left: 0\n    };\n\n    if (!isElement(el)) {\n      return _offset;\n    }\n\n    var parentOffset = {\n      top: 0,\n      left: 0\n    };\n    var elStyles = getCS(el);\n\n    if (elStyles.position === 'fixed') {\n      _offset = getBCR(el) || _offset;\n    } else {\n      _offset = offset(el);\n      var doc = el.ownerDocument;\n      var offsetParent = el.offsetParent || doc.documentElement;\n\n      while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && getCS(offsetParent).position === 'static') {\n        offsetParent = offsetParent.parentNode;\n      }\n\n      if (offsetParent && offsetParent !== el && offsetParent.nodeType === Node.ELEMENT_NODE) {\n        parentOffset = offset(offsetParent);\n        var offsetParentStyles = getCS(offsetParent);\n        parentOffset.top += parseFloat(offsetParentStyles.borderTopWidth);\n        parentOffset.left += parseFloat(offsetParentStyles.borderLeftWidth);\n      }\n    }\n\n    return {\n      top: _offset.top - parentOffset.top - parseFloat(elStyles.marginTop),\n      left: _offset.left - parentOffset.left - parseFloat(elStyles.marginLeft)\n    };\n  };\n\n  // Number utilities\n  // Converts a value (string, number, etc) to an integer number\n  // Assumes radix base 10\n  // Returns NaN if the value cannot be converted\n  var toInteger = function toInteger(val) {\n    return parseInt(val, 10);\n  }; // Converts a value (string, number, etc) to a number\n  // Returns NaN if the value cannot be converted\n\n  var toFloat = function toFloat(val) {\n    return parseFloat(val);\n  }; // Converts a value (string, number, etc) to a string\n  // representation with 'precision' digits after the decimal\n  // Returns the string 'NaN' if the value cannot be converted\n\n  var toFixed = function toFixed(val, precision) {\n    return toFloat(val).toFixed(toInteger(precision) || 0);\n  };\n\n  var e=function(){return (e=Object.assign||function(e){for(var t,r=1,s=arguments.length;r<s;r++)for(var a in t=arguments[r])Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);return e}).apply(this,arguments)},t={kebab:/-(\\w)/g,styleProp:/:(.*)/,styleList:/;(?![^(]*\\))/g};function r(e,t){return t?t.toUpperCase():\"\"}function s(e){for(var s,a={},c=0,o=e.split(t.styleList);c<o.length;c++){var n=o[c].split(t.styleProp),i=n[0],l=n[1];(i=i.trim())&&(\"string\"==typeof l&&(l=l.trim()),a[(s=i,s.replace(t.kebab,r))]=l);}return a}function a(){for(var t,r,a={},c=arguments.length;c--;)for(var o=0,n=Object.keys(arguments[c]);o<n.length;o++)switch(t=n[o]){case\"class\":case\"style\":case\"directives\":if(Array.isArray(a[t])||(a[t]=[]),\"style\"===t){var i=void 0;i=Array.isArray(arguments[c].style)?arguments[c].style:[arguments[c].style];for(var l=0;l<i.length;l++){var y=i[l];\"string\"==typeof y&&(i[l]=s(y));}arguments[c].style=i;}a[t]=a[t].concat(arguments[c][t]);break;case\"staticClass\":if(!arguments[c][t])break;void 0===a[t]&&(a[t]=\"\"),a[t]&&(a[t]+=\" \"),a[t]+=arguments[c][t].trim();break;case\"on\":case\"nativeOn\":a[t]||(a[t]={});for(var p=0,f=Object.keys(arguments[c][t]||{});p<f.length;p++)r=f[p],a[t][r]?a[t][r]=[].concat(a[t][r],arguments[c][t][r]):a[t][r]=arguments[c][t][r];break;case\"attrs\":case\"props\":case\"domProps\":case\"scopedSlots\":case\"staticStyle\":case\"hook\":case\"transition\":a[t]||(a[t]={}),a[t]=e({},arguments[c][t],a[t]);break;case\"slot\":case\"key\":case\"ref\":case\"tag\":case\"show\":case\"keepAlive\":default:a[t]||(a[t]=arguments[c][t]);}return a}\n\n  var NO_FADE_PROPS = {\n    name: '',\n    enterClass: '',\n    enterActiveClass: '',\n    enterToClass: 'show',\n    leaveClass: 'show',\n    leaveActiveClass: '',\n    leaveToClass: ''\n  };\n\n  var FADE_PROPS = _objectSpread2({}, NO_FADE_PROPS, {\n    enterActiveClass: 'fade',\n    leaveActiveClass: 'fade'\n  }); // @vue/component\n\n\n  var BVTransition =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BVTransition',\n    functional: true,\n    props: {\n      noFade: {\n        // Only applicable to the built in transition\n        // Has no effect if `trans-props` provided\n        type: Boolean,\n        default: false\n      },\n      appear: {\n        // Has no effect if `trans-props` provided\n        type: Boolean,\n        default: false\n      },\n      mode: {\n        // Can be overridden by user supplied trans-props\n        type: String // default: undefined\n\n      },\n      // For user supplied transitions (if needed)\n      transProps: {\n        type: Object,\n        default: null\n      }\n    },\n    render: function render(h, _ref) {\n      var children = _ref.children,\n          data = _ref.data,\n          props = _ref.props;\n      var transProps = props.transProps;\n\n      if (!isPlainObject(transProps)) {\n        transProps = props.noFade ? NO_FADE_PROPS : FADE_PROPS;\n\n        if (props.appear) {\n          // Default the appear classes to equal the enter classes\n          transProps = _objectSpread2({}, transProps, {\n            appear: true,\n            appearClass: transProps.enterClass,\n            appearActiveClass: transProps.enterActiveClass,\n            appearToClass: transProps.enterToClass\n          });\n        }\n      }\n\n      transProps = _objectSpread2({\n        mode: props.mode\n      }, transProps, {\n        // We always need `css` true\n        css: true\n      });\n      return h('transition', // Any transition event listeners will get merged here\n      a(data, {\n        props: transProps\n      }), children);\n    }\n  });\n\n  // In functional components, `slots` is a function so it must be called\n  // first before passing to the below methods. `scopedSlots` is always an\n  // object and may be undefined (for Vue < 2.6.x)\n\n  /**\n   * Returns true if either scoped or unscoped named slot exists\n   *\n   * @param {String, Array} name or name[]\n   * @param {Object} scopedSlots\n   * @param {Object} slots\n   * @returns {Array|undefined} VNodes\n   */\n\n  var hasNormalizedSlot = function hasNormalizedSlot(names) {\n    var $scopedSlots = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var $slots = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // Ensure names is an array\n    names = concat(names).filter(identity); // Returns true if the either a $scopedSlot or $slot exists with the specified name\n\n    return names.some(function (name) {\n      return $scopedSlots[name] || $slots[name];\n    });\n  };\n  /**\n   * Returns VNodes for named slot either scoped or unscoped\n   *\n   * @param {String, Array} name or name[]\n   * @param {String} scope\n   * @param {Object} scopedSlots\n   * @param {Object} slots\n   * @returns {Array|undefined} VNodes\n   */\n\n\n  var normalizeSlot = function normalizeSlot(names) {\n    var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var $scopedSlots = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var $slots = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    // Ensure names is an array\n    names = concat(names).filter(identity);\n    var slot;\n\n    for (var i = 0; i < names.length && !slot; i++) {\n      var name = names[i];\n      slot = $scopedSlots[name] || $slots[name];\n    } // Note: in Vue 2.6.x, all named slots are also scoped slots\n\n\n    return isFunction(slot) ? slot(scope) : slot;\n  }; // Named exports\n\n  var normalizeSlotMixin = {\n    methods: {\n      hasNormalizedSlot: function hasNormalizedSlot$1(names) {\n        // Returns true if the either a $scopedSlot or $slot exists with the specified name\n        // `names` can be a string name or an array of names\n        return hasNormalizedSlot(names, this.$scopedSlots, this.$slots);\n      },\n      normalizeSlot: function normalizeSlot$1(names) {\n        var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        // Returns an array of rendered VNodes if slot found.\n        // Returns undefined if not found.\n        // `names` can be a string name or an array of names\n        var vNodes = normalizeSlot(names, scope, this.$scopedSlots, this.$slots);\n\n        return vNodes ? concat(vNodes) : vNodes;\n      }\n    }\n  };\n\n  var NAME$1 = 'BButtonClose';\n  var props = {\n    content: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$1, 'content');\n      }\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    ariaLabel: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$1, 'ariaLabel');\n      }\n    },\n    textVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$1, 'textVariant');\n      }\n    }\n  }; // @vue/component\n\n  var BButtonClose =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$1,\n    functional: true,\n    props: props,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          slots = _ref.slots,\n          scopedSlots = _ref.scopedSlots;\n      var $slots = slots();\n      var $scopedSlots = scopedSlots || {};\n      var componentData = {\n        staticClass: 'close',\n        class: _defineProperty({}, \"text-\".concat(props.textVariant), props.textVariant),\n        attrs: {\n          type: 'button',\n          disabled: props.disabled,\n          'aria-label': props.ariaLabel ? String(props.ariaLabel) : null\n        },\n        on: {\n          click: function click(evt) {\n            // Ensure click on button HTML content is also disabled\n\n            /* istanbul ignore if: bug in JSDOM still emits click on inner element */\n            if (props.disabled && isEvent(evt)) {\n              evt.stopPropagation();\n              evt.preventDefault();\n            }\n          }\n        }\n      }; // Careful not to override the default slot with innerHTML\n\n      if (!hasNormalizedSlot('default', $scopedSlots, $slots)) {\n        componentData.domProps = {\n          innerHTML: props.content\n        };\n      }\n\n      return h('button', a(data, componentData), normalizeSlot('default', {}, $scopedSlots, $slots));\n    }\n  });\n\n  var NAME$2 = 'BAlert'; // Convert `show` value to a number\n\n  var parseCountDown = function parseCountDown(show) {\n    if (show === '' || isBoolean(show)) {\n      return 0;\n    }\n\n    show = toInteger(show);\n    return show > 0 ? show : 0;\n  }; // Convert `show` value to a boolean\n\n\n  var parseShow = function parseShow(show) {\n    if (show === '' || show === true) {\n      return true;\n    }\n\n    if (toInteger(show) < 1) {\n      // Boolean will always return false for the above comparison\n      return false;\n    }\n\n    return !!show;\n  }; // Is a value number like (i.e. a number or a number as string)\n\n\n  var isNumericLike = function isNumericLike(value) {\n    return !isNaN(toInteger(value));\n  }; // @vue/component\n\n\n  var BAlert =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$2,\n    mixins: [normalizeSlotMixin],\n    model: {\n      prop: 'show',\n      event: 'input'\n    },\n    props: {\n      variant: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$2, 'variant');\n        }\n      },\n      dismissible: {\n        type: Boolean,\n        default: false\n      },\n      dismissLabel: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$2, 'dismissLabel');\n        }\n      },\n      show: {\n        type: [Boolean, Number, String],\n        default: false\n      },\n      fade: {\n        type: Boolean,\n        default: false\n      }\n    },\n    data: function data() {\n      return {\n        countDownTimerId: null,\n        countDown: 0,\n        // If initially shown, we need to set these for SSR\n        localShow: parseShow(this.show)\n      };\n    },\n    watch: {\n      show: function show(newVal) {\n        this.countDown = parseCountDown(newVal);\n        this.localShow = parseShow(newVal);\n      },\n      countDown: function countDown(newVal) {\n        var _this = this;\n\n        this.clearTimer();\n\n        if (isNumericLike(this.show)) {\n          // Ignore if this.show transitions to a boolean value.\n          this.$emit('dismiss-count-down', newVal);\n\n          if (this.show !== newVal) {\n            // Update the v-model if needed\n            this.$emit('input', newVal);\n          }\n\n          if (newVal > 0) {\n            this.localShow = true;\n            this.countDownTimerId = setTimeout(function () {\n              _this.countDown--;\n            }, 1000);\n          } else {\n            // Slightly delay the hide to allow any UI updates\n            this.$nextTick(function () {\n              requestAF(function () {\n                _this.localShow = false;\n              });\n            });\n          }\n        }\n      },\n      localShow: function localShow(newVal) {\n        if (!newVal && (this.dismissible || isNumericLike(this.show))) {\n          // Only emit dismissed events for dismissible or auto dismissing alerts\n          this.$emit('dismissed');\n        }\n\n        if (!isNumericLike(this.show) && this.show !== newVal) {\n          // Only emit booleans if we weren't passed a number via `this.show`\n          this.$emit('input', newVal);\n        }\n      }\n    },\n    created: function created() {\n      this.countDown = parseCountDown(this.show);\n      this.localShow = parseShow(this.show);\n    },\n    mounted: function mounted() {\n      this.countDown = parseCountDown(this.show);\n      this.localShow = parseShow(this.show);\n    },\n    beforeDestroy: function beforeDestroy() {\n      this.clearTimer();\n    },\n    methods: {\n      dismiss: function dismiss() {\n        this.clearTimer();\n        this.countDown = 0;\n        this.localShow = false;\n      },\n      clearTimer: function clearTimer() {\n        if (this.countDownTimerId) {\n          clearInterval(this.countDownTimerId);\n          this.countDownTimerId = null;\n        }\n      }\n    },\n    render: function render(h) {\n      var $alert; // undefined\n\n      if (this.localShow) {\n        var $dismissBtn = h();\n\n        if (this.dismissible) {\n          // Add dismiss button\n          $dismissBtn = h(BButtonClose, {\n            attrs: {\n              'aria-label': this.dismissLabel\n            },\n            on: {\n              click: this.dismiss\n            }\n          }, [this.normalizeSlot('dismiss')]);\n        }\n\n        $alert = h('div', {\n          key: this._uid,\n          staticClass: 'alert',\n          class: _defineProperty({\n            'alert-dismissible': this.dismissible\n          }, \"alert-\".concat(this.variant), this.variant),\n          attrs: {\n            role: 'alert',\n            'aria-live': 'polite',\n            'aria-atomic': true\n          }\n        }, [$dismissBtn, this.normalizeSlot('default')]);\n        $alert = [$alert];\n      }\n\n      return h(BVTransition, {\n        props: {\n          noFade: !this.fade\n        }\n      }, $alert);\n    }\n  });\n\n  var AlertPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BAlert: BAlert\n    }\n  });\n\n  /**\n   * Given an array of properties or an object of property keys,\n   * plucks all the values off the target object, returning a new object\n   * that has props that reference the original prop values\n   *\n   * @param {{}|string[]} keysToPluck\n   * @param {{}} objToPluck\n   * @param {Function} transformFn\n   * @return {{}}\n   */\n\n  var pluckProps = function pluckProps(keysToPluck, objToPluck) {\n    var transformFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n    return (isArray(keysToPluck) ? keysToPluck.slice() : keys(keysToPluck)).reduce(function (memo, prop) {\n      memo[transformFn(prop)] = objToPluck[prop];\n      return memo;\n    }, {});\n  };\n\n  // String utilities\n\n  var RX_TRIM_LEFT = /^\\s+/;\n  var RX_REGEXP_REPLACE = /[-/\\\\^$*+?.()|[\\]{}]/g;\n  var RX_UN_KEBAB = /-(\\w)/g;\n  var RX_HYPHENATE = /\\B([A-Z])/g; // --- Utilities ---\n  // Converts PascalCase or camelCase to kebab-case\n\n  var kebabCase = function kebabCase(str) {\n    return str.replace(RX_HYPHENATE, '-$1').toLowerCase();\n  }; // Converts a kebab-case or camelCase string to PascalCase\n\n  var pascalCase = function pascalCase(str) {\n    str = kebabCase(str).replace(RX_UN_KEBAB, function (_, c) {\n      return c ? c.toUpperCase() : '';\n    });\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }; // Lowercases the first letter of a string and returns a new string\n\n  var lowerFirst = function lowerFirst(str) {\n    str = isString(str) ? str.trim() : String(str);\n    return str.charAt(0).toLowerCase() + str.slice(1);\n  }; // Uppercases the first letter of a string and returns a new string\n\n  var upperFirst = function upperFirst(str) {\n    str = isString(str) ? str.trim() : String(str);\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }; // Escape characters to be used in building a regular expression\n\n  var escapeRegExp = function escapeRegExp(str) {\n    return str.replace(RX_REGEXP_REPLACE, '\\\\$&');\n  }; // Convert a value to a string that can be rendered\n  // `undefined`/`null` will be converted to `''`\n  // Plain objects and arrays will be JSON stringified\n\n  var toString$1 = function toString(val) {\n    var spaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    return isUndefinedOrNull(val) ? '' : isArray(val) || isPlainObject(val) && val.toString === Object.prototype.toString ? JSON.stringify(val, null, spaces) : String(val);\n  }; // Remove leading white space from a string\n\n  var trimLeft = function trimLeft(str) {\n    return toString$1(str).replace(RX_TRIM_LEFT, '');\n  }; // Remove Trailing white space from a string\n\n  var trim = function trim(str) {\n    return toString$1(str).trim();\n  }; // Lower case a string\n\n  var lowerCase = function lowerCase(str) {\n    return toString$1(str).toLowerCase();\n  }; // Upper case a string\n\n  var ANCHOR_TAG = 'a'; // Precompile RegExp\n\n  var commaRE = /%2C/g;\n  var encodeReserveRE = /[!'()*]/g;\n  var plusRE = /\\+/g;\n  var queryStartRE = /^(\\?|#|&)/; // Method to replace reserved chars\n\n  var encodeReserveReplacer = function encodeReserveReplacer(c) {\n    return '%' + c.charCodeAt(0).toString(16);\n  }; // Fixed encodeURIComponent which is more conformant to RFC3986:\n  // - escapes [!'()*]\n  // - preserve commas\n\n\n  var encode = function encode(str) {\n    return encodeURIComponent(toString$1(str)).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');\n  };\n\n  var decode = decodeURIComponent; // Stringifies an object of query parameters\n  // See: https://github.com/vuejs/vue-router/blob/dev/src/util/query.js\n\n  var stringifyQueryObj = function stringifyQueryObj(obj) {\n    if (!isPlainObject(obj)) {\n      return '';\n    }\n\n    var query = keys(obj).map(function (key) {\n      var val = obj[key];\n\n      if (isUndefined(val)) {\n        return '';\n      } else if (isNull(val)) {\n        return encode(key);\n      } else if (isArray(val)) {\n        return val.reduce(function (results, val2) {\n          if (isNull(val2)) {\n            results.push(encode(key));\n          } else if (!isUndefined(val2)) {\n            // Faster than string interpolation\n            results.push(encode(key) + '=' + encode(val2));\n          }\n\n          return results;\n        }, []).join('&');\n      } // Faster than string interpolation\n\n\n      return encode(key) + '=' + encode(val);\n    })\n    /* must check for length, as we only want to filter empty strings, not things that look falsey! */\n    .filter(function (x) {\n      return x.length > 0;\n    }).join('&');\n    return query ? \"?\".concat(query) : '';\n  };\n  var parseQuery = function parseQuery(query) {\n    var parsed = {};\n    query = toString$1(query).trim().replace(queryStartRE, '');\n\n    if (!query) {\n      return parsed;\n    }\n\n    query.split('&').forEach(function (param) {\n      var parts = param.replace(plusRE, ' ').split('=');\n      var key = decode(parts.shift());\n      var val = parts.length > 0 ? decode(parts.join('=')) : null;\n\n      if (isUndefined(parsed[key])) {\n        parsed[key] = val;\n      } else if (isArray(parsed[key])) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [parsed[key], val];\n      }\n    });\n    return parsed;\n  };\n  var isRouterLink = function isRouterLink(tag) {\n    return toString$1(tag).toLowerCase() !== ANCHOR_TAG;\n  };\n  var computeTag = function computeTag() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        to = _ref.to,\n        disabled = _ref.disabled;\n\n    var thisOrParent = arguments.length > 1 ? arguments[1] : undefined;\n    return thisOrParent.$router && to && !disabled ? thisOrParent.$nuxt ? 'nuxt-link' : 'router-link' : ANCHOR_TAG;\n  };\n  var computeRel = function computeRel() {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        target = _ref2.target,\n        rel = _ref2.rel;\n\n    if (target === '_blank' && isNull(rel)) {\n      return 'noopener';\n    }\n\n    return rel || null;\n  };\n  var computeHref = function computeHref() {\n    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        href = _ref3.href,\n        to = _ref3.to;\n\n    var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ANCHOR_TAG;\n    var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '#';\n    var toFallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';\n\n    // We've already checked the $router in computeTag(), so isRouterLink() indicates a live router.\n    // When deferring to Vue Router's router-link, don't use the href attribute at all.\n    // We return null, and then remove href from the attributes passed to router-link\n    if (isRouterLink(tag)) {\n      return null;\n    } // Return `href` when explicitly provided\n\n\n    if (href) {\n      return href;\n    } // Reconstruct `href` when `to` used, but no router\n\n\n    if (to) {\n      // Fallback to `to` prop (if `to` is a string)\n      if (isString(to)) {\n        return to || toFallback;\n      } // Fallback to `to.path + to.query + to.hash` prop (if `to` is an object)\n\n\n      if (isPlainObject(to) && (to.path || to.query || to.hash)) {\n        var path = toString$1(to.path);\n        var query = stringifyQueryObj(to.query);\n        var hash = toString$1(to.hash);\n        hash = !hash || hash.charAt(0) === '#' ? hash : \"#\".concat(hash);\n        return \"\".concat(path).concat(query).concat(hash) || toFallback;\n      }\n    } // If nothing is provided return the fallback\n\n\n    return fallback;\n  };\n\n  /**\n   * The Link component is used in many other BV components.\n   * As such, sharing its props makes supporting all its features easier.\n   * However, some components need to modify the defaults for their own purpose.\n   * Prefer sharing a fresh copy of the props to ensure mutations\n   * do not affect other component references to the props.\n   *\n   * https://github.com/vuejs/vue-router/blob/dev/src/components/link.js\n   * @return {{}}\n   */\n\n  var propsFactory = function propsFactory() {\n    return {\n      href: {\n        type: String,\n        default: null\n      },\n      rel: {\n        type: String,\n        default: null\n      },\n      target: {\n        type: String,\n        default: '_self'\n      },\n      active: {\n        type: Boolean,\n        default: false\n      },\n      disabled: {\n        type: Boolean,\n        default: false\n      },\n      // router-link specific props\n      to: {\n        type: [String, Object],\n        default: null\n      },\n      append: {\n        type: Boolean,\n        default: false\n      },\n      replace: {\n        type: Boolean,\n        default: false\n      },\n      event: {\n        type: [String, Array],\n        default: 'click'\n      },\n      activeClass: {\n        type: String // default: undefined\n\n      },\n      exact: {\n        type: Boolean,\n        default: false\n      },\n      exactActiveClass: {\n        type: String // default: undefined\n\n      },\n      routerTag: {\n        type: String,\n        default: 'a'\n      },\n      // nuxt-link specific prop(s)\n      noPrefetch: {\n        type: Boolean,\n        default: false\n      }\n    };\n  };\n\n  var BLink =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BLink',\n    mixins: [normalizeSlotMixin],\n    inheritAttrs: false,\n    props: propsFactory(),\n    computed: {\n      computedTag: function computedTag() {\n        // We don't pass `this` as the first arg as we need reactivity of the props\n        return computeTag({\n          to: this.to,\n          disabled: this.disabled\n        }, this);\n      },\n      isRouterLink: function isRouterLink$1() {\n        return isRouterLink(this.computedTag);\n      },\n      computedRel: function computedRel() {\n        // We don't pass `this` as the first arg as we need reactivity of the props\n        return computeRel({\n          target: this.target,\n          rel: this.rel\n        });\n      },\n      computedHref: function computedHref() {\n        // We don't pass `this` as the first arg as we need reactivity of the props\n        return computeHref({\n          to: this.to,\n          href: this.href\n        }, this.computedTag);\n      },\n      computedProps: function computedProps() {\n        return this.isRouterLink ? _objectSpread2({}, this.$props, {\n          tag: this.routerTag\n        }) : {};\n      }\n    },\n    methods: {\n      onClick: function onClick(evt) {\n        var _arguments = arguments;\n        var evtIsEvent = isEvent(evt);\n        var isRouterLink = this.isRouterLink;\n        var suppliedHandler = this.$listeners.click;\n\n        if (evtIsEvent && this.disabled) {\n          // Stop event from bubbling up\n          evt.stopPropagation(); // Kill the event loop attached to this specific `EventTarget`\n          // Needed to prevent `vue-router` for doing its thing\n\n          evt.stopImmediatePropagation();\n        } else {\n          /* istanbul ignore next: difficult to test, but we know it works */\n          if (isRouterLink && evt.currentTarget.__vue__) {\n            // Router links do not emit instance `click` events, so we\n            // add in an `$emit('click', evt)` on its Vue instance\n            evt.currentTarget.__vue__.$emit('click', evt);\n          } // Call the suppliedHandler(s), if any provided\n\n\n          concat(suppliedHandler).filter(function (h) {\n            return isFunction(h);\n          }).forEach(function (handler) {\n            handler.apply(void 0, _toConsumableArray(_arguments));\n          }); // Emit the global `$root` click event\n\n          this.$root.$emit('clicked::link', evt);\n        } // Stop scroll-to-top behavior or navigation on\n        // regular links when href is just '#'\n\n\n        if (evtIsEvent && (this.disabled || !isRouterLink && this.computedHref === '#')) {\n          evt.preventDefault();\n        }\n      },\n      focus: function focus() {\n        if (this.$el && this.$el.focus) {\n          this.$el.focus();\n        }\n      },\n      blur: function blur() {\n        if (this.$el && this.$el.blur) {\n          this.$el.blur();\n        }\n      }\n    },\n    render: function render(h) {\n      var tag = this.computedTag;\n      var rel = this.computedRel;\n      var href = this.computedHref;\n      var isRouterLink = this.isRouterLink;\n      var componentData = {\n        class: {\n          active: this.active,\n          disabled: this.disabled\n        },\n        attrs: _objectSpread2({}, this.$attrs, {\n          rel: rel,\n          target: this.target,\n          tabindex: this.disabled ? '-1' : isUndefined(this.$attrs.tabindex) ? null : this.$attrs.tabindex,\n          'aria-disabled': this.disabled ? 'true' : null\n        }),\n        props: this.computedProps\n      }; // Add the event handlers. We must use `nativeOn` for\n      // `<router-link>`/`<nuxt-link>` instead of `on`\n\n      componentData[isRouterLink ? 'nativeOn' : 'on'] = _objectSpread2({}, this.$listeners, {\n        // We want to overwrite any click handler since our callback\n        // will invoke the user supplied handler(s) if `!this.disabled`\n        click: this.onClick\n      }); // If href attribute exists on <router-link> (even undefined or null) it fails working on\n      // SSR, so we explicitly add it here if needed (i.e. if computedHref() is truthy)\n\n      if (href) {\n        componentData.attrs.href = href;\n      } else {\n        // Ensure the prop HREF does not exist for router links\n        delete componentData.props.href;\n      }\n\n      return h(tag, componentData, this.normalizeSlot('default'));\n    }\n  });\n\n  var NAME$3 = 'BBadge';\n  var linkProps = propsFactory();\n  delete linkProps.href.default;\n  delete linkProps.to.default;\n  var props$1 = _objectSpread2({}, linkProps, {\n    tag: {\n      type: String,\n      default: 'span'\n    },\n    variant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$3, 'variant');\n      }\n    },\n    pill: {\n      type: Boolean,\n      default: false\n    }\n  }); // @vue/component\n\n  var BBadge =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$3,\n    functional: true,\n    props: props$1,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      var isBLink = props.href || props.to;\n      var tag = isBLink ? BLink : props.tag;\n      var componentData = {\n        staticClass: 'badge',\n        class: [props.variant ? \"badge-\".concat(props.variant) : 'badge-secondary', {\n          'badge-pill': props.pill,\n          active: props.active,\n          disabled: props.disabled\n        }],\n        props: isBLink ? pluckProps(linkProps, props) : {}\n      };\n      return h(tag, a(data, componentData), children);\n    }\n  });\n\n  var BadgePlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BBadge: BBadge\n    }\n  });\n\n  var stripTagsRegex = /(<([^>]+)>)/gi; // Removes any thing that looks like an HTML tag from the supplied string\n\n  var stripTags = function stripTags() {\n    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return String(text).replace(stripTagsRegex, '');\n  }; // Generate a domProps object for either innerHTML, textContent or nothing\n\n  var htmlOrText = function htmlOrText(innerHTML, textContent) {\n    return innerHTML ? {\n      innerHTML: innerHTML\n    } : textContent ? {\n      textContent: textContent\n    } : {};\n  };\n\n  var props$2 = _objectSpread2({}, propsFactory(), {\n    text: {\n      type: String,\n      default: null\n    },\n    html: {\n      type: String,\n      default: null\n    },\n    ariaCurrent: {\n      type: String,\n      default: 'location'\n    }\n  }); // @vue/component\n\n  var BBreadcrumbLink =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BBreadcrumbLink',\n    functional: true,\n    props: props$2,\n    render: function render(h, _ref) {\n      var suppliedProps = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      var tag = suppliedProps.active ? 'span' : BLink;\n      var componentData = {\n        props: pluckProps(props$2, suppliedProps)\n      };\n\n      if (suppliedProps.active) {\n        componentData.attrs = {\n          'aria-current': suppliedProps.ariaCurrent\n        };\n      }\n\n      if (!children) {\n        componentData.domProps = htmlOrText(suppliedProps.html, suppliedProps.text);\n      }\n\n      return h(tag, a(data, componentData), children);\n    }\n  });\n\n  var BBreadcrumbItem =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BBreadcrumbItem',\n    functional: true,\n    props: props$2,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h('li', a(data, {\n        staticClass: 'breadcrumb-item',\n        class: {\n          active: props.active\n        }\n      }), [h(BBreadcrumbLink, {\n        props: props\n      }, children)]);\n    }\n  });\n\n  var props$3 = {\n    items: {\n      type: Array,\n      default: null\n    }\n  }; // @vue/component\n\n  var BBreadcrumb =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BBreadcrumb',\n    functional: true,\n    props: props$3,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      var childNodes = children; // Build child nodes from items if given.\n\n      if (isArray(props.items)) {\n        var activeDefined = false;\n        childNodes = props.items.map(function (item, idx) {\n          if (!isObject(item)) {\n            item = {\n              text: toString$1(item)\n            };\n          } // Copy the value here so we can normalize it.\n\n\n          var active = item.active;\n\n          if (active) {\n            activeDefined = true;\n          }\n\n          if (!active && !activeDefined) {\n            // Auto-detect active by position in list.\n            active = idx + 1 === props.items.length;\n          }\n\n          return h(BBreadcrumbItem, {\n            props: _objectSpread2({}, item, {\n              active: active\n            })\n          });\n        });\n      }\n\n      return h('ol', a(data, {\n        staticClass: 'breadcrumb'\n      }), childNodes);\n    }\n  });\n\n  var BreadcrumbPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BBreadcrumb: BBreadcrumb,\n      BBreadcrumbItem: BBreadcrumbItem,\n      BBreadcrumbLink: BBreadcrumbLink\n    }\n  });\n\n  /*\n   * Key Codes (events)\n   */\n  var KEY_CODES = freeze({\n    SPACE: 32,\n    ENTER: 13,\n    ESC: 27,\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40,\n    PAGEUP: 33,\n    PAGEDOWN: 34,\n    HOME: 36,\n    END: 35,\n    TAB: 9,\n    SHIFT: 16,\n    CTRL: 17,\n    BACKSPACE: 8,\n    ALT: 18,\n    PAUSE: 19,\n    BREAK: 19,\n    INSERT: 45,\n    INS: 45,\n    DELETE: 46\n  });\n\n  var NAME$4 = 'BButton';\n  var btnProps = {\n    block: {\n      type: Boolean,\n      default: false\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    size: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$4, 'size');\n      }\n    },\n    variant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$4, 'variant');\n      }\n    },\n    type: {\n      type: String,\n      default: 'button'\n    },\n    tag: {\n      type: String,\n      default: 'button'\n    },\n    pill: {\n      type: Boolean,\n      default: false\n    },\n    squared: {\n      type: Boolean,\n      default: false\n    },\n    pressed: {\n      // Tri-state: `true`, `false` or `null`\n      // => On, off, not a toggle\n      type: Boolean,\n      default: null\n    }\n  };\n  var linkProps$1 = propsFactory();\n  delete linkProps$1.href.default;\n  delete linkProps$1.to.default;\n  var linkPropKeys = keys(linkProps$1);\n  var props$4 = _objectSpread2({}, linkProps$1, {}, btnProps); // --- Helper methods ---\n  // Returns `true` if a tag's name equals `name`\n\n  var tagIs = function tagIs(tag, name) {\n    return toString$1(tag).toLowerCase() === toString$1(name).toLowerCase();\n  }; // Focus handler for toggle buttons\n  // Needs class of 'focus' when focused\n\n\n  var handleFocus = function handleFocus(evt) {\n    if (evt.type === 'focusin') {\n      addClass(evt.target, 'focus');\n    } else if (evt.type === 'focusout') {\n      removeClass(evt.target, 'focus');\n    }\n  }; // Is the requested button a link?\n  // If tag prop is set to `a`, we use a <b-link> to get proper disabled handling\n\n\n  var isLink = function isLink(props) {\n    return props.href || props.to || tagIs(props.tag, 'a');\n  }; // Is the button to be a toggle button?\n\n\n  var isToggle = function isToggle(props) {\n    return isBoolean(props.pressed);\n  }; // Is the button \"really\" a button?\n\n\n  var isButton = function isButton(props) {\n    return !(isLink(props) || props.tag && !tagIs(props.tag, 'button'));\n  }; // Is the requested tag not a button or link?\n\n\n  var isNonStandardTag = function isNonStandardTag(props) {\n    return !isLink(props) && !isButton(props);\n  }; // Compute required classes (non static classes)\n\n\n  var computeClass = function computeClass(props) {\n    var _ref;\n\n    return [\"btn-\".concat(props.variant || getComponentConfig(NAME$4, 'variant')), (_ref = {}, _defineProperty(_ref, \"btn-\".concat(props.size), props.size), _defineProperty(_ref, 'btn-block', props.block), _defineProperty(_ref, 'rounded-pill', props.pill), _defineProperty(_ref, 'rounded-0', props.squared && !props.pill), _defineProperty(_ref, \"disabled\", props.disabled), _defineProperty(_ref, \"active\", props.pressed), _ref)];\n  }; // Compute the link props to pass to b-link (if required)\n\n\n  var computeLinkProps = function computeLinkProps(props) {\n    return isLink(props) ? pluckProps(linkPropKeys, props) : null;\n  }; // Compute the attributes for a button\n\n\n  var computeAttrs = function computeAttrs(props, data) {\n    var button = isButton(props);\n    var link = isLink(props);\n    var toggle = isToggle(props);\n    var nonStandardTag = isNonStandardTag(props);\n    var hashLink = link && props.href === '#';\n    var role = data.attrs && data.attrs.role ? data.attrs.role : null;\n    var tabindex = data.attrs ? data.attrs.tabindex : null;\n\n    if (nonStandardTag || hashLink) {\n      tabindex = '0';\n    }\n\n    return {\n      // Type only used for \"real\" buttons\n      type: button && !link ? props.type : null,\n      // Disabled only set on \"real\" buttons\n      disabled: button ? props.disabled : null,\n      // We add a role of button when the tag is not a link or button for ARIA\n      // Don't bork any role provided in `data.attrs` when `isLink` or `isButton`\n      // Except when link has `href` of `#`\n      role: nonStandardTag || hashLink ? 'button' : role,\n      // We set the `aria-disabled` state for non-standard tags\n      'aria-disabled': nonStandardTag ? String(props.disabled) : null,\n      // For toggles, we need to set the pressed state for ARIA\n      'aria-pressed': toggle ? String(props.pressed) : null,\n      // `autocomplete=\"off\"` is needed in toggle mode to prevent some browsers\n      // from remembering the previous setting when using the back button\n      autocomplete: toggle ? 'off' : null,\n      // `tabindex` is used when the component is not a button\n      // Links are tabbable, but don't allow disabled, while non buttons or links\n      // are not tabbable, so we mimic that functionality by disabling tabbing\n      // when disabled, and adding a `tabindex=\"0\"` to non buttons or non links\n      tabindex: props.disabled && !button ? '-1' : tabindex\n    };\n  }; // @vue/component\n\n\n  var BButton =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$4,\n    functional: true,\n    props: props$4,\n    render: function render(h, _ref2) {\n      var props = _ref2.props,\n          data = _ref2.data,\n          listeners = _ref2.listeners,\n          children = _ref2.children;\n      var toggle = isToggle(props);\n      var link = isLink(props);\n      var nonStandardTag = isNonStandardTag(props);\n      var hashLink = link && props.href === '#';\n      var on = {\n        keydown: function keydown(evt) {\n          // When the link is a `href=\"#\"` or a non-standard tag (has `role=\"button\"`),\n          // we add a keydown handlers for SPACE/ENTER\n\n          /* istanbul ignore next */\n          if (props.disabled || !(nonStandardTag || hashLink)) {\n            return;\n          }\n\n          var keyCode = evt.keyCode; // Add SPACE handler for `href=\"#\"` and ENTER handler for non-standard tags\n\n          if (keyCode === KEY_CODES.SPACE || keyCode === KEY_CODES.ENTER && nonStandardTag) {\n            var target = evt.currentTarget || evt.target;\n            evt.preventDefault();\n            target.click();\n          }\n        },\n        click: function click(evt) {\n          /* istanbul ignore if: blink/button disabled should handle this */\n          if (props.disabled && isEvent(evt)) {\n            evt.stopPropagation();\n            evt.preventDefault();\n          } else if (toggle && listeners && listeners['update:pressed']) {\n            // Send `.sync` updates to any \"pressed\" prop (if `.sync` listeners)\n            // `concat()` will normalize the value to an array without\n            // double wrapping an array value in an array\n            concat(listeners['update:pressed']).forEach(function (fn) {\n              if (isFunction(fn)) {\n                fn(!props.pressed);\n              }\n            });\n          }\n        }\n      };\n\n      if (toggle) {\n        on.focusin = handleFocus;\n        on.focusout = handleFocus;\n      }\n\n      var componentData = {\n        staticClass: 'btn',\n        class: computeClass(props),\n        props: computeLinkProps(props),\n        attrs: computeAttrs(props, data),\n        on: on\n      };\n      return h(link ? BLink : props.tag, a(data, componentData), children);\n    }\n  });\n\n  var ButtonPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BButton: BButton,\n      BBtn: BButton,\n      BButtonClose: BButtonClose,\n      BBtnClose: BButtonClose\n    }\n  });\n\n  var NAME$5 = 'BButtonGroup';\n  var props$5 = {\n    vertical: {\n      type: Boolean,\n      default: false\n    },\n    size: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig('BButton', 'size');\n      }\n    },\n    tag: {\n      type: String,\n      default: 'div'\n    },\n    ariaRole: {\n      type: String,\n      default: 'group'\n    }\n  }; // @vue/component\n\n  var BButtonGroup =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$5,\n    functional: true,\n    props: props$5,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h(props.tag, a(data, {\n        class: _defineProperty({\n          'btn-group': !props.vertical,\n          'btn-group-vertical': props.vertical\n        }, \"btn-group-\".concat(props.size), props.size),\n        attrs: {\n          role: props.ariaRole\n        }\n      }), children);\n    }\n  });\n\n  var ButtonGroupPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BButtonGroup: BButtonGroup,\n      BBtnGroup: BButtonGroup\n    }\n  });\n\n  var ITEM_SELECTOR = ['.btn:not(.disabled):not([disabled]):not(.dropdown-item)', '.form-control:not(.disabled):not([disabled])', 'select:not(.disabled):not([disabled])', 'input[type=\"checkbox\"]:not(.disabled)', 'input[type=\"radio\"]:not(.disabled)'].join(','); // @vue/component\n\n  var BButtonToolbar =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BButtonToolbar',\n    mixins: [normalizeSlotMixin],\n    props: {\n      justify: {\n        type: Boolean,\n        default: false\n      },\n      keyNav: {\n        type: Boolean,\n        default: false\n      }\n    },\n    mounted: function mounted() {\n      if (this.keyNav) {\n        // Pre-set the tabindexes if the markup does not include tabindex=\"-1\" on the toolbar items\n        this.getItems();\n      }\n    },\n    methods: {\n      onFocusin: function onFocusin(evt) {\n        if (evt.target === this.$el) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          this.focusFirst(evt);\n        }\n      },\n      stop: function stop(evt) {\n        evt.preventDefault();\n        evt.stopPropagation();\n      },\n      onKeydown: function onKeydown(evt) {\n        if (!this.keyNav) {\n          /* istanbul ignore next: should never happen */\n          return;\n        }\n\n        var key = evt.keyCode;\n        var shift = evt.shiftKey;\n\n        if (key === KEY_CODES.UP || key === KEY_CODES.LEFT) {\n          this.stop(evt);\n          shift ? this.focusFirst(evt) : this.focusPrev(evt);\n        } else if (key === KEY_CODES.DOWN || key === KEY_CODES.RIGHT) {\n          this.stop(evt);\n          shift ? this.focusLast(evt) : this.focusNext(evt);\n        }\n      },\n      setItemFocus: function setItemFocus(item) {\n        item && item.focus && item.focus();\n      },\n      focusFirst: function focusFirst() {\n        var items = this.getItems();\n        this.setItemFocus(items[0]);\n      },\n      focusPrev: function focusPrev(evt) {\n        var items = this.getItems();\n        var index = items.indexOf(evt.target);\n\n        if (index > -1) {\n          items = items.slice(0, index).reverse();\n          this.setItemFocus(items[0]);\n        }\n      },\n      focusNext: function focusNext(evt) {\n        var items = this.getItems();\n        var index = items.indexOf(evt.target);\n\n        if (index > -1) {\n          items = items.slice(index + 1);\n          this.setItemFocus(items[0]);\n        }\n      },\n      focusLast: function focusLast() {\n        var items = this.getItems().reverse();\n        this.setItemFocus(items[0]);\n      },\n      getItems: function getItems() {\n        var items = selectAll(ITEM_SELECTOR, this.$el);\n        items.forEach(function (item) {\n          // Ensure tabfocus is -1 on any new elements\n          item.tabIndex = -1;\n        });\n        return items.filter(function (el) {\n          return isVisible(el);\n        });\n      }\n    },\n    render: function render(h) {\n      return h('div', {\n        staticClass: 'btn-toolbar',\n        class: {\n          'justify-content-between': this.justify\n        },\n        attrs: {\n          role: 'toolbar',\n          tabindex: this.keyNav ? '0' : null\n        },\n        on: this.keyNav ? {\n          focusin: this.onFocusin,\n          keydown: this.onKeydown\n        } : {}\n      }, [this.normalizeSlot('default')]);\n    }\n  });\n\n  var ButtonToolbarPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BButtonToolbar: BButtonToolbar,\n      BBtnToolbar: BButtonToolbar\n    }\n  });\n\n  // Handles when arrays are \"sparse\" (array.every(...) doesn't handle sparse)\n\n  var compareArrays = function compareArrays(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    var equal = true;\n\n    for (var i = 0; equal && i < a.length; i++) {\n      equal = looseEqual(a[i], b[i]);\n    }\n\n    return equal;\n  };\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   * Returns boolean true or false\n   */\n\n\n  var looseEqual = function looseEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    var aValidType = isDate(a);\n    var bValidType = isDate(b);\n\n    if (aValidType || bValidType) {\n      return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n    }\n\n    aValidType = isArray(a);\n    bValidType = isArray(b);\n\n    if (aValidType || bValidType) {\n      return aValidType && bValidType ? compareArrays(a, b) : false;\n    }\n\n    aValidType = isObject(a);\n    bValidType = isObject(b);\n\n    if (aValidType || bValidType) {\n      /* istanbul ignore if: this if will probably never be called */\n      if (!aValidType || !bValidType) {\n        return false;\n      }\n\n      var aKeysCount = keys(a).length;\n      var bKeysCount = keys(b).length;\n\n      if (aKeysCount !== bKeysCount) {\n        return false;\n      }\n\n      for (var key in a) {\n        // eslint-disable-next-line no-prototype-builtins\n        var aHasKey = a.hasOwnProperty(key); // eslint-disable-next-line no-prototype-builtins\n\n        var bHasKey = b.hasOwnProperty(key);\n\n        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n          return false;\n        }\n      }\n    }\n\n    return String(a) === String(b);\n  };\n\n  var RX_DATE = /^\\d+-\\d+-\\d+$/; // --- Date utility methods ---\n  // Create or clone a date (`new Date(...)` shortcut)\n\n  var createDate = function createDate() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _construct(Date, args);\n  }; // Parse a date sting, or Date object, into a Date object (with no time information)\n\n  var parseYMD = function parseYMD(date) {\n    if (isString(date) && RX_DATE.test(date.trim())) {\n      var _date$split$map = date.split('-').map(toInteger),\n          _date$split$map2 = _slicedToArray(_date$split$map, 3),\n          year = _date$split$map2[0],\n          month = _date$split$map2[1],\n          day = _date$split$map2[2];\n\n      return createDate(year, month - 1, day);\n    } else if (isDate(date)) {\n      return createDate(date.getFullYear(), date.getMonth(), date.getDate());\n    }\n\n    return null;\n  }; // Format a date object as `YYYY-MM-DD` format\n\n  var formatYMD = function formatYMD(date) {\n    date = parseYMD(date);\n\n    if (!date) {\n      return null;\n    }\n\n    var year = date.getFullYear();\n    var month = \"0\".concat(date.getMonth() + 1).slice(-2);\n    var day = \"0\".concat(date.getDate()).slice(-2);\n    return \"\".concat(year, \"-\").concat(month, \"-\").concat(day);\n  }; // Given a locale (or locales), resolve the browser available locale\n\n  var resolveLocale = function resolveLocale(locales)\n  /* istanbul ignore next */\n  {\n    var calendar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'gregory';\n    locales = concat(locales).filter(identity);\n    var fmt = new Intl.DateTimeFormat(locales, {\n      calendar: calendar\n    });\n    return fmt.resolvedOptions().locale;\n  }; // Create a `Intl.DateTimeFormat` formatter function\n\n  var createDateFormatter = function createDateFormatter(locale, options)\n  /* istanbul ignore next */\n  {\n    var dtf = new Intl.DateTimeFormat(locale, options);\n    return dtf.format;\n  }; // Determine if two dates are the same date (ignoring time portion)\n\n  var datesEqual = function datesEqual(date1, date2) {\n    // Returns true of the date portion of two date objects are equal\n    // We don't compare the time portion\n    return formatYMD(date1) === formatYMD(date2);\n  }; // --- Date \"math\" utility methods (for BCalendar component mainly) ---\n\n  var firstDateOfMonth = function firstDateOfMonth(date) {\n    date = createDate(date);\n    date.setDate(1);\n    return date;\n  };\n  var lastDateOfMonth = function lastDateOfMonth(date) {\n    date = createDate(date);\n    date.setMonth(date.getMonth() + 1);\n    date.setDate(0);\n    return date;\n  };\n  var oneMonthAgo = function oneMonthAgo(date) {\n    date = createDate(date);\n    var month = date.getMonth();\n    date.setMonth(month - 1);\n\n    if (date.getMonth() === month) {\n      date.setDate(0);\n    }\n\n    return date;\n  };\n  var oneMonthAhead = function oneMonthAhead(date) {\n    date = createDate(date);\n    var month = date.getMonth();\n    date.setMonth(month + 1);\n\n    if (date.getMonth() === (month + 2) % 12) {\n      date.setDate(0);\n    }\n\n    return date;\n  };\n  var oneYearAgo = function oneYearAgo(date) {\n    date = createDate(date);\n    var month = date.getMonth();\n    date.setMonth(month - 12);\n\n    if (date.getMonth() !== month) {\n      date.setDate(0);\n    }\n\n    return date;\n  };\n  var oneYearAhead = function oneYearAhead(date) {\n    date = createDate(date);\n    var month = date.getMonth();\n    date.setMonth(month + 12);\n\n    if (date.getMonth() !== month) {\n      date.setDate(0);\n    }\n\n    return date;\n  };\n\n  /*\n   * SSR Safe Client Side ID attribute generation\n   * id's can only be generated client side, after mount.\n   * this._uid is not synched between server and client.\n   */\n  // @vue/component\n  var idMixin = {\n    props: {\n      id: {\n        type: String,\n        default: null\n      }\n    },\n    data: function data() {\n      return {\n        localId_: null\n      };\n    },\n    computed: {\n      safeId: function safeId() {\n        // Computed property that returns a dynamic function for creating the ID.\n        // Reacts to changes in both .id and .localId_ And regens a new function\n        var id = this.id || this.localId_; // We return a function that accepts an optional suffix string\n        // So this computed prop looks and works like a method!!!\n        // But benefits from Vue's Computed prop caching\n\n        var fn = function fn(suffix) {\n          if (!id) {\n            return null;\n          }\n\n          suffix = String(suffix || '').replace(/\\s+/g, '_');\n          return suffix ? id + '_' + suffix : id;\n        };\n\n        return fn;\n      }\n    },\n    mounted: function mounted() {\n      var _this = this;\n\n      // mounted only occurs client side\n      this.$nextTick(function () {\n        // Update dom with auto ID after dom loaded to prevent\n        // SSR hydration errors.\n        _this.localId_ = \"__BVID__\".concat(_this._uid);\n      });\n    }\n  };\n\n  var commonIconProps = {\n    variant: {\n      type: String,\n      default: null\n    },\n    fontScale: {\n      type: [Number, String],\n      default: 1\n    },\n    scale: {\n      type: [Number, String],\n      default: 1\n    },\n    rotate: {\n      type: [Number, String],\n      default: 0\n    },\n    flipH: {\n      type: Boolean,\n      default: false\n    },\n    flipV: {\n      type: Boolean,\n      default: false\n    },\n    shiftH: {\n      type: [Number, String],\n      default: 0\n    },\n    shiftV: {\n      type: [Number, String],\n      default: 0\n    }\n  }; // Base attributes needed on all icons\n\n  var baseAttrs = {\n    width: '1em',\n    height: '1em',\n    viewBox: '0 0 20 20',\n    focusable: 'false',\n    role: 'img',\n    alt: 'icon'\n  }; // Shared private base component to reduce bundle/runtime size\n  // @vue/component\n\n  var BVIconBase =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BVIconBase',\n    functional: true,\n    props: _objectSpread2({\n      content: {\n        type: String\n      },\n      stacked: {\n        type: Boolean,\n        default: false\n      }\n    }, commonIconProps),\n    render: function render(h, _ref) {\n      var data = _ref.data,\n          props = _ref.props,\n          children = _ref.children;\n      var fontScale = Math.max(toFloat(props.fontScale) || 1, 0) || 1;\n      var scale = Math.max(toFloat(props.scale) || 1, 0) || 1;\n      var rotate = toFloat(props.rotate) || 0;\n      var shiftH = toFloat(props.shiftH) || 0;\n      var shiftV = toFloat(props.shiftV) || 0;\n      var flipH = props.flipH;\n      var flipV = props.flipV; // Compute the transforms\n      // Note that order is important as SVG transforms are applied in order from\n      // left to right and we want flipping/scale to occur before rotation\n      // Note shifting is applied separately\n      // Assumes that the viewbox is `0 0 20 20` (`10 10` is the center)\n\n      var hasScale = flipH || flipV || scale !== 1;\n      var hasTransforms = hasScale || rotate;\n      var hasShift = shiftH || shiftV;\n      var transforms = [hasTransforms ? 'translate(10 10)' : null, hasScale ? \"scale(\".concat((flipH ? -1 : 1) * scale, \" \").concat((flipV ? -1 : 1) * scale, \")\") : null, rotate ? \"rotate(\".concat(rotate, \")\") : null, hasTransforms ? 'translate(-10 -10)' : null].filter(identity); // Handling stacked icons\n\n      var isStacked = props.stacked;\n      var hasContent = !isUndefinedOrNull(props.content); // We wrap the content in a `<g>` for handling the transforms (except shift)\n\n      var $inner = h('g', {\n        attrs: {\n          transform: transforms.join(' ') || null\n        },\n        domProps: hasContent ? {\n          innerHTML: props.content || ''\n        } : {}\n      }, children); // If needed, we wrap in an additional `<g>` in order to handle the shifting\n\n      if (hasShift) {\n        $inner = h('g', {\n          attrs: {\n            transform: \"translate(\".concat(20 * shiftH / 16, \" \").concat(-20 * shiftV / 16, \")\")\n          }\n        }, [$inner]);\n      }\n\n      return h('svg', a({\n        staticClass: 'b-icon bi',\n        class: _defineProperty({}, \"text-\".concat(props.variant), !!props.variant),\n        attrs: baseAttrs,\n        style: isStacked ? {} : {\n          fontSize: fontScale === 1 ? null : \"\".concat(fontScale * 100, \"%\")\n        }\n      }, // Merge in user supplied data\n      data, // If icon is stacked, null out some attrs\n      isStacked ? {\n        attrs: {\n          width: null,\n          height: null,\n          role: null,\n          alt: null\n        }\n      } : {}, // These cannot be overridden by users\n      {\n        attrs: {\n          xmlns: isStacked ? null : 'http://www.w3.org/2000/svg',\n          fill: 'currentColor'\n        }\n      }), [$inner]);\n    }\n  });\n\n  /**\n   * Icon component generator function\n   *\n   * @param {string} icon name (minus the leading `BIcon`)\n   * @param {string} raw `innerHTML` for SVG\n   * @return {VueComponent}\n   */\n\n  var makeIcon = function makeIcon(name, content) {\n    // For performance reason we pre-compute some values, so that\n    // they are not computed on each render of the icon component\n    var iconName = \"BIcon\".concat(pascalCase(name));\n    var iconNameClass = \"bi-\".concat(kebabCase(name));\n    var svgContent = trim(content || ''); // Return the icon component definition\n\n    return (\n      /*#__PURE__*/\n      Vue.extend({\n        name: iconName,\n        functional: true,\n        props: _objectSpread2({}, commonIconProps, {\n          stacked: {\n            type: Boolean,\n            default: false\n          }\n        }),\n        render: function render(h, _ref) {\n          var data = _ref.data,\n              props = _ref.props;\n          return h(BVIconBase, a(data, {\n            staticClass: iconNameClass,\n            props: _objectSpread2({}, props, {\n              content: svgContent\n            })\n          }));\n        }\n      })\n    );\n  };\n\n  // --- BEGIN AUTO-GENERATED FILE ---\n\n  var BIconBlank =\n  /*#__PURE__*/\n  makeIcon('Blank', ''); // --- Bootstrap Icons ---\n  var BIconCalendar =\n  /*#__PURE__*/\n  makeIcon('Calendar', '<path fill-rule=\"evenodd\" d=\"M16 2H4a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2V4a2 2 0 00-2-2zM3 5.857C3 5.384 3.448 5 4 5h12c.552 0 1 .384 1 .857v10.286c0 .473-.448.857-1 .857H4c-.552 0-1-.384-1-.857V5.857z\" clip-rule=\"evenodd\"/><path fill-rule=\"evenodd\" d=\"M8.5 9a1 1 0 100-2 1 1 0 000 2zm3 0a1 1 0 100-2 1 1 0 000 2zm3 0a1 1 0 100-2 1 1 0 000 2zm-9 3a1 1 0 100-2 1 1 0 000 2zm3 0a1 1 0 100-2 1 1 0 000 2zm3 0a1 1 0 100-2 1 1 0 000 2zm3 0a1 1 0 100-2 1 1 0 000 2zm-9 3a1 1 0 100-2 1 1 0 000 2zm3 0a1 1 0 100-2 1 1 0 000 2zm3 0a1 1 0 100-2 1 1 0 000 2z\" clip-rule=\"evenodd\"/>');\n  var BIconCalendarFill =\n  /*#__PURE__*/\n  makeIcon('CalendarFill', '<path d=\"M2 4a2 2 0 012-2h12a2 2 0 012 2H2z\"/><path fill-rule=\"evenodd\" d=\"M2 5h16v11a2 2 0 01-2 2H4a2 2 0 01-2-2V5zm6.5 4a1 1 0 100-2 1 1 0 000 2zm4-1a1 1 0 11-2 0 1 1 0 012 0zm2 1a1 1 0 100-2 1 1 0 000 2zm-8 2a1 1 0 11-2 0 1 1 0 012 0zm2 1a1 1 0 100-2 1 1 0 000 2zm4-1a1 1 0 11-2 0 1 1 0 012 0zm2 1a1 1 0 100-2 1 1 0 000 2zm-8 2a1 1 0 11-2 0 1 1 0 012 0zm2 1a1 1 0 100-2 1 1 0 000 2zm4-1a1 1 0 11-2 0 1 1 0 012 0z\" clip-rule=\"evenodd\"/>');\n  var BIconChevronLeft =\n  /*#__PURE__*/\n  makeIcon('ChevronLeft', '<path fill-rule=\"evenodd\" d=\"M13.354 3.646a.5.5 0 010 .708L7.707 10l5.647 5.646a.5.5 0 01-.708.708l-6-6a.5.5 0 010-.708l6-6a.5.5 0 01.708 0z\" clip-rule=\"evenodd\"/>');\n  var BIconCircleFill =\n  /*#__PURE__*/\n  makeIcon('CircleFill', '<circle cx=\"10\" cy=\"10\" r=\"8\"/>');\n  var BIconDash =\n  /*#__PURE__*/\n  makeIcon('Dash', '<path fill-rule=\"evenodd\" d=\"M5.5 10a.5.5 0 01.5-.5h8a.5.5 0 010 1H6a.5.5 0 01-.5-.5z\" clip-rule=\"evenodd\"/>');\n  var BIconPlus =\n  /*#__PURE__*/\n  makeIcon('Plus', '<path fill-rule=\"evenodd\" d=\"M10 5.5a.5.5 0 01.5.5v4a.5.5 0 01-.5.5H6a.5.5 0 010-1h3.5V6a.5.5 0 01.5-.5z\" clip-rule=\"evenodd\"/><path fill-rule=\"evenodd\" d=\"M9.5 10a.5.5 0 01.5-.5h4a.5.5 0 010 1h-3.5V14a.5.5 0 01-1 0v-4z\" clip-rule=\"evenodd\"/>');\n   // --- END AUTO-GENERATED FILE ---\n\n  var BIconstack =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BIconstack',\n    functional: true,\n    props: _objectSpread2({}, commonIconProps),\n    render: function render(h, _ref) {\n      var data = _ref.data,\n          props = _ref.props,\n          children = _ref.children;\n      return h(BVIconBase, a(data, {\n        staticClass: 'b-iconstack',\n        props: _objectSpread2({}, props, {\n          stacked: false\n        })\n      }), children);\n    }\n  });\n\n  var NAME$6 = 'BCalendar'; // Key Codes\n\n  var UP = KEY_CODES.UP,\n      DOWN = KEY_CODES.DOWN,\n      LEFT = KEY_CODES.LEFT,\n      RIGHT = KEY_CODES.RIGHT,\n      PAGEUP = KEY_CODES.PAGEUP,\n      PAGEDOWN = KEY_CODES.PAGEDOWN,\n      HOME = KEY_CODES.HOME,\n      END = KEY_CODES.END,\n      ENTER = KEY_CODES.ENTER,\n      SPACE = KEY_CODES.SPACE; // Languages that are RTL\n\n  var RTL_LANGS = ['ar', 'az', 'ckb', 'fa', 'he', 'ks', 'lrc', 'mzn', 'ps', 'sd', 'te', 'ug', 'ur', 'yi'].map(function (locale) {\n    return locale.toLowerCase();\n  }); // --- Helper utilities ---\n\n  var isLocaleRTL = function isLocaleRTL(locale) {\n    // Determines if the locale is RTL (only single locale supported)\n    var parts = toString$1(locale).toLowerCase().replace(/-u-.+/, '').split('-');\n    var locale1 = parts.slice(0, 2).join('-');\n    var locale2 = parts[0];\n    return arrayIncludes(RTL_LANGS, locale1) || arrayIncludes(RTL_LANGS, locale2);\n  }; // --- BCalendar component ---\n  // @vue/component\n\n  var BCalendar = Vue.extend({\n    name: NAME$6,\n    mixins: [idMixin, normalizeSlotMixin],\n    model: {\n      // Even though this is the default that Vue assumes, we need\n      // to add it for the docs to reflect that this is the model\n      // And also for some validation libraries to work\n      prop: 'value',\n      event: 'input'\n    },\n    props: {\n      value: {\n        type: [String, Date] // default: null\n\n      },\n      valueAsDate: {\n        // Always return the `v-model` value as a date object\n        type: Boolean,\n        default: false\n      },\n      disabled: {\n        type: Boolean,\n        default: false\n      },\n      readonly: {\n        type: Boolean,\n        default: false\n      },\n      min: {\n        type: [String, Date] // default: null\n\n      },\n      max: {\n        type: [String, Date] // default: null\n\n      },\n      dateDisabledFn: {\n        type: Function // default: null\n\n      },\n      startWeekday: {\n        // `0` (Sunday), `1` (Monday), ... `6` (Saturday)\n        // Day of week to start calendar on\n        type: [Number, String],\n        default: 0\n      },\n      locale: {\n        // Locale(s) to use\n        // Default is to use page/browser default setting\n        type: [String, Array] // default: null\n\n      },\n      direction: {\n        // 'ltr', 'rtl', or `null` (for auto detect)\n        type: String // default: null\n\n      },\n      selectedVariant: {\n        // Variant color to use for the selected date\n        type: String,\n        default: 'primary'\n      },\n      todayVariant: {\n        // Variant color to use for today's date (defaults to `variant`)\n        type: String // default: null\n\n      },\n      noHighlightToday: {\n        // Disable highlighting today's date\n        type: Boolean,\n        default: false\n      },\n      dateInfoFn: {\n        // Function to set a class of (classes) on the date cell\n        // if passed a string or an array\n        // TODO:\n        //   If the function returns an object, look for class prop for classes,\n        //   and other props for handling events/details/descriptions\n        type: Function // default: null\n\n      },\n      width: {\n        // Has no effect if prop `block` is set\n        type: String,\n        default: '270px'\n      },\n      block: {\n        // Makes calendar the full width of its parent container\n        type: Boolean,\n        default: false\n      },\n      hideHeader: {\n        // When true makes the selected date header `sr-only`\n        type: Boolean,\n        default: false\n      },\n      hidden: {\n        // When `true`, renders a comment node, but keeps the component instance active\n        // Mainly for <b-form-date>, so that we can get the component's value and locale\n        // But we might just use separate date formatters, using the resolved locale\n        // (adjusted for the gregorian calendar)\n        type: Boolean,\n        default: false\n      },\n      ariaControls: {\n        type: String // default: null\n\n      },\n      roleDescription: {\n        type: String // default: null\n\n      },\n      // Labels for buttons and keyboard shortcuts\n      labelPrevYear: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$6, 'labelPrevYear');\n        }\n      },\n      labelPrevMonth: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$6, 'labelPrevMonth');\n        }\n      },\n      labelCurrentMonth: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$6, 'labelCurrentMonth');\n        }\n      },\n      labelNextMonth: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$6, 'labelNextMonth');\n        }\n      },\n      labelNextYear: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$6, 'labelNextYear');\n        }\n      },\n      labelToday: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$6, 'labelToday');\n        }\n      },\n      labelSelected: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$6, 'labelSelected');\n        }\n      },\n      labelNoDateSelected: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$6, 'labelNoDateSelected');\n        }\n      },\n      labelCalendar: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$6, 'labelCalendar');\n        }\n      },\n      labelNav: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$6, 'labelNav');\n        }\n      },\n      labelHelp: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$6, 'labelHelp');\n        }\n      }\n    },\n    data: function data() {\n      var selected = formatYMD(this.value) || '';\n      return {\n        // Selected date\n        selectedYMD: selected,\n        // Date in calendar grid that has `tabindex` of `0`\n        activeYMD: selected || formatYMD(this.getToday()),\n        // Will be true if the calendar grid has/contains focus\n        gridHasFocus: false,\n        // Flag to enable the `aria-live` region(s) after mount\n        // to prevent screen reader \"outbursts\" when mounting\n        isLive: false\n      };\n    },\n    computed: {\n      // TODO: Use computed props to convert `YYYY-MM-DD` to `Date` object\n      selectedDate: function selectedDate() {\n        // Selected as a `Date` object\n        return parseYMD(this.selectedYMD);\n      },\n      activeDate: function activeDate() {\n        // Active as a `Date` object\n        return parseYMD(this.activeYMD);\n      },\n      computedMin: function computedMin() {\n        return parseYMD(this.min);\n      },\n      computedMax: function computedMax() {\n        return parseYMD(this.max);\n      },\n      computedWeekStarts: function computedWeekStarts() {\n        // `startWeekday` is a prop (constrained to `0` through `6`)\n        return Math.max(toInteger(this.startWeekday) || 0, 0) % 7;\n      },\n      computedLocale: function computedLocale() {\n        // Returns the resolved locale used by the calendar\n        return resolveLocale(concat(this.locale).filter(identity), 'gregory');\n      },\n      calendarLocale: function calendarLocale() {\n        // This locale enforces the gregorian calendar (for use in formatter functions)\n        // Needed because IE 11 resolves `ar-IR` as islamic-civil calendar\n        // and IE 11 (and some other browsers) do not support the `calendar` option\n        // And we currently only support the gregorian calendar\n        var fmt = new Intl.DateTimeFormat(this.computedLocale, {\n          calendar: 'gregory'\n        });\n        var calendar = fmt.resolvedOptions().calendar;\n        var locale = fmt.resolvedOptions().locale;\n        /* istanbul ignore if: mainly for IE 11 and a few other browsers, hard to test in JSDOM */\n\n        if (calendar !== 'gregory') {\n          // Ensure the locale requests the gregorian calendar\n          // Mainly for IE 11, and currently we can't handle non-gregorian calendars\n          // TODO: Should we always return this value?\n          locale = locale.replace(/-u-.+$/i, '').concat('-u-ca-gregory');\n        }\n\n        return locale;\n      },\n      calendarYear: function calendarYear() {\n        return this.activeDate.getFullYear();\n      },\n      calendarMonth: function calendarMonth() {\n        return this.activeDate.getMonth();\n      },\n      calendarFirstDay: function calendarFirstDay() {\n        return createDate(this.calendarYear, this.calendarMonth, 1);\n      },\n      calendarDaysInMonth: function calendarDaysInMonth() {\n        // We create a new date as to not mutate the original\n        var date = createDate(this.calendarFirstDay);\n        date.setMonth(date.getMonth() + 1, 0);\n        return date.getDate();\n      },\n      computedVariant: function computedVariant() {\n        return \"btn-\".concat(this.selectedVariant || 'primary');\n      },\n      computedTodayVariant: function computedTodayVariant() {\n        return \"btn-outline-\".concat(this.todayVariant || this.selectedVariant || 'primary');\n      },\n      isRTL: function isRTL() {\n        // `true` if the language requested is RTL\n        var dir = toString$1(this.direction).toLowerCase();\n\n        if (dir === 'rtl') {\n          /* istanbul ignore next */\n          return true;\n        } else if (dir === 'ltr') {\n          /* istanbul ignore next */\n          return false;\n        }\n\n        return isLocaleRTL(this.computedLocale);\n      },\n      context: function context() {\n        var selectedYMD = this.selectedYMD;\n        var selectedDate = parseYMD(selectedYMD);\n        var activeYMD = this.activeYMD;\n        var activeDate = parseYMD(activeYMD);\n        return {\n          // The current value of the `v-model`\n          selectedYMD: selectedYMD,\n          selectedDate: selectedDate,\n          selectedFormatted: selectedDate ? this.formatDateString(selectedDate) : this.labelNoDateSelected,\n          // Which date cell is considered active due to navigation\n          activeYMD: activeYMD,\n          activeDate: activeDate,\n          activeFormatted: activeDate ? this.formatDateString(activeDate) : '',\n          // `true` if the date is disabled (when using keyboard navigation)\n          disabled: this.dateDisabled(activeDate),\n          // Locales used in formatting dates\n          locale: this.computedLocale,\n          calendarLocale: this.calendarLocale,\n          rtl: this.isRTL\n        };\n      },\n      // Computed props that return a function reference\n      dateOutOfRange: function dateOutOfRange() {\n        // Check wether a date is within the min/max range\n        // returns a new function ref if the pops change\n        // We do this as we need to trigger the calendar computed prop\n        // to update when these props update\n        var min = this.computedMin;\n        var max = this.computedMax;\n        return function (date) {\n          // Handle both `YYYY-MM-DD` and `Date` objects\n          date = parseYMD(date);\n          return min && date < min || max && date > max;\n        };\n      },\n      dateDisabled: function dateDisabled() {\n        // Returns a function for validating if a date is within range\n        // We grab this variables first to ensure a new function ref\n        // is generated when the props value changes\n        // We do this as we need to trigger the calendar computed prop\n        // to update when these props update\n        var rangeFn = this.dateOutOfRange;\n        var disabledFn = isFunction(this.dateDisabledFn) ? this.dateDisabledFn : function () {\n          return false;\n        }; // Return the function ref\n\n        return function (date) {\n          // Handle both `YYYY-MM-DD` and `Date` objects\n          date = parseYMD(date);\n          var ymd = formatYMD(date);\n          return !!(rangeFn(date) || disabledFn(ymd, date));\n        };\n      },\n      // Computed props that return date formatter functions\n      formatDateString: function formatDateString() {\n        // Returns a date formatter function\n        return createDateFormatter(this.calendarLocale, {\n          year: 'numeric',\n          month: 'long',\n          day: 'numeric',\n          weekday: 'long',\n          calendar: 'gregory'\n        });\n      },\n      formatYearMonth: function formatYearMonth() {\n        // Returns a date formatter function\n        return createDateFormatter(this.calendarLocale, {\n          year: 'numeric',\n          month: 'long',\n          calendar: 'gregory'\n        });\n      },\n      formatWeekdayName: function formatWeekdayName() {\n        return createDateFormatter(this.calendarLocale, {\n          weekday: 'long',\n          calendar: 'gregory'\n        });\n      },\n      formatWeekdayNameShort: function formatWeekdayNameShort() {\n        // Used as the header cells\n        return createDateFormatter(this.calendarLocale, {\n          weekday: 'short',\n          calendar: 'gregory'\n        });\n      },\n      formatDay: function formatDay() {\n        return createDateFormatter(this.calendarLocale, {\n          day: 'numeric',\n          calendar: 'gregory'\n        });\n      },\n      // Disabled states for the nav buttons\n      prevYearDisabled: function prevYearDisabled() {\n        var min = this.computedMin;\n        return this.disabled || min && lastDateOfMonth(oneYearAgo(this.activeDate)) < min;\n      },\n      prevMonthDisabled: function prevMonthDisabled() {\n        var min = this.computedMin;\n        return this.disabled || min && lastDateOfMonth(oneMonthAgo(this.activeDate)) < min;\n      },\n      thisMonthDisabled: function thisMonthDisabled() {\n        // TODO: We could/should check if today is out of range\n        return this.disabled;\n      },\n      nextMonthDisabled: function nextMonthDisabled() {\n        var max = this.computedMax;\n        return this.disabled || max && firstDateOfMonth(oneMonthAhead(this.activeDate)) > max;\n      },\n      nextYearDisabled: function nextYearDisabled() {\n        var max = this.computedMax;\n        return this.disabled || max && firstDateOfMonth(oneYearAhead(this.activeDate)) > max;\n      },\n      // Calendar generation\n      calendar: function calendar() {\n        var matrix = [];\n        var firstDay = this.calendarFirstDay;\n        var calendarYear = firstDay.getFullYear();\n        var calendarMonth = firstDay.getMonth();\n        var daysInMonth = this.calendarDaysInMonth;\n        var startIndex = firstDay.getDay(); // `0`..`6`\n\n        var weekOffset = (this.computedWeekStarts > startIndex ? 7 : 0) - this.computedWeekStarts; // TODO: Change `dateInfoFn` to handle events and notes as well as classes\n\n        var dateInfoFn = isFunction(this.dateInfoFn) ? this.dateInfoFn : function () {\n          return {};\n        }; // Build the calendar matrix\n\n        var currentDay = 0 - weekOffset - startIndex;\n\n        for (var week = 0; week < 6 && currentDay < daysInMonth; week++) {\n          // For each week\n          matrix[week] = []; // The following could be a map function\n\n          for (var j = 0; j < 7; j++) {\n            // For each day in week\n            currentDay++;\n            var date = createDate(calendarYear, calendarMonth, currentDay);\n            var month = date.getMonth();\n            var dayYMD = formatYMD(date);\n            var dayDisabled = this.dateDisabled(date); // TODO: This could be a normalizer method\n\n            var dateInfo = dateInfoFn(dayYMD, parseYMD(dayYMD));\n            dateInfo = isString(dateInfo) || isArray(dateInfo) ? {\n              class: dateInfo\n            } : isPlainObject(dateInfo) ? _objectSpread2({\n              class: ''\n            }, dateInfo) : {\n              class: ''\n            };\n            matrix[week].push({\n              ymd: dayYMD,\n              // Cell content\n              day: this.formatDay(date),\n              label: this.formatDateString(date),\n              // Flags for styling\n              isThisMonth: month === calendarMonth,\n              isDisabled: dayDisabled,\n              // TODO: Handle other dateInfo properties such as notes/events\n              info: dateInfo\n            });\n          }\n        }\n\n        return matrix;\n      },\n      calendarHeadings: function calendarHeadings() {\n        var _this = this;\n\n        return this.calendar[0].map(function (d) {\n          return {\n            text: _this.formatWeekdayNameShort(parseYMD(d.ymd)),\n            label: _this.formatWeekdayName(parseYMD(d.ymd))\n          };\n        });\n      }\n    },\n    watch: {\n      value: function value(newVal, oldVal) {\n        var selected = formatYMD(newVal) || '';\n        var old = formatYMD(oldVal) || '';\n\n        if (!datesEqual(selected, old)) {\n          this.activeYMD = selected || this.activeYMD;\n          this.selectedYMD = selected;\n        }\n      },\n      selectedYMD: function selectedYMD(newYMD, oldYMD) {\n        // TODO:\n        //   Should we compare to `formatYMD(this.value)` and emit\n        //   only if they are different?\n        if (newYMD !== oldYMD) {\n          this.$emit('input', this.valueAsDate ? parseYMD(newYMD) || null : newYMD || '');\n        }\n      },\n      context: function context(newVal, oldVal) {\n        if (!looseEqual(newVal, oldVal)) {\n          this.$emit('context', newVal);\n        }\n      },\n      hidden: function hidden(newVal) {\n        // Reset the active focused day when hidden\n        this.activeYMD = this.selectedYMD || formatYMD(this.value) || formatYMD(this.getToday()); // Enable/disable the live regions\n\n        this.setLive(!newVal);\n      }\n    },\n    created: function created() {\n      var _this2 = this;\n\n      this.$nextTick(function () {\n        _this2.$emit('context', _this2.context);\n      });\n    },\n    mounted: function mounted() {\n      this.setLive(true);\n    },\n    activated: function activated()\n    /* istanbul ignore next */\n    {\n      this.setLive(true);\n    },\n    deactivated: function deactivated()\n    /* istanbul ignore next */\n    {\n      this.setLive(false);\n    },\n    beforeDestroy: function beforeDestroy() {\n      this.setLive(false);\n    },\n    methods: {\n      // Public method(s)\n      focus: function focus() {\n        if (!this.disabled) {\n          try {\n            this.$refs.grid.focus();\n          } catch (_unused) {}\n        }\n      },\n      blur: function blur() {\n        try {\n          this.$refs.grid.blur();\n        } catch (_unused2) {}\n      },\n      // Private methods\n      setLive: function setLive(on) {\n        var _this3 = this;\n\n        if (on) {\n          this.$nextTick(function () {\n            requestAF(function () {\n              _this3.isLive = true;\n            });\n          });\n        } else {\n          this.isLive = false;\n        }\n      },\n      getToday: function getToday() {\n        return parseYMD(createDate());\n      },\n      constrainDate: function constrainDate(date) {\n        // Constrains a date between min and max\n        // returns a new `Date` object instance\n        date = parseYMD(date);\n        var min = this.computedMin || date;\n        var max = this.computedMax || date;\n        return createDate(date < min ? min : date > max ? max : date);\n      },\n      emitSelected: function emitSelected(date) {\n        var _this4 = this;\n\n        // Performed in a `$nextTick()` to (probably) ensure\n        // the input event has emitted first\n        this.$nextTick(function () {\n          _this4.$emit('selected', formatYMD(date) || '', parseYMD(date) || null);\n        });\n      },\n      // Event handlers\n      setGridFocusFlag: function setGridFocusFlag(evt) {\n        // Sets the gridHasFocus flag to make date \"button\" look focused\n        this.gridHasFocus = !this.disabled && evt.type === 'focus';\n      },\n      onKeydownWrapper: function onKeydownWrapper(evt) {\n        // Calendar keyboard navigation\n        // Handles PAGEUP/PAGEDOWN/END/HOME/LEFT/UP/RIGHT/DOWN\n        // Focuses grid after updating\n        var keyCode = evt.keyCode;\n        var altKey = evt.altKey;\n\n        if (!arrayIncludes([PAGEUP, PAGEDOWN, END, HOME, LEFT, UP, RIGHT, DOWN], keyCode)) {\n          /* istanbul ignore next */\n          return;\n        }\n\n        evt.preventDefault();\n        evt.stopPropagation();\n        var activeDate = createDate(this.activeDate);\n        var checkDate = createDate(this.activeDate);\n        var day = activeDate.getDate();\n        var isRTL = this.isRTL;\n\n        if (keyCode === PAGEUP) {\n          // PAGEUP - Previous month/year\n          activeDate = (altKey ? oneYearAgo : oneMonthAgo)(activeDate); // We check the first day of month to be in rage\n\n          checkDate = createDate(activeDate);\n          checkDate.setDate(1);\n        } else if (keyCode === PAGEDOWN) {\n          // PAGEDOWN - Next month/year\n          activeDate = (altKey ? oneYearAhead : oneMonthAhead)(activeDate); // We check the last day of month to be in rage\n\n          checkDate = createDate(activeDate);\n          checkDate.setMonth(checkDate.getMonth() + 1);\n          checkDate.setDate(0);\n        } else if (keyCode === LEFT) {\n          // LEFT - Previous day (or next day for RTL)\n          activeDate.setDate(day + (isRTL ? 1 : -1));\n          checkDate = activeDate;\n        } else if (keyCode === RIGHT) {\n          // RIGHT - Next day (or previous day for RTL)\n          activeDate.setDate(day + (isRTL ? -1 : 1));\n          checkDate = activeDate;\n        } else if (keyCode === UP) {\n          // UP - Previous week\n          activeDate.setDate(day - 7);\n          checkDate = activeDate;\n        } else if (keyCode === DOWN) {\n          // DOWN - Next week\n          activeDate.setDate(day + 7);\n          checkDate = activeDate;\n        } else if (keyCode === HOME) {\n          // HOME - Today\n          activeDate = this.getToday();\n          checkDate = activeDate;\n        } else if (keyCode === END) {\n          // END - Selected date, or today if no selected date\n          activeDate = parseYMD(this.selectedDate) || this.getToday();\n          checkDate = activeDate;\n        }\n\n        if (!this.dateOutOfRange(checkDate) && !datesEqual(activeDate, this.activeDate)) {\n          // We only jump to date if within min/max\n          // We don't check for individual disabled dates though (via user function)\n          this.activeYMD = formatYMD(activeDate);\n        } // Ensure grid is focused\n\n\n        this.focus();\n      },\n      onKeydownGrid: function onKeydownGrid(evt) {\n        // Pressing enter/space on grid to select active date\n        var keyCode = evt.keyCode;\n        var activeDate = this.activeDate;\n\n        if (keyCode === ENTER || keyCode === SPACE) {\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          if (!this.disabled && !this.readonly && !this.dateDisabled(activeDate)) {\n            this.selectedYMD = formatYMD(activeDate);\n            this.emitSelected(activeDate);\n          } // Ensure grid is focused\n\n\n          this.focus();\n        }\n      },\n      onClickDay: function onClickDay(day) {\n        // Clicking on a date \"button\" to select it\n        // TODO: Change to lookup the `data-data` attribute\n        var selectedDate = this.selectedDate;\n        var activeDate = this.activeDate;\n        var clickedDate = parseYMD(day.ymd);\n\n        if (!this.disabled && !day.isDisabled && !this.dateDisabled(clickedDate)) {\n          if (!this.readonly) {\n            // If readonly mode, we don't set the selected date, just the active date\n            // If the clicked date is equal to the already selected date, we don't update the model\n            this.selectedYMD = formatYMD(datesEqual(clickedDate, selectedDate) ? selectedDate : clickedDate);\n            this.emitSelected(clickedDate);\n          }\n\n          this.activeYMD = formatYMD(datesEqual(clickedDate, activeDate) ? activeDate : createDate(clickedDate)); // Ensure grid is focused\n\n          this.focus();\n        }\n      },\n      gotoPrevYear: function gotoPrevYear() {\n        this.activeYMD = formatYMD(this.constrainDate(oneYearAgo(this.activeDate)));\n      },\n      gotoPrevMonth: function gotoPrevMonth() {\n        this.activeYMD = formatYMD(this.constrainDate(oneMonthAgo(this.activeDate)));\n      },\n      gotoCurrentMonth: function gotoCurrentMonth() {\n        // TODO: Maybe this goto date should be configurable?\n        this.activeYMD = formatYMD(this.getToday());\n      },\n      gotoNextMonth: function gotoNextMonth() {\n        this.activeYMD = formatYMD(this.constrainDate(oneMonthAhead(this.activeDate)));\n      },\n      gotoNextYear: function gotoNextYear() {\n        this.activeYMD = formatYMD(this.constrainDate(oneYearAhead(this.activeDate)));\n      }\n    },\n    render: function render(h) {\n      var _this5 = this;\n\n      // If hidden prop is set, render just a placeholder node\n      if (this.hidden) {\n        return h();\n      }\n\n      var isRTL = this.isRTL;\n      var todayYMD = formatYMD(this.getToday());\n      var selectedYMD = this.selectedYMD;\n      var activeYMD = this.activeYMD;\n      var highlightToday = !this.noHighlightToday;\n      var safeId = this.safeId; // Flag for making the `aria-live` regions live\n\n      var isLive = this.isLive; // Pre-compute some IDs\n\n      var idWidget = safeId();\n      var idValue = safeId('_calendar-value_');\n      var idNav = safeId('_calendar-nav_');\n      var idGrid = safeId('_calendar-grid_');\n      var idGridCaption = safeId('_calendar-grid-caption_');\n      var idGridHelp = safeId('_calendar-grid-help_');\n      var idActive = activeYMD ? safeId(\"_cell-\".concat(activeYMD, \"_\")) : null; // Header showing current selected date\n\n      var $header = h('output', {\n        staticClass: 'd-block text-center rounded border small p-1 mb-1',\n        class: {\n          'text-muted': this.disabled,\n          readonly: this.readonly || this.disabled\n        },\n        attrs: {\n          id: idValue,\n          for: idGrid,\n          role: 'status',\n          // Mainly for testing purposes, as we do not know\n          // the exact format `Intl` will format the date string\n          'data-selected': toString$1(selectedYMD),\n          // We wait until after mount to enable `aria-live`\n          // to prevent initial announcement on page render\n          'aria-live': isLive ? 'polite' : 'off',\n          'aria-atomic': isLive ? 'true' : null\n        }\n      }, this.selectedDate ? [// We use `bdi` elements here in case the label doesn't match the locale\n      // Although IE 11 does not deal with <BDI> at all (equivalent to a span)\n      h('bdi', {\n        staticClass: 'sr-only'\n      }, \" (\".concat(toString$1(this.labelSelected), \") \")), h('bdi', {}, this.formatDateString(this.selectedDate))] : this.labelNoDateSelected || \"\\xA0\" // '&nbsp;'\n      );\n      $header = h('header', {\n        class: this.hideHeader ? 'sr-only' : 'mb-1',\n        attrs: {\n          title: this.selectedDate ? this.labelSelectedDate || null : null\n        }\n      }, [$header]); // Content for the date navigation buttons\n\n      var $prevYearIcon = h(BIconstack, {\n        props: {\n          shiftV: 0.5,\n          flipH: isRTL\n        }\n      }, [h(BIconChevronLeft, {\n        props: {\n          shiftH: -2\n        }\n      }), h(BIconChevronLeft, {\n        props: {\n          shiftH: 2\n        }\n      })]);\n      var $prevMonthIcon = h(BIconChevronLeft, {\n        props: {\n          shiftV: 0.5,\n          flipH: isRTL\n        }\n      });\n      var $thisMonthIcon = h(BIconCircleFill, {\n        props: {\n          shiftV: 0.5\n        }\n      });\n      var $nextMonthIcon = h(BIconChevronLeft, {\n        props: {\n          shiftV: 0.5,\n          flipH: !isRTL\n        }\n      });\n      var $nextYearIcon = h(BIconstack, {\n        props: {\n          shiftV: 0.5,\n          flipH: !isRTL\n        }\n      }, [h(BIconChevronLeft, {\n        props: {\n          shiftH: -2\n        }\n      }), h(BIconChevronLeft, {\n        props: {\n          shiftH: 2\n        }\n      })]); // Utility to create the date navigation buttons\n\n      var makeNavBtn = function makeNavBtn(content, label, handler, btnDisabled, shortcut) {\n        return h('button', {\n          staticClass: 'btn btn-sm btn-outline-secondary border-0 flex-fill p-1 mx-1',\n          class: {\n            disabled: btnDisabled\n          },\n          attrs: {\n            title: label || null,\n            type: 'button',\n            'aria-label': label || null,\n            'aria-disabled': btnDisabled ? 'true' : null,\n            'aria-keyshortcuts': shortcut || null\n          },\n          on: btnDisabled ? {} : {\n            click: handler\n          }\n        }, [h('div', {\n          attrs: {\n            'aria-hidden': 'true'\n          }\n        }, [content])]);\n      }; // Generate the date navigation buttons\n\n\n      var $nav = h('div', {\n        staticClass: 'b-calendar-nav d-flex mx-n1 mb-1',\n        attrs: {\n          id: idNav,\n          role: 'group',\n          'aria-hidden': this.disabled ? 'true' : null,\n          'aria-label': this.labelNav || null,\n          'aria-controls': idGrid\n        }\n      }, [makeNavBtn($prevYearIcon, this.labelPrevYear, this.gotoPrevYear, this.prevYearDisabled, 'Alt+PageDown'), makeNavBtn($prevMonthIcon, this.labelPrevMonth, this.gotoPrevMonth, this.prevMonthDisabled, 'PageDown'), makeNavBtn($thisMonthIcon, this.labelCurrentMonth, this.gotoCurrentMonth, this.thisMonthDisabled, 'Home'), makeNavBtn($nextMonthIcon, this.labelNextMonth, this.gotoNextMonth, this.nextMonthDisabled, 'PageUp'), makeNavBtn($nextYearIcon, this.labelNextYear, this.gotoNextYear, this.nextYearDisabled, 'Alt+PageUp')]); // Caption for calendar grid\n\n      var $gridCaption = h('header', {\n        key: 'grid-caption',\n        staticClass: 'text-center font-weight-bold p-1 m-0',\n        class: {\n          'text-muted': this.disabled\n        },\n        attrs: {\n          id: idGridCaption,\n          'aria-live': isLive ? 'polite' : null,\n          'aria-atomic': isLive ? 'true' : null\n        }\n      }, this.formatYearMonth(this.calendarFirstDay)); // Calendar weekday headings\n\n      var $gridWeekDays = h('div', {\n        staticClass: 'row no-gutters border-bottom',\n        attrs: {\n          'aria-hidden': 'true'\n        }\n      }, this.calendarHeadings.map(function (d, idx) {\n        return h('small', {\n          key: idx,\n          staticClass: 'col',\n          class: {\n            'text-muted': _this5.disabled\n          },\n          attrs: {\n            title: d.label === d.text ? null : d.label,\n            'aria-label': d.label\n          }\n        }, d.text);\n      })); // Calendar day grid\n\n      var $gridBody = this.calendar.map(function (week) {\n        var $cells = week.map(function (day, dIndex) {\n          var _class;\n\n          var isSelected = day.ymd === selectedYMD;\n          var isActive = day.ymd === activeYMD;\n          var isToday = day.ymd === todayYMD;\n          var idCell = safeId(\"_cell-\".concat(day.ymd, \"_\")); // \"fake\" button\n\n          var $btn = h('span', {\n            staticClass: 'btn border-0 rounded-circle text-nowrap',\n            // Should we add some classes to signify if today/selected/etc?\n            class: (_class = {\n              // Give the fake button a focus ring\n              focus: isActive && _this5.gridHasFocus,\n              // Styling\n              disabled: day.isDisabled || _this5.disabled,\n              active: isSelected\n            }, _defineProperty(_class, _this5.computedVariant, isSelected), _defineProperty(_class, _this5.computedTodayVariant, isToday && highlightToday && !isSelected && day.isThisMonth), _defineProperty(_class, 'btn-outline-light', !(isToday && highlightToday) && !isSelected && !isActive), _defineProperty(_class, 'btn-light', !(isToday && highlightToday) && !isSelected && isActive), _defineProperty(_class, 'text-muted', !day.isThisMonth && !isSelected), _defineProperty(_class, 'text-dark', !(isToday && highlightToday) && !isSelected && !isActive && day.isThisMonth), _defineProperty(_class, 'font-weight-bold', (isSelected || day.isThisMonth) && !day.isDisabled), _class),\n            on: {\n              click: function click() {\n                return _this5.onClickDay(day);\n              }\n            }\n          }, day.day);\n          return h('div', // Cell with button\n          {\n            key: dIndex,\n            staticClass: 'col p-0',\n            class: day.isDisabled ? 'bg-light' : day.info.class || '',\n            attrs: {\n              id: idCell,\n              role: 'button',\n              'data-date': day.ymd,\n              // Primarily for testing purposes\n              // Only days in the month are presented as buttons to screen readers\n              'aria-hidden': day.isThisMonth ? null : 'true',\n              'aria-disabled': day.isDisabled || _this5.disabled ? 'true' : null,\n              'aria-label': [day.label, isSelected ? \"(\".concat(_this5.labelSelected, \")\") : null, isToday ? \"(\".concat(_this5.labelToday, \")\") : null].filter(identity).join(' '),\n              // NVDA doesn't convey `aria-selected`, but does `aria-current`,\n              // ChromeVox doesn't convey `aria-current`, but does `aria-selected`,\n              // so we set both attributes for robustness\n              'aria-selected': isSelected ? 'true' : null,\n              'aria-current': isSelected ? 'date' : null\n            }\n          }, [$btn]);\n        }); // Return the week \"row\"\n        // We use the first day of the weeks YMD value as a\n        // key for efficient DOM patching / element re-use\n\n        return h('div', {\n          key: week[0].ymd,\n          staticClass: 'row no-gutters'\n        }, $cells);\n      });\n      $gridBody = h('div', {\n        // A key is only required on the body if we add in transition support\n        // key: this.activeYMD.slice(0, -3),\n        staticClass: 'b-calendar-grid-body',\n        style: this.disabled ? {\n          pointerEvents: 'none'\n        } : {}\n      }, $gridBody);\n      var $gridHelp = h('footer', {\n        staticClass: 'border-top small text-muted text-center bg-light',\n        attrs: {\n          id: idGridHelp\n        }\n      }, [h('div', {\n        staticClass: 'small'\n      }, this.labelHelp)]);\n      var $grid = h('div', {\n        ref: 'grid',\n        staticClass: 'form-control h-auto text-center p-0 mb-0',\n        attrs: {\n          id: idGrid,\n          role: 'application',\n          tabindex: this.disabled ? null : '0',\n          'data-month': activeYMD.slice(0, -3),\n          // `YYYY-MM`, mainly for testing\n          // tabindex: this.disabled ? null : '0',\n          'aria-roledescription': this.labelCalendar || null,\n          'aria-labelledby': idGridCaption,\n          'aria-describedby': idGridHelp,\n          // `aria-readonly` is not considered valid on `role=\"application\"`\n          // https://www.w3.org/TR/wai-aria-1.1/#aria-readonly\n          // 'aria-readonly': this.readonly && !this.disabled ? 'true' : null,\n          'aria-disabled': this.disabled ? 'true' : null,\n          'aria-activedescendant': idActive\n        },\n        on: {\n          keydown: this.onKeydownGrid,\n          focus: this.setGridFocusFlag,\n          blur: this.setGridFocusFlag\n        }\n      }, [$gridCaption, $gridWeekDays, $gridBody, $gridHelp]); // Optional bottom slot\n\n      var $slot = this.normalizeSlot('default');\n      $slot = $slot ? h('footer', {\n        staticClass: 'mt-2'\n      }, $slot) : h();\n      var $widget = h('div', {\n        class: this.block ? 'd-block' : 'd-inline-block',\n        style: this.block ? {} : {\n          width: this.width\n        },\n        attrs: {\n          id: idWidget,\n          dir: isRTL ? 'rtl' : 'ltr',\n          lang: this.computedLocale || null,\n          role: 'group',\n          'aria-disabled': this.disabled ? 'true' : null,\n          // If datepicker controls an input, this will specify the ID of the input\n          'aria-controls': this.ariaControls || null,\n          // This should be a prop (so it can be changed to Date picker, etc, localized\n          'aria-roledescription': this.roleDescription || null,\n          'aria-describedby': [// Should the attr (if present) go last?\n          // Or should this attr be a prop?\n          this.$attrs['aria-describedby'], idValue, idGridHelp].filter(identity).join(' ')\n        },\n        on: {\n          keydown: this.onKeydownWrapper\n        }\n      }, [$header, $nav, $grid, $slot]); // Wrap in an outer div that can be styled\n\n      return h('div', {\n        staticClass: 'b-calendar',\n        // We use a style here rather than class `d-inline-block` so that users can\n        // override the display value (`d-*` classes use the `!important` flag)\n        style: this.block ? {} : {\n          display: 'inline-block'\n        }\n      }, [$widget]);\n    }\n  });\n\n  var CalendarPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BCalendar: BCalendar\n    }\n  });\n\n  /**\n   * @param {string} prefix\n   * @param {string} value\n   */\n\n  var prefixPropName = function prefixPropName(prefix, value) {\n    return prefix + upperFirst(value);\n  };\n\n  /**\n   * @param {string} prefix\n   * @param {string} value\n   */\n\n  var unprefixPropName = function unprefixPropName(prefix, value) {\n    return lowerFirst(value.replace(prefix, ''));\n  };\n\n  /**\n   * Copies props from one array/object to a new array/object. Prop values\n   * are also cloned as new references to prevent possible mutation of original\n   * prop object values. Optionally accepts a function to transform the prop name.\n   *\n   * @param {[]|{}} props\n   * @param {Function} transformFn\n   */\n\n  var copyProps = function copyProps(props) {\n    var transformFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n\n    if (isArray(props)) {\n      return props.map(transformFn);\n    } // Props as an object.\n\n\n    var copied = {};\n\n    for (var prop in props) {\n      /* istanbul ignore else */\n      // eslint-disable-next-line no-prototype-builtins\n      if (props.hasOwnProperty(prop)) {\n        // If the prop value is an object, do a shallow clone to prevent\n        // potential mutations to the original object.\n        copied[transformFn(prop)] = isObject(props[prop]) ? clone(props[prop]) : props[prop];\n      }\n    }\n\n    return copied;\n  };\n\n  // @vue/component\n  var cardMixin = {\n    props: {\n      tag: {\n        type: String,\n        default: 'div'\n      },\n      bgVariant: {\n        type: String,\n        default: null\n      },\n      borderVariant: {\n        type: String,\n        default: null\n      },\n      textVariant: {\n        type: String,\n        default: null\n      }\n    }\n  };\n\n  var props$6 = {\n    title: {\n      type: String,\n      default: ''\n    },\n    titleTag: {\n      type: String,\n      default: 'h4'\n    }\n  }; // @vue/component\n\n  var BCardTitle =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BCardTitle',\n    functional: true,\n    props: props$6,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h(props.titleTag, a(data, {\n        staticClass: 'card-title'\n      }), children || props.title);\n    }\n  });\n\n  var NAME$7 = 'BCardSubTitle';\n  var props$7 = {\n    subTitle: {\n      type: String,\n      default: ''\n    },\n    subTitleTag: {\n      type: String,\n      default: 'h6'\n    },\n    subTitleTextVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$7, 'subTitleTextVariant');\n      }\n    }\n  }; // @vue/component\n\n  var BCardSubTitle =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$7,\n    functional: true,\n    props: props$7,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h(props.subTitleTag, a(data, {\n        staticClass: 'card-subtitle',\n        class: [props.subTitleTextVariant ? \"text-\".concat(props.subTitleTextVariant) : null]\n      }), children || props.subTitle);\n    }\n  });\n\n  var props$8 = _objectSpread2({}, copyProps(cardMixin.props, prefixPropName.bind(null, 'body')), {\n    bodyClass: {\n      type: [String, Object, Array],\n      default: null\n    }\n  }, props$6, {}, props$7, {\n    overlay: {\n      type: Boolean,\n      default: false\n    }\n  }); // @vue/component\n\n  var BCardBody =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BCardBody',\n    functional: true,\n    props: props$8,\n    render: function render(h, _ref) {\n      var _ref2;\n\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      var cardTitle = h();\n      var cardSubTitle = h();\n      var cardContent = children || [h()];\n\n      if (props.title) {\n        cardTitle = h(BCardTitle, {\n          props: pluckProps(props$6, props)\n        });\n      }\n\n      if (props.subTitle) {\n        cardSubTitle = h(BCardSubTitle, {\n          props: pluckProps(props$7, props),\n          class: ['mb-2']\n        });\n      }\n\n      return h(props.bodyTag, a(data, {\n        staticClass: 'card-body',\n        class: [(_ref2 = {\n          'card-img-overlay': props.overlay\n        }, _defineProperty(_ref2, \"bg-\".concat(props.bodyBgVariant), props.bodyBgVariant), _defineProperty(_ref2, \"border-\".concat(props.bodyBorderVariant), props.bodyBorderVariant), _defineProperty(_ref2, \"text-\".concat(props.bodyTextVariant), props.bodyTextVariant), _ref2), props.bodyClass || {}]\n      }), [cardTitle, cardSubTitle].concat(_toConsumableArray(cardContent)));\n    }\n  });\n\n  var props$9 = _objectSpread2({}, copyProps(cardMixin.props, prefixPropName.bind(null, 'header')), {\n    header: {\n      type: String,\n      default: null\n    },\n    headerHtml: {\n      type: String,\n      default: null\n    },\n    headerClass: {\n      type: [String, Object, Array],\n      default: null\n    }\n  }); // @vue/component\n\n  var BCardHeader =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BCardHeader',\n    functional: true,\n    props: props$9,\n    render: function render(h, _ref) {\n      var _ref2;\n\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h(props.headerTag, a(data, {\n        staticClass: 'card-header',\n        class: [props.headerClass, (_ref2 = {}, _defineProperty(_ref2, \"bg-\".concat(props.headerBgVariant), props.headerBgVariant), _defineProperty(_ref2, \"border-\".concat(props.headerBorderVariant), props.headerBorderVariant), _defineProperty(_ref2, \"text-\".concat(props.headerTextVariant), props.headerTextVariant), _ref2)]\n      }), children || [h('div', {\n        domProps: htmlOrText(props.headerHtml, props.header)\n      })]);\n    }\n  });\n\n  var props$a = _objectSpread2({}, copyProps(cardMixin.props, prefixPropName.bind(null, 'footer')), {\n    footer: {\n      type: String,\n      default: null\n    },\n    footerHtml: {\n      type: String,\n      default: null\n    },\n    footerClass: {\n      type: [String, Object, Array],\n      default: null\n    }\n  }); // @vue/component\n\n  var BCardFooter =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BCardFooter',\n    functional: true,\n    props: props$a,\n    render: function render(h, _ref) {\n      var _ref2;\n\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h(props.footerTag, a(data, {\n        staticClass: 'card-footer',\n        class: [props.footerClass, (_ref2 = {}, _defineProperty(_ref2, \"bg-\".concat(props.footerBgVariant), props.footerBgVariant), _defineProperty(_ref2, \"border-\".concat(props.footerBorderVariant), props.footerBorderVariant), _defineProperty(_ref2, \"text-\".concat(props.footerTextVariant), props.footerTextVariant), _ref2)]\n      }), children || [h('div', {\n        domProps: htmlOrText(props.footerHtml, props.footer)\n      })]);\n    }\n  });\n\n  var props$b = {\n    src: {\n      type: String,\n      default: null,\n      required: true\n    },\n    alt: {\n      type: String,\n      default: null\n    },\n    top: {\n      type: Boolean,\n      default: false\n    },\n    bottom: {\n      type: Boolean,\n      default: false\n    },\n    start: {\n      type: Boolean,\n      default: false\n    },\n    left: {\n      // alias of 'start'\n      type: Boolean,\n      default: false\n    },\n    end: {\n      type: Boolean,\n      default: false\n    },\n    right: {\n      // alias of 'end'\n      type: Boolean,\n      default: false\n    },\n    height: {\n      type: [Number, String],\n      default: null\n    },\n    width: {\n      type: [Number, String],\n      default: null\n    }\n  }; // @vue/component\n\n  var BCardImg =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BCardImg',\n    functional: true,\n    props: props$b,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data;\n      var baseClass = 'card-img';\n\n      if (props.top) {\n        baseClass += '-top';\n      } else if (props.right || props.end) {\n        baseClass += '-right';\n      } else if (props.bottom) {\n        baseClass += '-bottom';\n      } else if (props.left || props.start) {\n        baseClass += '-left';\n      }\n\n      return h('img', a(data, {\n        class: [baseClass],\n        attrs: {\n          src: props.src,\n          alt: props.alt,\n          height: props.height,\n          width: props.width\n        }\n      }));\n    }\n  });\n\n  var cardImgProps = copyProps(props$b, prefixPropName.bind(null, 'img'));\n  cardImgProps.imgSrc.required = false;\n  var props$c = _objectSpread2({}, props$8, {}, props$9, {}, props$a, {}, cardImgProps, {}, copyProps(cardMixin.props), {\n    align: {\n      type: String,\n      default: null\n    },\n    noBody: {\n      type: Boolean,\n      default: false\n    }\n  }); // @vue/component\n\n  var BCard =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BCard',\n    functional: true,\n    props: props$c,\n    render: function render(h, _ref) {\n      var _class;\n\n      var props = _ref.props,\n          data = _ref.data,\n          slots = _ref.slots,\n          scopedSlots = _ref.scopedSlots;\n      var $slots = slots(); // Vue < 2.6.x may return undefined for scopedSlots\n\n      var $scopedSlots = scopedSlots || {}; // Create placeholder elements for each section\n\n      var imgFirst = h();\n      var header = h();\n      var content = h();\n      var footer = h();\n      var imgLast = h();\n\n      if (props.imgSrc) {\n        var img = h(BCardImg, {\n          props: pluckProps(cardImgProps, props, unprefixPropName.bind(null, 'img'))\n        });\n\n        if (props.imgBottom) {\n          imgLast = img;\n        } else {\n          imgFirst = img;\n        }\n      }\n\n      if (props.header || hasNormalizedSlot('header', $scopedSlots, $slots)) {\n        header = h(BCardHeader, {\n          props: pluckProps(props$9, props)\n        }, normalizeSlot('header', {}, $scopedSlots, $slots));\n      }\n\n      content = normalizeSlot('default', {}, $scopedSlots, $slots) || [];\n\n      if (!props.noBody) {\n        // Wrap content in card-body\n        content = [h(BCardBody, {\n          props: pluckProps(props$8, props)\n        }, _toConsumableArray(content))];\n      }\n\n      if (props.footer || hasNormalizedSlot('footer', $scopedSlots, $slots)) {\n        footer = h(BCardFooter, {\n          props: pluckProps(props$a, props)\n        }, normalizeSlot('footer', {}, $scopedSlots, $slots));\n      }\n\n      return h(props.tag, a(data, {\n        staticClass: 'card',\n        class: (_class = {\n          'flex-row': props.imgLeft || props.imgStart,\n          'flex-row-reverse': (props.imgRight || props.imgEnd) && !(props.imgLeft || props.imgStart)\n        }, _defineProperty(_class, \"text-\".concat(props.align), props.align), _defineProperty(_class, \"bg-\".concat(props.bgVariant), props.bgVariant), _defineProperty(_class, \"border-\".concat(props.borderVariant), props.borderVariant), _defineProperty(_class, \"text-\".concat(props.textVariant), props.textVariant), _class)\n      }), [imgFirst, header].concat(_toConsumableArray(content), [footer, imgLast]));\n    }\n  });\n\n  var OBSERVER_PROP_NAME = '__bv__visibility_observer';\n  var onlyDgitsRE = /^\\d+$/;\n\n  var VisibilityObserver =\n  /*#__PURE__*/\n  function () {\n    function VisibilityObserver(el, options, vnode) {\n      _classCallCheck(this, VisibilityObserver);\n\n      this.el = el;\n      this.callback = options.callback;\n      this.margin = options.margin || 0;\n      this.once = options.once || false;\n      this.observer = null;\n      this.visible = undefined;\n      this.doneOnce = false; // Create the observer instance (if possible)\n\n      this.createObserver(vnode);\n    }\n\n    _createClass(VisibilityObserver, [{\n      key: \"createObserver\",\n      value: function createObserver(vnode) {\n        var _this = this;\n\n        // Remove any previous observer\n        if (this.observer) {\n          /* istanbul ignore next */\n          this.stop();\n        } // Should only be called once and `callback` prop should be a function\n\n\n        if (this.doneOnce || !isFunction(this.callback)) {\n          /* istanbul ignore next */\n          return;\n        } // Create the observer instance\n\n\n        try {\n          // Future: Possibly add in other modifiers for left/right/top/bottom\n          // offsets, root element reference, and thresholds\n          this.observer = new IntersectionObserver(this.handler.bind(this), {\n            // `null` = 'viewport'\n            root: null,\n            // Pixels away from view port to consider \"visible\"\n            rootMargin: this.margin,\n            // Intersection ratio of el and root (as a value from 0 to 1)\n            threshold: 0\n          });\n        } catch (_unused) {\n          // No IntersectionObserver support, so just stop trying to observe\n          this.doneOnce = true;\n          this.observer = undefined;\n          this.callback(null);\n          return;\n        } // Start observing in a `$nextTick()` (to allow DOM to complete rendering)\n\n        /* istanbul ignore next: IntersectionObserver not supported in JSDOM */\n\n\n        vnode.context.$nextTick(function () {\n          requestAF(function () {\n            // Placed in an `if` just in case we were destroyed before\n            // this `requestAnimationFrame` runs\n            if (_this.observer) {\n              _this.observer.observe(_this.el);\n            }\n          });\n        });\n      }\n    }, {\n      key: \"handler\",\n      value: function handler(entries)\n      /* istanbul ignore next: IntersectionObserver not supported in JSDOM */\n      {\n        var entry = entries ? entries[0] : {};\n        var isIntersecting = Boolean(entry.isIntersecting || entry.intersectionRatio > 0.0);\n\n        if (isIntersecting !== this.visible) {\n          this.visible = isIntersecting;\n          this.callback(isIntersecting);\n\n          if (this.once && this.visible) {\n            this.doneOnce = true;\n            this.stop();\n          }\n        }\n      }\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        var observer = this.observer;\n        /* istanbul ignore next */\n\n        if (observer && observer.disconnect) {\n          observer.disconnect();\n        }\n\n        this.observer = null;\n      }\n    }]);\n\n    return VisibilityObserver;\n  }();\n\n  var destroy = function destroy(el) {\n    var observer = el[OBSERVER_PROP_NAME];\n\n    if (observer && observer.stop) {\n      observer.stop();\n    }\n\n    delete el[OBSERVER_PROP_NAME];\n  };\n\n  var bind = function bind(el, _ref, vnode) {\n    var value = _ref.value,\n        modifiers = _ref.modifiers;\n    // `value` is the callback function\n    var options = {\n      margin: '0px',\n      once: false,\n      callback: value\n    }; // Parse modifiers\n\n    keys(modifiers).forEach(function (mod) {\n      /* istanbul ignore else: Until <b-img-lazy> is switched to use this directive */\n      if (onlyDgitsRE.test(mod)) {\n        options.margin = \"\".concat(mod, \"px\");\n      } else if (mod.toLowerCase() === 'once') {\n        options.once = true;\n      }\n    }); // Destroy any previous observer\n\n    destroy(el); // Create new observer\n\n    el[OBSERVER_PROP_NAME] = new VisibilityObserver(el, options, vnode); // Store the current modifiers on the object (cloned)\n\n    el[OBSERVER_PROP_NAME]._prevModifiers = clone(modifiers);\n  }; // When the directive options may have been updated (or element)\n\n\n  var componentUpdated = function componentUpdated(el, _ref2, vnode) {\n    var value = _ref2.value,\n        oldValue = _ref2.oldValue,\n        modifiers = _ref2.modifiers;\n    // Compare value/oldValue and modifiers to see if anything has changed\n    // and if so, destroy old observer and create new observer\n\n    /* istanbul ignore next */\n    modifiers = clone(modifiers);\n    /* istanbul ignore next */\n\n    if (el && (value !== oldValue || !el[OBSERVER_PROP_NAME] || !looseEqual(modifiers, el[OBSERVER_PROP_NAME]._prevModifiers))) {\n      // Re-bind on element\n      bind(el, {\n        value: value,\n        modifiers: modifiers\n      }, vnode);\n    }\n  }; // When directive un-binds from element\n\n\n  var unbind = function unbind(el) {\n    // Remove the observer\n    destroy(el);\n  }; // Export the directive\n\n\n  var VBVisible = {\n    bind: bind,\n    componentUpdated: componentUpdated,\n    unbind: unbind\n  };\n\n  var NAME$8 = 'BImg'; // Blank image with fill template\n\n  var BLANK_TEMPLATE = '<svg width=\"%{w}\" height=\"%{h}\" ' + 'xmlns=\"http://www.w3.org/2000/svg\" ' + 'viewBox=\"0 0 %{w} %{h}\" preserveAspectRatio=\"none\">' + '<rect width=\"100%\" height=\"100%\" style=\"fill:%{f};\"></rect>' + '</svg>';\n  var props$d = {\n    src: {\n      type: String,\n      default: null\n    },\n    srcset: {\n      type: [String, Array],\n      default: null\n    },\n    sizes: {\n      type: [String, Array],\n      default: null\n    },\n    alt: {\n      type: String,\n      default: null\n    },\n    width: {\n      type: [Number, String],\n      default: null\n    },\n    height: {\n      type: [Number, String],\n      default: null\n    },\n    block: {\n      type: Boolean,\n      default: false\n    },\n    fluid: {\n      type: Boolean,\n      default: false\n    },\n    fluidGrow: {\n      // Gives fluid images class `w-100` to make them grow to fit container\n      type: Boolean,\n      default: false\n    },\n    rounded: {\n      // rounded can be:\n      //   false: no rounding of corners\n      //   true: slightly rounded corners\n      //   'top': top corners rounded\n      //   'right': right corners rounded\n      //   'bottom': bottom corners rounded\n      //   'left': left corners rounded\n      //   'circle': circle/oval\n      //   '0': force rounding off\n      type: [Boolean, String],\n      default: false\n    },\n    thumbnail: {\n      type: Boolean,\n      default: false\n    },\n    left: {\n      type: Boolean,\n      default: false\n    },\n    right: {\n      type: Boolean,\n      default: false\n    },\n    center: {\n      type: Boolean,\n      default: false\n    },\n    blank: {\n      type: Boolean,\n      default: false\n    },\n    blankColor: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$8, 'blankColor');\n      }\n    }\n  }; // --- Helper methods ---\n\n  var makeBlankImgSrc = function makeBlankImgSrc(width, height, color) {\n    var src = encodeURIComponent(BLANK_TEMPLATE.replace('%{w}', toString$1(width)).replace('%{h}', toString$1(height)).replace('%{f}', color));\n    return \"data:image/svg+xml;charset=UTF-8,\".concat(src);\n  }; // @vue/component\n\n\n  var BImg =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$8,\n    functional: true,\n    props: props$d,\n    render: function render(h, _ref) {\n      var _class;\n\n      var props = _ref.props,\n          data = _ref.data;\n      var src = props.src;\n      var width = toInteger(props.width) || null;\n      var height = toInteger(props.height) || null;\n      var align = null;\n      var block = props.block;\n      var srcset = concat(props.srcset).filter(identity).join(',');\n      var sizes = concat(props.sizes).filter(identity).join(',');\n\n      if (props.blank) {\n        if (!height && width) {\n          height = width;\n        } else if (!width && height) {\n          width = height;\n        }\n\n        if (!width && !height) {\n          width = 1;\n          height = 1;\n        } // Make a blank SVG image\n\n\n        src = makeBlankImgSrc(width, height, props.blankColor || 'transparent'); // Disable srcset and sizes\n\n        srcset = null;\n        sizes = null;\n      }\n\n      if (props.left) {\n        align = 'float-left';\n      } else if (props.right) {\n        align = 'float-right';\n      } else if (props.center) {\n        align = 'mx-auto';\n        block = true;\n      }\n\n      return h('img', a(data, {\n        attrs: {\n          src: src,\n          alt: props.alt,\n          width: width ? toString$1(width) : null,\n          height: height ? toString$1(height) : null,\n          srcset: srcset || null,\n          sizes: sizes || null\n        },\n        class: (_class = {\n          'img-thumbnail': props.thumbnail,\n          'img-fluid': props.fluid || props.fluidGrow,\n          'w-100': props.fluidGrow,\n          rounded: props.rounded === '' || props.rounded === true\n        }, _defineProperty(_class, \"rounded-\".concat(props.rounded), isString(props.rounded) && props.rounded !== ''), _defineProperty(_class, align, align), _defineProperty(_class, 'd-block', block), _class)\n      }));\n    }\n  });\n\n  var NAME$9 = 'BImgLazy';\n  var props$e = {\n    src: {\n      type: String,\n      default: null,\n      required: true\n    },\n    srcset: {\n      type: [String, Array],\n      default: null\n    },\n    sizes: {\n      type: [String, Array],\n      default: null\n    },\n    alt: {\n      type: String,\n      default: null\n    },\n    width: {\n      type: [Number, String],\n      default: null\n    },\n    height: {\n      type: [Number, String],\n      default: null\n    },\n    blankSrc: {\n      // If null, a blank image is generated\n      type: String,\n      default: null\n    },\n    blankColor: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$9, 'blankColor');\n      }\n    },\n    blankWidth: {\n      type: [Number, String],\n      default: null\n    },\n    blankHeight: {\n      type: [Number, String],\n      default: null\n    },\n    show: {\n      type: Boolean,\n      default: false\n    },\n    fluid: {\n      type: Boolean,\n      default: false\n    },\n    fluidGrow: {\n      type: Boolean,\n      default: false\n    },\n    block: {\n      type: Boolean,\n      default: false\n    },\n    thumbnail: {\n      type: Boolean,\n      default: false\n    },\n    rounded: {\n      type: [Boolean, String],\n      default: false\n    },\n    left: {\n      type: Boolean,\n      default: false\n    },\n    right: {\n      type: Boolean,\n      default: false\n    },\n    center: {\n      type: Boolean,\n      default: false\n    },\n    offset: {\n      // Distance away from viewport (in pixels) before being\n      // considered \"visible\"\n      type: [Number, String],\n      default: 360\n    }\n  }; // @vue/component\n\n  var BImgLazy =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$9,\n    directives: {\n      bVisible: VBVisible\n    },\n    props: props$e,\n    data: function data() {\n      return {\n        isShown: this.show\n      };\n    },\n    computed: {\n      computedSrc: function computedSrc() {\n        return !this.blankSrc || this.isShown ? this.src : this.blankSrc;\n      },\n      computedBlank: function computedBlank() {\n        return !(this.isShown || this.blankSrc);\n      },\n      computedWidth: function computedWidth() {\n        return this.isShown ? this.width : this.blankWidth || this.width;\n      },\n      computedHeight: function computedHeight() {\n        return this.isShown ? this.height : this.blankHeight || this.height;\n      },\n      computedSrcset: function computedSrcset() {\n        var srcset = concat(this.srcset).filter(identity).join(',');\n        return !this.blankSrc || this.isShown ? srcset : null;\n      },\n      computedSizes: function computedSizes() {\n        var sizes = concat(this.sizes).filter(identity).join(',');\n        return !this.blankSrc || this.isShown ? sizes : null;\n      }\n    },\n    watch: {\n      show: function show(newVal, oldVal) {\n        if (newVal !== oldVal) {\n          // If IntersectionObserver support is not available, image is always shown\n          var visible = hasIntersectionObserverSupport ? newVal : true;\n          this.isShown = visible;\n\n          if (visible !== newVal) {\n            // Ensure the show prop is synced (when no IntersectionObserver)\n            this.$nextTick(this.updateShowProp);\n          }\n        }\n      },\n      isShown: function isShown(newVal, oldVal) {\n        if (newVal !== oldVal) {\n          // Update synched show prop\n          this.updateShowProp();\n        }\n      }\n    },\n    mounted: function mounted() {\n      // If IntersectionObserver is not available, image is always shown\n      this.isShown = hasIntersectionObserverSupport ? this.show : true;\n    },\n    methods: {\n      updateShowProp: function updateShowProp() {\n        this.$emit('update:show', this.isShown);\n      },\n      doShow: function doShow(visible) {\n        // If IntersectionObserver is not supported, the callback\n        // will be called with `null` rather than `true` or `false`\n        if ((visible || visible === null) && !this.isShown) {\n          this.isShown = true;\n        }\n      }\n    },\n    render: function render(h) {\n      var directives = [];\n\n      if (!this.isShown) {\n        var _modifiers;\n\n        // We only add the visible directive if we are not shown\n        directives.push({\n          // Visible directive will silently do nothing if\n          // IntersectionObserver is not supported\n          name: 'b-visible',\n          // Value expects a callback (passed one arg of `visible` = `true` or `false`)\n          value: this.doShow,\n          modifiers: (_modifiers = {}, _defineProperty(_modifiers, \"\".concat(toInteger(this.offset) || 0), true), _defineProperty(_modifiers, \"once\", true), _modifiers)\n        });\n      }\n\n      return h(BImg, {\n        directives: directives,\n        props: {\n          // Computed value props\n          src: this.computedSrc,\n          blank: this.computedBlank,\n          width: this.computedWidth,\n          height: this.computedHeight,\n          srcset: this.computedSrcset || null,\n          sizes: this.computedSizes || null,\n          // Passthrough props\n          alt: this.alt,\n          blankColor: this.blankColor,\n          fluid: this.fluid,\n          fluidGrow: this.fluidGrow,\n          block: this.block,\n          thumbnail: this.thumbnail,\n          rounded: this.rounded,\n          left: this.left,\n          right: this.right,\n          center: this.center\n        }\n      });\n    }\n  });\n\n  // The `omit()` util creates a new object, so we can just pass the original props\n\n  var lazyProps = omit(props$e, ['left', 'right', 'center', 'block', 'rounded', 'thumbnail', 'fluid', 'fluidGrow']);\n  var props$f = _objectSpread2({}, lazyProps, {\n    top: {\n      type: Boolean,\n      default: false\n    },\n    bottom: {\n      type: Boolean,\n      default: false\n    },\n    start: {\n      type: Boolean,\n      default: false\n    },\n    left: {\n      // alias of 'start'\n      type: Boolean,\n      default: false\n    },\n    end: {\n      type: Boolean,\n      default: false\n    },\n    right: {\n      // alias of 'end'\n      type: Boolean,\n      default: false\n    }\n  }); // @vue/component\n\n  var BCardImgLazy =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BCardImgLazy',\n    functional: true,\n    props: props$f,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data;\n      var baseClass = 'card-img';\n\n      if (props.top) {\n        baseClass += '-top';\n      } else if (props.right || props.end) {\n        baseClass += '-right';\n      } else if (props.bottom) {\n        baseClass += '-bottom';\n      } else if (props.left || props.start) {\n        baseClass += '-left';\n      } // False out the left/center/right props before passing to b-img-lazy\n\n\n      var lazyProps = _objectSpread2({}, props, {\n        left: false,\n        right: false,\n        center: false\n      });\n\n      return h(BImgLazy, a(data, {\n        class: [baseClass],\n        props: lazyProps\n      }));\n    }\n  });\n\n  var props$g = {\n    textTag: {\n      type: String,\n      default: 'p'\n    }\n  }; // @vue/component\n\n  var BCardText =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BCardText',\n    functional: true,\n    props: props$g,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h(props.textTag, a(data, {\n        staticClass: 'card-text'\n      }), children);\n    }\n  });\n\n  var props$h = {\n    tag: {\n      type: String,\n      default: 'div'\n    },\n    deck: {\n      type: Boolean,\n      default: false\n    },\n    columns: {\n      type: Boolean,\n      default: false\n    }\n  }; // @vue/component\n\n  var BCardGroup =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BCardGroup',\n    functional: true,\n    props: props$h,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h(props.tag, a(data, {\n        class: props.deck ? 'card-deck' : props.columns ? 'card-columns' : 'card-group'\n      }), children);\n    }\n  });\n\n  var CardPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BCard: BCard,\n      BCardHeader: BCardHeader,\n      BCardBody: BCardBody,\n      BCardTitle: BCardTitle,\n      BCardSubTitle: BCardSubTitle,\n      BCardFooter: BCardFooter,\n      BCardImg: BCardImg,\n      BCardImgLazy: BCardImgLazy,\n      BCardText: BCardText,\n      BCardGroup: BCardGroup\n    }\n  });\n\n  var noop = function noop() {};\n\n  /**\n   * Observe a DOM element changes, falls back to eventListener mode\n   * @param {Element} el The DOM element to observe\n   * @param {Function} callback callback to be called on change\n   * @param {object} [options={childList: true, subtree: true}] observe options\n   * @see http://stackoverflow.com/questions/3219758\n   */\n\n  var observeDom = function observeDom(el, callback, options)\n  /* istanbul ignore next: difficult to test in JSDOM */\n  {\n    // Handle cases where we might be passed a Vue instance\n    el = el ? el.$el || el : null; // Early exit when we have no element\n\n    /* istanbul ignore next: difficult to test in JSDOM */\n\n    if (!isElement(el)) {\n      return null;\n    } // Exit and throw a warning when `MutationObserver` isn't available\n\n\n    if (warnNoMutationObserverSupport('observeDom')) {\n      return null;\n    } // Define a new observer\n\n\n    var obs = new MutationObs(function (mutations) {\n      var changed = false; // A mutation can contain several change records, so we loop\n      // through them to see what has changed\n      // We break out of the loop early if any \"significant\" change\n      // has been detected\n\n      for (var i = 0; i < mutations.length && !changed; i++) {\n        // The mutation record\n        var mutation = mutations[i]; // Mutation type\n\n        var type = mutation.type; // DOM node (could be any DOM node type - HTMLElement, Text, comment, etc.)\n\n        var target = mutation.target; // Detect whether a change happened based on type and target\n\n        if (type === 'characterData' && target.nodeType === Node.TEXT_NODE) {\n          // We ignore nodes that are not TEXT (i.e. comments, etc)\n          // as they don't change layout\n          changed = true;\n        } else if (type === 'attributes') {\n          changed = true;\n        } else if (type === 'childList' && (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {\n          // This includes HTMLElement and text nodes being\n          // added/removed/re-arranged\n          changed = true;\n        }\n      } // We only call the callback if a change that could affect\n      // layout/size truely happened\n\n\n      if (changed) {\n        callback();\n      }\n    }); // Have the observer observe foo for changes in children, etc\n\n    obs.observe(el, _objectSpread2({\n      childList: true,\n      subtree: true\n    }, options)); // We return a reference to the observer so that `obs.disconnect()`\n    // can be called if necessary\n    // To reduce overhead when the root element is hidden\n\n    return obs;\n  };\n\n  var EVENT_OPTIONS_PASSIVE = {\n    passive: true\n  };\n  var EVENT_OPTIONS_NO_CAPTURE = {\n    passive: true,\n    capture: false\n  }; // --- Utils ---\n  // Normalize event options based on support of passive option\n  // Exported only for testing purposes\n\n  var parseEventOptions = function parseEventOptions(options) {\n    /* istanbul ignore else: can't test in JSDOM, as it supports passive */\n    if (hasPassiveEventSupport) {\n      return isObject(options) ? options : {\n        capture: !!options || false\n      };\n    } else {\n      // Need to translate to actual Boolean value\n      return !!(isObject(options) ? options.capture : options);\n    }\n  }; // Attach an event listener to an element\n\n  var eventOn = function eventOn(el, evtName, handler, options) {\n    if (el && el.addEventListener) {\n      el.addEventListener(evtName, handler, parseEventOptions(options));\n    }\n  }; // Remove an event listener from an element\n\n  var eventOff = function eventOff(el, evtName, handler, options) {\n    if (el && el.removeEventListener) {\n      el.removeEventListener(evtName, handler, parseEventOptions(options));\n    }\n  }; // Utility method to add/remove a event listener based on first argument (boolean)\n  // It passes all other arguments to the `eventOn()` or `eventOff` method\n\n  var eventOnOff = function eventOnOff(on) {\n    var method = on ? eventOn : eventOff;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    method.apply(void 0, args);\n  };\n\n  var NAME$a = 'BCarousel'; // Slide directional classes\n\n  var DIRECTION = {\n    next: {\n      dirClass: 'carousel-item-left',\n      overlayClass: 'carousel-item-next'\n    },\n    prev: {\n      dirClass: 'carousel-item-right',\n      overlayClass: 'carousel-item-prev'\n    }\n  }; // Fallback Transition duration (with a little buffer) in ms\n\n  var TRANS_DURATION = 600 + 50; // Time for mouse compat events to fire after touch\n\n  var TOUCH_EVENT_COMPAT_WAIT = 500; // Number of pixels to consider touch move a swipe\n\n  var SWIPE_THRESHOLD = 40; // PointerEvent pointer types\n\n  var PointerType = {\n    TOUCH: 'touch',\n    PEN: 'pen'\n  }; // Transition Event names\n\n  var TransitionEndEvents = {\n    WebkitTransition: 'webkitTransitionEnd',\n    MozTransition: 'transitionend',\n    OTransition: 'otransitionend oTransitionEnd',\n    transition: 'transitionend'\n  }; // Return the browser specific transitionEnd event name\n\n  var getTransitionEndEvent = function getTransitionEndEvent(el) {\n    for (var name in TransitionEndEvents) {\n      if (!isUndefined(el.style[name])) {\n        return TransitionEndEvents[name];\n      }\n    } // Fallback\n\n    /* istanbul ignore next */\n\n\n    return null;\n  }; // @vue/component\n\n\n  var BCarousel =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$a,\n    mixins: [idMixin, normalizeSlotMixin],\n    provide: function provide() {\n      return {\n        bvCarousel: this\n      };\n    },\n    model: {\n      prop: 'value',\n      event: 'input'\n    },\n    props: {\n      labelPrev: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$a, 'labelPrev');\n        }\n      },\n      labelNext: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$a, 'labelNext');\n        }\n      },\n      labelGotoSlide: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$a, 'labelGotoSlide');\n        }\n      },\n      labelIndicators: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$a, 'labelIndicators');\n        }\n      },\n      interval: {\n        type: Number,\n        default: 5000\n      },\n      indicators: {\n        type: Boolean,\n        default: false\n      },\n      controls: {\n        type: Boolean,\n        default: false\n      },\n      noAnimation: {\n        // Disable slide/fade animation\n        type: Boolean,\n        default: false\n      },\n      fade: {\n        // Enable cross-fade animation instead of slide animation\n        type: Boolean,\n        default: false\n      },\n      noWrap: {\n        // Disable wrapping/looping when start/end is reached\n        type: Boolean,\n        default: false\n      },\n      noTouch: {\n        // Sniffed by carousel-slide\n        type: Boolean,\n        default: false\n      },\n      noHoverPause: {\n        // Disable pause on hover\n        type: Boolean,\n        default: false\n      },\n      imgWidth: {\n        // Sniffed by carousel-slide\n        type: [Number, String] // default: undefined\n\n      },\n      imgHeight: {\n        // Sniffed by carousel-slide\n        type: [Number, String] // default: undefined\n\n      },\n      background: {\n        type: String // default: undefined\n\n      },\n      value: {\n        type: Number,\n        default: 0\n      }\n    },\n    data: function data() {\n      return {\n        index: this.value || 0,\n        isSliding: false,\n        transitionEndEvent: null,\n        slides: [],\n        direction: null,\n        isPaused: !(toInteger(this.interval) > 0),\n        // Touch event handling values\n        touchStartX: 0,\n        touchDeltaX: 0\n      };\n    },\n    computed: {\n      numSlides: function numSlides() {\n        return this.slides.length;\n      }\n    },\n    watch: {\n      value: function value(newVal, oldVal) {\n        if (newVal !== oldVal) {\n          this.setSlide(toInteger(newVal) || 0);\n        }\n      },\n      interval: function interval(newVal, oldVal) {\n        if (newVal === oldVal) {\n          /* istanbul ignore next */\n          return;\n        }\n\n        if (!newVal) {\n          // Pausing slide show\n          this.pause(false);\n        } else {\n          // Restarting or Changing interval\n          this.pause(true);\n          this.start(false);\n        }\n      },\n      isPaused: function isPaused(newVal, oldVal) {\n        if (newVal !== oldVal) {\n          this.$emit(newVal ? 'paused' : 'unpaused');\n        }\n      },\n      index: function index(to, from) {\n        if (to === from || this.isSliding) {\n          /* istanbul ignore next */\n          return;\n        }\n\n        this.doSlide(to, from);\n      }\n    },\n    created: function created() {\n      // Create private non-reactive props\n      this._intervalId = null;\n      this._animationTimeout = null;\n      this._touchTimeout = null; // Set initial paused state\n\n      this.isPaused = !(toInteger(this.interval) > 0);\n    },\n    mounted: function mounted() {\n      // Cache current browser transitionend event name\n      this.transitionEndEvent = getTransitionEndEvent(this.$el) || null; // Get all slides\n\n      this.updateSlides(); // Observe child changes so we can update slide list\n\n      observeDom(this.$refs.inner, this.updateSlides.bind(this), {\n        subtree: false,\n        childList: true,\n        attributes: true,\n        attributeFilter: ['id']\n      });\n    },\n    beforeDestroy: function beforeDestroy() {\n      clearTimeout(this._animationTimeout);\n      clearTimeout(this._touchTimeout);\n      clearInterval(this._intervalId);\n      this._intervalId = null;\n      this._animationTimeout = null;\n      this._touchTimeout = null;\n    },\n    methods: {\n      // Set slide\n      setSlide: function setSlide(slide) {\n        var _this = this;\n\n        var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        // Don't animate when page is not visible\n\n        /* istanbul ignore if: difficult to test */\n        if (isBrowser && document.visibilityState && document.hidden) {\n          return;\n        }\n\n        var noWrap = this.noWrap;\n        var numSlides = this.numSlides; // Make sure we have an integer (you never know!)\n\n        slide = Math.floor(slide); // Don't do anything if nothing to slide to\n\n        if (numSlides === 0) {\n          return;\n        } // Don't change slide while transitioning, wait until transition is done\n\n\n        if (this.isSliding) {\n          // Schedule slide after sliding complete\n          this.$once('sliding-end', function () {\n            return _this.setSlide(slide, direction);\n          });\n          return;\n        }\n\n        this.direction = direction; // Set new slide index\n        // Wrap around if necessary (if no-wrap not enabled)\n\n        this.index = slide >= numSlides ? noWrap ? numSlides - 1 : 0 : slide < 0 ? noWrap ? 0 : numSlides - 1 : slide; // Ensure the v-model is synched up if no-wrap is enabled\n        // and user tried to slide pass either ends\n\n        if (noWrap && this.index !== slide && this.index !== this.value) {\n          this.$emit('input', this.index);\n        }\n      },\n      // Previous slide\n      prev: function prev() {\n        this.setSlide(this.index - 1, 'prev');\n      },\n      // Next slide\n      next: function next() {\n        this.setSlide(this.index + 1, 'next');\n      },\n      // Pause auto rotation\n      pause: function pause(evt) {\n        if (!evt) {\n          this.isPaused = true;\n        }\n\n        if (this._intervalId) {\n          clearInterval(this._intervalId);\n          this._intervalId = null;\n        }\n      },\n      // Start auto rotate slides\n      start: function start(evt) {\n        if (!evt) {\n          this.isPaused = false;\n        }\n        /* istanbul ignore next: most likely will never happen, but just in case */\n\n\n        if (this._intervalId) {\n          clearInterval(this._intervalId);\n          this._intervalId = null;\n        } // Don't start if no interval, or less than 2 slides\n\n\n        if (this.interval && this.numSlides > 1) {\n          this._intervalId = setInterval(this.next, Math.max(1000, this.interval));\n        }\n      },\n      // Restart auto rotate slides when focus/hover leaves the carousel\n      restart: function restart()\n      /* istanbul ignore next: difficult to test */\n      {\n        if (!this.$el.contains(document.activeElement)) {\n          this.start();\n        }\n      },\n      doSlide: function doSlide(to, from) {\n        var _this2 = this;\n\n        var isCycling = Boolean(this.interval); // Determine sliding direction\n\n        var direction = this.calcDirection(this.direction, from, to);\n        var overlayClass = direction.overlayClass;\n        var dirClass = direction.dirClass; // Determine current and next slides\n\n        var currentSlide = this.slides[from];\n        var nextSlide = this.slides[to]; // Don't do anything if there aren't any slides to slide to\n\n        if (!currentSlide || !nextSlide) {\n          /* istanbul ignore next */\n          return;\n        } // Start animating\n\n\n        this.isSliding = true;\n\n        if (isCycling) {\n          this.pause(false);\n        }\n\n        this.$emit('sliding-start', to); // Update v-model\n\n        this.$emit('input', this.index);\n\n        if (this.noAnimation) {\n          addClass(nextSlide, 'active');\n          removeClass(currentSlide, 'active');\n          this.isSliding = false; // Notify ourselves that we're done sliding (slid)\n\n          this.$nextTick(function () {\n            return _this2.$emit('sliding-end', to);\n          });\n        } else {\n          addClass(nextSlide, overlayClass); // Trigger a reflow of next slide\n\n          reflow(nextSlide);\n          addClass(currentSlide, dirClass);\n          addClass(nextSlide, dirClass); // Transition End handler\n\n          var called = false;\n          /* istanbul ignore next: difficult to test */\n\n          var onceTransEnd = function onceTransEnd() {\n            if (called) {\n              return;\n            }\n\n            called = true;\n            /* istanbul ignore if: transition events cant be tested in JSDOM */\n\n            if (_this2.transitionEndEvent) {\n              var events = _this2.transitionEndEvent.split(/\\s+/);\n\n              events.forEach(function (evt) {\n                return eventOff(currentSlide, evt, onceTransEnd, EVENT_OPTIONS_NO_CAPTURE);\n              });\n            }\n\n            _this2._animationTimeout = null;\n            removeClass(nextSlide, dirClass);\n            removeClass(nextSlide, overlayClass);\n            addClass(nextSlide, 'active');\n            removeClass(currentSlide, 'active');\n            removeClass(currentSlide, dirClass);\n            removeClass(currentSlide, overlayClass);\n            setAttr(currentSlide, 'aria-current', 'false');\n            setAttr(nextSlide, 'aria-current', 'true');\n            setAttr(currentSlide, 'aria-hidden', 'true');\n            setAttr(nextSlide, 'aria-hidden', 'false');\n            _this2.isSliding = false;\n            _this2.direction = null; // Notify ourselves that we're done sliding (slid)\n\n            _this2.$nextTick(function () {\n              return _this2.$emit('sliding-end', to);\n            });\n          }; // Set up transitionend handler\n\n          /* istanbul ignore if: transition events cant be tested in JSDOM */\n\n\n          if (this.transitionEndEvent) {\n            var events = this.transitionEndEvent.split(/\\s+/);\n            events.forEach(function (event) {\n              return eventOn(currentSlide, event, onceTransEnd, EVENT_OPTIONS_NO_CAPTURE);\n            });\n          } // Fallback to setTimeout()\n\n\n          this._animationTimeout = setTimeout(onceTransEnd, TRANS_DURATION);\n        }\n\n        if (isCycling) {\n          this.start(false);\n        }\n      },\n      // Update slide list\n      updateSlides: function updateSlides() {\n        this.pause(true); // Get all slides as DOM elements\n\n        this.slides = selectAll('.carousel-item', this.$refs.inner);\n        var numSlides = this.slides.length; // Keep slide number in range\n\n        var index = Math.max(0, Math.min(Math.floor(this.index), numSlides - 1));\n        this.slides.forEach(function (slide, idx) {\n          var n = idx + 1;\n\n          if (idx === index) {\n            addClass(slide, 'active');\n            setAttr(slide, 'aria-current', 'true');\n          } else {\n            removeClass(slide, 'active');\n            setAttr(slide, 'aria-current', 'false');\n          }\n\n          setAttr(slide, 'aria-posinset', String(n));\n          setAttr(slide, 'aria-setsize', String(numSlides));\n        }); // Set slide as active\n\n        this.setSlide(index);\n        this.start(this.isPaused);\n      },\n      calcDirection: function calcDirection() {\n        var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        var curIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var nextIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n        if (!direction) {\n          return nextIndex > curIndex ? DIRECTION.next : DIRECTION.prev;\n        }\n\n        return DIRECTION[direction];\n      },\n      handleClick: function handleClick(evt, fn) {\n        var keyCode = evt.keyCode;\n\n        if (evt.type === 'click' || keyCode === KEY_CODES.SPACE || keyCode === KEY_CODES.ENTER) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          fn();\n        }\n      },\n      handleSwipe: function handleSwipe()\n      /* istanbul ignore next: JSDOM doesn't support touch events */\n      {\n        var absDeltaX = Math.abs(this.touchDeltaX);\n\n        if (absDeltaX <= SWIPE_THRESHOLD) {\n          return;\n        }\n\n        var direction = absDeltaX / this.touchDeltaX; // Reset touch delta X\n        // https://github.com/twbs/bootstrap/pull/28558\n\n        this.touchDeltaX = 0;\n\n        if (direction > 0) {\n          // Swipe left\n          this.prev();\n        } else if (direction < 0) {\n          // Swipe right\n          this.next();\n        }\n      },\n      touchStart: function touchStart(evt)\n      /* istanbul ignore next: JSDOM doesn't support touch events */\n      {\n        if (hasPointerEventSupport && PointerType[evt.pointerType.toUpperCase()]) {\n          this.touchStartX = evt.clientX;\n        } else if (!hasPointerEventSupport) {\n          this.touchStartX = evt.touches[0].clientX;\n        }\n      },\n      touchMove: function touchMove(evt)\n      /* istanbul ignore next: JSDOM doesn't support touch events */\n      {\n        // Ensure swiping with one touch and not pinching\n        if (evt.touches && evt.touches.length > 1) {\n          this.touchDeltaX = 0;\n        } else {\n          this.touchDeltaX = evt.touches[0].clientX - this.touchStartX;\n        }\n      },\n      touchEnd: function touchEnd(evt)\n      /* istanbul ignore next: JSDOM doesn't support touch events */\n      {\n        if (hasPointerEventSupport && PointerType[evt.pointerType.toUpperCase()]) {\n          this.touchDeltaX = evt.clientX - this.touchStartX;\n        }\n\n        this.handleSwipe(); // If it's a touch-enabled device, mouseenter/leave are fired as\n        // part of the mouse compatibility events on first tap - the carousel\n        // would stop cycling until user tapped out of it;\n        // here, we listen for touchend, explicitly pause the carousel\n        // (as if it's the second time we tap on it, mouseenter compat event\n        // is NOT fired) and after a timeout (to allow for mouse compatibility\n        // events to fire) we explicitly restart cycling\n\n        this.pause(false);\n\n        if (this._touchTimeout) {\n          clearTimeout(this._touchTimeout);\n        }\n\n        this._touchTimeout = setTimeout(this.start, TOUCH_EVENT_COMPAT_WAIT + Math.max(1000, this.interval));\n      }\n    },\n    render: function render(h) {\n      var _this3 = this;\n\n      // Wrapper for slides\n      var inner = h('div', {\n        ref: 'inner',\n        class: ['carousel-inner'],\n        attrs: {\n          id: this.safeId('__BV_inner_'),\n          role: 'list'\n        }\n      }, [this.normalizeSlot('default')]); // Prev and next controls\n\n      var controls = h();\n\n      if (this.controls) {\n        var prevHandler = function prevHandler(evt) {\n          /* istanbul ignore next */\n          if (!_this3.isSliding) {\n            _this3.handleClick(evt, _this3.prev);\n          } else {\n            evt.preventDefault();\n          }\n        };\n\n        var nextHandler = function nextHandler(evt) {\n          /* istanbul ignore next */\n          if (!_this3.isSliding) {\n            _this3.handleClick(evt, _this3.next);\n          } else {\n            evt.preventDefault();\n          }\n        };\n\n        controls = [h('a', {\n          class: ['carousel-control-prev'],\n          attrs: {\n            href: '#',\n            role: 'button',\n            'aria-controls': this.safeId('__BV_inner_'),\n            'aria-disabled': this.isSliding ? 'true' : null\n          },\n          on: {\n            click: prevHandler,\n            keydown: prevHandler\n          }\n        }, [h('span', {\n          class: ['carousel-control-prev-icon'],\n          attrs: {\n            'aria-hidden': 'true'\n          }\n        }), h('span', {\n          class: ['sr-only']\n        }, [this.labelPrev])]), h('a', {\n          class: ['carousel-control-next'],\n          attrs: {\n            href: '#',\n            role: 'button',\n            'aria-controls': this.safeId('__BV_inner_'),\n            'aria-disabled': this.isSliding ? 'true' : null\n          },\n          on: {\n            click: nextHandler,\n            keydown: nextHandler\n          }\n        }, [h('span', {\n          class: ['carousel-control-next-icon'],\n          attrs: {\n            'aria-hidden': 'true'\n          }\n        }), h('span', {\n          class: ['sr-only']\n        }, [this.labelNext])])];\n      } // Indicators\n\n\n      var indicators = h('ol', {\n        class: ['carousel-indicators'],\n        directives: [{\n          name: 'show',\n          rawName: 'v-show',\n          value: this.indicators,\n          expression: 'indicators'\n        }],\n        attrs: {\n          id: this.safeId('__BV_indicators_'),\n          'aria-hidden': this.indicators ? 'false' : 'true',\n          'aria-label': this.labelIndicators,\n          'aria-owns': this.safeId('__BV_inner_')\n        }\n      }, this.slides.map(function (slide, n) {\n        return h('li', {\n          key: \"slide_\".concat(n),\n          class: {\n            active: n === _this3.index\n          },\n          attrs: {\n            role: 'button',\n            id: _this3.safeId(\"__BV_indicator_\".concat(n + 1, \"_\")),\n            tabindex: _this3.indicators ? '0' : '-1',\n            'aria-current': n === _this3.index ? 'true' : 'false',\n            'aria-label': \"\".concat(_this3.labelGotoSlide, \" \").concat(n + 1),\n            'aria-describedby': _this3.slides[n].id || null,\n            'aria-controls': _this3.safeId('__BV_inner_')\n          },\n          on: {\n            click: function click(evt) {\n              _this3.handleClick(evt, function () {\n                _this3.setSlide(n);\n              });\n            },\n            keydown: function keydown(evt) {\n              _this3.handleClick(evt, function () {\n                _this3.setSlide(n);\n              });\n            }\n          }\n        });\n      }));\n      var on = {\n        mouseenter: this.noHoverPause ? noop : this.pause,\n        mouseleave: this.noHoverPause ? noop : this.restart,\n        focusin: this.pause,\n        focusout: this.restart,\n        keydown: function keydown(evt) {\n          if (/input|textarea/i.test(evt.target.tagName)) {\n            /* istanbul ignore next */\n            return;\n          }\n\n          var keyCode = evt.keyCode;\n\n          if (keyCode === KEY_CODES.LEFT || keyCode === KEY_CODES.RIGHT) {\n            evt.preventDefault();\n            evt.stopPropagation();\n\n            _this3[keyCode === KEY_CODES.LEFT ? 'prev' : 'next']();\n          }\n        }\n      }; // Touch support event handlers for environment\n\n      if (!this.noTouch && hasTouchSupport) {\n        // Attach appropriate listeners (prepend event name with '&' for passive mode)\n\n        /* istanbul ignore next: JSDOM doesn't support touch events */\n        if (hasPointerEventSupport) {\n          on['&pointerdown'] = this.touchStart;\n          on['&pointerup'] = this.touchEnd;\n        } else {\n          on['&touchstart'] = this.touchStart;\n          on['&touchmove'] = this.touchMove;\n          on['&touchend'] = this.touchEnd;\n        }\n      } // Return the carousel\n\n\n      return h('div', {\n        staticClass: 'carousel',\n        class: {\n          slide: !this.noAnimation,\n          'carousel-fade': !this.noAnimation && this.fade,\n          'pointer-event': !this.noTouch && hasTouchSupport && hasPointerEventSupport\n        },\n        style: {\n          background: this.background\n        },\n        attrs: {\n          role: 'region',\n          id: this.safeId(),\n          'aria-busy': this.isSliding ? 'true' : 'false'\n        },\n        on: on\n      }, [inner, controls, indicators]);\n    }\n  });\n\n  var props$i = {\n    imgSrc: {\n      type: String // default: undefined\n\n    },\n    imgAlt: {\n      type: String // default: undefined\n\n    },\n    imgWidth: {\n      type: [Number, String] // default: undefined\n\n    },\n    imgHeight: {\n      type: [Number, String] // default: undefined\n\n    },\n    imgBlank: {\n      type: Boolean,\n      default: false\n    },\n    imgBlankColor: {\n      type: String,\n      default: 'transparent'\n    },\n    contentVisibleUp: {\n      type: String\n    },\n    contentTag: {\n      type: String,\n      default: 'div'\n    },\n    caption: {\n      type: String\n    },\n    captionHtml: {\n      type: String\n    },\n    captionTag: {\n      type: String,\n      default: 'h3'\n    },\n    text: {\n      type: String\n    },\n    textHtml: {\n      type: String\n    },\n    textTag: {\n      type: String,\n      default: 'p'\n    },\n    background: {\n      type: String\n    }\n  }; // @vue/component\n\n  var BCarouselSlide =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BCarouselSlide',\n    mixins: [idMixin, normalizeSlotMixin],\n    inject: {\n      bvCarousel: {\n        default: function _default() {\n          return {\n            // Explicitly disable touch if not a child of carousel\n            noTouch: true\n          };\n        }\n      }\n    },\n    props: props$i,\n    computed: {\n      contentClasses: function contentClasses() {\n        return [this.contentVisibleUp ? 'd-none' : '', this.contentVisibleUp ? \"d-\".concat(this.contentVisibleUp, \"-block\") : ''];\n      },\n      computedWidth: function computedWidth() {\n        // Use local width, or try parent width\n        return this.imgWidth || this.bvCarousel.imgWidth || null;\n      },\n      computedHeight: function computedHeight() {\n        // Use local height, or try parent height\n        return this.imgHeight || this.bvCarousel.imgHeight || null;\n      }\n    },\n    render: function render(h) {\n      var noDrag = !this.bvCarousel.noTouch && hasTouchSupport;\n      var img = this.normalizeSlot('img');\n\n      if (!img && (this.imgSrc || this.imgBlank)) {\n        img = h(BImg, {\n          props: {\n            fluidGrow: true,\n            block: true,\n            src: this.imgSrc,\n            blank: this.imgBlank,\n            blankColor: this.imgBlankColor,\n            width: this.computedWidth,\n            height: this.computedHeight,\n            alt: this.imgAlt\n          },\n          // Touch support event handler\n          on: noDrag ? {\n            dragstart: function dragstart(e) {\n              /* istanbul ignore next: difficult to test in JSDOM */\n              e.preventDefault();\n            }\n          } : {}\n        });\n      }\n\n      if (!img) {\n        img = h();\n      }\n\n      var content = h();\n      var contentChildren = [this.caption || this.captionHtml ? h(this.captionTag, {\n        domProps: htmlOrText(this.captionHtml, this.caption)\n      }) : false, this.text || this.textHtml ? h(this.textTag, {\n        domProps: htmlOrText(this.textHtml, this.text)\n      }) : false, this.normalizeSlot('default') || false];\n\n      if (contentChildren.some(Boolean)) {\n        content = h(this.contentTag, {\n          staticClass: 'carousel-caption',\n          class: this.contentClasses\n        }, contentChildren.map(function (i) {\n          return i || h();\n        }));\n      }\n\n      return h('div', {\n        staticClass: 'carousel-item',\n        style: {\n          background: this.background || this.bvCarousel.background || null\n        },\n        attrs: {\n          id: this.safeId(),\n          role: 'listitem'\n        }\n      }, [img, content]);\n    }\n  });\n\n  var CarouselPlugin =\n  /*#__PURE*/\n  pluginFactory({\n    components: {\n      BCarousel: BCarousel,\n      BCarouselSlide: BCarouselSlide\n    }\n  });\n\n  // Generic collapse transion helper component\n\n  var onEnter = function onEnter(el) {\n    el.style.height = 0; // Animaton frame delay neeeded for `appear` to work\n\n    requestAF(function () {\n      reflow(el);\n      el.style.height = \"\".concat(el.scrollHeight, \"px\");\n    });\n  };\n\n  var onAfterEnter = function onAfterEnter(el) {\n    el.style.height = null;\n  };\n\n  var onLeave = function onLeave(el) {\n    el.style.height = 'auto';\n    el.style.display = 'block';\n    el.style.height = \"\".concat(getBCR(el).height, \"px\");\n    reflow(el);\n    el.style.height = 0;\n  };\n\n  var onAfterLeave = function onAfterLeave(el) {\n    el.style.height = null;\n  }; // Default transition props\n  // `appear` will use the enter classes\n\n\n  var TRANSITION_PROPS = {\n    css: true,\n    enterClass: '',\n    enterActiveClass: 'collapsing',\n    enterToClass: 'collapse show',\n    leaveClass: 'collapse show',\n    leaveActiveClass: 'collapsing',\n    leaveToClass: 'collapse'\n  }; // Default transition handlers\n  // `appear` will use the enter handlers\n\n  var TRANSITION_HANDLERS = {\n    enter: onEnter,\n    afterEnter: onAfterEnter,\n    leave: onLeave,\n    afterLeave: onAfterLeave\n  }; // @vue/component\n\n  var BVCollapse =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BVCollapse',\n    functional: true,\n    props: {\n      appear: {\n        // If `true` (and `visible` is `true` on mount), animate initially visible\n        type: Boolean,\n        default: false\n      }\n    },\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h('transition', // We merge in the `appear` prop last\n      a(data, {\n        props: TRANSITION_PROPS,\n        on: TRANSITION_HANDLERS\n      }, {\n        props: props\n      }), // Note: `<tranition>` supports a single root element only\n      children);\n    }\n  });\n\n  /**\n   * Issue #569: collapse::toggle::state triggered too many times\n   * @link https://github.com/bootstrap-vue/bootstrap-vue/issues/569\n   */\n  // @vue/component\n  var listenOnRootMixin = {\n    methods: {\n      /**\n       * Safely register event listeners on the root Vue node.\n       * While Vue automatically removes listeners for individual components,\n       * when a component registers a listener on root and is destroyed,\n       * this orphans a callback because the node is gone,\n       * but the root does not clear the callback.\n       *\n       * When registering a $root listener, it also registers a listener on\n       * the component's `beforeDestroy` hook to automatically remove the\n       * event listener from the $root instance.\n       *\n       * @param {string} event\n       * @param {function} callback\n       * @chainable\n       */\n      listenOnRoot: function listenOnRoot(event, callback) {\n        var _this = this;\n\n        this.$root.$on(event, callback);\n        this.$on('hook:beforeDestroy', function () {\n          _this.$root.$off(event, callback);\n        }); // Return this for easy chaining\n\n        return this;\n      },\n\n      /**\n       * Safely register a $once event listener on the root Vue node.\n       * While Vue automatically removes listeners for individual components,\n       * when a component registers a listener on root and is destroyed,\n       * this orphans a callback because the node is gone,\n       * but the root does not clear the callback.\n       *\n       * When registering a $root listener, it also registers a listener on\n       * the component's `beforeDestroy` hook to automatically remove the\n       * event listener from the $root instance.\n       *\n       * @param {string} event\n       * @param {function} callback\n       * @chainable\n       */\n      listenOnRootOnce: function listenOnRootOnce(event, callback) {\n        var _this2 = this;\n\n        this.$root.$once(event, callback);\n        this.$on('hook:beforeDestroy', function () {\n          _this2.$root.$off(event, callback);\n        }); // Return this for easy chaining\n\n        return this;\n      },\n\n      /**\n       * Convenience method for calling vm.$emit on vm.$root.\n       * @param {string} event\n       * @param {*} args\n       * @chainable\n       */\n      emitOnRoot: function emitOnRoot(event) {\n        var _this$$root;\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        (_this$$root = this.$root).$emit.apply(_this$$root, [event].concat(args)); // Return this for easy chaining\n\n\n        return this;\n      }\n    }\n  };\n\n  var EVENT_STATE = 'bv::collapse::state';\n  var EVENT_ACCORDION = 'bv::collapse::accordion'; // Private event we emit on `$root` to ensure the toggle state is\n  // always synced. It gets emitted even if the state has not changed!\n  // This event is NOT to be documented as people should not be using it\n\n  var EVENT_STATE_SYNC = 'bv::collapse::sync::state'; // Events we listen to on `$root`\n\n  var EVENT_TOGGLE = 'bv::toggle::collapse';\n  var EVENT_STATE_REQUEST = 'bv::request::collapse::state'; // @vue/component\n\n  var BCollapse =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BCollapse',\n    mixins: [idMixin, listenOnRootMixin, normalizeSlotMixin],\n    model: {\n      prop: 'visible',\n      event: 'input'\n    },\n    props: {\n      isNav: {\n        type: Boolean,\n        default: false\n      },\n      accordion: {\n        type: String,\n        default: null\n      },\n      visible: {\n        type: Boolean,\n        default: false\n      },\n      tag: {\n        type: String,\n        default: 'div'\n      },\n      appear: {\n        // If `true` (and `visible` is `true` on mount), animate initially visible\n        type: Boolean,\n        default: false\n      }\n    },\n    data: function data() {\n      return {\n        show: this.visible,\n        transitioning: false\n      };\n    },\n    computed: {\n      classObject: function classObject() {\n        return {\n          'navbar-collapse': this.isNav,\n          collapse: !this.transitioning,\n          show: this.show && !this.transitioning\n        };\n      }\n    },\n    watch: {\n      visible: function visible(newVal) {\n        if (newVal !== this.show) {\n          this.show = newVal;\n        }\n      },\n      show: function show(newVal, oldVal) {\n        if (newVal !== oldVal) {\n          this.emitState();\n        }\n      }\n    },\n    created: function created() {\n      this.show = this.visible;\n    },\n    mounted: function mounted() {\n      var _this = this;\n\n      this.show = this.visible; // Listen for toggle events to open/close us\n\n      this.listenOnRoot(EVENT_TOGGLE, this.handleToggleEvt); // Listen to other collapses for accordion events\n\n      this.listenOnRoot(EVENT_ACCORDION, this.handleAccordionEvt);\n\n      if (this.isNav) {\n        // Set up handlers\n        this.setWindowEvents(true);\n        this.handleResize();\n      }\n\n      this.$nextTick(function () {\n        _this.emitState();\n      }); // Listen for \"Sync state\" requests from `v-b-toggle`\n\n      this.listenOnRoot(EVENT_STATE_REQUEST, function (id) {\n        if (id === _this.safeId()) {\n          _this.$nextTick(_this.emitSync);\n        }\n      });\n    },\n    updated: function updated() {\n      // Emit a private event every time this component updates to ensure\n      // the toggle button is in sync with the collapse's state\n      // It is emitted regardless if the visible state changes\n      this.emitSync();\n    },\n    deactivated: function deactivated()\n    /* istanbul ignore next */\n    {\n      if (this.isNav) {\n        this.setWindowEvents(false);\n      }\n    },\n    activated: function activated()\n    /* istanbul ignore next */\n    {\n      if (this.isNav) {\n        this.setWindowEvents(true);\n      }\n\n      this.emitSync();\n    },\n    beforeDestroy: function beforeDestroy() {\n      // Trigger state emit if needed\n      this.show = false;\n\n      if (this.isNav && isBrowser) {\n        this.setWindowEvents(false);\n      }\n    },\n    methods: {\n      setWindowEvents: function setWindowEvents(on) {\n        eventOnOff(on, window, 'resize', this.handleResize, EVENT_OPTIONS_NO_CAPTURE);\n        eventOnOff(on, window, 'orientationchange', this.handleResize, EVENT_OPTIONS_NO_CAPTURE);\n      },\n      toggle: function toggle() {\n        this.show = !this.show;\n      },\n      onEnter: function onEnter() {\n        this.transitioning = true; // This should be moved out so we can add cancellable events\n\n        this.$emit('show');\n      },\n      onAfterEnter: function onAfterEnter() {\n        this.transitioning = false;\n        this.$emit('shown');\n      },\n      onLeave: function onLeave() {\n        this.transitioning = true; // This should be moved out so we can add cancellable events\n\n        this.$emit('hide');\n      },\n      onAfterLeave: function onAfterLeave() {\n        this.transitioning = false;\n        this.$emit('hidden');\n      },\n      emitState: function emitState() {\n        this.$emit('input', this.show); // Let `v-b-toggle` know the state of this collapse\n\n        this.$root.$emit(EVENT_STATE, this.safeId(), this.show);\n\n        if (this.accordion && this.show) {\n          // Tell the other collapses in this accordion to close\n          this.$root.$emit(EVENT_ACCORDION, this.safeId(), this.accordion);\n        }\n      },\n      emitSync: function emitSync() {\n        // Emit a private event every time this component updates to ensure\n        // the toggle button is in sync with the collapse's state\n        // It is emitted regardless if the visible state changes\n        this.$root.$emit(EVENT_STATE_SYNC, this.safeId(), this.show);\n      },\n      checkDisplayBlock: function checkDisplayBlock() {\n        // Check to see if the collapse has `display: block !important` set\n        // We can't set `display: none` directly on `this.$el`, as it would\n        // trigger a new transition to start (or cancel a current one)\n        var restore = hasClass(this.$el, 'show');\n        removeClass(this.$el, 'show');\n        var isBlock = getCS(this.$el).display === 'block';\n\n        if (restore) {\n          addClass(this.$el, 'show');\n        }\n\n        return isBlock;\n      },\n      clickHandler: function clickHandler(evt) {\n        // If we are in a nav/navbar, close the collapse when non-disabled link clicked\n        var el = evt.target;\n\n        if (!this.isNav || !el || getCS(this.$el).display !== 'block') {\n          /* istanbul ignore next: can't test getComputedStyle in JSDOM */\n          return;\n        }\n\n        if (matches(el, '.nav-link,.dropdown-item') || closest('.nav-link,.dropdown-item', el)) {\n          if (!this.checkDisplayBlock()) {\n            // Only close the collapse if it is not forced to be `display: block !important`\n            this.show = false;\n          }\n        }\n      },\n      handleToggleEvt: function handleToggleEvt(target) {\n        if (target !== this.safeId()) {\n          return;\n        }\n\n        this.toggle();\n      },\n      handleAccordionEvt: function handleAccordionEvt(openedId, accordion) {\n        if (!this.accordion || accordion !== this.accordion) {\n          return;\n        }\n\n        if (openedId === this.safeId()) {\n          // Open this collapse if not shown\n          if (!this.show) {\n            this.toggle();\n          }\n        } else {\n          // Close this collapse if shown\n          if (this.show) {\n            this.toggle();\n          }\n        }\n      },\n      handleResize: function handleResize() {\n        // Handler for orientation/resize to set collapsed state in nav/navbar\n        this.show = getCS(this.$el).display === 'block';\n      }\n    },\n    render: function render(h) {\n      var _this2 = this;\n\n      var scope = {\n        visible: this.show,\n        close: function close() {\n          return _this2.show = false;\n        }\n      };\n      var content = h(this.tag, {\n        class: this.classObject,\n        directives: [{\n          name: 'show',\n          value: this.show\n        }],\n        attrs: {\n          id: this.safeId()\n        },\n        on: {\n          click: this.clickHandler\n        }\n      }, [this.normalizeSlot('default', scope)]);\n      return h(BVCollapse, {\n        props: {\n          appear: this.appear\n        },\n        on: {\n          enter: this.onEnter,\n          afterEnter: this.onAfterEnter,\n          leave: this.onLeave,\n          afterLeave: this.onAfterLeave\n        }\n      }, [content]);\n    }\n  });\n\n  var allListenTypes = {\n    hover: true,\n    click: true,\n    focus: true\n  };\n  var BVBoundListeners = '__BV_boundEventListeners__';\n\n  var getTargets = function getTargets(binding) {\n    var targets = keys(binding.modifiers || {}).filter(function (t) {\n      return !allListenTypes[t];\n    });\n\n    if (binding.value) {\n      targets.push(binding.value);\n    }\n\n    return targets;\n  };\n\n  var bindTargets = function bindTargets(vnode, binding, listenTypes, fn) {\n    var targets = getTargets(binding);\n\n    var listener = function listener() {\n      fn({\n        targets: targets,\n        vnode: vnode\n      });\n    };\n\n    keys(allListenTypes).forEach(function (type) {\n      if (listenTypes[type] || binding.modifiers[type]) {\n        eventOn(vnode.elm, type, listener);\n        var boundListeners = vnode.elm[BVBoundListeners] || {};\n        boundListeners[type] = boundListeners[type] || [];\n        boundListeners[type].push(listener);\n        vnode.elm[BVBoundListeners] = boundListeners;\n      }\n    }); // Return the list of targets\n\n    return targets;\n  };\n\n  var unbindTargets = function unbindTargets(vnode, binding, listenTypes) {\n    keys(allListenTypes).forEach(function (type) {\n      if (listenTypes[type] || binding.modifiers[type]) {\n        var boundListeners = vnode.elm[BVBoundListeners] && vnode.elm[BVBoundListeners][type];\n\n        if (boundListeners) {\n          boundListeners.forEach(function (listener) {\n            return eventOff(vnode.elm, type, listener);\n          });\n          delete vnode.elm[BVBoundListeners][type];\n        }\n      }\n    });\n  };\n\n  var listenTypes = {\n    click: true\n  }; // Property key for handler storage\n\n  var BV_TOGGLE = '__BV_toggle__';\n  var BV_TOGGLE_STATE = '__BV_toggle_STATE__';\n  var BV_TOGGLE_CONTROLS = '__BV_toggle_CONTROLS__';\n  var BV_TOGGLE_TARGETS = '__BV_toggle_TARGETS__'; // Emitted control event for collapse (emitted to collapse)\n\n  var EVENT_TOGGLE$1 = 'bv::toggle::collapse'; // Listen to event for toggle state update (emitted by collapse)\n\n  var EVENT_STATE$1 = 'bv::collapse::state'; // Private event emitted on $root to ensure the toggle state is always synced.\n  // Gets emitted even if the state of b-collapse has not changed.\n  // This event is NOT to be documented as people should not be using it.\n\n  var EVENT_STATE_SYNC$1 = 'bv::collapse::sync::state'; // Private event we send to collapse to request state update sync event\n\n  var EVENT_STATE_REQUEST$1 = 'bv::request::collapse::state'; // Reset and remove a property from the provided element\n\n  var resetProp = function resetProp(el, prop) {\n    el[prop] = null;\n    delete el[prop];\n  }; // Handle targets update\n\n\n  var handleTargets = function handleTargets(_ref) {\n    var targets = _ref.targets,\n        vnode = _ref.vnode;\n    targets.forEach(function (target) {\n      vnode.context.$root.$emit(EVENT_TOGGLE$1, target);\n    });\n  }; // Handle directive updates\n\n  /* istanbul ignore next: not easy to test */\n\n\n  var handleUpdate = function handleUpdate(el, binding, vnode) {\n    if (!isBrowser) {\n      return;\n    }\n\n    if (!looseEqual(getTargets(binding), el[BV_TOGGLE_TARGETS])) {\n      // Targets have changed, so update accordingly\n      unbindTargets(vnode, binding, listenTypes);\n      var targets = bindTargets(vnode, binding, listenTypes, handleTargets); // Update targets array to element\n\n      el[BV_TOGGLE_TARGETS] = targets; // Add aria attributes to element\n\n      el[BV_TOGGLE_CONTROLS] = targets.join(' '); // ensure aria-controls is up to date\n\n      setAttr(el, 'aria-controls', el[BV_TOGGLE_CONTROLS]); // Request a state update from targets so that we can ensure\n      // expanded state is correct\n\n      targets.forEach(function (target) {\n        vnode.context.$root.$emit(EVENT_STATE_REQUEST$1, target);\n      });\n    } // Ensure the collapse class and aria-* attributes persist\n    // after element is updated (either by parent re-rendering\n    // or changes to this element or its contents\n\n\n    if (el[BV_TOGGLE_STATE] === true) {\n      addClass(el, 'collapsed');\n      setAttr(el, 'aria-expanded', 'true');\n    } else if (el[BV_TOGGLE_STATE] === false) {\n      removeClass(el, 'collapsed');\n      setAttr(el, 'aria-expanded', 'false');\n    }\n\n    setAttr(el, 'aria-controls', el[BV_TOGGLE_CONTROLS]);\n  };\n  /*\n   * Export our directive\n   */\n\n\n  var VBToggle = {\n    bind: function bind(el, binding, vnode) {\n      var targets = bindTargets(vnode, binding, listenTypes, handleTargets);\n\n      if (isBrowser && vnode.context && targets.length > 0) {\n        // Add targets array to element\n        el[BV_TOGGLE_TARGETS] = targets; // Add aria attributes to element\n\n        el[BV_TOGGLE_CONTROLS] = targets.join(' '); // State is initially collapsed until we receive a state event\n\n        el[BV_TOGGLE_STATE] = false;\n        setAttr(el, 'aria-controls', el[BV_TOGGLE_CONTROLS]);\n        setAttr(el, 'aria-expanded', 'false'); // If element is not a button, we add `role=\"button\"` for accessibility\n\n        if (el.tagName !== 'BUTTON' && !hasAttr(el, 'role')) {\n          setAttr(el, 'role', 'button');\n        } // Toggle state handler\n\n\n        var toggleDirectiveHandler = function toggleDirectiveHandler(id, state) {\n          var targets = el[BV_TOGGLE_TARGETS] || [];\n\n          if (targets.indexOf(id) !== -1) {\n            // Set aria-expanded state\n            setAttr(el, 'aria-expanded', state ? 'true' : 'false'); // Set/Clear 'collapsed' class state\n\n            el[BV_TOGGLE_STATE] = state;\n\n            if (state) {\n              removeClass(el, 'collapsed');\n            } else {\n              addClass(el, 'collapsed');\n            }\n          }\n        }; // Store the toggle handler on the element\n\n\n        el[BV_TOGGLE] = toggleDirectiveHandler; // Listen for toggle state changes (public)\n\n        vnode.context.$root.$on(EVENT_STATE$1, el[BV_TOGGLE]); // Listen for toggle state sync (private)\n\n        vnode.context.$root.$on(EVENT_STATE_SYNC$1, el[BV_TOGGLE]);\n      }\n    },\n    componentUpdated: handleUpdate,\n    updated: handleUpdate,\n    unbind: function unbind(el, binding, vnode)\n    /* istanbul ignore next */\n    {\n      unbindTargets(vnode, binding, listenTypes); // Remove our $root listener\n\n      if (el[BV_TOGGLE]) {\n        vnode.context.$root.$off(EVENT_STATE$1, el[BV_TOGGLE]);\n        vnode.context.$root.$off(EVENT_STATE_SYNC$1, el[BV_TOGGLE]);\n      } // Reset custom  props\n\n\n      resetProp(el, BV_TOGGLE);\n      resetProp(el, BV_TOGGLE_STATE);\n      resetProp(el, BV_TOGGLE_CONTROLS);\n      resetProp(el, BV_TOGGLE_TARGETS); // Reset classes/attrs\n\n      removeClass(el, 'collapsed');\n      removeAttr(el, 'aria-expanded');\n      removeAttr(el, 'aria-controls');\n      removeAttr(el, 'role');\n    }\n  };\n\n  var CollapsePlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BCollapse: BCollapse\n    },\n    directives: {\n      VBToggle: VBToggle\n    }\n  });\n\n  /**!\n   * @fileOverview Kickass library to create and place poppers near their reference elements.\n   * @version 1.16.1\n   * @license\n   * Copyright (c) 2016 Federico Zivolo and contributors\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a copy\n   * of this software and associated documentation files (the \"Software\"), to deal\n   * in the Software without restriction, including without limitation the rights\n   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   * copies of the Software, and to permit persons to whom the Software is\n   * furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in all\n   * copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   * SOFTWARE.\n   */\n  var isBrowser$1 = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';\n\n  var timeoutDuration = function () {\n    var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\n    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n      if (isBrowser$1 && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n        return 1;\n      }\n    }\n    return 0;\n  }();\n\n  function microtaskDebounce(fn) {\n    var called = false;\n    return function () {\n      if (called) {\n        return;\n      }\n      called = true;\n      window.Promise.resolve().then(function () {\n        called = false;\n        fn();\n      });\n    };\n  }\n\n  function taskDebounce(fn) {\n    var scheduled = false;\n    return function () {\n      if (!scheduled) {\n        scheduled = true;\n        setTimeout(function () {\n          scheduled = false;\n          fn();\n        }, timeoutDuration);\n      }\n    };\n  }\n\n  var supportsMicroTasks = isBrowser$1 && window.Promise;\n\n  /**\n  * Create a debounced version of a method, that's asynchronously deferred\n  * but called in the minimum time possible.\n  *\n  * @method\n  * @memberof Popper.Utils\n  * @argument {Function} fn\n  * @returns {Function}\n  */\n  var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n  /**\n   * Check if the given variable is a function\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Any} functionToCheck - variable to check\n   * @returns {Boolean} answer to: is a function?\n   */\n  function isFunction$1(functionToCheck) {\n    var getType = {};\n    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n  }\n\n  /**\n   * Get CSS computed property of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Eement} element\n   * @argument {String} property\n   */\n  function getStyleComputedProperty(element, property) {\n    if (element.nodeType !== 1) {\n      return [];\n    }\n    // NOTE: 1 DOM access here\n    var window = element.ownerDocument.defaultView;\n    var css = window.getComputedStyle(element, null);\n    return property ? css[property] : css;\n  }\n\n  /**\n   * Returns the parentNode or the host of the element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} parent\n   */\n  function getParentNode(element) {\n    if (element.nodeName === 'HTML') {\n      return element;\n    }\n    return element.parentNode || element.host;\n  }\n\n  /**\n   * Returns the scrolling parent of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} scroll parent\n   */\n  function getScrollParent(element) {\n    // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n    if (!element) {\n      return document.body;\n    }\n\n    switch (element.nodeName) {\n      case 'HTML':\n      case 'BODY':\n        return element.ownerDocument.body;\n      case '#document':\n        return element.body;\n    }\n\n    // Firefox want us to check `-x` and `-y` variations as well\n\n    var _getStyleComputedProp = getStyleComputedProperty(element),\n        overflow = _getStyleComputedProp.overflow,\n        overflowX = _getStyleComputedProp.overflowX,\n        overflowY = _getStyleComputedProp.overflowY;\n\n    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n      return element;\n    }\n\n    return getScrollParent(getParentNode(element));\n  }\n\n  /**\n   * Returns the reference node of the reference object, or the reference object itself.\n   * @method\n   * @memberof Popper.Utils\n   * @param {Element|Object} reference - the reference element (the popper will be relative to this)\n   * @returns {Element} parent\n   */\n  function getReferenceNode(reference) {\n    return reference && reference.referenceNode ? reference.referenceNode : reference;\n  }\n\n  var isIE11 = isBrowser$1 && !!(window.MSInputMethodContext && document.documentMode);\n  var isIE10 = isBrowser$1 && /MSIE 10/.test(navigator.userAgent);\n\n  /**\n   * Determines if the browser is Internet Explorer\n   * @method\n   * @memberof Popper.Utils\n   * @param {Number} version to check\n   * @returns {Boolean} isIE\n   */\n  function isIE$1(version) {\n    if (version === 11) {\n      return isIE11;\n    }\n    if (version === 10) {\n      return isIE10;\n    }\n    return isIE11 || isIE10;\n  }\n\n  /**\n   * Returns the offset parent of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} offset parent\n   */\n  function getOffsetParent(element) {\n    if (!element) {\n      return document.documentElement;\n    }\n\n    var noOffsetParent = isIE$1(10) ? document.body : null;\n\n    // NOTE: 1 DOM access here\n    var offsetParent = element.offsetParent || null;\n    // Skip hidden elements which don't have an offsetParent\n    while (offsetParent === noOffsetParent && element.nextElementSibling) {\n      offsetParent = (element = element.nextElementSibling).offsetParent;\n    }\n\n    var nodeName = offsetParent && offsetParent.nodeName;\n\n    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n      return element ? element.ownerDocument.documentElement : document.documentElement;\n    }\n\n    // .offsetParent will return the closest TH, TD or TABLE in case\n    // no offsetParent is present, I hate this job...\n    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n      return getOffsetParent(offsetParent);\n    }\n\n    return offsetParent;\n  }\n\n  function isOffsetContainer(element) {\n    var nodeName = element.nodeName;\n\n    if (nodeName === 'BODY') {\n      return false;\n    }\n    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n  }\n\n  /**\n   * Finds the root node (document, shadowDOM root) of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} node\n   * @returns {Element} root node\n   */\n  function getRoot(node) {\n    if (node.parentNode !== null) {\n      return getRoot(node.parentNode);\n    }\n\n    return node;\n  }\n\n  /**\n   * Finds the offset parent common to the two provided nodes\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element1\n   * @argument {Element} element2\n   * @returns {Element} common offset parent\n   */\n  function findCommonOffsetParent(element1, element2) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n      return document.documentElement;\n    }\n\n    // Here we make sure to give as \"start\" the element that comes first in the DOM\n    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n    var start = order ? element1 : element2;\n    var end = order ? element2 : element1;\n\n    // Get common ancestor container\n    var range = document.createRange();\n    range.setStart(start, 0);\n    range.setEnd(end, 0);\n    var commonAncestorContainer = range.commonAncestorContainer;\n\n    // Both nodes are inside #document\n\n    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n      if (isOffsetContainer(commonAncestorContainer)) {\n        return commonAncestorContainer;\n      }\n\n      return getOffsetParent(commonAncestorContainer);\n    }\n\n    // one of the nodes is inside shadowDOM, find which one\n    var element1root = getRoot(element1);\n    if (element1root.host) {\n      return findCommonOffsetParent(element1root.host, element2);\n    } else {\n      return findCommonOffsetParent(element1, getRoot(element2).host);\n    }\n  }\n\n  /**\n   * Gets the scroll value of the given element in the given side (top and left)\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @argument {String} side `top` or `left`\n   * @returns {number} amount of scrolled pixels\n   */\n  function getScroll(element) {\n    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n    var nodeName = element.nodeName;\n\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n      var html = element.ownerDocument.documentElement;\n      var scrollingElement = element.ownerDocument.scrollingElement || html;\n      return scrollingElement[upperSide];\n    }\n\n    return element[upperSide];\n  }\n\n  /*\n   * Sum or subtract the element scroll values (left and top) from a given rect object\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} rect - Rect object you want to change\n   * @param {HTMLElement} element - The element from the function reads the scroll values\n   * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n   * @return {Object} rect - The modifier rect object\n   */\n  function includeScroll(rect, element) {\n    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    var scrollTop = getScroll(element, 'top');\n    var scrollLeft = getScroll(element, 'left');\n    var modifier = subtract ? -1 : 1;\n    rect.top += scrollTop * modifier;\n    rect.bottom += scrollTop * modifier;\n    rect.left += scrollLeft * modifier;\n    rect.right += scrollLeft * modifier;\n    return rect;\n  }\n\n  /*\n   * Helper to detect borders of a given element\n   * @method\n   * @memberof Popper.Utils\n   * @param {CSSStyleDeclaration} styles\n   * Result of `getStyleComputedProperty` on the given element\n   * @param {String} axis - `x` or `y`\n   * @return {number} borders - The borders size of the given axis\n   */\n\n  function getBordersSize(styles, axis) {\n    var sideA = axis === 'x' ? 'Left' : 'Top';\n    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n    return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);\n  }\n\n  function getSize(axis, body, html, computedStyle) {\n    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE$1(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);\n  }\n\n  function getWindowSizes(document) {\n    var body = document.body;\n    var html = document.documentElement;\n    var computedStyle = isIE$1(10) && getComputedStyle(html);\n\n    return {\n      height: getSize('Height', body, html, computedStyle),\n      width: getSize('Width', body, html, computedStyle)\n    };\n  }\n\n  var classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n\n\n\n\n  var defineProperty$1 = function (obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  };\n\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  /**\n   * Given element offsets, generate an output similar to getBoundingClientRect\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Object} offsets\n   * @returns {Object} ClientRect like output\n   */\n  function getClientRect(offsets) {\n    return _extends({}, offsets, {\n      right: offsets.left + offsets.width,\n      bottom: offsets.top + offsets.height\n    });\n  }\n\n  /**\n   * Get bounding client rect of given element\n   * @method\n   * @memberof Popper.Utils\n   * @param {HTMLElement} element\n   * @return {Object} client rect\n   */\n  function getBoundingClientRect(element) {\n    var rect = {};\n\n    // IE10 10 FIX: Please, don't ask, the element isn't\n    // considered in DOM in some circumstances...\n    // This isn't reproducible in IE10 compatibility mode of IE11\n    try {\n      if (isIE$1(10)) {\n        rect = element.getBoundingClientRect();\n        var scrollTop = getScroll(element, 'top');\n        var scrollLeft = getScroll(element, 'left');\n        rect.top += scrollTop;\n        rect.left += scrollLeft;\n        rect.bottom += scrollTop;\n        rect.right += scrollLeft;\n      } else {\n        rect = element.getBoundingClientRect();\n      }\n    } catch (e) {}\n\n    var result = {\n      left: rect.left,\n      top: rect.top,\n      width: rect.right - rect.left,\n      height: rect.bottom - rect.top\n    };\n\n    // subtract scrollbar size from sizes\n    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n    var width = sizes.width || element.clientWidth || result.width;\n    var height = sizes.height || element.clientHeight || result.height;\n\n    var horizScrollbar = element.offsetWidth - width;\n    var vertScrollbar = element.offsetHeight - height;\n\n    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n    // we make this check conditional for performance reasons\n    if (horizScrollbar || vertScrollbar) {\n      var styles = getStyleComputedProperty(element);\n      horizScrollbar -= getBordersSize(styles, 'x');\n      vertScrollbar -= getBordersSize(styles, 'y');\n\n      result.width -= horizScrollbar;\n      result.height -= vertScrollbar;\n    }\n\n    return getClientRect(result);\n  }\n\n  function getOffsetRectRelativeToArbitraryNode(children, parent) {\n    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    var isIE10 = isIE$1(10);\n    var isHTML = parent.nodeName === 'HTML';\n    var childrenRect = getBoundingClientRect(children);\n    var parentRect = getBoundingClientRect(parent);\n    var scrollParent = getScrollParent(children);\n\n    var styles = getStyleComputedProperty(parent);\n    var borderTopWidth = parseFloat(styles.borderTopWidth);\n    var borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n    // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n    if (fixedPosition && isHTML) {\n      parentRect.top = Math.max(parentRect.top, 0);\n      parentRect.left = Math.max(parentRect.left, 0);\n    }\n    var offsets = getClientRect({\n      top: childrenRect.top - parentRect.top - borderTopWidth,\n      left: childrenRect.left - parentRect.left - borderLeftWidth,\n      width: childrenRect.width,\n      height: childrenRect.height\n    });\n    offsets.marginTop = 0;\n    offsets.marginLeft = 0;\n\n    // Subtract margins of documentElement in case it's being used as parent\n    // we do this only on HTML because it's the only element that behaves\n    // differently when margins are applied to it. The margins are included in\n    // the box of the documentElement, in the other cases not.\n    if (!isIE10 && isHTML) {\n      var marginTop = parseFloat(styles.marginTop);\n      var marginLeft = parseFloat(styles.marginLeft);\n\n      offsets.top -= borderTopWidth - marginTop;\n      offsets.bottom -= borderTopWidth - marginTop;\n      offsets.left -= borderLeftWidth - marginLeft;\n      offsets.right -= borderLeftWidth - marginLeft;\n\n      // Attach marginTop and marginLeft because in some circumstances we may need them\n      offsets.marginTop = marginTop;\n      offsets.marginLeft = marginLeft;\n    }\n\n    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n      offsets = includeScroll(offsets, parent);\n    }\n\n    return offsets;\n  }\n\n  function getViewportOffsetRectRelativeToArtbitraryNode(element) {\n    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    var html = element.ownerDocument.documentElement;\n    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n    var width = Math.max(html.clientWidth, window.innerWidth || 0);\n    var height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n    var scrollTop = !excludeScroll ? getScroll(html) : 0;\n    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n    var offset = {\n      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n      width: width,\n      height: height\n    };\n\n    return getClientRect(offset);\n  }\n\n  /**\n   * Check if the given element is fixed or is inside a fixed parent\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @argument {Element} customContainer\n   * @returns {Boolean} answer to \"isFixed?\"\n   */\n  function isFixed(element) {\n    var nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n      return false;\n    }\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n      return true;\n    }\n    var parentNode = getParentNode(element);\n    if (!parentNode) {\n      return false;\n    }\n    return isFixed(parentNode);\n  }\n\n  /**\n   * Finds the first parent of an element that has a transformed property defined\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} first transformed parent or documentElement\n   */\n\n  function getFixedPositionOffsetParent(element) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element || !element.parentElement || isIE$1()) {\n      return document.documentElement;\n    }\n    var el = element.parentElement;\n    while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n      el = el.parentElement;\n    }\n    return el || document.documentElement;\n  }\n\n  /**\n   * Computed the boundaries limits and return them\n   * @method\n   * @memberof Popper.Utils\n   * @param {HTMLElement} popper\n   * @param {HTMLElement} reference\n   * @param {number} padding\n   * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n   * @param {Boolean} fixedPosition - Is in fixed position mode\n   * @returns {Object} Coordinates of the boundaries\n   */\n  function getBoundaries(popper, reference, padding, boundariesElement) {\n    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    // NOTE: 1 DOM access here\n\n    var boundaries = { top: 0, left: 0 };\n    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n    // Handle viewport case\n    if (boundariesElement === 'viewport') {\n      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n    } else {\n      // Handle other cases based on DOM element used as boundaries\n      var boundariesNode = void 0;\n      if (boundariesElement === 'scrollParent') {\n        boundariesNode = getScrollParent(getParentNode(reference));\n        if (boundariesNode.nodeName === 'BODY') {\n          boundariesNode = popper.ownerDocument.documentElement;\n        }\n      } else if (boundariesElement === 'window') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      } else {\n        boundariesNode = boundariesElement;\n      }\n\n      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n      // In case of HTML, we need a different computation\n      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n        var _getWindowSizes = getWindowSizes(popper.ownerDocument),\n            height = _getWindowSizes.height,\n            width = _getWindowSizes.width;\n\n        boundaries.top += offsets.top - offsets.marginTop;\n        boundaries.bottom = height + offsets.top;\n        boundaries.left += offsets.left - offsets.marginLeft;\n        boundaries.right = width + offsets.left;\n      } else {\n        // for all the other DOM elements, this one is good\n        boundaries = offsets;\n      }\n    }\n\n    // Add paddings\n    padding = padding || 0;\n    var isPaddingNumber = typeof padding === 'number';\n    boundaries.left += isPaddingNumber ? padding : padding.left || 0;\n    boundaries.top += isPaddingNumber ? padding : padding.top || 0;\n    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;\n    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n\n    return boundaries;\n  }\n\n  function getArea(_ref) {\n    var width = _ref.width,\n        height = _ref.height;\n\n    return width * height;\n  }\n\n  /**\n   * Utility used to transform the `auto` placement to the placement with more\n   * available space.\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n    if (placement.indexOf('auto') === -1) {\n      return placement;\n    }\n\n    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n    var rects = {\n      top: {\n        width: boundaries.width,\n        height: refRect.top - boundaries.top\n      },\n      right: {\n        width: boundaries.right - refRect.right,\n        height: boundaries.height\n      },\n      bottom: {\n        width: boundaries.width,\n        height: boundaries.bottom - refRect.bottom\n      },\n      left: {\n        width: refRect.left - boundaries.left,\n        height: boundaries.height\n      }\n    };\n\n    var sortedAreas = Object.keys(rects).map(function (key) {\n      return _extends({\n        key: key\n      }, rects[key], {\n        area: getArea(rects[key])\n      });\n    }).sort(function (a, b) {\n      return b.area - a.area;\n    });\n\n    var filteredAreas = sortedAreas.filter(function (_ref2) {\n      var width = _ref2.width,\n          height = _ref2.height;\n      return width >= popper.clientWidth && height >= popper.clientHeight;\n    });\n\n    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n\n    var variation = placement.split('-')[1];\n\n    return computedPlacement + (variation ? '-' + variation : '');\n  }\n\n  /**\n   * Get offsets to the reference element\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} state\n   * @param {Element} popper - the popper element\n   * @param {Element} reference - the reference element (the popper will be relative to this)\n   * @param {Element} fixedPosition - is in fixed position mode\n   * @returns {Object} An object containing the offsets which will be applied to the popper\n   */\n  function getReferenceOffsets(state, popper, reference) {\n    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n  }\n\n  /**\n   * Get the outer sizes of the given element (offset size + margins)\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Object} object containing width and height properties\n   */\n  function getOuterSizes(element) {\n    var window = element.ownerDocument.defaultView;\n    var styles = window.getComputedStyle(element);\n    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n    var result = {\n      width: element.offsetWidth + y,\n      height: element.offsetHeight + x\n    };\n    return result;\n  }\n\n  /**\n   * Get the opposite placement of the given one\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement\n   * @returns {String} flipped placement\n   */\n  function getOppositePlacement(placement) {\n    var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash[matched];\n    });\n  }\n\n  /**\n   * Get offsets to the popper\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} position - CSS position the Popper will get applied\n   * @param {HTMLElement} popper - the popper element\n   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n   * @param {String} placement - one of the valid placement options\n   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n   */\n  function getPopperOffsets(popper, referenceOffsets, placement) {\n    placement = placement.split('-')[0];\n\n    // Get popper node sizes\n    var popperRect = getOuterSizes(popper);\n\n    // Add position, width and height to our offsets object\n    var popperOffsets = {\n      width: popperRect.width,\n      height: popperRect.height\n    };\n\n    // depending by the popper placement we have to compute its offsets slightly differently\n    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n    var mainSide = isHoriz ? 'top' : 'left';\n    var secondarySide = isHoriz ? 'left' : 'top';\n    var measurement = isHoriz ? 'height' : 'width';\n    var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n    if (placement === secondarySide) {\n      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n    } else {\n      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n    }\n\n    return popperOffsets;\n  }\n\n  /**\n   * Mimics the `find` method of Array\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Array} arr\n   * @argument prop\n   * @argument value\n   * @returns index or -1\n   */\n  function find(arr, check) {\n    // use native find if supported\n    if (Array.prototype.find) {\n      return arr.find(check);\n    }\n\n    // use `filter` to obtain the same behavior of `find`\n    return arr.filter(check)[0];\n  }\n\n  /**\n   * Return the index of the matching object\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Array} arr\n   * @argument prop\n   * @argument value\n   * @returns index or -1\n   */\n  function findIndex(arr, prop, value) {\n    // use native findIndex if supported\n    if (Array.prototype.findIndex) {\n      return arr.findIndex(function (cur) {\n        return cur[prop] === value;\n      });\n    }\n\n    // use `find` + `indexOf` if `findIndex` isn't supported\n    var match = find(arr, function (obj) {\n      return obj[prop] === value;\n    });\n    return arr.indexOf(match);\n  }\n\n  /**\n   * Loop trough the list of modifiers and run them in order,\n   * each of them will then edit the data object.\n   * @method\n   * @memberof Popper.Utils\n   * @param {dataObject} data\n   * @param {Array} modifiers\n   * @param {String} ends - Optional modifier name used as stopper\n   * @returns {dataObject}\n   */\n  function runModifiers(modifiers, data, ends) {\n    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n    modifiersToRun.forEach(function (modifier) {\n      if (modifier['function']) {\n        // eslint-disable-line dot-notation\n        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n      }\n      var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n      if (modifier.enabled && isFunction$1(fn)) {\n        // Add properties to offsets to make them a complete clientRect object\n        // we do this before each modifier to make sure the previous one doesn't\n        // mess with these values\n        data.offsets.popper = getClientRect(data.offsets.popper);\n        data.offsets.reference = getClientRect(data.offsets.reference);\n\n        data = fn(data, modifier);\n      }\n    });\n\n    return data;\n  }\n\n  /**\n   * Updates the position of the popper, computing the new offsets and applying\n   * the new style.<br />\n   * Prefer `scheduleUpdate` over `update` because of performance reasons.\n   * @method\n   * @memberof Popper\n   */\n  function update() {\n    // if popper is destroyed, don't perform any further update\n    if (this.state.isDestroyed) {\n      return;\n    }\n\n    var data = {\n      instance: this,\n      styles: {},\n      arrowStyles: {},\n      attributes: {},\n      flipped: false,\n      offsets: {}\n    };\n\n    // compute reference element offsets\n    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n    // compute auto placement, store placement inside the data object,\n    // modifiers will be able to edit `placement` if needed\n    // and refer to originalPlacement to know the original value\n    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n    // store the computed placement inside `originalPlacement`\n    data.originalPlacement = data.placement;\n\n    data.positionFixed = this.options.positionFixed;\n\n    // compute the popper offsets\n    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n\n    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n    // run the modifiers\n    data = runModifiers(this.modifiers, data);\n\n    // the first `update` will call `onCreate` callback\n    // the other ones will call `onUpdate` callback\n    if (!this.state.isCreated) {\n      this.state.isCreated = true;\n      this.options.onCreate(data);\n    } else {\n      this.options.onUpdate(data);\n    }\n  }\n\n  /**\n   * Helper used to know if the given modifier is enabled.\n   * @method\n   * @memberof Popper.Utils\n   * @returns {Boolean}\n   */\n  function isModifierEnabled(modifiers, modifierName) {\n    return modifiers.some(function (_ref) {\n      var name = _ref.name,\n          enabled = _ref.enabled;\n      return enabled && name === modifierName;\n    });\n  }\n\n  /**\n   * Get the prefixed supported property name\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} property (camelCase)\n   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n   */\n  function getSupportedPropertyName(property) {\n    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n    for (var i = 0; i < prefixes.length; i++) {\n      var prefix = prefixes[i];\n      var toCheck = prefix ? '' + prefix + upperProp : property;\n      if (typeof document.body.style[toCheck] !== 'undefined') {\n        return toCheck;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Destroys the popper.\n   * @method\n   * @memberof Popper\n   */\n  function destroy$1() {\n    this.state.isDestroyed = true;\n\n    // touch DOM only if `applyStyle` modifier is enabled\n    if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n      this.popper.removeAttribute('x-placement');\n      this.popper.style.position = '';\n      this.popper.style.top = '';\n      this.popper.style.left = '';\n      this.popper.style.right = '';\n      this.popper.style.bottom = '';\n      this.popper.style.willChange = '';\n      this.popper.style[getSupportedPropertyName('transform')] = '';\n    }\n\n    this.disableEventListeners();\n\n    // remove the popper if user explicitly asked for the deletion on destroy\n    // do not use `remove` because IE11 doesn't support it\n    if (this.options.removeOnDestroy) {\n      this.popper.parentNode.removeChild(this.popper);\n    }\n    return this;\n  }\n\n  /**\n   * Get the window associated with the element\n   * @argument {Element} element\n   * @returns {Window}\n   */\n  function getWindow(element) {\n    var ownerDocument = element.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView : window;\n  }\n\n  function attachToScrollParents(scrollParent, event, callback, scrollParents) {\n    var isBody = scrollParent.nodeName === 'BODY';\n    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n    target.addEventListener(event, callback, { passive: true });\n\n    if (!isBody) {\n      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n    }\n    scrollParents.push(target);\n  }\n\n  /**\n   * Setup needed event listeners used to update the popper position\n   * @method\n   * @memberof Popper.Utils\n   * @private\n   */\n  function setupEventListeners(reference, options, state, updateBound) {\n    // Resize event listener on window\n    state.updateBound = updateBound;\n    getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });\n\n    // Scroll event listener on scroll parents\n    var scrollElement = getScrollParent(reference);\n    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n    state.scrollElement = scrollElement;\n    state.eventsEnabled = true;\n\n    return state;\n  }\n\n  /**\n   * It will add resize/scroll events and start recalculating\n   * position of the popper element when they are triggered.\n   * @method\n   * @memberof Popper\n   */\n  function enableEventListeners() {\n    if (!this.state.eventsEnabled) {\n      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n    }\n  }\n\n  /**\n   * Remove event listeners used to update the popper position\n   * @method\n   * @memberof Popper.Utils\n   * @private\n   */\n  function removeEventListeners(reference, state) {\n    // Remove resize event listener on window\n    getWindow(reference).removeEventListener('resize', state.updateBound);\n\n    // Remove scroll event listener on scroll parents\n    state.scrollParents.forEach(function (target) {\n      target.removeEventListener('scroll', state.updateBound);\n    });\n\n    // Reset state\n    state.updateBound = null;\n    state.scrollParents = [];\n    state.scrollElement = null;\n    state.eventsEnabled = false;\n    return state;\n  }\n\n  /**\n   * It will remove resize/scroll events and won't recalculate popper position\n   * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n   * unless you call `update` method manually.\n   * @method\n   * @memberof Popper\n   */\n  function disableEventListeners() {\n    if (this.state.eventsEnabled) {\n      cancelAnimationFrame(this.scheduleUpdate);\n      this.state = removeEventListeners(this.reference, this.state);\n    }\n  }\n\n  /**\n   * Tells if a given input is a number\n   * @method\n   * @memberof Popper.Utils\n   * @param {*} input to check\n   * @return {Boolean}\n   */\n  function isNumeric(n) {\n    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  /**\n   * Set the style to the given popper\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element - Element to apply the style to\n   * @argument {Object} styles\n   * Object with a list of properties and values which will be applied to the element\n   */\n  function setStyles(element, styles) {\n    Object.keys(styles).forEach(function (prop) {\n      var unit = '';\n      // add unit if the value is numeric and is one of the following\n      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n        unit = 'px';\n      }\n      element.style[prop] = styles[prop] + unit;\n    });\n  }\n\n  /**\n   * Set the attributes to the given popper\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element - Element to apply the attributes to\n   * @argument {Object} styles\n   * Object with a list of properties and values which will be applied to the element\n   */\n  function setAttributes(element, attributes) {\n    Object.keys(attributes).forEach(function (prop) {\n      var value = attributes[prop];\n      if (value !== false) {\n        element.setAttribute(prop, attributes[prop]);\n      } else {\n        element.removeAttribute(prop);\n      }\n    });\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} data.styles - List of style properties - values to apply to popper element\n   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The same data object\n   */\n  function applyStyle(data) {\n    // any property present in `data.styles` will be applied to the popper,\n    // in this way we can make the 3rd party modifiers add custom styles to it\n    // Be aware, modifiers could override the properties defined in the previous\n    // lines of this modifier!\n    setStyles(data.instance.popper, data.styles);\n\n    // any property present in `data.attributes` will be applied to the popper,\n    // they will be set as HTML attributes of the element\n    setAttributes(data.instance.popper, data.attributes);\n\n    // if arrowElement is defined and arrowStyles has some properties\n    if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n      setStyles(data.arrowElement, data.arrowStyles);\n    }\n\n    return data;\n  }\n\n  /**\n   * Set the x-placement attribute before everything else because it could be used\n   * to add margins to the popper margins needs to be calculated to get the\n   * correct popper offsets.\n   * @method\n   * @memberof Popper.modifiers\n   * @param {HTMLElement} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as popper\n   * @param {Object} options - Popper.js options\n   */\n  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n    // compute reference element offsets\n    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n    // compute auto placement, store placement inside the data object,\n    // modifiers will be able to edit `placement` if needed\n    // and refer to originalPlacement to know the original value\n    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n\n    popper.setAttribute('x-placement', placement);\n\n    // Apply `position` to popper before anything else because\n    // without the position applied we can't guarantee correct computations\n    setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });\n\n    return options;\n  }\n\n  /**\n   * @function\n   * @memberof Popper.Utils\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n   * @returns {Object} The popper's position offsets rounded\n   *\n   * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n   * good as it can be within reason.\n   * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n   *\n   * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n   * as well on High DPI screens).\n   *\n   * Firefox prefers no rounding for positioning and does not have blurriness on\n   * high DPI screens.\n   *\n   * Only horizontal placement and left/right values need to be considered.\n   */\n  function getRoundedOffsets(data, shouldRound) {\n    var _data$offsets = data.offsets,\n        popper = _data$offsets.popper,\n        reference = _data$offsets.reference;\n    var round = Math.round,\n        floor = Math.floor;\n\n    var noRound = function noRound(v) {\n      return v;\n    };\n\n    var referenceWidth = round(reference.width);\n    var popperWidth = round(popper.width);\n\n    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n    var isVariation = data.placement.indexOf('-') !== -1;\n    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n\n    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;\n    var verticalToInteger = !shouldRound ? noRound : round;\n\n    return {\n      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),\n      top: verticalToInteger(popper.top),\n      bottom: verticalToInteger(popper.bottom),\n      right: horizontalToInteger(popper.right)\n    };\n  }\n\n  var isFirefox = isBrowser$1 && /Firefox/i.test(navigator.userAgent);\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function computeStyle(data, options) {\n    var x = options.x,\n        y = options.y;\n    var popper = data.offsets.popper;\n\n    // Remove this legacy support in Popper.js v2\n\n    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n      return modifier.name === 'applyStyle';\n    }).gpuAcceleration;\n    if (legacyGpuAccelerationOption !== undefined) {\n      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n    }\n    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n    var offsetParent = getOffsetParent(data.instance.popper);\n    var offsetParentRect = getBoundingClientRect(offsetParent);\n\n    // Styles\n    var styles = {\n      position: popper.position\n    };\n\n    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);\n\n    var sideA = x === 'bottom' ? 'top' : 'bottom';\n    var sideB = y === 'right' ? 'left' : 'right';\n\n    // if gpuAcceleration is set to `true` and transform is supported,\n    //  we use `translate3d` to apply the position to the popper we\n    // automatically use the supported prefixed version if needed\n    var prefixedProperty = getSupportedPropertyName('transform');\n\n    // now, let's make a step back and look at this code closely (wtf?)\n    // If the content of the popper grows once it's been positioned, it\n    // may happen that the popper gets misplaced because of the new content\n    // overflowing its reference element\n    // To avoid this problem, we provide two options (x and y), which allow\n    // the consumer to define the offset origin.\n    // If we position a popper on top of a reference element, we can set\n    // `x` to `top` to make the popper grow towards its top instead of\n    // its bottom.\n    var left = void 0,\n        top = void 0;\n    if (sideA === 'bottom') {\n      // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n      // and not the bottom of the html element\n      if (offsetParent.nodeName === 'HTML') {\n        top = -offsetParent.clientHeight + offsets.bottom;\n      } else {\n        top = -offsetParentRect.height + offsets.bottom;\n      }\n    } else {\n      top = offsets.top;\n    }\n    if (sideB === 'right') {\n      if (offsetParent.nodeName === 'HTML') {\n        left = -offsetParent.clientWidth + offsets.right;\n      } else {\n        left = -offsetParentRect.width + offsets.right;\n      }\n    } else {\n      left = offsets.left;\n    }\n    if (gpuAcceleration && prefixedProperty) {\n      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n      styles[sideA] = 0;\n      styles[sideB] = 0;\n      styles.willChange = 'transform';\n    } else {\n      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n      var invertTop = sideA === 'bottom' ? -1 : 1;\n      var invertLeft = sideB === 'right' ? -1 : 1;\n      styles[sideA] = top * invertTop;\n      styles[sideB] = left * invertLeft;\n      styles.willChange = sideA + ', ' + sideB;\n    }\n\n    // Attributes\n    var attributes = {\n      'x-placement': data.placement\n    };\n\n    // Update `data` attributes, styles and arrowStyles\n    data.attributes = _extends({}, attributes, data.attributes);\n    data.styles = _extends({}, styles, data.styles);\n    data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n\n    return data;\n  }\n\n  /**\n   * Helper used to know if the given modifier depends from another one.<br />\n   * It checks if the needed modifier is listed and enabled.\n   * @method\n   * @memberof Popper.Utils\n   * @param {Array} modifiers - list of modifiers\n   * @param {String} requestingName - name of requesting modifier\n   * @param {String} requestedName - name of requested modifier\n   * @returns {Boolean}\n   */\n  function isModifierRequired(modifiers, requestingName, requestedName) {\n    var requesting = find(modifiers, function (_ref) {\n      var name = _ref.name;\n      return name === requestingName;\n    });\n\n    var isRequired = !!requesting && modifiers.some(function (modifier) {\n      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n    });\n\n    if (!isRequired) {\n      var _requesting = '`' + requestingName + '`';\n      var requested = '`' + requestedName + '`';\n      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n    }\n    return isRequired;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function arrow(data, options) {\n    var _data$offsets$arrow;\n\n    // arrow depends on keepTogether in order to work\n    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n      return data;\n    }\n\n    var arrowElement = options.element;\n\n    // if arrowElement is a string, suppose it's a CSS selector\n    if (typeof arrowElement === 'string') {\n      arrowElement = data.instance.popper.querySelector(arrowElement);\n\n      // if arrowElement is not found, don't run the modifier\n      if (!arrowElement) {\n        return data;\n      }\n    } else {\n      // if the arrowElement isn't a query selector we must check that the\n      // provided DOM node is child of its popper node\n      if (!data.instance.popper.contains(arrowElement)) {\n        console.warn('WARNING: `arrow.element` must be child of its popper element!');\n        return data;\n      }\n    }\n\n    var placement = data.placement.split('-')[0];\n    var _data$offsets = data.offsets,\n        popper = _data$offsets.popper,\n        reference = _data$offsets.reference;\n\n    var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n    var len = isVertical ? 'height' : 'width';\n    var sideCapitalized = isVertical ? 'Top' : 'Left';\n    var side = sideCapitalized.toLowerCase();\n    var altSide = isVertical ? 'left' : 'top';\n    var opSide = isVertical ? 'bottom' : 'right';\n    var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n    //\n    // extends keepTogether behavior making sure the popper and its\n    // reference have enough pixels in conjunction\n    //\n\n    // top/left side\n    if (reference[opSide] - arrowElementSize < popper[side]) {\n      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n    }\n    // bottom/right side\n    if (reference[side] + arrowElementSize > popper[opSide]) {\n      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n    }\n    data.offsets.popper = getClientRect(data.offsets.popper);\n\n    // compute center of the popper\n    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n    // Compute the sideValue using the updated popper offsets\n    // take popper margin in account because we don't have this info available\n    var css = getStyleComputedProperty(data.instance.popper);\n    var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);\n    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);\n    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n    // prevent arrowElement from being placed not contiguously to its popper\n    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n    data.arrowElement = arrowElement;\n    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty$1(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty$1(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n\n    return data;\n  }\n\n  /**\n   * Get the opposite placement variation of the given one\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement variation\n   * @returns {String} flipped placement variation\n   */\n  function getOppositeVariation(variation) {\n    if (variation === 'end') {\n      return 'start';\n    } else if (variation === 'start') {\n      return 'end';\n    }\n    return variation;\n  }\n\n  /**\n   * List of accepted placements to use as values of the `placement` option.<br />\n   * Valid placements are:\n   * - `auto`\n   * - `top`\n   * - `right`\n   * - `bottom`\n   * - `left`\n   *\n   * Each placement can have a variation from this list:\n   * - `-start`\n   * - `-end`\n   *\n   * Variations are interpreted easily if you think of them as the left to right\n   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n   * is right.<br />\n   * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n   *\n   * Some valid examples are:\n   * - `top-end` (on top of reference, right aligned)\n   * - `right-start` (on right of reference, top aligned)\n   * - `bottom` (on bottom, centered)\n   * - `auto-end` (on the side with more space available, alignment depends by placement)\n   *\n   * @static\n   * @type {Array}\n   * @enum {String}\n   * @readonly\n   * @method placements\n   * @memberof Popper\n   */\n  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n  // Get rid of `auto` `auto-start` and `auto-end`\n  var validPlacements = placements.slice(3);\n\n  /**\n   * Given an initial placement, returns all the subsequent placements\n   * clockwise (or counter-clockwise).\n   *\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement - A valid placement (it accepts variations)\n   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n   * @returns {Array} placements including their variations\n   */\n  function clockwise(placement) {\n    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    var index = validPlacements.indexOf(placement);\n    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n    return counter ? arr.reverse() : arr;\n  }\n\n  var BEHAVIORS = {\n    FLIP: 'flip',\n    CLOCKWISE: 'clockwise',\n    COUNTERCLOCKWISE: 'counterclockwise'\n  };\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function flip(data, options) {\n    // if `inner` modifier is enabled, we can't use the `flip` modifier\n    if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n      return data;\n    }\n\n    if (data.flipped && data.placement === data.originalPlacement) {\n      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n      return data;\n    }\n\n    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n\n    var placement = data.placement.split('-')[0];\n    var placementOpposite = getOppositePlacement(placement);\n    var variation = data.placement.split('-')[1] || '';\n\n    var flipOrder = [];\n\n    switch (options.behavior) {\n      case BEHAVIORS.FLIP:\n        flipOrder = [placement, placementOpposite];\n        break;\n      case BEHAVIORS.CLOCKWISE:\n        flipOrder = clockwise(placement);\n        break;\n      case BEHAVIORS.COUNTERCLOCKWISE:\n        flipOrder = clockwise(placement, true);\n        break;\n      default:\n        flipOrder = options.behavior;\n    }\n\n    flipOrder.forEach(function (step, index) {\n      if (placement !== step || flipOrder.length === index + 1) {\n        return data;\n      }\n\n      placement = data.placement.split('-')[0];\n      placementOpposite = getOppositePlacement(placement);\n\n      var popperOffsets = data.offsets.popper;\n      var refOffsets = data.offsets.reference;\n\n      // using floor because the reference offsets may contain decimals we are not going to consider here\n      var floor = Math.floor;\n      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n      // flip the variation if required\n      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n\n      // flips variation if reference element overflows boundaries\n      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n      // flips variation if popper content overflows boundaries\n      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);\n\n      var flippedVariation = flippedVariationByRef || flippedVariationByContent;\n\n      if (overlapsRef || overflowsBoundaries || flippedVariation) {\n        // this boolean to detect any flip loop\n        data.flipped = true;\n\n        if (overlapsRef || overflowsBoundaries) {\n          placement = flipOrder[index + 1];\n        }\n\n        if (flippedVariation) {\n          variation = getOppositeVariation(variation);\n        }\n\n        data.placement = placement + (variation ? '-' + variation : '');\n\n        // this object contains `position`, we want to preserve it along with\n        // any additional property we may add in the future\n        data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n        data = runModifiers(data.instance.modifiers, data, 'flip');\n      }\n    });\n    return data;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function keepTogether(data) {\n    var _data$offsets = data.offsets,\n        popper = _data$offsets.popper,\n        reference = _data$offsets.reference;\n\n    var placement = data.placement.split('-')[0];\n    var floor = Math.floor;\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    var side = isVertical ? 'right' : 'bottom';\n    var opSide = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    if (popper[side] < floor(reference[opSide])) {\n      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n    }\n    if (popper[opSide] > floor(reference[side])) {\n      data.offsets.popper[opSide] = floor(reference[side]);\n    }\n\n    return data;\n  }\n\n  /**\n   * Converts a string containing value + unit into a px value number\n   * @function\n   * @memberof {modifiers~offset}\n   * @private\n   * @argument {String} str - Value + unit string\n   * @argument {String} measurement - `height` or `width`\n   * @argument {Object} popperOffsets\n   * @argument {Object} referenceOffsets\n   * @returns {Number|String}\n   * Value in pixels, or original string if no values were extracted\n   */\n  function toValue(str, measurement, popperOffsets, referenceOffsets) {\n    // separate value from unit\n    var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n    var value = +split[1];\n    var unit = split[2];\n\n    // If it's not a number it's an operator, I guess\n    if (!value) {\n      return str;\n    }\n\n    if (unit.indexOf('%') === 0) {\n      var element = void 0;\n      switch (unit) {\n        case '%p':\n          element = popperOffsets;\n          break;\n        case '%':\n        case '%r':\n        default:\n          element = referenceOffsets;\n      }\n\n      var rect = getClientRect(element);\n      return rect[measurement] / 100 * value;\n    } else if (unit === 'vh' || unit === 'vw') {\n      // if is a vh or vw, we calculate the size based on the viewport\n      var size = void 0;\n      if (unit === 'vh') {\n        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n      } else {\n        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n      }\n      return size / 100 * value;\n    } else {\n      // if is an explicit pixel unit, we get rid of the unit and keep the value\n      // if is an implicit unit, it's px, and we return just the value\n      return value;\n    }\n  }\n\n  /**\n   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n   * @function\n   * @memberof {modifiers~offset}\n   * @private\n   * @argument {String} offset\n   * @argument {Object} popperOffsets\n   * @argument {Object} referenceOffsets\n   * @argument {String} basePlacement\n   * @returns {Array} a two cells array with x and y offsets in numbers\n   */\n  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n    var offsets = [0, 0];\n\n    // Use height if placement is left or right and index is 0 otherwise use width\n    // in this way the first offset will use an axis and the second one\n    // will use the other one\n    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n    // Split the offset string to obtain a list of values and operands\n    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n    var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n      return frag.trim();\n    });\n\n    // Detect if the offset string contains a pair of values or a single one\n    // they could be separated by comma or space\n    var divider = fragments.indexOf(find(fragments, function (frag) {\n      return frag.search(/,|\\s/) !== -1;\n    }));\n\n    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n    }\n\n    // If divider is found, we divide the list of values and operands to divide\n    // them by ofset X and Y.\n    var splitRegex = /\\s*,\\s*|\\s+/;\n    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n    // Convert the values with units to absolute pixels to allow our computations\n    ops = ops.map(function (op, index) {\n      // Most of the units rely on the orientation of the popper\n      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n      var mergeWithPrevious = false;\n      return op\n      // This aggregates any `+` or `-` sign that aren't considered operators\n      // e.g.: 10 + +5 => [10, +, +5]\n      .reduce(function (a, b) {\n        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n          a[a.length - 1] = b;\n          mergeWithPrevious = true;\n          return a;\n        } else if (mergeWithPrevious) {\n          a[a.length - 1] += b;\n          mergeWithPrevious = false;\n          return a;\n        } else {\n          return a.concat(b);\n        }\n      }, [])\n      // Here we convert the string values into number values (in px)\n      .map(function (str) {\n        return toValue(str, measurement, popperOffsets, referenceOffsets);\n      });\n    });\n\n    // Loop trough the offsets arrays and execute the operations\n    ops.forEach(function (op, index) {\n      op.forEach(function (frag, index2) {\n        if (isNumeric(frag)) {\n          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n        }\n      });\n    });\n    return offsets;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @argument {Number|String} options.offset=0\n   * The offset value as described in the modifier description\n   * @returns {Object} The data object, properly modified\n   */\n  function offset$1(data, _ref) {\n    var offset = _ref.offset;\n    var placement = data.placement,\n        _data$offsets = data.offsets,\n        popper = _data$offsets.popper,\n        reference = _data$offsets.reference;\n\n    var basePlacement = placement.split('-')[0];\n\n    var offsets = void 0;\n    if (isNumeric(+offset)) {\n      offsets = [+offset, 0];\n    } else {\n      offsets = parseOffset(offset, popper, reference, basePlacement);\n    }\n\n    if (basePlacement === 'left') {\n      popper.top += offsets[0];\n      popper.left -= offsets[1];\n    } else if (basePlacement === 'right') {\n      popper.top += offsets[0];\n      popper.left += offsets[1];\n    } else if (basePlacement === 'top') {\n      popper.left += offsets[0];\n      popper.top -= offsets[1];\n    } else if (basePlacement === 'bottom') {\n      popper.left += offsets[0];\n      popper.top += offsets[1];\n    }\n\n    data.popper = popper;\n    return data;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function preventOverflow(data, options) {\n    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n    // If offsetParent is the reference element, we really want to\n    // go one step up and use the next offsetParent as reference to\n    // avoid to make this modifier completely useless and look like broken\n    if (data.instance.reference === boundariesElement) {\n      boundariesElement = getOffsetParent(boundariesElement);\n    }\n\n    // NOTE: DOM access here\n    // resets the popper's position so that the document size can be calculated excluding\n    // the size of the popper element itself\n    var transformProp = getSupportedPropertyName('transform');\n    var popperStyles = data.instance.popper.style; // assignment to help minification\n    var top = popperStyles.top,\n        left = popperStyles.left,\n        transform = popperStyles[transformProp];\n\n    popperStyles.top = '';\n    popperStyles.left = '';\n    popperStyles[transformProp] = '';\n\n    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n    // NOTE: DOM access here\n    // restores the original style properties after the offsets have been computed\n    popperStyles.top = top;\n    popperStyles.left = left;\n    popperStyles[transformProp] = transform;\n\n    options.boundaries = boundaries;\n\n    var order = options.priority;\n    var popper = data.offsets.popper;\n\n    var check = {\n      primary: function primary(placement) {\n        var value = popper[placement];\n        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n          value = Math.max(popper[placement], boundaries[placement]);\n        }\n        return defineProperty$1({}, placement, value);\n      },\n      secondary: function secondary(placement) {\n        var mainSide = placement === 'right' ? 'left' : 'top';\n        var value = popper[mainSide];\n        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n        }\n        return defineProperty$1({}, mainSide, value);\n      }\n    };\n\n    order.forEach(function (placement) {\n      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n      popper = _extends({}, popper, check[side](placement));\n    });\n\n    data.offsets.popper = popper;\n\n    return data;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function shift(data) {\n    var placement = data.placement;\n    var basePlacement = placement.split('-')[0];\n    var shiftvariation = placement.split('-')[1];\n\n    // if shift shiftvariation is specified, run the modifier\n    if (shiftvariation) {\n      var _data$offsets = data.offsets,\n          reference = _data$offsets.reference,\n          popper = _data$offsets.popper;\n\n      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n      var side = isVertical ? 'left' : 'top';\n      var measurement = isVertical ? 'width' : 'height';\n\n      var shiftOffsets = {\n        start: defineProperty$1({}, side, reference[side]),\n        end: defineProperty$1({}, side, reference[side] + reference[measurement] - popper[measurement])\n      };\n\n      data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n    }\n\n    return data;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function hide(data) {\n    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n      return data;\n    }\n\n    var refRect = data.offsets.reference;\n    var bound = find(data.instance.modifiers, function (modifier) {\n      return modifier.name === 'preventOverflow';\n    }).boundaries;\n\n    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n      // Avoid unnecessary DOM access if visibility hasn't changed\n      if (data.hide === true) {\n        return data;\n      }\n\n      data.hide = true;\n      data.attributes['x-out-of-boundaries'] = '';\n    } else {\n      // Avoid unnecessary DOM access if visibility hasn't changed\n      if (data.hide === false) {\n        return data;\n      }\n\n      data.hide = false;\n      data.attributes['x-out-of-boundaries'] = false;\n    }\n\n    return data;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function inner(data) {\n    var placement = data.placement;\n    var basePlacement = placement.split('-')[0];\n    var _data$offsets = data.offsets,\n        popper = _data$offsets.popper,\n        reference = _data$offsets.reference;\n\n    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n    data.placement = getOppositePlacement(placement);\n    data.offsets.popper = getClientRect(popper);\n\n    return data;\n  }\n\n  /**\n   * Modifier function, each modifier can have a function of this type assigned\n   * to its `fn` property.<br />\n   * These functions will be called on each update, this means that you must\n   * make sure they are performant enough to avoid performance bottlenecks.\n   *\n   * @function ModifierFn\n   * @argument {dataObject} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {dataObject} The data object, properly modified\n   */\n\n  /**\n   * Modifiers are plugins used to alter the behavior of your poppers.<br />\n   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n   * needed by the library.\n   *\n   * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n   * All the other properties are configurations that could be tweaked.\n   * @namespace modifiers\n   */\n  var modifiers = {\n    /**\n     * Modifier used to shift the popper on the start or end of its reference\n     * element.<br />\n     * It will read the variation of the `placement` property.<br />\n     * It can be one either `-end` or `-start`.\n     * @memberof modifiers\n     * @inner\n     */\n    shift: {\n      /** @prop {number} order=100 - Index used to define the order of execution */\n      order: 100,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: shift\n    },\n\n    /**\n     * The `offset` modifier can shift your popper on both its axis.\n     *\n     * It accepts the following units:\n     * - `px` or unit-less, interpreted as pixels\n     * - `%` or `%r`, percentage relative to the length of the reference element\n     * - `%p`, percentage relative to the length of the popper element\n     * - `vw`, CSS viewport width unit\n     * - `vh`, CSS viewport height unit\n     *\n     * For length is intended the main axis relative to the placement of the popper.<br />\n     * This means that if the placement is `top` or `bottom`, the length will be the\n     * `width`. In case of `left` or `right`, it will be the `height`.\n     *\n     * You can provide a single value (as `Number` or `String`), or a pair of values\n     * as `String` divided by a comma or one (or more) white spaces.<br />\n     * The latter is a deprecated method because it leads to confusion and will be\n     * removed in v2.<br />\n     * Additionally, it accepts additions and subtractions between different units.\n     * Note that multiplications and divisions aren't supported.\n     *\n     * Valid examples are:\n     * ```\n     * 10\n     * '10%'\n     * '10, 10'\n     * '10%, 10'\n     * '10 + 10%'\n     * '10 - 5vh + 3%'\n     * '-10px + 5vh, 5px - 6%'\n     * ```\n     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n     *\n     * @memberof modifiers\n     * @inner\n     */\n    offset: {\n      /** @prop {number} order=200 - Index used to define the order of execution */\n      order: 200,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: offset$1,\n      /** @prop {Number|String} offset=0\n       * The offset value as described in the modifier description\n       */\n      offset: 0\n    },\n\n    /**\n     * Modifier used to prevent the popper from being positioned outside the boundary.\n     *\n     * A scenario exists where the reference itself is not within the boundaries.<br />\n     * We can say it has \"escaped the boundaries\"  or just \"escaped\".<br />\n     * In this case we need to decide whether the popper should either:\n     *\n     * - detach from the reference and remain \"trapped\" in the boundaries, or\n     * - if it should ignore the boundary and \"escape with its reference\"\n     *\n     * When `escapeWithReference` is set to`true` and reference is completely\n     * outside its boundaries, the popper will overflow (or completely leave)\n     * the boundaries in order to remain attached to the edge of the reference.\n     *\n     * @memberof modifiers\n     * @inner\n     */\n    preventOverflow: {\n      /** @prop {number} order=300 - Index used to define the order of execution */\n      order: 300,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: preventOverflow,\n      /**\n       * @prop {Array} [priority=['left','right','top','bottom']]\n       * Popper will try to prevent overflow following these priorities by default,\n       * then, it could overflow on the left and on top of the `boundariesElement`\n       */\n      priority: ['left', 'right', 'top', 'bottom'],\n      /**\n       * @prop {number} padding=5\n       * Amount of pixel used to define a minimum distance between the boundaries\n       * and the popper. This makes sure the popper always has a little padding\n       * between the edges of its container\n       */\n      padding: 5,\n      /**\n       * @prop {String|HTMLElement} boundariesElement='scrollParent'\n       * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n       * `viewport` or any DOM element.\n       */\n      boundariesElement: 'scrollParent'\n    },\n\n    /**\n     * Modifier used to make sure the reference and its popper stay near each other\n     * without leaving any gap between the two. Especially useful when the arrow is\n     * enabled and you want to ensure that it points to its reference element.\n     * It cares only about the first axis. You can still have poppers with margin\n     * between the popper and its reference element.\n     * @memberof modifiers\n     * @inner\n     */\n    keepTogether: {\n      /** @prop {number} order=400 - Index used to define the order of execution */\n      order: 400,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: keepTogether\n    },\n\n    /**\n     * This modifier is used to move the `arrowElement` of the popper to make\n     * sure it is positioned between the reference element and its popper element.\n     * It will read the outer size of the `arrowElement` node to detect how many\n     * pixels of conjunction are needed.\n     *\n     * It has no effect if no `arrowElement` is provided.\n     * @memberof modifiers\n     * @inner\n     */\n    arrow: {\n      /** @prop {number} order=500 - Index used to define the order of execution */\n      order: 500,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: arrow,\n      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n      element: '[x-arrow]'\n    },\n\n    /**\n     * Modifier used to flip the popper's placement when it starts to overlap its\n     * reference element.\n     *\n     * Requires the `preventOverflow` modifier before it in order to work.\n     *\n     * **NOTE:** this modifier will interrupt the current update cycle and will\n     * restart it if it detects the need to flip the placement.\n     * @memberof modifiers\n     * @inner\n     */\n    flip: {\n      /** @prop {number} order=600 - Index used to define the order of execution */\n      order: 600,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: flip,\n      /**\n       * @prop {String|Array} behavior='flip'\n       * The behavior used to change the popper's placement. It can be one of\n       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n       * placements (with optional variations)\n       */\n      behavior: 'flip',\n      /**\n       * @prop {number} padding=5\n       * The popper will flip if it hits the edges of the `boundariesElement`\n       */\n      padding: 5,\n      /**\n       * @prop {String|HTMLElement} boundariesElement='viewport'\n       * The element which will define the boundaries of the popper position.\n       * The popper will never be placed outside of the defined boundaries\n       * (except if `keepTogether` is enabled)\n       */\n      boundariesElement: 'viewport',\n      /**\n       * @prop {Boolean} flipVariations=false\n       * The popper will switch placement variation between `-start` and `-end` when\n       * the reference element overlaps its boundaries.\n       *\n       * The original placement should have a set variation.\n       */\n      flipVariations: false,\n      /**\n       * @prop {Boolean} flipVariationsByContent=false\n       * The popper will switch placement variation between `-start` and `-end` when\n       * the popper element overlaps its reference boundaries.\n       *\n       * The original placement should have a set variation.\n       */\n      flipVariationsByContent: false\n    },\n\n    /**\n     * Modifier used to make the popper flow toward the inner of the reference element.\n     * By default, when this modifier is disabled, the popper will be placed outside\n     * the reference element.\n     * @memberof modifiers\n     * @inner\n     */\n    inner: {\n      /** @prop {number} order=700 - Index used to define the order of execution */\n      order: 700,\n      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n      enabled: false,\n      /** @prop {ModifierFn} */\n      fn: inner\n    },\n\n    /**\n     * Modifier used to hide the popper when its reference element is outside of the\n     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n     * be used to hide with a CSS selector the popper when its reference is\n     * out of boundaries.\n     *\n     * Requires the `preventOverflow` modifier before it in order to work.\n     * @memberof modifiers\n     * @inner\n     */\n    hide: {\n      /** @prop {number} order=800 - Index used to define the order of execution */\n      order: 800,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: hide\n    },\n\n    /**\n     * Computes the style that will be applied to the popper element to gets\n     * properly positioned.\n     *\n     * Note that this modifier will not touch the DOM, it just prepares the styles\n     * so that `applyStyle` modifier can apply it. This separation is useful\n     * in case you need to replace `applyStyle` with a custom implementation.\n     *\n     * This modifier has `850` as `order` value to maintain backward compatibility\n     * with previous versions of Popper.js. Expect the modifiers ordering method\n     * to change in future major versions of the library.\n     *\n     * @memberof modifiers\n     * @inner\n     */\n    computeStyle: {\n      /** @prop {number} order=850 - Index used to define the order of execution */\n      order: 850,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: computeStyle,\n      /**\n       * @prop {Boolean} gpuAcceleration=true\n       * If true, it uses the CSS 3D transformation to position the popper.\n       * Otherwise, it will use the `top` and `left` properties\n       */\n      gpuAcceleration: true,\n      /**\n       * @prop {string} [x='bottom']\n       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n       * Change this if your popper should grow in a direction different from `bottom`\n       */\n      x: 'bottom',\n      /**\n       * @prop {string} [x='left']\n       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n       * Change this if your popper should grow in a direction different from `right`\n       */\n      y: 'right'\n    },\n\n    /**\n     * Applies the computed styles to the popper element.\n     *\n     * All the DOM manipulations are limited to this modifier. This is useful in case\n     * you want to integrate Popper.js inside a framework or view library and you\n     * want to delegate all the DOM manipulations to it.\n     *\n     * Note that if you disable this modifier, you must make sure the popper element\n     * has its position set to `absolute` before Popper.js can do its work!\n     *\n     * Just disable this modifier and define your own to achieve the desired effect.\n     *\n     * @memberof modifiers\n     * @inner\n     */\n    applyStyle: {\n      /** @prop {number} order=900 - Index used to define the order of execution */\n      order: 900,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: applyStyle,\n      /** @prop {Function} */\n      onLoad: applyStyleOnLoad,\n      /**\n       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n       * @prop {Boolean} gpuAcceleration=true\n       * If true, it uses the CSS 3D transformation to position the popper.\n       * Otherwise, it will use the `top` and `left` properties\n       */\n      gpuAcceleration: undefined\n    }\n  };\n\n  /**\n   * The `dataObject` is an object containing all the information used by Popper.js.\n   * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n   * @name dataObject\n   * @property {Object} data.instance The Popper.js instance\n   * @property {String} data.placement Placement applied to popper\n   * @property {String} data.originalPlacement Placement originally defined on init\n   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n   * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n   * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n   * @property {Object} data.boundaries Offsets of the popper boundaries\n   * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n   */\n\n  /**\n   * Default options provided to Popper.js constructor.<br />\n   * These can be overridden using the `options` argument of Popper.js.<br />\n   * To override an option, simply pass an object with the same\n   * structure of the `options` object, as the 3rd argument. For example:\n   * ```\n   * new Popper(ref, pop, {\n   *   modifiers: {\n   *     preventOverflow: { enabled: false }\n   *   }\n   * })\n   * ```\n   * @type {Object}\n   * @static\n   * @memberof Popper\n   */\n  var Defaults = {\n    /**\n     * Popper's placement.\n     * @prop {Popper.placements} placement='bottom'\n     */\n    placement: 'bottom',\n\n    /**\n     * Set this to true if you want popper to position it self in 'fixed' mode\n     * @prop {Boolean} positionFixed=false\n     */\n    positionFixed: false,\n\n    /**\n     * Whether events (resize, scroll) are initially enabled.\n     * @prop {Boolean} eventsEnabled=true\n     */\n    eventsEnabled: true,\n\n    /**\n     * Set to true if you want to automatically remove the popper when\n     * you call the `destroy` method.\n     * @prop {Boolean} removeOnDestroy=false\n     */\n    removeOnDestroy: false,\n\n    /**\n     * Callback called when the popper is created.<br />\n     * By default, it is set to no-op.<br />\n     * Access Popper.js instance with `data.instance`.\n     * @prop {onCreate}\n     */\n    onCreate: function onCreate() {},\n\n    /**\n     * Callback called when the popper is updated. This callback is not called\n     * on the initialization/creation of the popper, but only on subsequent\n     * updates.<br />\n     * By default, it is set to no-op.<br />\n     * Access Popper.js instance with `data.instance`.\n     * @prop {onUpdate}\n     */\n    onUpdate: function onUpdate() {},\n\n    /**\n     * List of modifiers used to modify the offsets before they are applied to the popper.\n     * They provide most of the functionalities of Popper.js.\n     * @prop {modifiers}\n     */\n    modifiers: modifiers\n  };\n\n  /**\n   * @callback onCreate\n   * @param {dataObject} data\n   */\n\n  /**\n   * @callback onUpdate\n   * @param {dataObject} data\n   */\n\n  // Utils\n  // Methods\n  var Popper = function () {\n    /**\n     * Creates a new Popper.js instance.\n     * @class Popper\n     * @param {Element|referenceObject} reference - The reference element used to position the popper\n     * @param {Element} popper - The HTML / XML element used as the popper\n     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n     * @return {Object} instance - The generated Popper.js instance\n     */\n    function Popper(reference, popper) {\n      var _this = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      classCallCheck(this, Popper);\n\n      this.scheduleUpdate = function () {\n        return requestAnimationFrame(_this.update);\n      };\n\n      // make update() debounced, so that it only runs at most once-per-tick\n      this.update = debounce(this.update.bind(this));\n\n      // with {} we create a new object with the options inside it\n      this.options = _extends({}, Popper.Defaults, options);\n\n      // init state\n      this.state = {\n        isDestroyed: false,\n        isCreated: false,\n        scrollParents: []\n      };\n\n      // get reference and popper elements (allow jQuery wrappers)\n      this.reference = reference && reference.jquery ? reference[0] : reference;\n      this.popper = popper && popper.jquery ? popper[0] : popper;\n\n      // Deep merge modifiers options\n      this.options.modifiers = {};\n      Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n        _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n      });\n\n      // Refactoring modifiers' list (Object => Array)\n      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n        return _extends({\n          name: name\n        }, _this.options.modifiers[name]);\n      })\n      // sort the modifiers by order\n      .sort(function (a, b) {\n        return a.order - b.order;\n      });\n\n      // modifiers have the ability to execute arbitrary code when Popper.js get inited\n      // such code is executed in the same order of its modifier\n      // they could add new properties to their options configuration\n      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n      this.modifiers.forEach(function (modifierOptions) {\n        if (modifierOptions.enabled && isFunction$1(modifierOptions.onLoad)) {\n          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n        }\n      });\n\n      // fire the first update to position the popper in the right place\n      this.update();\n\n      var eventsEnabled = this.options.eventsEnabled;\n      if (eventsEnabled) {\n        // setup event listeners, they will take care of update the position in specific situations\n        this.enableEventListeners();\n      }\n\n      this.state.eventsEnabled = eventsEnabled;\n    }\n\n    // We can't use class properties because they don't get listed in the\n    // class prototype and break stuff like Sinon stubs\n\n\n    createClass(Popper, [{\n      key: 'update',\n      value: function update$$1() {\n        return update.call(this);\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy$$1() {\n        return destroy$1.call(this);\n      }\n    }, {\n      key: 'enableEventListeners',\n      value: function enableEventListeners$$1() {\n        return enableEventListeners.call(this);\n      }\n    }, {\n      key: 'disableEventListeners',\n      value: function disableEventListeners$$1() {\n        return disableEventListeners.call(this);\n      }\n\n      /**\n       * Schedules an update. It will run on the next UI update available.\n       * @method scheduleUpdate\n       * @memberof Popper\n       */\n\n\n      /**\n       * Collection of utilities useful when writing custom modifiers.\n       * Starting from version 1.7, this method is available only if you\n       * include `popper-utils.js` before `popper.js`.\n       *\n       * **DEPRECATION**: This way to access PopperUtils is deprecated\n       * and will be removed in v2! Use the PopperUtils module directly instead.\n       * Due to the high instability of the methods contained in Utils, we can't\n       * guarantee them to follow semver. Use them at your own risk!\n       * @static\n       * @private\n       * @type {Object}\n       * @deprecated since version 1.8\n       * @member Utils\n       * @memberof Popper\n       */\n\n    }]);\n    return Popper;\n  }();\n\n  /**\n   * The `referenceObject` is an object that provides an interface compatible with Popper.js\n   * and lets you use it as replacement of a real DOM node.<br />\n   * You can use this method to position a popper relatively to a set of coordinates\n   * in case you don't have a DOM node to use as reference.\n   *\n   * ```\n   * new Popper(referenceObject, popperNode);\n   * ```\n   *\n   * NB: This feature isn't supported in Internet Explorer 10.\n   * @name referenceObject\n   * @property {Function} data.getBoundingClientRect\n   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n   * @property {number} data.clientWidth\n   * An ES6 getter that will return the width of the virtual reference element.\n   * @property {number} data.clientHeight\n   * An ES6 getter that will return the height of the virtual reference element.\n   */\n\n\n  Popper.Utils = (typeof window !== 'undefined' ? window : __webpack_require__.g).PopperUtils;\n  Popper.placements = placements;\n  Popper.Defaults = Defaults;\n\n  var BvEvent =\n  /*#__PURE__*/\n  function () {\n    function BvEvent(type) {\n      var eventInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, BvEvent);\n\n      // Start by emulating native Event constructor\n      if (!type) {\n        /* istanbul ignore next */\n        throw new TypeError(\"Failed to construct '\".concat(this.constructor.name, \"'. 1 argument required, \").concat(arguments.length, \" given.\"));\n      } // Merge defaults first, the eventInit, and the type last\n      // so it can't be overwritten\n\n\n      assign(this, BvEvent.Defaults, this.constructor.Defaults, eventInit, {\n        type: type\n      }); // Freeze some props as readonly, but leave them enumerable\n\n      defineProperties(this, {\n        type: readonlyDescriptor(),\n        cancelable: readonlyDescriptor(),\n        nativeEvent: readonlyDescriptor(),\n        target: readonlyDescriptor(),\n        relatedTarget: readonlyDescriptor(),\n        vueTarget: readonlyDescriptor(),\n        componentId: readonlyDescriptor()\n      }); // Create a private variable using closure scoping\n\n      var defaultPrevented = false; // Recreate preventDefault method. One way setter\n\n      this.preventDefault = function preventDefault() {\n        if (this.cancelable) {\n          defaultPrevented = true;\n        }\n      }; // Create `defaultPrevented` publicly accessible prop that\n      // can only be altered by the preventDefault method\n\n\n      defineProperty(this, 'defaultPrevented', {\n        enumerable: true,\n        get: function get() {\n          return defaultPrevented;\n        }\n      });\n    }\n\n    _createClass(BvEvent, null, [{\n      key: \"Defaults\",\n      get: function get() {\n        return {\n          type: '',\n          cancelable: true,\n          nativeEvent: null,\n          target: null,\n          relatedTarget: null,\n          vueTarget: null,\n          componentId: null\n        };\n      }\n    }]);\n\n    return BvEvent;\n  }(); // Named Exports\n\n  var clickOutMixin = {\n    data: function data() {\n      return {\n        listenForClickOut: false\n      };\n    },\n    watch: {\n      listenForClickOut: function listenForClickOut(newValue, oldValue) {\n        if (newValue !== oldValue) {\n          eventOff(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, EVENT_OPTIONS_NO_CAPTURE);\n\n          if (newValue) {\n            eventOn(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, EVENT_OPTIONS_NO_CAPTURE);\n          }\n        }\n      }\n    },\n    beforeCreate: function beforeCreate() {\n      // Declare non-reactive properties\n      this.clickOutElement = null;\n      this.clickOutEventName = null;\n    },\n    mounted: function mounted() {\n      if (!this.clickOutElement) {\n        this.clickOutElement = document;\n      }\n\n      if (!this.clickOutEventName) {\n        this.clickOutEventName = 'click';\n      }\n\n      if (this.listenForClickOut) {\n        eventOn(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, EVENT_OPTIONS_NO_CAPTURE);\n      }\n    },\n    beforeDestroy: function beforeDestroy()\n    /* istanbul ignore next */\n    {\n      eventOff(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, EVENT_OPTIONS_NO_CAPTURE);\n    },\n    methods: {\n      isClickOut: function isClickOut(evt) {\n        return !contains(this.$el, evt.target);\n      },\n      _clickOutHandler: function _clickOutHandler(evt) {\n        if (this.clickOutHandler && this.isClickOut(evt)) {\n          this.clickOutHandler(evt);\n        }\n      }\n    }\n  };\n\n  var focusInMixin = {\n    data: function data() {\n      return {\n        listenForFocusIn: false\n      };\n    },\n    watch: {\n      listenForFocusIn: function listenForFocusIn(newValue, oldValue) {\n        if (newValue !== oldValue) {\n          eventOff(this.focusInElement, 'focusin', this._focusInHandler, EVENT_OPTIONS_NO_CAPTURE);\n\n          if (newValue) {\n            eventOn(this.focusInElement, 'focusin', this._focusInHandler, EVENT_OPTIONS_NO_CAPTURE);\n          }\n        }\n      }\n    },\n    beforeCreate: function beforeCreate() {\n      // Declare non-reactive properties\n      this.focusInElement = null;\n    },\n    mounted: function mounted() {\n      if (!this.focusInElement) {\n        this.focusInElement = document;\n      }\n\n      if (this.listenForFocusIn) {\n        eventOn(this.focusInElement, 'focusin', this._focusInHandler, EVENT_OPTIONS_NO_CAPTURE);\n      }\n    },\n    beforeDestroy: function beforeDestroy()\n    /* istanbul ignore next */\n    {\n      eventOff(this.focusInElement, 'focusin', this._focusInHandler, EVENT_OPTIONS_NO_CAPTURE);\n    },\n    methods: {\n      _focusInHandler: function _focusInHandler(evt) {\n        if (this.focusInHandler) {\n          this.focusInHandler(evt);\n        }\n      }\n    }\n  };\n\n  var filterVisibles = function filterVisibles(els) {\n    return (els || []).filter(isVisible);\n  }; // Root dropdown event names\n\n\n  var ROOT_DROPDOWN_PREFIX = 'bv::dropdown::';\n  var ROOT_DROPDOWN_SHOWN = \"\".concat(ROOT_DROPDOWN_PREFIX, \"shown\");\n  var ROOT_DROPDOWN_HIDDEN = \"\".concat(ROOT_DROPDOWN_PREFIX, \"hidden\"); // Dropdown item CSS selectors\n\n  var Selector = {\n    FORM_CHILD: '.dropdown form',\n    ITEM_SELECTOR: ['.dropdown-item', '.b-dropdown-form'].map(function (selector) {\n      return \"\".concat(selector, \":not(.disabled):not([disabled])\");\n    }).join(', ')\n  }; // Popper attachment positions\n\n  var AttachmentMap = {\n    // Dropup left align\n    TOP: 'top-start',\n    // Dropup right align\n    TOPEND: 'top-end',\n    // Dropdown left align\n    BOTTOM: 'bottom-start',\n    // Dropdown right align\n    BOTTOMEND: 'bottom-end',\n    // Dropright left align\n    RIGHT: 'right-start',\n    // Dropright right align\n    RIGHTEND: 'right-end',\n    // Dropleft left align\n    LEFT: 'left-start',\n    // Dropleft right align\n    LEFTEND: 'left-end'\n  }; // @vue/component\n\n  var dropdownMixin = {\n    mixins: [idMixin, clickOutMixin, focusInMixin],\n    provide: function provide() {\n      return {\n        bvDropdown: this\n      };\n    },\n    inject: {\n      bvNavbar: {\n        default: null\n      }\n    },\n    props: {\n      disabled: {\n        type: Boolean,\n        default: false\n      },\n      dropup: {\n        // place on top if possible\n        type: Boolean,\n        default: false\n      },\n      dropright: {\n        // place right if possible\n        type: Boolean,\n        default: false\n      },\n      dropleft: {\n        // place left if possible\n        type: Boolean,\n        default: false\n      },\n      right: {\n        // Right align menu (default is left align)\n        type: Boolean,\n        default: false\n      },\n      offset: {\n        // Number of pixels to offset menu, or a CSS unit value (i.e. 1px, 1rem, etc)\n        type: [Number, String],\n        default: 0\n      },\n      noFlip: {\n        // Disable auto-flipping of menu from bottom<=>top\n        type: Boolean,\n        default: false\n      },\n      popperOpts: {\n        // type: Object,\n        default: function _default() {}\n      },\n      boundary: {\n        // String: `scrollParent`, `window` or `viewport`\n        // HTMLElement: HTML Element reference\n        type: [String, HTMLElement],\n        default: 'scrollParent'\n      }\n    },\n    data: function data() {\n      return {\n        visible: false,\n        visibleChangePrevented: false\n      };\n    },\n    computed: {\n      inNavbar: function inNavbar() {\n        return !isNull(this.bvNavbar);\n      },\n      toggler: function toggler() {\n        var toggle = this.$refs.toggle;\n        return toggle ? toggle.$el || toggle : null;\n      },\n      directionClass: function directionClass() {\n        if (this.dropup) {\n          return 'dropup';\n        } else if (this.dropright) {\n          return 'dropright';\n        } else if (this.dropleft) {\n          return 'dropleft';\n        }\n\n        return '';\n      }\n    },\n    watch: {\n      visible: function visible(newValue, oldValue) {\n        if (this.visibleChangePrevented) {\n          this.visibleChangePrevented = false;\n          return;\n        }\n\n        if (newValue !== oldValue) {\n          var evtName = newValue ? 'show' : 'hide';\n          var bvEvt = new BvEvent(evtName, {\n            cancelable: true,\n            vueTarget: this,\n            target: this.$refs.menu,\n            relatedTarget: null,\n            componentId: this.safeId ? this.safeId() : this.id || null\n          });\n          this.emitEvent(bvEvt);\n\n          if (bvEvt.defaultPrevented) {\n            // Reset value and exit if canceled\n            this.visibleChangePrevented = true;\n            this.visible = oldValue; // Just in case a child element triggered `this.hide(true)`\n\n            this.$off('hidden', this.focusToggler);\n            return;\n          }\n\n          if (evtName === 'show') {\n            this.showMenu();\n          } else {\n            this.hideMenu();\n          }\n        }\n      },\n      disabled: function disabled(newValue, oldValue) {\n        if (newValue !== oldValue && newValue && this.visible) {\n          // Hide dropdown if disabled changes to true\n          this.visible = false;\n        }\n      }\n    },\n    created: function created() {\n      // Create non-reactive property\n      this.$_popper = null;\n    },\n    deactivated: function deactivated()\n    /* istanbul ignore next: not easy to test */\n    {\n      // In case we are inside a `<keep-alive>`\n      this.visible = false;\n      this.whileOpenListen(false);\n      this.destroyPopper();\n    },\n    beforeDestroy: function beforeDestroy() {\n      this.visible = false;\n      this.whileOpenListen(false);\n      this.destroyPopper();\n    },\n    methods: {\n      // Event emitter\n      emitEvent: function emitEvent(bvEvt) {\n        var type = bvEvt.type;\n        this.$emit(type, bvEvt);\n        this.$root.$emit(\"\".concat(ROOT_DROPDOWN_PREFIX).concat(type), bvEvt);\n      },\n      showMenu: function showMenu() {\n        var _this = this;\n\n        if (this.disabled) {\n          /* istanbul ignore next */\n          return;\n        } // Only instantiate Popper.js when dropdown is not in `<b-navbar>`\n\n\n        if (!this.inNavbar) {\n          if (typeof Popper === 'undefined') {\n            /* istanbul ignore next */\n            warn('Popper.js not found. Falling back to CSS positioning', 'BDropdown');\n          } else {\n            // For dropup with alignment we use the parent element as popper container\n            var el = this.dropup && this.right || this.split ? this.$el : this.$refs.toggle; // Make sure we have a reference to an element, not a component!\n\n            el = el.$el || el; // Instantiate Popper.js\n\n            this.createPopper(el);\n          }\n        } // Ensure other menus are closed\n\n\n        this.$root.$emit(ROOT_DROPDOWN_SHOWN, this); // Enable listeners\n\n        this.whileOpenListen(true); // Wrap in `$nextTick()` to ensure menu is fully rendered/shown\n\n        this.$nextTick(function () {\n          // Focus on the menu container on show\n          _this.focusMenu(); // Emit the shown event\n\n\n          _this.$emit('shown');\n        });\n      },\n      hideMenu: function hideMenu() {\n        this.whileOpenListen(false);\n        this.$root.$emit(ROOT_DROPDOWN_HIDDEN, this);\n        this.$emit('hidden');\n        this.destroyPopper();\n      },\n      createPopper: function createPopper(element) {\n        this.destroyPopper();\n        this.$_popper = new Popper(element, this.$refs.menu, this.getPopperConfig());\n      },\n      destroyPopper: function destroyPopper() {\n        // Ensure popper event listeners are removed cleanly\n        if (this.$_popper) {\n          this.$_popper.destroy();\n        }\n\n        this.$_popper = null;\n      },\n      updatePopper: function updatePopper()\n      /* istanbul ignore next: not easy to test */\n      {\n        // Instructs popper to re-computes the dropdown position\n        // usefull if the content changes size\n        try {\n          this.$_popper.scheduleUpdate();\n        } catch (_unused) {}\n      },\n      getPopperConfig: function getPopperConfig() {\n        var placement = AttachmentMap.BOTTOM;\n\n        if (this.dropup) {\n          placement = this.right ? AttachmentMap.TOPEND : AttachmentMap.TOP;\n        } else if (this.dropright) {\n          placement = AttachmentMap.RIGHT;\n        } else if (this.dropleft) {\n          placement = AttachmentMap.LEFT;\n        } else if (this.right) {\n          placement = AttachmentMap.BOTTOMEND;\n        }\n\n        var popperConfig = {\n          placement: placement,\n          modifiers: {\n            offset: {\n              offset: this.offset || 0\n            },\n            flip: {\n              enabled: !this.noFlip\n            }\n          }\n        };\n\n        if (this.boundary) {\n          popperConfig.modifiers.preventOverflow = {\n            boundariesElement: this.boundary\n          };\n        }\n\n        return _objectSpread2({}, popperConfig, {}, this.popperOpts || {});\n      },\n      // Turn listeners on/off while open\n      whileOpenListen: function whileOpenListen(isOpen) {\n        // Hide the dropdown when clicked outside\n        this.listenForClickOut = isOpen; // Hide the dropdown when it loses focus\n\n        this.listenForFocusIn = isOpen; // Hide the dropdown when another dropdown is opened\n\n        var method = isOpen ? '$on' : '$off';\n        this.$root[method](ROOT_DROPDOWN_SHOWN, this.rootCloseListener);\n      },\n      rootCloseListener: function rootCloseListener(vm) {\n        if (vm !== this) {\n          this.visible = false;\n        }\n      },\n      show: function show() {\n        var _this2 = this;\n\n        // Public method to show dropdown\n        if (this.disabled) {\n          return;\n        } // Wrap in a `requestAF()` to allow any previous\n        // click handling to occur first\n\n\n        requestAF(function () {\n          _this2.visible = true;\n        });\n      },\n      hide: function hide() {\n        var refocus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        // Public method to hide dropdown\n        if (this.disabled) {\n          /* istanbul ignore next */\n          return;\n        }\n\n        this.visible = false;\n\n        if (refocus) {\n          // Child element is closing the dropdown on click\n          this.$once('hidden', this.focusToggler);\n        }\n      },\n      // Called only by a button that toggles the menu\n      toggle: function toggle(evt) {\n        evt = evt || {}; // Early exit when not a click event or ENTER, SPACE or DOWN were pressed\n\n        var _evt = evt,\n            type = _evt.type,\n            keyCode = _evt.keyCode;\n\n        if (type !== 'click' && !(type === 'keydown' && [KEY_CODES.ENTER, KEY_CODES.SPACE, KEY_CODES.DOWN].indexOf(keyCode) !== -1)) {\n          /* istanbul ignore next */\n          return;\n        }\n        /* istanbul ignore next */\n\n\n        if (this.disabled) {\n          this.visible = false;\n          return;\n        }\n\n        this.$emit('toggle', evt);\n        evt.preventDefault();\n        evt.stopPropagation(); // Toggle visibility\n\n        if (this.visible) {\n          this.hide(true);\n        } else {\n          this.show();\n        }\n      },\n      // Mousedown handler for the toggle\n      onMousedown: function onMousedown(evt)\n      /* istanbul ignore next */\n      {\n        // We prevent the 'mousedown' event for the toggle to stop the\n        // 'focusin' event from being fired\n        // The event would otherwise be picked up by the global 'focusin'\n        // listener and there is no cross-browser solution to detect it\n        // relates to the toggle click\n        // The 'click' event will still be fired and we handle closing\n        // other dropdowns there too\n        // See https://github.com/bootstrap-vue/bootstrap-vue/issues/4328\n        evt.preventDefault();\n      },\n      // Called from dropdown menu context\n      onKeydown: function onKeydown(evt) {\n        var keyCode = evt.keyCode;\n\n        if (keyCode === KEY_CODES.ESC) {\n          // Close on ESC\n          this.onEsc(evt);\n        } else if (keyCode === KEY_CODES.DOWN) {\n          // Down Arrow\n          this.focusNext(evt, false);\n        } else if (keyCode === KEY_CODES.UP) {\n          // Up Arrow\n          this.focusNext(evt, true);\n        }\n      },\n      // If user presses ESC, close the menu\n      onEsc: function onEsc(evt) {\n        if (this.visible) {\n          this.visible = false;\n          evt.preventDefault();\n          evt.stopPropagation(); // Return focus to original trigger button\n\n          this.$once('hidden', this.focusToggler);\n        }\n      },\n      // Called only in split button mode, for the split button\n      onSplitClick: function onSplitClick(evt) {\n        /* istanbul ignore next */\n        if (this.disabled) {\n          this.visible = false;\n          return;\n        }\n\n        this.$emit('click', evt);\n      },\n      // Shared hide handler between click-out and focus-in events\n      hideHandler: function hideHandler(evt) {\n        var target = evt.target;\n\n        if (this.visible && !contains(this.$refs.menu, target) && !contains(this.toggler, target)) {\n          this.hide();\n        }\n      },\n      // Document click-out listener\n      clickOutHandler: function clickOutHandler(evt) {\n        this.hideHandler(evt);\n      },\n      // Document focus-in listener\n      focusInHandler: function focusInHandler(evt) {\n        this.hideHandler(evt);\n      },\n      // Keyboard nav\n      focusNext: function focusNext(evt, up) {\n        var _this3 = this;\n\n        // Ignore key up/down on form elements\n        var target = evt.target;\n\n        if (!this.visible || evt && closest(Selector.FORM_CHILD, target)) {\n          /* istanbul ignore next: should never happen */\n          return;\n        }\n\n        evt.preventDefault();\n        evt.stopPropagation();\n        this.$nextTick(function () {\n          var items = _this3.getItems();\n\n          if (items.length < 1) {\n            /* istanbul ignore next: should never happen */\n            return;\n          }\n\n          var index = items.indexOf(target);\n\n          if (up && index > 0) {\n            index--;\n          } else if (!up && index < items.length - 1) {\n            index++;\n          }\n\n          if (index < 0) {\n            /* istanbul ignore next: should never happen */\n            index = 0;\n          }\n\n          _this3.focusItem(index, items);\n        });\n      },\n      focusItem: function focusItem(idx, items) {\n        var el = items.find(function (el, i) {\n          return i === idx;\n        });\n\n        if (el && el.focus) {\n          el.focus();\n        }\n      },\n      getItems: function getItems() {\n        // Get all items\n        return filterVisibles(selectAll(Selector.ITEM_SELECTOR, this.$refs.menu));\n      },\n      focusMenu: function focusMenu() {\n        try {\n          this.$refs.menu.focus();\n        } catch (_unused2) {}\n      },\n      focusToggler: function focusToggler() {\n        var _this4 = this;\n\n        this.$nextTick(function () {\n          var toggler = _this4.toggler;\n\n          if (toggler && toggler.focus) {\n            toggler.focus();\n          }\n        });\n      }\n    }\n  };\n\n  var NAME$b = 'BDropdown';\n  var props$j = {\n    text: {\n      // Button label\n      type: String,\n      default: ''\n    },\n    html: {\n      // Button label\n      type: String\n    },\n    size: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$b, 'size');\n      }\n    },\n    variant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$b, 'variant');\n      }\n    },\n    block: {\n      type: Boolean,\n      default: false\n    },\n    menuClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    toggleTag: {\n      type: String,\n      default: 'button'\n    },\n    toggleText: {\n      // This really should be toggleLabel\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$b, 'toggleText');\n      }\n    },\n    toggleClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    noCaret: {\n      type: Boolean,\n      default: false\n    },\n    split: {\n      type: Boolean,\n      default: false\n    },\n    splitHref: {\n      type: String // default: undefined\n\n    },\n    splitTo: {\n      type: [String, Object] // default: undefined\n\n    },\n    splitVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$b, 'splitVariant');\n      }\n    },\n    splitClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    splitButtonType: {\n      type: String,\n      default: 'button',\n      validator: function validator(value) {\n        return arrayIncludes(['button', 'submit', 'reset'], value);\n      }\n    },\n    lazy: {\n      // If true, only render menu contents when open\n      type: Boolean,\n      default: false\n    },\n    role: {\n      type: String,\n      default: 'menu'\n    }\n  }; // @vue/component\n\n  var BDropdown =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$b,\n    mixins: [idMixin, dropdownMixin, normalizeSlotMixin],\n    props: props$j,\n    computed: {\n      dropdownClasses: function dropdownClasses() {\n        return [this.directionClass, {\n          show: this.visible,\n          // The 'btn-group' class is required in `split` mode for button alignment\n          // It needs also to be applied when `block` is disabled to allow multiple\n          // dropdowns to be aligned one line\n          'btn-group': this.split || !this.block,\n          // When `block` is enabled and we are in `split` mode the 'd-flex' class\n          // needs to be applied to allow the buttons to stretch to full width\n          'd-flex': this.block && this.split,\n          // Position `static` is needed to allow menu to \"breakout\" of the `scrollParent`\n          // boundaries when boundary is anything other than `scrollParent`\n          // See: https://github.com/twbs/bootstrap/issues/24251#issuecomment-341413786\n          'position-static': this.boundary !== 'scrollParent' || !this.boundary\n        }];\n      },\n      menuClasses: function menuClasses() {\n        return [this.menuClass, {\n          'dropdown-menu-right': this.right,\n          show: this.visible\n        }];\n      },\n      toggleClasses: function toggleClasses() {\n        return [this.toggleClass, {\n          'dropdown-toggle-split': this.split,\n          'dropdown-toggle-no-caret': this.noCaret && !this.split\n        }];\n      }\n    },\n    render: function render(h) {\n      var split = h();\n      var buttonContent = this.normalizeSlot('button-content') || this.html || stripTags(this.text);\n\n      if (this.split) {\n        var btnProps = {\n          variant: this.splitVariant || this.variant,\n          size: this.size,\n          block: this.block,\n          disabled: this.disabled\n        }; // We add these as needed due to router-link issues with defined property with undefined/null values\n\n        if (this.splitTo) {\n          btnProps.to = this.splitTo;\n        } else if (this.splitHref) {\n          btnProps.href = this.splitHref;\n        } else if (this.splitButtonType) {\n          btnProps.type = this.splitButtonType;\n        }\n\n        split = h(BButton, {\n          ref: 'button',\n          props: btnProps,\n          class: this.splitClass,\n          attrs: {\n            id: this.safeId('_BV_button_')\n          },\n          on: {\n            click: this.onSplitClick\n          }\n        }, [buttonContent]);\n      }\n\n      var toggle = h(BButton, {\n        ref: 'toggle',\n        staticClass: 'dropdown-toggle',\n        class: this.toggleClasses,\n        props: {\n          tag: this.toggleTag,\n          variant: this.variant,\n          size: this.size,\n          block: this.block && !this.split,\n          disabled: this.disabled\n        },\n        attrs: {\n          id: this.safeId('_BV_toggle_'),\n          'aria-haspopup': 'true',\n          'aria-expanded': this.visible ? 'true' : 'false'\n        },\n        on: {\n          mousedown: this.onMousedown,\n          click: this.toggle,\n          keydown: this.toggle // Handle ENTER, SPACE and DOWN\n\n        }\n      }, [this.split ? h('span', {\n        class: ['sr-only']\n      }, [this.toggleText]) : buttonContent]);\n      var menu = h('ul', {\n        ref: 'menu',\n        staticClass: 'dropdown-menu',\n        class: this.menuClasses,\n        attrs: {\n          role: this.role,\n          tabindex: '-1',\n          'aria-labelledby': this.safeId(this.split ? '_BV_button_' : '_BV_toggle_')\n        },\n        on: {\n          keydown: this.onKeydown // Handle UP, DOWN and ESC\n\n        }\n      }, !this.lazy || this.visible ? this.normalizeSlot('default', {\n        hide: this.hide\n      }) : [h()]);\n      return h('div', {\n        staticClass: 'dropdown b-dropdown',\n        class: this.dropdownClasses,\n        attrs: {\n          id: this.safeId()\n        }\n      }, [split, toggle, menu]);\n    }\n  });\n\n  var props$k = propsFactory(); // @vue/component\n\n  var BDropdownItem =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BDropdownItem',\n    mixins: [normalizeSlotMixin],\n    inheritAttrs: false,\n    inject: {\n      bvDropdown: {\n        default: null\n      }\n    },\n    props: _objectSpread2({}, props$k, {\n      variant: {\n        type: String,\n        default: null\n      }\n    }),\n    methods: {\n      closeDropdown: function closeDropdown() {\n        var _this = this;\n\n        // Close on next animation frame to allow <b-link> time to process\n        requestAF(function () {\n          if (_this.bvDropdown) {\n            _this.bvDropdown.hide(true);\n          }\n        });\n      },\n      onClick: function onClick(evt) {\n        this.$emit('click', evt);\n        this.closeDropdown();\n      }\n    },\n    render: function render(h) {\n      return h('li', {\n        attrs: {\n          role: 'presentation'\n        }\n      }, [h(BLink, {\n        props: this.$props,\n        staticClass: 'dropdown-item',\n        class: _defineProperty({}, \"text-\".concat(this.variant), this.variant && !(this.active || this.disabled)),\n        attrs: _objectSpread2({}, this.$attrs, {\n          role: 'menuitem'\n        }),\n        on: {\n          click: this.onClick\n        },\n        ref: 'item'\n      }, this.normalizeSlot('default'))]);\n    }\n  });\n\n  var props$l = {\n    active: {\n      type: Boolean,\n      default: false\n    },\n    activeClass: {\n      type: String,\n      default: 'active'\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    variant: {\n      type: String,\n      default: null\n    }\n  }; // @vue/component\n\n  var BDropdownItemButton =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BDropdownItemButton',\n    mixins: [normalizeSlotMixin],\n    inheritAttrs: false,\n    inject: {\n      bvDropdown: {\n        default: null\n      }\n    },\n    props: props$l,\n    methods: {\n      closeDropdown: function closeDropdown() {\n        if (this.bvDropdown) {\n          this.bvDropdown.hide(true);\n        }\n      },\n      onClick: function onClick(evt) {\n        this.$emit('click', evt);\n        this.closeDropdown();\n      }\n    },\n    render: function render(h) {\n      var _class;\n\n      return h('li', {\n        attrs: {\n          role: 'presentation'\n        }\n      }, [h('button', {\n        staticClass: 'dropdown-item',\n        class: (_class = {}, _defineProperty(_class, this.activeClass, this.active), _defineProperty(_class, \"text-\".concat(this.variant), this.variant && !(this.active || this.disabled)), _class),\n        attrs: _objectSpread2({}, this.$attrs, {\n          role: 'menuitem',\n          type: 'button',\n          disabled: this.disabled\n        }),\n        on: {\n          click: this.onClick\n        },\n        ref: 'button'\n      }, this.normalizeSlot('default'))]);\n    }\n  });\n\n  var props$m = {\n    id: {\n      type: String,\n      default: null\n    },\n    tag: {\n      type: String,\n      default: 'header'\n    },\n    variant: {\n      type: String,\n      default: null\n    }\n  }; // @vue/component\n\n  var BDropdownHeader =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BDropdownHeader',\n    functional: true,\n    props: props$m,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      var $attrs = data.attrs || {};\n      data.attrs = {};\n      return h('li', a(data, {\n        attrs: {\n          role: 'presentation'\n        }\n      }), [h(props.tag, {\n        staticClass: 'dropdown-header',\n        class: _defineProperty({}, \"text-\".concat(props.variant), props.variant),\n        attrs: _objectSpread2({}, $attrs, {\n          id: props.id || null,\n          role: 'heading'\n        }),\n        ref: 'header'\n      }, children)]);\n    }\n  });\n\n  var props$n = {\n    tag: {\n      type: String,\n      default: 'hr'\n    }\n  }; // @vue/component\n\n  var BDropdownDivider =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BDropdownDivider',\n    functional: true,\n    props: props$n,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data;\n      var $attrs = data.attrs || {};\n      data.attrs = {};\n      return h('li', a(data, {\n        attrs: {\n          role: 'presentation'\n        }\n      }), [h(props.tag, {\n        staticClass: 'dropdown-divider',\n        attrs: _objectSpread2({}, $attrs, {\n          role: 'separator',\n          'aria-orientation': 'horizontal'\n        }),\n        ref: 'divider'\n      })]);\n    }\n  });\n\n  var props$o = {\n    id: {\n      type: String,\n      default: null\n    },\n    inline: {\n      type: Boolean,\n      default: false\n    },\n    novalidate: {\n      type: Boolean,\n      default: false\n    },\n    validated: {\n      type: Boolean,\n      default: false\n    }\n  }; // @vue/component\n\n  var BForm =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BForm',\n    functional: true,\n    props: props$o,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h('form', a(data, {\n        class: {\n          'form-inline': props.inline,\n          'was-validated': props.validated\n        },\n        attrs: {\n          id: props.id,\n          novalidate: props.novalidate\n        }\n      }), children);\n    }\n  });\n\n  var BDropdownForm =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BDropdownForm',\n    functional: true,\n    props: _objectSpread2({}, props$o, {\n      disabled: {\n        type: Boolean,\n        default: false\n      },\n      formClass: {\n        type: [String, Object, Array],\n        default: null\n      }\n    }),\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      var $attrs = data.attrs || {};\n      var $listeners = data.on || {};\n      data.attrs = {};\n      data.on = {};\n      return h('li', a(data, {\n        attrs: {\n          role: 'presentation'\n        }\n      }), [h(BForm, {\n        ref: 'form',\n        staticClass: 'b-dropdown-form',\n        class: [props.formClass, {\n          disabled: props.disabled\n        }],\n        props: props,\n        attrs: _objectSpread2({}, $attrs, {\n          disabled: props.disabled,\n          // Tab index of -1 for keyboard navigation\n          tabindex: props.disabled ? null : '-1'\n        }),\n        on: $listeners\n      }, children)]);\n    }\n  });\n\n  var BDropdownText =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BDropdownText',\n    functional: true,\n    props: {\n      tag: {\n        type: String,\n        default: 'p'\n      },\n      variant: {\n        type: String,\n        default: null\n      }\n    },\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      var $attrs = data.attrs || {};\n      data.attrs = {};\n      return h('li', a(data, {\n        attrs: {\n          role: 'presentation'\n        }\n      }), [h(props.tag, {\n        staticClass: 'b-dropdown-text',\n        class: _defineProperty({}, \"text-\".concat(props.variant), props.variant),\n        props: props,\n        attrs: $attrs,\n        ref: 'text'\n      }, children)]);\n    }\n  });\n\n  var props$p = {\n    id: {\n      type: String,\n      default: null\n    },\n    header: {\n      type: String,\n      default: null\n    },\n    headerTag: {\n      type: String,\n      default: 'header'\n    },\n    headerVariant: {\n      type: String,\n      default: null\n    },\n    headerClasses: {\n      type: [String, Array, Object],\n      default: null\n    },\n    ariaDescribedby: {\n      type: String,\n      default: null\n    }\n  }; // @vue/component\n\n  var BDropdownGroup =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BDropdownGroup',\n    functional: true,\n    props: props$p,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          slots = _ref.slots,\n          scopedSlots = _ref.scopedSlots;\n      var $slots = slots();\n      var $scopedSlots = scopedSlots || {};\n      var $attrs = data.attrs || {};\n      data.attrs = {};\n      var header;\n      var headerId = null;\n\n      if (hasNormalizedSlot('header', $scopedSlots, $slots) || props.header) {\n        headerId = props.id ? \"_bv_\".concat(props.id, \"_group_dd_header\") : null;\n        header = h(props.headerTag, {\n          staticClass: 'dropdown-header',\n          class: [props.headerClasses, _defineProperty({}, \"text-\".concat(props.variant), props.variant)],\n          attrs: {\n            id: headerId,\n            role: 'heading'\n          }\n        }, normalizeSlot('header', {}, $scopedSlots, $slots) || props.header);\n      }\n\n      var adb = [headerId, props.ariaDescribedBy].filter(Boolean).join(' ').trim();\n      return h('li', a(data, {\n        attrs: {\n          role: 'presentation'\n        }\n      }), [header || h(), h('ul', {\n        staticClass: 'list-unstyled',\n        attrs: _objectSpread2({}, $attrs, {\n          id: props.id || null,\n          role: 'group',\n          'aria-describedby': adb || null\n        })\n      }, normalizeSlot('default', {}, $scopedSlots, $slots))]);\n    }\n  });\n\n  var DropdownPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BDropdown: BDropdown,\n      BDd: BDropdown,\n      BDropdownItem: BDropdownItem,\n      BDdItem: BDropdownItem,\n      BDropdownItemButton: BDropdownItemButton,\n      BDropdownItemBtn: BDropdownItemButton,\n      BDdItemButton: BDropdownItemButton,\n      BDdItemBtn: BDropdownItemButton,\n      BDropdownHeader: BDropdownHeader,\n      BDdHeader: BDropdownHeader,\n      BDropdownDivider: BDropdownDivider,\n      BDdDivider: BDropdownDivider,\n      BDropdownForm: BDropdownForm,\n      BDdForm: BDropdownForm,\n      BDropdownText: BDropdownText,\n      BDdText: BDropdownText,\n      BDropdownGroup: BDropdownGroup,\n      BDdGroup: BDropdownGroup\n    }\n  });\n\n  var props$q = {\n    type: {\n      type: String,\n      default: 'iframe',\n      validator: function validator(str) {\n        return arrayIncludes(['iframe', 'embed', 'video', 'object', 'img', 'b-img', 'b-img-lazy'], str);\n      }\n    },\n    tag: {\n      type: String,\n      default: 'div'\n    },\n    aspect: {\n      type: String,\n      default: '16by9'\n    }\n  }; // @vue/component\n\n  var BEmbed =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BEmbed',\n    functional: true,\n    props: props$q,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h(props.tag, {\n        ref: data.ref,\n        staticClass: 'embed-responsive',\n        class: _defineProperty({}, \"embed-responsive-\".concat(props.aspect), props.aspect)\n      }, [h(props.type, a(data, {\n        ref: '',\n        staticClass: 'embed-responsive-item'\n      }), children)]);\n    }\n  });\n\n  var EmbedPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BEmbed: BEmbed\n    }\n  });\n\n  var OPTIONS_OBJECT_DEPRECATED_MSG = 'Setting prop \"options\" to an object is deprecated. Use the array format instead.'; // @vue/component\n\n  var formOptionsMixin = {\n    props: {\n      options: {\n        type: [Array, Object],\n        default: function _default() {\n          return [];\n        }\n      },\n      valueField: {\n        type: String,\n        default: 'value'\n      },\n      textField: {\n        type: String,\n        default: 'text'\n      },\n      htmlField: {\n        type: String,\n        default: 'html'\n      },\n      disabledField: {\n        type: String,\n        default: 'disabled'\n      }\n    },\n    computed: {\n      formOptions: function formOptions() {\n        var _this = this;\n\n        var options = this.options; // Normalize the given options array\n\n        if (isArray(options)) {\n          return options.map(function (option) {\n            return _this.normalizeOption(option);\n          });\n        } // Deprecate the object options format\n\n\n        warn(OPTIONS_OBJECT_DEPRECATED_MSG, this.$options.name); // Normalize a `options` object to an array of options\n\n        return keys(options).map(function (key) {\n          return _this.normalizeOption(options[key] || {}, key);\n        });\n      }\n    },\n    methods: {\n      normalizeOption: function normalizeOption(option) {\n        var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        // When the option is an object, normalize it\n        if (isPlainObject(option)) {\n          var value = get(option, this.valueField);\n          var text = get(option, this.textField);\n          return {\n            value: isUndefined(value) ? key || text : value,\n            text: stripTags(String(isUndefined(text) ? key : text)),\n            html: get(option, this.htmlField),\n            disabled: Boolean(get(option, this.disabledField))\n          };\n        } // Otherwise create an `<option>` object from the given value\n\n\n        return {\n          value: key || option,\n          text: stripTags(String(option)),\n          disabled: false\n        };\n      }\n    }\n  };\n\n  var BFormDatalist =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BFormDatalist',\n    mixins: [formOptionsMixin, normalizeSlotMixin],\n    props: {\n      id: {\n        type: String,\n        default: null,\n        required: true\n      }\n    },\n    render: function render(h) {\n      var options = this.formOptions.map(function (option, index) {\n        return h('option', {\n          key: \"option_\".concat(index, \"_opt\"),\n          attrs: {\n            disabled: option.disabled\n          },\n          domProps: _objectSpread2({}, htmlOrText(option.html, option.text), {\n            value: option.value\n          })\n        });\n      });\n      return h('datalist', {\n        attrs: {\n          id: this.id\n        }\n      }, [options, this.normalizeSlot('default')]);\n    }\n  });\n\n  var NAME$c = 'BFormText';\n  var props$r = {\n    id: {\n      type: String,\n      default: null\n    },\n    tag: {\n      type: String,\n      default: 'small'\n    },\n    textVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$c, 'textVariant');\n      }\n    },\n    inline: {\n      type: Boolean,\n      default: false\n    }\n  }; // @vue/component\n\n  var BFormText =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$c,\n    functional: true,\n    props: props$r,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h(props.tag, a(data, {\n        class: _defineProperty({\n          'form-text': !props.inline\n        }, \"text-\".concat(props.textVariant), props.textVariant),\n        attrs: {\n          id: props.id\n        }\n      }), children);\n    }\n  });\n\n  var props$s = {\n    id: {\n      type: String,\n      default: null\n    },\n    tag: {\n      type: String,\n      default: 'div'\n    },\n    tooltip: {\n      type: Boolean,\n      default: false\n    },\n    forceShow: {\n      type: Boolean,\n      default: false\n    },\n    state: {\n      type: Boolean,\n      default: null\n    },\n    ariaLive: {\n      type: String,\n      default: null\n    },\n    role: {\n      type: String,\n      default: null\n    }\n  }; // @vue/component\n\n  var BFormInvalidFeedback =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BFormInvalidFeedback',\n    functional: true,\n    props: props$s,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      var show = props.forceShow === true || props.state === false;\n      return h(props.tag, a(data, {\n        class: {\n          'invalid-feedback': !props.tooltip,\n          'invalid-tooltip': props.tooltip,\n          'd-block': show\n        },\n        attrs: {\n          id: props.id,\n          role: props.role,\n          'aria-live': props.ariaLive,\n          'aria-atomic': props.ariaLive ? 'true' : null\n        }\n      }), children);\n    }\n  });\n\n  var props$t = {\n    id: {\n      type: String,\n      default: null\n    },\n    tag: {\n      type: String,\n      default: 'div'\n    },\n    tooltip: {\n      type: Boolean,\n      default: false\n    },\n    forceShow: {\n      type: Boolean,\n      default: false\n    },\n    state: {\n      type: Boolean,\n      default: null\n    },\n    ariaLive: {\n      type: String,\n      default: null\n    },\n    role: {\n      type: String,\n      default: null\n    }\n  }; // @vue/component\n\n  var BFormValidFeedback =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BFormValidFeedback',\n    functional: true,\n    props: props$t,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      var show = props.forceShow === true || props.state === true;\n      return h(props.tag, a(data, {\n        class: {\n          'valid-feedback': !props.tooltip,\n          'valid-tooltip': props.tooltip,\n          'd-block': show\n        },\n        attrs: {\n          id: props.id,\n          role: props.role,\n          'aria-live': props.ariaLive,\n          'aria-atomic': props.ariaLive ? 'true' : null\n        }\n      }), children);\n    }\n  });\n\n  var props$u = {\n    tag: {\n      type: String,\n      default: 'div'\n    }\n  }; // @vue/component\n\n  var BFormRow =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BFormRow',\n    functional: true,\n    props: props$u,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h(props.tag, a(data, {\n        staticClass: 'form-row'\n      }), children);\n    }\n  });\n\n  var FormPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BForm: BForm,\n      BFormDatalist: BFormDatalist,\n      BDatalist: BFormDatalist,\n      BFormText: BFormText,\n      BFormInvalidFeedback: BFormInvalidFeedback,\n      BFormFeedback: BFormInvalidFeedback,\n      BFormValidFeedback: BFormValidFeedback,\n      // Added here for convenience\n      BFormRow: BFormRow\n    }\n  }); // BFormRow is not exported here as a named export, as it is exported by Layout\n\n  var looseIndexOf = function looseIndexOf(arr, val) {\n    // Assumes that the first argument is an array\n    for (var i = 0; i < arr.length; i++) {\n      if (looseEqual(arr[i], val)) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  var SELECTOR = 'input, textarea, select'; // @vue/component\n\n  var formMixin = {\n    props: {\n      name: {\n        type: String // default: undefined\n\n      },\n      id: {\n        type: String // default: undefined\n\n      },\n      disabled: {\n        type: Boolean\n      },\n      required: {\n        type: Boolean,\n        default: false\n      },\n      form: {\n        type: String,\n        default: null\n      },\n      autofocus: {\n        type: Boolean,\n        default: false\n      }\n    },\n    mounted: function mounted() {\n      this.handleAutofocus();\n    },\n    activated: function activated()\n    /* istanbul ignore next */\n    {\n      this.handleAutofocus();\n    },\n    methods: {\n      handleAutofocus: function handleAutofocus() {\n        var _this = this;\n\n        this.$nextTick(function () {\n          requestAF(function () {\n            var el = _this.$el;\n\n            if (_this.autofocus && isVisible(el)) {\n              if (!matches(el, SELECTOR)) {\n                el = select(SELECTOR, el);\n              }\n\n              el && el.focus && el.focus();\n            }\n          });\n        });\n      }\n    }\n  };\n\n  var formRadioCheckMixin = {\n    mixins: [normalizeSlotMixin],\n    inheritAttrs: false,\n    model: {\n      prop: 'checked',\n      event: 'input'\n    },\n    props: {\n      value: {// Value when checked\n        // type: Object,\n        // default: undefined\n      },\n      checked: {// This is the v-model\n        // type: Object,\n        // default: undefined\n      },\n      inline: {\n        type: Boolean,\n        default: false\n      },\n      plain: {\n        type: Boolean,\n        default: false\n      },\n      button: {\n        // Only applicable in standalone mode (non group)\n        type: Boolean,\n        default: false\n      },\n      buttonVariant: {\n        // Only applicable when rendered with button style\n        type: String,\n        default: null\n      },\n      ariaLabel: {\n        // Placed on the input if present.\n        type: String,\n        default: null\n      },\n      ariaLabelledby: {\n        // Placed on the input if present.\n        type: String,\n        default: null\n      }\n    },\n    data: function data() {\n      return {\n        localChecked: this.isGroup ? this.bvGroup.checked : this.checked,\n        hasFocus: false\n      };\n    },\n    computed: {\n      computedLocalChecked: {\n        get: function get() {\n          return this.isGroup ? this.bvGroup.localChecked : this.localChecked;\n        },\n        set: function set(val) {\n          if (this.isGroup) {\n            this.bvGroup.localChecked = val;\n          } else {\n            this.localChecked = val;\n          }\n        }\n      },\n      isGroup: function isGroup() {\n        // Is this check/radio a child of check-group or radio-group?\n        return Boolean(this.bvGroup);\n      },\n      isBtnMode: function isBtnMode() {\n        // Support button style in single input mode\n        return this.isGroup ? this.bvGroup.buttons : this.button;\n      },\n      isPlain: function isPlain() {\n        return this.isBtnMode ? false : this.isGroup ? this.bvGroup.plain : this.plain;\n      },\n      isCustom: function isCustom() {\n        return this.isBtnMode ? false : !this.isPlain;\n      },\n      isSwitch: function isSwitch() {\n        // Custom switch styling (checkboxes only)\n        return this.isBtnMode || this.isRadio || this.isPlain ? false : this.isGroup ? this.bvGroup.switches : this.switch;\n      },\n      isInline: function isInline() {\n        return this.isGroup ? this.bvGroup.inline : this.inline;\n      },\n      isDisabled: function isDisabled() {\n        // Child can be disabled while parent isn't, but is always disabled if group is\n        return this.isGroup ? this.bvGroup.disabled || this.disabled : this.disabled;\n      },\n      isRequired: function isRequired() {\n        // Required only works when a name is provided for the input(s)\n        // Child can only be required when parent is\n        // Groups will always have a name (either user supplied or auto generated)\n        return this.getName && (this.isGroup ? this.bvGroup.required : this.required);\n      },\n      getName: function getName() {\n        // Group name preferred over local name\n        return (this.isGroup ? this.bvGroup.groupName : this.name) || null;\n      },\n      getForm: function getForm() {\n        return (this.isGroup ? this.bvGroup.form : this.form) || null;\n      },\n      getSize: function getSize() {\n        return (this.isGroup ? this.bvGroup.size : this.size) || '';\n      },\n      getState: function getState() {\n        return this.isGroup ? this.bvGroup.computedState : this.computedState;\n      },\n      getButtonVariant: function getButtonVariant() {\n        // Local variant preferred over group variant\n        if (this.buttonVariant) {\n          return this.buttonVariant;\n        } else if (this.isGroup && this.bvGroup.buttonVariant) {\n          return this.bvGroup.buttonVariant;\n        } // default variant\n\n\n        return 'secondary';\n      },\n      buttonClasses: function buttonClasses() {\n        var _ref;\n\n        // Same for radio & check\n        return ['btn', \"btn-\".concat(this.getButtonVariant), (_ref = {}, _defineProperty(_ref, \"btn-\".concat(this.getSize), this.getSize), _defineProperty(_ref, \"disabled\", this.isDisabled), _defineProperty(_ref, \"active\", this.isChecked), _defineProperty(_ref, \"focus\", this.hasFocus), _ref)];\n      }\n    },\n    watch: {\n      checked: function checked(newVal) {\n        this.computedLocalChecked = newVal;\n      }\n    },\n    methods: {\n      handleFocus: function handleFocus(evt) {\n        // When in buttons mode, we need to add 'focus' class to label when input focused\n        // As it is the hidden input which has actual focus\n        if (evt.target) {\n          if (evt.type === 'focus') {\n            this.hasFocus = true;\n          } else if (evt.type === 'blur') {\n            this.hasFocus = false;\n          }\n        }\n      },\n      // Convenience methods for focusing the input\n      focus: function focus() {\n        if (!this.isDisabled && this.$refs.input && this.$refs.input.focus) {\n          this.$refs.input.focus();\n        }\n      },\n      blur: function blur() {\n        if (!this.isDisabled && this.$refs.input && this.$refs.input.blur) {\n          this.$refs.input.blur();\n        }\n      }\n    },\n    render: function render(h) {\n      var defaultSlot = this.normalizeSlot('default'); // Generate the input element\n\n      var on = {\n        change: this.handleChange\n      };\n\n      if (this.isBtnMode) {\n        // Handlers for focus styling when in button mode\n        on.focus = on.blur = this.handleFocus;\n      }\n\n      var input = h('input', {\n        ref: 'input',\n        key: 'input',\n        on: on,\n        class: {\n          'form-check-input': this.isPlain,\n          'custom-control-input': this.isCustom,\n          'is-valid': this.getState === true && !this.isBtnMode,\n          'is-invalid': this.getState === false && !this.isBtnMode,\n          // https://github.com/bootstrap-vue/bootstrap-vue/issues/2911\n          'position-static': this.isPlain && !defaultSlot\n        },\n        directives: [{\n          name: 'model',\n          rawName: 'v-model',\n          value: this.computedLocalChecked,\n          expression: 'computedLocalChecked'\n        }],\n        attrs: _objectSpread2({}, this.$attrs, {\n          id: this.safeId(),\n          type: this.isRadio ? 'radio' : 'checkbox',\n          name: this.getName,\n          form: this.getForm,\n          disabled: this.isDisabled,\n          required: this.isRequired,\n          autocomplete: 'off',\n          'aria-required': this.isRequired || null,\n          'aria-label': this.ariaLabel || null,\n          'aria-labelledby': this.ariaLabelledby || null\n        }),\n        domProps: {\n          value: this.value,\n          checked: this.isChecked\n        }\n      });\n\n      if (this.isBtnMode) {\n        // Button mode\n        var button = h('label', {\n          class: this.buttonClasses\n        }, [input, defaultSlot]);\n\n        if (!this.isGroup) {\n          // Standalone button mode, so wrap in 'btn-group-toggle'\n          // and flag it as inline-block to mimic regular buttons\n          button = h('div', {\n            class: ['btn-group-toggle', 'd-inline-block']\n          }, [button]);\n        }\n\n        return button;\n      } else {\n        // Not button mode\n        var label = h(); // If no label content in plain mode we dont render the label\n        // https://github.com/bootstrap-vue/bootstrap-vue/issues/2911\n\n        if (!(this.isPlain && !defaultSlot)) {\n          label = h('label', {\n            class: {\n              'form-check-label': this.isPlain,\n              'custom-control-label': this.isCustom\n            },\n            attrs: {\n              for: this.safeId()\n            }\n          }, defaultSlot);\n        } // Wrap it in a div\n\n\n        return h('div', {\n          class: _defineProperty({\n            'form-check': this.isPlain,\n            'form-check-inline': this.isPlain && this.isInline,\n            'custom-control': this.isCustom,\n            'custom-control-inline': this.isCustom && this.isInline,\n            'custom-checkbox': this.isCustom && this.isCheck && !this.isSwitch,\n            'custom-switch': this.isSwitch,\n            'custom-radio': this.isCustom && this.isRadio\n          }, \"b-custom-control-\".concat(this.getSize), Boolean(this.getSize && !this.isBtnMode))\n        }, [input, label]);\n      }\n    }\n  };\n\n  var formSizeMixin = {\n    props: {\n      size: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig('formControls', 'size');\n        }\n      }\n    },\n    computed: {\n      sizeFormClass: function sizeFormClass() {\n        return [this.size ? \"form-control-\".concat(this.size) : null];\n      },\n      sizeBtnClass: function sizeBtnClass()\n      /* istanbul ignore next: don't think this is used */\n      {\n        return [this.size ? \"btn-\".concat(this.size) : null];\n      }\n    }\n  };\n\n  /* Form control contextual state class computation\n   *\n   * Returned class is either 'is-valid' or 'is-invalid' based on the 'state' prop\n   * state can be one of five values:\n   *  - true for is-valid\n   *  - false for is-invalid\n   *  - null for no contextual state\n   */\n\n  var formStateMixin = {\n    props: {\n      state: {\n        // Tri-state prop: true, false, null (or undefined)\n        type: Boolean,\n        default: null\n      }\n    },\n    computed: {\n      computedState: function computedState() {\n        // If not a boolean, ensure that value is null\n        return isBoolean(this.state) ? this.state : null;\n      },\n      stateClass: function stateClass() {\n        var state = this.computedState;\n        return state === true ? 'is-valid' : state === false ? 'is-invalid' : null;\n      }\n    }\n  };\n\n  var BFormCheckbox =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BFormCheckbox',\n    mixins: [formRadioCheckMixin, // Includes shared render function\n    idMixin, formMixin, formSizeMixin, formStateMixin],\n    inject: {\n      bvGroup: {\n        from: 'bvCheckGroup',\n        default: false\n      }\n    },\n    props: {\n      value: {\n        // type: [String, Number, Boolean, Object],\n        default: true\n      },\n      uncheckedValue: {\n        // type: [String, Number, Boolean, Object],\n        // Not applicable in multi-check mode\n        default: false\n      },\n      indeterminate: {\n        // Not applicable in multi-check mode\n        type: Boolean,\n        default: false\n      },\n      switch: {\n        // Custom switch styling\n        type: Boolean,\n        default: false\n      },\n      checked: {\n        // v-model (Array when multiple checkboxes have same name)\n        // type: [String, Number, Boolean, Object, Array],\n        default: null\n      }\n    },\n    computed: {\n      isChecked: function isChecked() {\n        var checked = this.computedLocalChecked;\n        var value = this.value;\n\n        if (isArray(checked)) {\n          return looseIndexOf(checked, value) > -1;\n        } else {\n          return looseEqual(checked, value);\n        }\n      },\n      isRadio: function isRadio() {\n        return false;\n      },\n      isCheck: function isCheck() {\n        return true;\n      }\n    },\n    watch: {\n      computedLocalChecked: function computedLocalChecked(newVal) {\n        this.$emit('input', newVal);\n\n        if (this.$refs && this.$refs.input) {\n          this.$emit('update:indeterminate', this.$refs.input.indeterminate);\n        }\n      },\n      indeterminate: function indeterminate(newVal) {\n        this.setIndeterminate(newVal);\n      }\n    },\n    mounted: function mounted() {\n      // Set initial indeterminate state\n      this.setIndeterminate(this.indeterminate);\n    },\n    methods: {\n      handleChange: function handleChange(_ref) {\n        var _ref$target = _ref.target,\n            checked = _ref$target.checked,\n            indeterminate = _ref$target.indeterminate;\n        var localChecked = this.computedLocalChecked;\n        var value = this.value;\n        var isArr = isArray(localChecked);\n        var uncheckedValue = isArr ? null : this.uncheckedValue; // Update computedLocalChecked\n\n        if (isArr) {\n          var idx = looseIndexOf(localChecked, value);\n\n          if (checked && idx < 0) {\n            // Add value to array\n            localChecked = localChecked.concat(value);\n          } else if (!checked && idx > -1) {\n            // Remove value from array\n            localChecked = localChecked.slice(0, idx).concat(localChecked.slice(idx + 1));\n          }\n        } else {\n          localChecked = checked ? value : uncheckedValue;\n        }\n\n        this.computedLocalChecked = localChecked; // Change is only emitted on user interaction\n\n        this.$emit('change', checked ? value : uncheckedValue); // If this is a child of form-checkbox-group, we emit a change event on it as well\n\n        if (this.isGroup) {\n          this.bvGroup.$emit('change', localChecked);\n        }\n\n        this.$emit('update:indeterminate', indeterminate);\n      },\n      setIndeterminate: function setIndeterminate(state) {\n        // Indeterminate only supported in single checkbox mode\n        if (isArray(this.computedLocalChecked)) {\n          state = false;\n        }\n\n        if (this.$refs && this.$refs.input) {\n          this.$refs.input.indeterminate = state; // Emit update event to prop\n\n          this.$emit('update:indeterminate', state);\n        }\n      }\n    }\n  });\n\n  var BFormRadio =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BFormRadio',\n    mixins: [idMixin, formRadioCheckMixin, // Includes shared render function\n    formMixin, formSizeMixin, formStateMixin],\n    inject: {\n      bvGroup: {\n        from: 'bvRadioGroup',\n        default: false\n      }\n    },\n    props: {\n      checked: {\n        // v-model\n        // type: [String, Number, Boolean, Object],\n        default: null\n      }\n    },\n    computed: {\n      // Radio Groups can only have a single value, so determining if checked is simple\n      isChecked: function isChecked() {\n        return looseEqual(this.value, this.computedLocalChecked);\n      },\n      // Flags for form-radio-check mixin\n      isRadio: function isRadio() {\n        return true;\n      },\n      isCheck: function isCheck() {\n        return false;\n      }\n    },\n    watch: {\n      // Radio Groups can only have a single value, so our watchers are simple\n      computedLocalChecked: function computedLocalChecked() {\n        this.$emit('input', this.computedLocalChecked);\n      }\n    },\n    methods: {\n      handleChange: function handleChange(_ref) {\n        var checked = _ref.target.checked;\n        var value = this.value;\n        this.computedLocalChecked = value; // Change is only emitted on user interaction\n\n        this.$emit('change', checked ? value : null); // If this is a child of form-radio-group, we emit a change event on it as well\n\n        if (this.isGroup) {\n          this.bvGroup.$emit('change', checked ? value : null);\n        }\n      }\n    }\n  });\n\n  var formRadioCheckGroupMixin = {\n    mixins: [normalizeSlotMixin],\n    model: {\n      prop: 'checked',\n      event: 'input'\n    },\n    props: {\n      validated: {\n        type: Boolean,\n        default: false\n      },\n      ariaInvalid: {\n        type: [Boolean, String],\n        default: false\n      },\n      stacked: {\n        type: Boolean,\n        default: false\n      },\n      plain: {\n        type: Boolean,\n        default: false\n      },\n      buttons: {\n        // Render as button style\n        type: Boolean,\n        default: false\n      },\n      buttonVariant: {\n        // Only applicable when rendered with button style\n        type: String,\n        default: 'secondary'\n      }\n    },\n    computed: {\n      inline: function inline() {\n        return !this.stacked;\n      },\n      groupName: function groupName() {\n        // Checks/Radios tied to the same model must have the same name,\n        // especially for ARIA accessibility.\n        return this.name || this.safeId();\n      },\n      groupClasses: function groupClasses() {\n        if (this.buttons) {\n          return ['btn-group-toggle', this.inline ? 'btn-group' : 'btn-group-vertical', this.size ? \"btn-group-\".concat(this.size) : '', this.validated ? \"was-validated\" : ''];\n        }\n\n        return [this.validated ? \"was-validated\" : ''];\n      },\n      computedAriaInvalid: function computedAriaInvalid() {\n        var ariaInvalid = this.ariaInvalid;\n\n        if (ariaInvalid === true || ariaInvalid === 'true' || ariaInvalid === '') {\n          return 'true';\n        }\n\n        return this.computedState === false ? 'true' : null;\n      }\n    },\n    watch: {\n      checked: function checked(newVal) {\n        this.localChecked = newVal;\n      },\n      localChecked: function localChecked(newVal) {\n        this.$emit('input', newVal);\n      }\n    },\n    render: function render(h) {\n      var _this = this;\n\n      var inputs = this.formOptions.map(function (option, idx) {\n        var uid = \"_BV_option_\".concat(idx, \"_\");\n        return h(_this.isRadioGroup ? BFormRadio : BFormCheckbox, {\n          key: uid,\n          props: {\n            id: _this.safeId(uid),\n            value: option.value,\n            // Individual radios or checks can be disabled in a group\n            disabled: option.disabled || false // We don't need to include these, since the input's will know they are inside here\n            // name: this.groupName,\n            // form: this.form || null,\n            // required: Boolean(this.name && this.required)\n\n          }\n        }, [h('span', {\n          domProps: htmlOrText(option.html, option.text)\n        })]);\n      });\n      return h('div', {\n        class: [this.groupClasses, 'bv-no-focus-ring'],\n        attrs: {\n          id: this.safeId(),\n          role: this.isRadioGroup ? 'radiogroup' : 'group',\n          // Tabindex to allow group to be focused\n          // if needed by screen readers\n          tabindex: '-1',\n          'aria-required': this.required ? 'true' : null,\n          'aria-invalid': this.computedAriaInvalid\n        }\n      }, [this.normalizeSlot('first'), inputs, this.normalizeSlot('default')]);\n    }\n  };\n\n  var props$v = {\n    switches: {\n      // Custom switch styling\n      type: Boolean,\n      default: false\n    },\n    checked: {\n      type: Array,\n      default: null\n    }\n  }; // @vue/component\n\n  var BFormCheckboxGroup =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BFormCheckboxGroup',\n    mixins: [idMixin, formMixin, formRadioCheckGroupMixin, // Includes render function\n    formOptionsMixin, formSizeMixin, formStateMixin],\n    provide: function provide() {\n      return {\n        bvCheckGroup: this\n      };\n    },\n    props: props$v,\n    data: function data() {\n      return {\n        localChecked: this.checked || []\n      };\n    },\n    computed: {\n      isRadioGroup: function isRadioGroup() {\n        return false;\n      }\n    }\n  });\n\n  var FormCheckboxPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BFormCheckbox: BFormCheckbox,\n      BCheckbox: BFormCheckbox,\n      BCheck: BFormCheckbox,\n      BFormCheckboxGroup: BFormCheckboxGroup,\n      BCheckboxGroup: BFormCheckboxGroup,\n      BCheckGroup: BFormCheckboxGroup\n    }\n  });\n\n  // v-b-hover directive\n\n  var PROP = '__BV_hover_handler__';\n  var MOUSEENTER = 'mouseenter';\n  var MOUSELEAVE = 'mouseleave'; // --- Utility methods ---\n\n  var createListener = function createListener(handler) {\n    var listener = function listener(evt) {\n      handler(evt.type === MOUSEENTER, evt);\n    };\n\n    listener.fn = handler;\n    return listener;\n  };\n\n  var updateListeners = function updateListeners(on, el, listener) {\n    eventOnOff(on, el, MOUSEENTER, listener, EVENT_OPTIONS_NO_CAPTURE);\n    eventOnOff(on, el, MOUSELEAVE, listener, EVENT_OPTIONS_NO_CAPTURE);\n  }; // --- Directive bind/unbind/update handler ---\n\n\n  var directive = function directive(el, _ref) {\n    var _ref$value = _ref.value,\n        handler = _ref$value === void 0 ? null : _ref$value;\n\n    if (isBrowser) {\n      var listener = el[PROP];\n      var hasListener = isFunction(listener);\n      var handlerChanged = !(hasListener && listener.fn === handler);\n\n      if (hasListener && handlerChanged) {\n        updateListeners(false, el, listener);\n        delete el[PROP];\n      }\n\n      if (isFunction(handler) && handlerChanged) {\n        el[PROP] = createListener(handler);\n        updateListeners(true, el, el[PROP]);\n      }\n    }\n  }; // VBHover directive\n\n\n  var VBHover = {\n    bind: directive,\n    componentUpdated: directive,\n    unbind: function unbind(el) {\n      directive(el, {\n        value: null\n      });\n    }\n  };\n\n  var NAME$d = 'BFormDatepicker'; // Fallback to BCalendar prop if no value found\n\n  var getConfigFallback = function getConfigFallback(prop) {\n    return getComponentConfig(NAME$d, prop) || getComponentConfig('BCalendar', prop);\n  }; // We create our props as a mixin so that we can control\n  // where they appear in the props listing reference section\n\n\n  var propsMixin = {\n    props: {\n      value: {\n        type: [String, Date],\n        default: null\n      },\n      valueAsDate: {\n        type: Boolean,\n        default: false\n      },\n      resetValue: {\n        type: [String, Date],\n        default: ''\n      },\n      placeholder: {\n        type: String,\n        // Defaults to `labelNoDateSelected` from calendar context\n        default: null\n      },\n      size: {\n        type: String,\n        default: null\n      },\n      min: {\n        type: [String, Date],\n        default: null\n      },\n      max: {\n        type: [String, Date],\n        default: null\n      },\n      disabled: {\n        type: Boolean,\n        default: false\n      },\n      readonly: {\n        type: Boolean,\n        default: false\n      },\n      required: {\n        // If true adds the `aria-required` attribute\n        type: Boolean,\n        default: false\n      },\n      name: {\n        type: String,\n        default: null\n      },\n      form: {\n        type: String,\n        default: null\n      },\n      state: {\n        // Tri-state prop: `true`, `false` or `null`\n        type: Boolean,\n        default: null\n      },\n      dateDisabledFn: {\n        type: Function,\n        default: null\n      },\n      noCloseOnSelect: {\n        type: Boolean,\n        default: false\n      },\n      hideHeader: {\n        type: Boolean,\n        default: false\n      },\n      locale: {\n        type: [String, Array],\n        default: null\n      },\n      startWeekday: {\n        // `0` (Sunday), `1` (Monday), ... `6` (Saturday)\n        // Day of week to start calendar on\n        type: [Number, String],\n        default: 0\n      },\n      direction: {\n        type: String,\n        default: null\n      },\n      selectedVariant: {\n        // Variant color to use for the selected date\n        type: String,\n        default: 'primary'\n      },\n      todayVariant: {\n        // Variant color to use for today's date (defaults to `variant`)\n        type: String,\n        default: null\n      },\n      noHighlightToday: {\n        // Disable highlighting today's date\n        type: Boolean,\n        default: false\n      },\n      todayButton: {\n        type: Boolean,\n        default: false\n      },\n      labelTodayButton: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$d, 'labelTodayButton');\n        }\n      },\n      todayButtonVariant: {\n        type: String,\n        default: 'outline-primary'\n      },\n      resetButton: {\n        type: Boolean,\n        default: false\n      },\n      labelResetButton: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$d, 'labelResetButton');\n        }\n      },\n      resetButtonVariant: {\n        type: String,\n        default: 'outline-danger'\n      },\n      closeButton: {\n        type: Boolean,\n        default: false\n      },\n      labelCloseButton: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$d, 'labelCloseButton');\n        }\n      },\n      closeButtonVariant: {\n        type: String,\n        default: 'outline-secondary'\n      },\n      // Labels for buttons and keyboard shortcuts\n      // These pick BCalendar global config if no BFormDate global config\n      labelPrevYear: {\n        type: String,\n        default: function _default() {\n          return getConfigFallback('labelPrevYear');\n        }\n      },\n      labelPrevMonth: {\n        type: String,\n        default: function _default() {\n          return getConfigFallback('labelPrevMonth');\n        }\n      },\n      labelCurrentMonth: {\n        type: String,\n        default: function _default() {\n          return getConfigFallback('labelCurrentMonth');\n        }\n      },\n      labelNextMonth: {\n        type: String,\n        default: function _default() {\n          return getConfigFallback('labelNextMonth');\n        }\n      },\n      labelNextYear: {\n        type: String,\n        default: function _default() {\n          return getConfigFallback('labelNextYear');\n        }\n      },\n      labelToday: {\n        type: String,\n        default: function _default() {\n          return getConfigFallback('labelToday');\n        }\n      },\n      labelSelected: {\n        type: String,\n        default: function _default() {\n          return getConfigFallback('labelSelected');\n        }\n      },\n      labelNoDateSelected: {\n        type: String,\n        default: function _default() {\n          return getConfigFallback('labelNoDateSelected');\n        }\n      },\n      labelCalendar: {\n        type: String,\n        default: function _default() {\n          return getConfigFallback('labelCalendar');\n        }\n      },\n      labelNav: {\n        type: String,\n        default: function _default() {\n          return getConfigFallback('labelNav');\n        }\n      },\n      labelHelp: {\n        type: String,\n        default: function _default() {\n          return getConfigFallback('labelHelp');\n        }\n      },\n      // Dark mode\n      dark: {\n        type: Boolean,\n        default: false\n      }\n    }\n  }; // --- BFormDate component ---\n  // @vue/component\n\n  var BFormDatepicker =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$d,\n    directives: {\n      BHover: VBHover\n    },\n    // The mixins order determines the order of appearance in the props reference section\n    mixins: [idMixin, propsMixin, dropdownMixin],\n    model: {\n      prop: 'value',\n      event: 'input'\n    },\n    data: function data() {\n      return {\n        // We always use `YYYY-MM-DD` value internally\n        localYMD: formatYMD(this.value) || '',\n        // Context data from BCalendar\n        localLocale: null,\n        isRTL: false,\n        formatedValue: '',\n        activeYMD: '',\n        // Flag to add focus ring to outer wrapper\n        hasFocus: false,\n        // If the control is hovered\n        isHovered: false\n      };\n    },\n    computed: {\n      calendarYM: function calendarYM() {\n        // Returns the calendar year/month\n        // Returns the `YYYY-MM` portion of the active calendar date\n        return this.activeYMD.slice(0, -3);\n      },\n      calendarProps: function calendarProps() {\n        // TODO: Make the ID's computed props\n        var idLabel = this.safeId('_value_');\n        var idWrapper = this.safeId('_b-form-date_');\n        return {\n          // id: this.safeId('_picker_'),\n          ariaControls: [idLabel, idWrapper].filter(identity).join(' ') || null,\n          value: this.localYMD,\n          hidden: !this.visible,\n          min: this.min,\n          max: this.max,\n          readonly: this.readonly,\n          disabled: this.disabled,\n          locale: this.locale,\n          startWeekday: this.startWeekday,\n          direction: this.direction,\n          dateDisabledFn: this.dateDisabledFn,\n          selectedVariant: this.selectedVariant,\n          todayVariant: this.todayVariant,\n          hideHeader: this.hideHeader,\n          labelPrevYear: this.labelPrevYear,\n          labelPrevMonth: this.labelPrevMonth,\n          labelCurrentMonth: this.labelCurrentMonth,\n          labelNextMonth: this.labelNextMonth,\n          labelNextYear: this.labelNextYear,\n          labelToday: this.labelToday,\n          labelSelected: this.labelSelected,\n          labelNoDateSelected: this.labelNoDateSelected,\n          labelCalendar: this.labelCalendar,\n          labelNav: this.labelNav,\n          labelHelp: this.labelHelp\n        };\n      },\n      computedResetValue: function computedResetValue() {\n        return parseYMD(this.resetValue) || '';\n      }\n    },\n    watch: {\n      value: function value(newVal) {\n        this.localYMD = formatYMD(newVal) || '';\n      },\n      localYMD: function localYMD(newVal) {\n        this.$emit('input', this.valueAsDate ? parseYMD(newVal) || null : newVal || '');\n      },\n      calendarYM: function calendarYM(newVal, oldVal)\n      /* istanbul ignore next */\n      {\n        // Displayed calendar month has changed\n        // So possibly the calendar height has changed...\n        // We need to update popper computed position\n        if (newVal !== oldVal && oldVal) {\n          this.updatePopper();\n        }\n      }\n    },\n    mounted: function mounted() {\n      var _this = this;\n\n      this.$on('shown', function () {\n        // May want to make an option to focus\n        // the entire calendar (dropdown-menu) or just the date\n        try {\n          _this.$refs.calendar.focus();\n        } catch (_unused) {}\n      });\n    },\n    methods: {\n      // Public methods\n      focus: function focus() {\n        if (!this.disabled) {\n          try {\n            // This assumes the toggle is an element and not a component\n            this.$refs.toggle.focus();\n          } catch (_unused2) {}\n        }\n      },\n      blur: function blur() {\n        if (!this.disabled) {\n          try {\n            // This assumes the toggle is an element and not a component\n            this.$refs.toggle.blur();\n          } catch (_unused3) {}\n        }\n      },\n      // Private methods\n      setAndClose: function setAndClose(ymd) {\n        var _this2 = this;\n\n        this.localYMD = ymd; // Close calendar popup, unless `noCloseOnSelect`\n\n        if (!this.noCloseOnSelect) {\n          this.$nextTick(function () {\n            _this2.hide(true);\n          });\n        }\n      },\n      onSelected: function onSelected(ymd) {\n        var _this3 = this;\n\n        this.$nextTick(function () {\n          _this3.setAndClose(ymd);\n        });\n      },\n      onInput: function onInput(ymd) {\n        if (this.localYMD !== ymd) {\n          this.localYMD = ymd;\n        }\n      },\n      onContext: function onContext(ctx) {\n        var activeYMD = ctx.activeYMD,\n            isRTL = ctx.isRTL,\n            locale = ctx.locale,\n            selectedYMD = ctx.selectedYMD,\n            selectedFormatted = ctx.selectedFormatted;\n        this.isRTL = isRTL;\n        this.localLocale = locale;\n        this.formattedValue = selectedFormatted;\n        this.localYMD = selectedYMD;\n        this.activeYMD = activeYMD; // Re-emit the context event\n\n        this.$emit('context', ctx);\n      },\n      onTodayButton: function onTodayButton() {\n        this.setAndClose(formatYMD(createDate()));\n      },\n      onResetButton: function onResetButton() {\n        this.setAndClose(this.computedResetValue);\n      },\n      onCloseButton: function onCloseButton() {\n        this.hide(true);\n      },\n      setFocus: function setFocus(evt) {\n        this.hasFocus = evt.type === 'focus';\n      },\n      handleHover: function handleHover(hovered) {\n        this.isHovered = hovered;\n      }\n    },\n    render: function render(h) {\n      var _class2, _ref;\n\n      var size = this.size;\n      var state = this.state;\n      var localYMD = this.localYMD;\n      var disabled = this.disabled;\n      var readonly = this.readonly;\n      var idButton = this.safeId();\n      var idLabel = this.safeId('_value_');\n      var idMenu = this.safeId('_dialog_');\n      var idWrapper = this.safeId('_b-form-date_');\n      var $button = h('div', {\n        attrs: {\n          'aria-hidden': 'true'\n        }\n      }, [this.isHovered || this.hasFocus ? h(BIconCalendarFill, {\n        props: {\n          scale: 1.25\n        }\n      }) : h(BIconCalendar, {\n        props: {\n          scale: 1.25\n        }\n      })]);\n      $button = h('button', {\n        ref: 'toggle',\n        staticClass: 'btn border-0 h-auto py-0',\n        class: _defineProperty({}, \"btn-\".concat(size), !!size),\n        attrs: {\n          id: idButton,\n          type: 'button',\n          disabled: disabled,\n          'aria-haspopup': 'dialog',\n          'aria-expanded': this.visible ? 'true' : 'false',\n          'aria-invalid': state === false ? 'true' : null,\n          'aria-required': this.required ? 'true' : null\n        },\n        on: {\n          mousedown: this.onMousedown,\n          click: this.toggle,\n          keydown: this.toggle,\n          // Handle ENTER, SPACE and DOWN\n          '!focus': this.setFocus,\n          '!blur': this.setFocus\n        }\n      }, [$button]); // Label as a \"fake\" input\n      // This label will be read by screen readers when the button is focused\n\n      var $input = h('label', {\n        staticClass: 'form-control text-break text-wrap border-0 bg-transparent h-auto pl-1 m-0',\n        class: (_class2 = {\n          // Mute the text if showing the placeholder\n          'text-muted': !localYMD\n        }, _defineProperty(_class2, \"form-control-\".concat(size), !!size), _defineProperty(_class2, 'is-invalid', state === false), _defineProperty(_class2, 'is-valid', state === true), _class2),\n        attrs: {\n          id: idLabel,\n          for: idButton,\n          dir: this.isRTL ? 'rtl' : 'ltr',\n          lang: this.localLocale || null,\n          'aria-invalid': state === false ? 'true' : null,\n          'aria-required': this.required ? 'true' : null\n        },\n        on: {\n          // Disable bubbling of the click event to\n          // prevent menu from closing and re-opening\n          click: function click(evt)\n          /* istanbul ignore next */\n          {\n            evt.stopPropagation();\n          }\n        }\n      }, [// Add the formatted value or placeholder\n      localYMD ? this.formattedValue : this.placeholder || this.labelNoDateSelected, // Add an sr-only 'selected date' label if a date is selected\n      localYMD ? h('span', {\n        staticClass: 'sr-only'\n      }, \" (\".concat(this.labelSelected, \") \")) : h()]); // Optional footer buttons\n\n      var $controls = [];\n\n      if (this.todayButton) {\n        var label = this.labelTodayButton;\n        $controls.push(h(BButton, {\n          props: {\n            size: 'sm',\n            disabled: disabled || readonly,\n            variant: this.todayButtonVariant\n          },\n          attrs: {\n            'aria-label': label || null\n          },\n          on: {\n            click: this.onTodayButton\n          }\n        }, label));\n      }\n\n      if (this.resetButton) {\n        var _label = this.labelResetButton;\n        $controls.push(h(BButton, {\n          props: {\n            size: 'sm',\n            disabled: disabled || readonly,\n            variant: this.resetButtonVariant\n          },\n          attrs: {\n            'aria-label': _label || null\n          },\n          on: {\n            click: this.onResetButton\n          }\n        }, _label));\n      }\n\n      if (this.closeButton) {\n        var _label2 = this.labelCloseButton;\n        $controls.push(h(BButton, {\n          props: {\n            size: 'sm',\n            disabled: this.disabled,\n            variant: this.closeButtonVariant\n          },\n          attrs: {\n            'aria-label': _label2 || null\n          },\n          on: {\n            click: this.onCloseButton\n          }\n        }, _label2));\n      }\n\n      if ($controls.length > 0) {\n        $controls = [h('div', {\n          staticClass: 'b-form-date-controls d-flex flex-wrap',\n          class: {\n            'justify-content-between': $controls.length > 1,\n            'justify-content-end': $controls.length < 2\n          }\n        }, $controls)];\n      }\n\n      var $calendar = h(BCalendar, {\n        key: 'calendar',\n        ref: 'calendar',\n        staticClass: 'b-form-date-calendar',\n        props: this.calendarProps,\n        on: {\n          selected: this.onSelected,\n          input: this.onInput,\n          context: this.onContext\n        }\n      }, $controls);\n      var $menu = h('div', {\n        ref: 'menu',\n        staticClass: 'dropdown-menu p-2',\n        class: {\n          show: this.visible,\n          'dropdown-menu-right': this.right,\n          'bg-dark': this.dark,\n          'text-light': this.dark\n        },\n        attrs: {\n          id: idMenu,\n          role: 'dialog',\n          'aria-modal': 'false',\n          'aria-labelledby': idLabel\n        },\n        on: {\n          keydown: this.onKeydown // Handle ESC\n\n        }\n      }, [$calendar]);\n      var $hidden = h();\n\n      if (this.name && !disabled) {\n        $hidden = h('input', {\n          attrs: {\n            type: 'hidden',\n            name: this.name,\n            form: this.form,\n            value: localYMD || ''\n          }\n        });\n      }\n\n      return h('div', {\n        staticClass: 'b-form-datepicker form-control dropdown h-auto p-0 d-flex',\n        class: [this.directionClass, (_ref = {\n          show: this.visible,\n          focus: this.hasFocus\n        }, _defineProperty(_ref, \"form-control-\".concat(size), !!size), _defineProperty(_ref, 'is-invalid', state === false), _defineProperty(_ref, 'is-valid', state === true), _ref)],\n        attrs: {\n          id: idWrapper,\n          role: 'group',\n          'aria-disabled': disabled,\n          'aria-readonly': readonly && !disabled,\n          'aria-labelledby': idLabel,\n          'aria-invalid': state === false ? 'true' : null,\n          'aria-required': this.required ? 'true' : null,\n          // We don't want the flex order to change here\n          // So we always use 'ltr'\n          dir: 'ltr'\n        },\n        directives: [{\n          name: 'b-hover',\n          value: this.handleHover\n        }]\n      }, [$button, $hidden, $menu, $input]);\n    }\n  });\n\n  var FormDatepickerPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BFormDatepicker: BFormDatepicker,\n      BDatepicker: BFormDatepicker\n    }\n  });\n\n  // @vue/component\n  var formCustomMixin = {\n    props: {\n      plain: {\n        type: Boolean,\n        default: false\n      }\n    },\n    computed: {\n      custom: function custom() {\n        return !this.plain;\n      }\n    }\n  };\n\n  var NAME$e = 'BFormFile';\n  var VALUE_EMPTY_DEPRECATED_MSG = 'Setting \"value\"/\"v-model\" to an empty string for reset is deprecated. Set to \"null\" instead.'; // @vue/component\n\n  var BFormFile =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$e,\n    mixins: [idMixin, formMixin, formStateMixin, formCustomMixin, normalizeSlotMixin],\n    inheritAttrs: false,\n    model: {\n      prop: 'value',\n      event: 'input'\n    },\n    props: {\n      size: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig('BFormControl', 'size');\n        }\n      },\n      value: {\n        type: [File, Array],\n        default: null,\n        validator: function validator(val) {\n          /* istanbul ignore next */\n          if (val === '') {\n            warn(VALUE_EMPTY_DEPRECATED_MSG, NAME$e);\n            return true;\n          }\n\n          return isUndefinedOrNull(val) || isFile(val) || isArray(val) && (val.length === 0 || val.every(isFile));\n        }\n      },\n      accept: {\n        type: String,\n        default: ''\n      },\n      // Instruct input to capture from camera\n      capture: {\n        type: Boolean,\n        default: false\n      },\n      placeholder: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$e, 'placeholder');\n        }\n      },\n      browseText: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$e, 'browseText');\n        }\n      },\n      dropPlaceholder: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$e, 'dropPlaceholder');\n        }\n      },\n      multiple: {\n        type: Boolean,\n        default: false\n      },\n      directory: {\n        type: Boolean,\n        default: false\n      },\n      noTraverse: {\n        type: Boolean,\n        default: false\n      },\n      noDrop: {\n        type: Boolean,\n        default: false\n      },\n      fileNameFormatter: {\n        type: Function,\n        default: null\n      }\n    },\n    data: function data() {\n      return {\n        selectedFile: null,\n        dragging: false,\n        hasFocus: false\n      };\n    },\n    computed: {\n      selectLabel: function selectLabel() {\n        // Draging active\n        if (this.dragging && this.dropPlaceholder) {\n          return this.dropPlaceholder;\n        } // No file chosen\n\n\n        if (!this.selectedFile || this.selectedFile.length === 0) {\n          return this.placeholder;\n        } // Convert selectedFile to an array (if not already one)\n\n\n        var files = concat(this.selectedFile).filter(identity);\n\n        if (this.hasNormalizedSlot('file-name')) {\n          // There is a slot for formatting the files/names\n          return [this.normalizeSlot('file-name', {\n            files: files,\n            names: files.map(function (f) {\n              return f.name;\n            })\n          })];\n        } else {\n          // Use the user supplied formatter, or the built in one.\n          return isFunction(this.fileNameFormatter) ? toString$1(this.fileNameFormatter(files)) : files.map(function (file) {\n            return file.name;\n          }).join(', ');\n        }\n      }\n    },\n    watch: {\n      selectedFile: function selectedFile(newVal, oldVal) {\n        // The following test is needed when the file input is \"reset\" or the\n        // exact same file(s) are selected to prevent an infinite loop.\n        // When in `multiple` mode we need to check for two empty arrays or\n        // two arrays with identical files\n        if (newVal === oldVal || isArray(newVal) && isArray(oldVal) && newVal.length === oldVal.length && newVal.every(function (v, i) {\n          return v === oldVal[i];\n        })) {\n          return;\n        }\n\n        if (!newVal && this.multiple) {\n          this.$emit('input', []);\n        } else {\n          this.$emit('input', newVal);\n        }\n      },\n      value: function value(newVal) {\n        if (!newVal || isArray(newVal) && newVal.length === 0) {\n          this.reset();\n        }\n      }\n    },\n    methods: {\n      focusHandler: function focusHandler(evt) {\n        // Bootstrap v4 doesn't have focus styling for custom file input\n        // Firefox has a '[type=file]:focus ~ sibling' selector issue,\n        // so we add a 'focus' class to get around these bugs\n        if (this.plain || evt.type === 'focusout') {\n          this.hasFocus = false;\n        } else {\n          // Add focus styling for custom file input\n          this.hasFocus = true;\n        }\n      },\n      reset: function reset() {\n        try {\n          // Wrapped in try in case IE 11 craps out\n          this.$refs.input.value = '';\n        } catch (e) {} // IE 11 doesn't support setting `input.value` to '' or null\n        // So we use this little extra hack to reset the value, just in case.\n        // This also appears to work on modern browsers as well.\n\n\n        this.$refs.input.type = '';\n        this.$refs.input.type = 'file';\n        this.selectedFile = this.multiple ? [] : null;\n      },\n      onFileChange: function onFileChange(evt) {\n        var _this = this;\n\n        // Always emit original event\n        this.$emit('change', evt); // Check if special `items` prop is available on event (drop mode)\n        // Can be disabled by setting no-traverse\n\n        var items = evt.dataTransfer && evt.dataTransfer.items;\n        /* istanbul ignore next: not supported in JSDOM */\n\n        if (items && !this.noTraverse) {\n          var queue = [];\n\n          for (var i = 0; i < items.length; i++) {\n            var item = items[i].webkitGetAsEntry();\n\n            if (item) {\n              queue.push(this.traverseFileTree(item));\n            }\n          }\n\n          Promise.all(queue).then(function (filesArr) {\n            _this.setFiles(from(filesArr));\n          });\n          return;\n        } // Normal handling\n\n\n        this.setFiles(evt.target.files || evt.dataTransfer.files);\n      },\n      setFiles: function setFiles() {\n        var files = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n        if (!files) {\n          /* istanbul ignore next: this will probably not happen */\n          this.selectedFile = null;\n        } else if (this.multiple) {\n          // Convert files to array\n          var filesArray = [];\n\n          for (var i = 0; i < files.length; i++) {\n            filesArray.push(files[i]);\n          } // Return file(s) as array\n\n\n          this.selectedFile = filesArray;\n        } else {\n          // Return single file object\n          this.selectedFile = files[0] || null;\n        }\n      },\n      onReset: function onReset() {\n        // Triggered when the parent form (if any) is reset\n        this.selectedFile = this.multiple ? [] : null;\n      },\n      onDragover: function onDragover(evt)\n      /* istanbul ignore next: difficult to test in JSDOM */\n      {\n        evt.preventDefault();\n        evt.stopPropagation();\n\n        if (this.noDrop || !this.custom) {\n          return;\n        }\n\n        this.dragging = true;\n        evt.dataTransfer.dropEffect = 'copy';\n      },\n      onDragleave: function onDragleave(evt)\n      /* istanbul ignore next: difficult to test in JSDOM */\n      {\n        evt.preventDefault();\n        evt.stopPropagation();\n        this.dragging = false;\n      },\n      onDrop: function onDrop(evt)\n      /* istanbul ignore next: difficult to test in JSDOM */\n      {\n        evt.preventDefault();\n        evt.stopPropagation();\n\n        if (this.noDrop) {\n          return;\n        }\n\n        this.dragging = false;\n\n        if (evt.dataTransfer.files && evt.dataTransfer.files.length > 0) {\n          this.onFileChange(evt);\n        }\n      },\n      traverseFileTree: function traverseFileTree(item, path)\n      /* istanbul ignore next: not supported in JSDOM */\n      {\n        var _this2 = this;\n\n        // Based on http://stackoverflow.com/questions/3590058\n        return new Promise(function (resolve) {\n          path = path || '';\n\n          if (item.isFile) {\n            // Get file\n            item.file(function (file) {\n              file.$path = path; // Inject $path to file obj\n\n              resolve(file);\n            });\n          } else if (item.isDirectory) {\n            // Get folder contents\n            item.createReader().readEntries(function (entries) {\n              var queue = [];\n\n              for (var i = 0; i < entries.length; i++) {\n                queue.push(_this2.traverseFileTree(entries[i], path + item.name + '/'));\n              }\n\n              Promise.all(queue).then(function (filesArr) {\n                resolve(from(filesArr));\n              });\n            });\n          }\n        });\n      }\n    },\n    render: function render(h) {\n      // Form Input\n      var input = h('input', {\n        ref: 'input',\n        class: [{\n          'form-control-file': this.plain,\n          'custom-file-input': this.custom,\n          focus: this.custom && this.hasFocus\n        }, this.stateClass],\n        attrs: _objectSpread2({}, this.$attrs, {\n          type: 'file',\n          id: this.safeId(),\n          name: this.name,\n          disabled: this.disabled,\n          required: this.required,\n          form: this.form || null,\n          capture: this.capture || null,\n          accept: this.accept || null,\n          multiple: this.multiple,\n          webkitdirectory: this.directory,\n          'aria-required': this.required ? 'true' : null\n        }),\n        on: {\n          change: this.onFileChange,\n          focusin: this.focusHandler,\n          focusout: this.focusHandler,\n          reset: this.onReset\n        }\n      });\n\n      if (this.plain) {\n        return input;\n      } // Overlay Labels\n\n\n      var label = h('label', {\n        staticClass: 'custom-file-label',\n        class: [this.dragging ? 'dragging' : null],\n        attrs: {\n          for: this.safeId(),\n          'data-browse': this.browseText || null\n        }\n      }, this.selectLabel); // Return rendered custom file input\n\n      return h('div', {\n        staticClass: 'custom-file b-form-file',\n        class: [this.stateClass, _defineProperty({}, \"b-custom-control-\".concat(this.size), this.size)],\n        attrs: {\n          id: this.safeId('_BV_file_outer_')\n        },\n        on: {\n          dragover: this.onDragover,\n          dragleave: this.onDragleave,\n          drop: this.onDrop\n        }\n      }, [input, label]);\n    }\n  });\n\n  var FormFilePlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BFormFile: BFormFile,\n      BFile: BFormFile\n    }\n  });\n\n  /**\n   * Suffix can be a falsey value so nothing is appended to string.\n   * (helps when looping over props & some shouldn't change)\n   * Use data last parameters to allow for currying.\n   * @param {string} suffix\n   * @param {string} str\n   */\n\n  var suffixPropName = function suffixPropName(suffix, str) {\n    return str + (suffix ? upperFirst(suffix) : '');\n  };\n\n  var RX_COL_CLASS = /^col-/; // Generates a prop object with a type of `[Boolean, String, Number]`\n\n  var boolStrNum = function boolStrNum() {\n    return {\n      type: [Boolean, String, Number],\n      default: false\n    };\n  }; // Generates a prop object with a type of `[String, Number]`\n\n\n  var strNum = function strNum() {\n    return {\n      type: [String, Number],\n      default: null\n    };\n  }; // Compute a breakpoint class name\n\n\n  var computeBreakpoint = function computeBreakpoint(type, breakpoint, val) {\n    var className = type;\n\n    if (isUndefinedOrNull(val) || val === false) {\n      return undefined;\n    }\n\n    if (breakpoint) {\n      className += \"-\".concat(breakpoint);\n    } // Handling the boolean style prop when accepting [Boolean, String, Number]\n    // means Vue will not convert <b-col sm></b-col> to sm: true for us.\n    // Since the default is false, an empty string indicates the prop's presence.\n\n\n    if (type === 'col' && (val === '' || val === true)) {\n      // .col-md\n      return lowerCase(className);\n    } // .order-md-6\n\n\n    className += \"-\".concat(val);\n    return lowerCase(className);\n  }; // Memoized function for better performance on generating class names\n\n\n  var computeBreakpointClass = memoize(computeBreakpoint); // Cached copy of the breakpoint prop names\n\n  var breakpointPropMap = create(null); // Lazy evaled props factory for BCol\n\n  var generateProps = function generateProps() {\n    // Grab the breakpoints from the cached config (exclude the '' (xs) breakpoint)\n    var breakpoints = getBreakpointsUpCached().filter(identity); // Supports classes like: .col-sm, .col-md-6, .col-lg-auto\n\n    var breakpointCol = breakpoints.reduce(function (propMap, breakpoint) {\n      if (breakpoint) {\n        // We filter out the '' breakpoint (xs), as making a prop name ''\n        // would not work. The `cols` prop is used for `xs`\n        propMap[breakpoint] = boolStrNum();\n      }\n\n      return propMap;\n    }, create(null)); // Supports classes like: .offset-md-1, .offset-lg-12\n\n    var breakpointOffset = breakpoints.reduce(function (propMap, breakpoint) {\n      propMap[suffixPropName(breakpoint, 'offset')] = strNum();\n      return propMap;\n    }, create(null)); // Supports classes like: .order-md-1, .order-lg-12\n\n    var breakpointOrder = breakpoints.reduce(function (propMap, breakpoint) {\n      propMap[suffixPropName(breakpoint, 'order')] = strNum();\n      return propMap;\n    }, create(null)); // For loop doesn't need to check hasOwnProperty\n    // when using an object created from null\n\n    breakpointPropMap = assign(create(null), {\n      col: keys(breakpointCol),\n      offset: keys(breakpointOffset),\n      order: keys(breakpointOrder)\n    }); // Return the generated props\n\n    return _objectSpread2({\n      // Generic flexbox .col (xs)\n      col: {\n        type: Boolean,\n        default: false\n      },\n      // .col-[1-12]|auto  (xs)\n      cols: strNum()\n    }, breakpointCol, {\n      offset: strNum()\n    }, breakpointOffset, {\n      order: strNum()\n    }, breakpointOrder, {\n      // Flex alignment\n      alignSelf: {\n        type: String,\n        default: null,\n        validator: function validator(str) {\n          return arrayIncludes(['auto', 'start', 'end', 'center', 'baseline', 'stretch'], str);\n        }\n      },\n      tag: {\n        type: String,\n        default: 'div'\n      }\n    });\n  }; // We do not use Vue.extend here as that would evaluate the props\n  // immediately, which we do not want to happen\n  // @vue/component\n\n\n  var BCol = {\n    name: 'BCol',\n    functional: true,\n\n    get props() {\n      // Allow props to be lazy evaled on first access and\n      // then they become a non-getter afterwards.\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#Smart_self-overwriting_lazy_getters\n      delete this.props; // eslint-disable-next-line no-return-assign\n\n      return this.props = generateProps();\n    },\n\n    render: function render(h, _ref) {\n      var _classList$push;\n\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      var classList = []; // Loop through `col`, `offset`, `order` breakpoint props\n\n      for (var type in breakpointPropMap) {\n        // Returns colSm, offset, offsetSm, orderMd, etc.\n        var _keys = breakpointPropMap[type];\n\n        for (var i = 0; i < _keys.length; i++) {\n          // computeBreakpoint(col, colSm => Sm, value=[String, Number, Boolean])\n          var c = computeBreakpointClass(type, _keys[i].replace(type, ''), props[_keys[i]]); // If a class is returned, push it onto the array.\n\n          if (c) {\n            classList.push(c);\n          }\n        }\n      }\n\n      var hasColClasses = classList.some(function (className) {\n        return RX_COL_CLASS.test(className);\n      });\n      classList.push((_classList$push = {\n        // Default to .col if no other col-{bp}-* classes generated nor `cols` specified.\n        col: props.col || !hasColClasses && !props.cols\n      }, _defineProperty(_classList$push, \"col-\".concat(props.cols), props.cols), _defineProperty(_classList$push, \"offset-\".concat(props.offset), props.offset), _defineProperty(_classList$push, \"order-\".concat(props.order), props.order), _defineProperty(_classList$push, \"align-self-\".concat(props.alignSelf), props.alignSelf), _classList$push));\n      return h(props.tag, a(data, {\n        class: classList\n      }), children);\n    }\n  };\n\n  var NAME$f = 'BFormGroup'; // Selector for finding first input in the form-group\n\n  var SELECTOR$1 = 'input:not([disabled]),textarea:not([disabled]),select:not([disabled])'; // Render helper functions (here rather than polluting the instance with more methods)\n\n  var renderInvalidFeedback = function renderInvalidFeedback(h, ctx) {\n    var content = ctx.normalizeSlot('invalid-feedback') || ctx.invalidFeedback;\n    var invalidFeedback = h();\n\n    if (content) {\n      invalidFeedback = h(BFormInvalidFeedback, {\n        props: {\n          id: ctx.invalidFeedbackId,\n          // If state is explicitly false, always show the feedback\n          state: ctx.computedState,\n          tooltip: ctx.tooltip,\n          ariaLive: ctx.feedbackAriaLive,\n          role: ctx.feedbackAriaLive ? 'alert' : null\n        },\n        attrs: {\n          tabindex: content ? '-1' : null\n        }\n      }, [content]);\n    }\n\n    return invalidFeedback;\n  };\n\n  var renderValidFeedback = function renderValidFeedback(h, ctx) {\n    var content = ctx.normalizeSlot('valid-feedback') || ctx.validFeedback;\n    var validFeedback = h();\n\n    if (content) {\n      validFeedback = h(BFormValidFeedback, {\n        props: {\n          id: ctx.validFeedbackId,\n          // If state is explicitly true, always show the feedback\n          state: ctx.computedState,\n          tooltip: ctx.tooltip,\n          ariaLive: ctx.feedbackAriaLive,\n          role: ctx.feedbackAriaLive ? 'alert' : null\n        },\n        attrs: {\n          tabindex: content ? '-1' : null\n        }\n      }, [content]);\n    }\n\n    return validFeedback;\n  };\n\n  var renderHelpText = function renderHelpText(h, ctx) {\n    // Form help text (description)\n    var content = ctx.normalizeSlot('description') || ctx.description;\n    var description = h();\n\n    if (content) {\n      description = h(BFormText, {\n        attrs: {\n          id: ctx.descriptionId,\n          tabindex: content ? '-1' : null\n        }\n      }, [content]);\n    }\n\n    return description;\n  };\n\n  var renderLabel = function renderLabel(h, ctx) {\n    // Render label/legend inside b-col if necessary\n    var content = ctx.normalizeSlot('label') || ctx.label;\n    var labelFor = ctx.labelFor;\n    var isLegend = !labelFor;\n    var isHorizontal = ctx.isHorizontal;\n    var labelTag = isLegend ? 'legend' : 'label';\n\n    if (!content && !isHorizontal) {\n      return h();\n    } else if (ctx.labelSrOnly) {\n      var label = h();\n\n      if (content) {\n        label = h(labelTag, {\n          class: 'sr-only',\n          attrs: {\n            id: ctx.labelId,\n            for: labelFor || null\n          }\n        }, [content]);\n      }\n\n      return h(isHorizontal ? BCol : 'div', {\n        props: isHorizontal ? ctx.labelColProps : {}\n      }, [label]);\n    } else {\n      return h(isHorizontal ? BCol : labelTag, {\n        on: isLegend ? {\n          click: ctx.legendClick\n        } : {},\n        props: isHorizontal ? _objectSpread2({\n          tag: labelTag\n        }, ctx.labelColProps) : {},\n        attrs: {\n          id: ctx.labelId,\n          for: labelFor || null,\n          // We add a tab index to legend so that screen readers\n          // will properly read the aria-labelledby in IE.\n          tabindex: isLegend ? '-1' : null\n        },\n        class: [// Hide the focus ring on the legend\n        isLegend ? 'bv-no-focus-ring' : '', // When horizontal or if a legend is rendered, add col-form-label\n        // for correct sizing as Bootstrap has inconsistent font styling\n        // for legend in non-horizontal form-groups.\n        // See: https://github.com/twbs/bootstrap/issues/27805\n        isHorizontal || isLegend ? 'col-form-label' : '', // Emulate label padding top of 0 on legend when not horizontal\n        !isHorizontal && isLegend ? 'pt-0' : '', // If not horizontal and not a legend, we add d-block to label\n        // so that label-align works\n        !isHorizontal && !isLegend ? 'd-block' : '', ctx.labelSize ? \"col-form-label-\".concat(ctx.labelSize) : '', ctx.labelAlignClasses, ctx.labelClass]\n      }, [content]);\n    }\n  }; // -- BFormGroup Prop factory -- used for lazy generation of props\n  // Memoize this function to return cached values to\n  // save time in computed functions\n\n\n  var makePropName = memoize(function () {\n    var breakpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var prefix = arguments.length > 1 ? arguments[1] : undefined;\n    return \"\".concat(prefix).concat(upperFirst(breakpoint));\n  }); // BFormGroup prop generator for lazy generation of props\n\n  var generateProps$1 = function generateProps() {\n    var BREAKPOINTS = getBreakpointsUpCached(); // Generate the labelCol breakpoint props\n\n    var bpLabelColProps = BREAKPOINTS.reduce(function (props, breakpoint) {\n      // i.e. label-cols, label-cols-sm, label-cols-md, ...\n      props[makePropName(breakpoint, 'labelCols')] = {\n        type: [Number, String, Boolean],\n        default: breakpoint ? false : null\n      };\n      return props;\n    }, create(null)); // Generate the labelAlign breakpoint props\n\n    var bpLabelAlignProps = BREAKPOINTS.reduce(function (props, breakpoint) {\n      // label-align, label-align-sm, label-align-md, ...\n      props[makePropName(breakpoint, 'labelAlign')] = {\n        type: String,\n        // left, right, center\n        default: null\n      };\n      return props;\n    }, create(null));\n    return _objectSpread2({\n      label: {\n        type: String,\n        default: null\n      },\n      labelFor: {\n        type: String,\n        default: null\n      },\n      labelSize: {\n        type: String,\n        default: null\n      },\n      labelSrOnly: {\n        type: Boolean,\n        default: false\n      }\n    }, bpLabelColProps, {}, bpLabelAlignProps, {\n      labelClass: {\n        type: [String, Array, Object],\n        default: null\n      },\n      description: {\n        type: String,\n        default: null\n      },\n      invalidFeedback: {\n        type: String,\n        default: null\n      },\n      validFeedback: {\n        type: String,\n        default: null\n      },\n      tooltip: {\n        // Enable tooltip style feedback\n        type: Boolean,\n        default: false\n      },\n      feedbackAriaLive: {\n        type: String,\n        default: 'assertive'\n      },\n      validated: {\n        type: Boolean,\n        default: false\n      },\n      disabled: {\n        type: Boolean,\n        default: false\n      }\n    });\n  }; // We do not use Vue.extend here as that would evaluate the props\n  // immediately, which we do not want to happen\n  // @vue/component\n\n\n  var BFormGroup = {\n    name: NAME$f,\n    mixins: [idMixin, formStateMixin, normalizeSlotMixin],\n\n    get props() {\n      // Allow props to be lazy evaled on first access and\n      // then they become a non-getter afterwards.\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#Smart_self-overwriting_lazy_getters\n      delete this.props; // eslint-disable-next-line no-return-assign\n\n      return this.props = generateProps$1();\n    },\n\n    computed: {\n      labelColProps: function labelColProps() {\n        var _this = this;\n\n        var props = {};\n        getBreakpointsUpCached().forEach(function (breakpoint) {\n          // Grab the value if the label column breakpoint prop\n          var propVal = _this[makePropName(breakpoint, 'labelCols')]; // Handle case where the prop's value is an empty string,\n          // which represents true\n\n\n          propVal = propVal === '' ? true : propVal || false;\n\n          if (!isBoolean(propVal) && propVal !== 'auto') {\n            // Convert to column size to number\n            propVal = parseInt(propVal, 10) || 0; // Ensure column size is greater than 0\n\n            propVal = propVal > 0 ? propVal : false;\n          }\n\n          if (propVal) {\n            // Add the prop to the list of props to give to b-col\n            // If breakpoint is '' (labelCols=true), then we use the\n            // col prop to make equal width at xs\n            var bColPropName = breakpoint || (isBoolean(propVal) ? 'col' : 'cols'); // Add it to the props\n\n            props[bColPropName] = propVal;\n          }\n        });\n        return props;\n      },\n      labelAlignClasses: function labelAlignClasses() {\n        var _this2 = this;\n\n        var classes = [];\n        getBreakpointsUpCached().forEach(function (breakpoint) {\n          // Assemble the label column breakpoint align classes\n          var propVal = _this2[makePropName(breakpoint, 'labelAlign')] || null;\n\n          if (propVal) {\n            var className = breakpoint ? \"text-\".concat(breakpoint, \"-\").concat(propVal) : \"text-\".concat(propVal);\n            classes.push(className);\n          }\n        });\n        return classes;\n      },\n      isHorizontal: function isHorizontal() {\n        // Determine if the resultant form-group will be rendered\n        // horizontal (meaning it has label-col breakpoints)\n        return keys(this.labelColProps).length > 0;\n      },\n      labelId: function labelId() {\n        return this.hasNormalizedSlot('label') || this.label ? this.safeId('_BV_label_') : null;\n      },\n      descriptionId: function descriptionId() {\n        return this.hasNormalizedSlot('description') || this.description ? this.safeId('_BV_description_') : null;\n      },\n      hasInvalidFeedback: function hasInvalidFeedback() {\n        // Used for computing aria-describedby\n        return this.computedState === false && (this.hasNormalizedSlot('invalid-feedback') || this.invalidFeedback);\n      },\n      invalidFeedbackId: function invalidFeedbackId() {\n        return this.hasInvalidFeedback ? this.safeId('_BV_feedback_invalid_') : null;\n      },\n      hasValidFeedback: function hasValidFeedback() {\n        // Used for computing aria-describedby\n        return this.computedState === true && (this.hasNormalizedSlot('valid-feedback') || this.validFeedback);\n      },\n      validFeedbackId: function validFeedbackId() {\n        return this.hasValidFeedback ? this.safeId('_BV_feedback_valid_') : null;\n      },\n      describedByIds: function describedByIds() {\n        // Screen readers will read out any content linked to by aria-describedby\n        // even if the content is hidden with `display: none;`, hence we only include\n        // feedback IDs if the form-group's state is explicitly valid or invalid.\n        return [this.descriptionId, this.invalidFeedbackId, this.validFeedbackId].filter(Boolean).join(' ') || null;\n      }\n    },\n    watch: {\n      describedByIds: function describedByIds(add, remove) {\n        if (add !== remove) {\n          this.setInputDescribedBy(add, remove);\n        }\n      }\n    },\n    mounted: function mounted() {\n      var _this3 = this;\n\n      this.$nextTick(function () {\n        // Set the aria-describedby IDs on the input specified by label-for\n        // We do this in a nextTick to ensure the children have finished rendering\n        _this3.setInputDescribedBy(_this3.describedByIds);\n      });\n    },\n    methods: {\n      legendClick: function legendClick(evt) {\n        if (this.labelFor) {\n          // Don't do anything if labelFor is set\n\n          /* istanbul ignore next: clicking a label will focus the input, so no need to test */\n          return;\n        }\n\n        var tagName = evt.target ? evt.target.tagName : '';\n\n        if (/^(input|select|textarea|label|button|a)$/i.test(tagName)) {\n          // If clicked an interactive element inside legend,\n          // we just let the default happen\n\n          /* istanbul ignore next */\n          return;\n        }\n\n        var inputs = selectAll(SELECTOR$1, this.$refs.content).filter(isVisible);\n\n        if (inputs && inputs.length === 1 && inputs[0].focus) {\n          // if only a single input, focus it, emulating label behaviour\n          try {\n            inputs[0].focus();\n          } catch (_unused) {}\n        }\n      },\n      setInputDescribedBy: function setInputDescribedBy(add, remove) {\n        // Sets the `aria-describedby` attribute on the input if label-for is set.\n        // Optionally accepts a string of IDs to remove as the second parameter.\n        // Preserves any aria-describedby value(s) user may have on input.\n        if (this.labelFor && isBrowser) {\n          var input = select(\"#\".concat(this.labelFor), this.$refs.content);\n\n          if (input) {\n            var adb = 'aria-describedby';\n            var ids = (getAttr(input, adb) || '').split(/\\s+/);\n            add = (add || '').split(/\\s+/);\n            remove = (remove || '').split(/\\s+/); // Update ID list, preserving any original IDs\n            // and ensuring the ID's are unique\n\n            ids = ids.filter(function (id) {\n              return !arrayIncludes(remove, id);\n            }).concat(add).filter(Boolean);\n            ids = keys(ids.reduce(function (memo, id) {\n              return _objectSpread2({}, memo, _defineProperty({}, id, true));\n            }, {})).join(' ').trim();\n\n            if (ids) {\n              setAttr(input, adb, ids);\n            } else {\n              // No IDs, so remove the attribute\n              removeAttr(input, adb);\n            }\n          }\n        }\n      }\n    },\n    render: function render(h) {\n      var isFieldset = !this.labelFor;\n      var isHorizontal = this.isHorizontal; // Generate the label\n\n      var label = renderLabel(h, this); // Generate the content\n\n      var content = h(isHorizontal ? BCol : 'div', {\n        ref: 'content',\n        // Hide focus ring\n        staticClass: 'bv-no-focus-ring',\n        attrs: {\n          tabindex: isFieldset ? '-1' : null,\n          role: isFieldset ? 'group' : null\n        }\n      }, [this.normalizeSlot('default') || h(), renderInvalidFeedback(h, this), renderValidFeedback(h, this), renderHelpText(h, this)]); // Create the form-group\n\n      var data = {\n        staticClass: 'form-group',\n        class: [this.validated ? 'was-validated' : null, this.stateClass],\n        attrs: {\n          id: this.safeId(),\n          disabled: isFieldset ? this.disabled : null,\n          role: isFieldset ? null : 'group',\n          'aria-invalid': this.computedState === false ? 'true' : null,\n          // Only apply aria-labelledby if we are a horizontal fieldset\n          // as the legend is no longer a direct child of fieldset\n          'aria-labelledby': isFieldset && isHorizontal ? this.labelId : null,\n          // Only apply aria-describedby IDs if we are a fieldset\n          // as the input will have the IDs when not a fieldset\n          'aria-describedby': isFieldset ? this.describedByIds : null\n        }\n      }; // Return it wrapped in a form-group\n      // Note: Fieldsets do not support adding `row` or `form-row` directly\n      // to them due to browser specific render issues, so we move the `form-row`\n      // to an inner wrapper div when horizontal and using a fieldset\n\n      return h(isFieldset ? 'fieldset' : isHorizontal ? BFormRow : 'div', data, isHorizontal && isFieldset ? [h(BFormRow, [label, content])] : [label, content]);\n    }\n  };\n\n  var FormGroupPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BFormGroup: BFormGroup,\n      BFormFieldset: BFormGroup\n    }\n  });\n\n  var formTextMixin = {\n    model: {\n      prop: 'value',\n      event: 'update'\n    },\n    props: {\n      value: {\n        type: [String, Number],\n        default: ''\n      },\n      ariaInvalid: {\n        type: [Boolean, String],\n        default: false\n      },\n      readonly: {\n        type: Boolean,\n        default: false\n      },\n      plaintext: {\n        type: Boolean,\n        default: false\n      },\n      autocomplete: {\n        type: String,\n        default: null\n      },\n      placeholder: {\n        type: String,\n        default: null\n      },\n      formatter: {\n        type: Function,\n        default: null\n      },\n      lazyFormatter: {\n        type: Boolean,\n        default: false\n      },\n      trim: {\n        type: Boolean,\n        default: false\n      },\n      number: {\n        type: Boolean,\n        default: false\n      },\n      lazy: {\n        // Only update the `v-model` on blur/change events\n        type: Boolean,\n        default: false\n      },\n      debounce: {\n        // Debounce timout (in ms). Not applicable with `lazy` prop\n        type: [Number, String],\n        default: 0\n      }\n    },\n    data: function data() {\n      return {\n        localValue: toString$1(this.value),\n        vModelValue: this.value\n      };\n    },\n    computed: {\n      computedClass: function computedClass() {\n        return [{\n          // Range input needs class `custom-range`\n          'custom-range': this.type === 'range',\n          // `plaintext` not supported by `type=\"range\"` or `type=\"color\"`\n          'form-control-plaintext': this.plaintext && this.type !== 'range' && this.type !== 'color',\n          // `form-control` not used by `type=\"range\"` or `plaintext`\n          // Always used by `type=\"color\"`\n          'form-control': !this.plaintext && this.type !== 'range' || this.type === 'color'\n        }, this.sizeFormClass, this.stateClass];\n      },\n      computedAriaInvalid: function computedAriaInvalid() {\n        if (!this.ariaInvalid || this.ariaInvalid === 'false') {\n          // `this.ariaInvalid` is `null` or `false` or 'false'\n          return this.computedState === false ? 'true' : null;\n        }\n\n        if (this.ariaInvalid === true) {\n          // User wants explicit `:aria-invalid=\"true\"`\n          return 'true';\n        } // Most likely a string value (which could be the string 'true')\n\n\n        return this.ariaInvalid;\n      },\n      computedDebounce: function computedDebounce() {\n        // Ensure we have a positive number equal to or greater than 0\n        return Math.max(toInteger(this.debounce) || 0, 0);\n      },\n      hasFormatter: function hasFormatter() {\n        return isFunction(this.formatter);\n      }\n    },\n    watch: {\n      value: function value(newVal) {\n        var stringifyValue = toString$1(newVal);\n\n        if (stringifyValue !== this.localValue && newVal !== this.vModelValue) {\n          // Clear any pending debounce timeout, as we are overwriting the user input\n          this.clearDebounce(); // Update the local values\n\n          this.localValue = stringifyValue;\n          this.vModelValue = newVal;\n        }\n      }\n    },\n    mounted: function mounted() {\n      // Create non-reactive property and set up destroy handler\n      this.$_inputDebounceTimer = null;\n      this.$on('hook:beforeDestroy', this.clearDebounce); // Preset the internal state\n\n      var value = this.value;\n      var stringifyValue = toString$1(value);\n      /* istanbul ignore next */\n\n      if (stringifyValue !== this.localValue && value !== this.vModelValue) {\n        this.localValue = stringifyValue;\n        this.vModelValue = value;\n      }\n    },\n    methods: {\n      clearDebounce: function clearDebounce() {\n        clearTimeout(this.$_inputDebounceTimer);\n        this.$_inputDebounceTimer = null;\n      },\n      formatValue: function formatValue(value, evt) {\n        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        value = toString$1(value);\n\n        if (this.hasFormatter && (!this.lazyFormatter || force)) {\n          value = this.formatter(value, evt);\n        }\n\n        return value;\n      },\n      modifyValue: function modifyValue(value) {\n        // Emulate `.trim` modifier behaviour\n        if (this.trim) {\n          value = value.trim();\n        } // Emulate `.number` modifier behaviour\n\n\n        if (this.number) {\n          var number = toFloat(value);\n          value = isNaN(number) ? value : number;\n        }\n\n        return value;\n      },\n      updateValue: function updateValue(value) {\n        var _this = this;\n\n        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var lazy = this.lazy;\n\n        if (lazy && !force) {\n          return;\n        }\n\n        value = this.modifyValue(value);\n\n        if (value !== this.vModelValue) {\n          this.clearDebounce();\n\n          var doUpdate = function doUpdate() {\n            _this.vModelValue = value;\n\n            _this.$emit('update', value);\n          };\n\n          var debounce = this.computedDebounce; // Only debounce the value update when a value greater than `0`\n          // is set and we are not in lazy mode or this is a forced update\n\n          if (debounce > 0 && !lazy && !force) {\n            this.$_inputDebounceTimer = setTimeout(doUpdate, debounce);\n          } else {\n            // Immediately update the v-model\n            doUpdate();\n          }\n        } else if (this.hasFormatter) {\n          // When the `vModelValue` hasn't changed but the actual input value\n          // is out of sync, make sure to change it to the given one\n          // Usually caused by browser autocomplete and how it triggers the\n          // change or input event, or depending on the formatter function\n          // https://github.com/bootstrap-vue/bootstrap-vue/issues/2657\n          // https://github.com/bootstrap-vue/bootstrap-vue/issues/3498\n\n          /* istanbul ignore next: hard to test */\n          var $input = this.$refs.input;\n          /* istanbul ignore if: hard to test out of sync value */\n\n          if ($input && value !== $input.value) {\n            $input.value = value;\n          }\n        }\n      },\n      onInput: function onInput(evt) {\n        // `evt.target.composing` is set by Vue\n        // https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/directives/model.js\n        // TODO: Is this needed now with the latest Vue?\n\n        /* istanbul ignore if: hard to test composition events */\n        if (evt.target.composing) {\n          return;\n        }\n\n        var value = evt.target.value;\n        var formattedValue = this.formatValue(value, evt); // Exit when the `formatter` function strictly returned `false`\n        // or prevented the input event\n\n        /* istanbul ignore next */\n\n        if (formattedValue === false || evt.defaultPrevented) {\n          evt.preventDefault();\n          return;\n        }\n\n        this.localValue = formattedValue;\n        this.updateValue(formattedValue);\n        this.$emit('input', formattedValue);\n      },\n      onChange: function onChange(evt) {\n        var value = evt.target.value;\n        var formattedValue = this.formatValue(value, evt); // Exit when the `formatter` function strictly returned `false`\n        // or prevented the input event\n\n        /* istanbul ignore next */\n\n        if (formattedValue === false || evt.defaultPrevented) {\n          evt.preventDefault();\n          return;\n        }\n\n        this.localValue = formattedValue;\n        this.updateValue(formattedValue, true);\n        this.$emit('change', formattedValue);\n      },\n      onBlur: function onBlur(evt) {\n        // Apply the `localValue` on blur to prevent cursor jumps\n        // on mobile browsers (e.g. caused by autocomplete)\n        var value = evt.target.value;\n        var formattedValue = this.formatValue(value, evt, true);\n\n        if (formattedValue !== false) {\n          // We need to use the modified value here to apply the\n          // `.trim` and `.number` modifiers properly\n          this.localValue = toString$1(this.modifyValue(formattedValue)); // We pass the formatted value here since the `updateValue` method\n          // handles the modifiers itself\n\n          this.updateValue(formattedValue, true);\n        } // Emit native blur event\n\n\n        this.$emit('blur', evt);\n      },\n      focus: function focus() {\n        // For external handler that may want a focus method\n        if (!this.disabled) {\n          this.$el.focus();\n        }\n      },\n      blur: function blur() {\n        // For external handler that may want a blur method\n        if (!this.disabled) {\n          this.$el.blur();\n        }\n      }\n    }\n  };\n\n  // @vue/component\n  var formSelectionMixin = {\n    computed: {\n      selectionStart: {\n        // Expose selectionStart for formatters, etc\n        cache: false,\n        get: function get()\n        /* istanbul ignore next */\n        {\n          return this.$refs.input.selectionStart;\n        },\n        set: function set(val)\n        /* istanbul ignore next */\n        {\n          this.$refs.input.selectionStart = val;\n        }\n      },\n      selectionEnd: {\n        // Expose selectionEnd for formatters, etc\n        cache: false,\n        get: function get()\n        /* istanbul ignore next */\n        {\n          return this.$refs.input.selectionEnd;\n        },\n        set: function set(val)\n        /* istanbul ignore next */\n        {\n          this.$refs.input.selectionEnd = val;\n        }\n      },\n      selectionDirection: {\n        // Expose selectionDirection for formatters, etc\n        cache: false,\n        get: function get()\n        /* istanbul ignore next */\n        {\n          return this.$refs.input.selectionDirection;\n        },\n        set: function set(val)\n        /* istanbul ignore next */\n        {\n          this.$refs.input.selectionDirection = val;\n        }\n      }\n    },\n    methods: {\n      select: function select()\n      /* istanbul ignore next */\n      {\n        var _this$$refs$input;\n\n        // For external handler that may want a select() method\n        (_this$$refs$input = this.$refs.input).select.apply(_this$$refs$input, arguments);\n      },\n      setSelectionRange: function setSelectionRange()\n      /* istanbul ignore next */\n      {\n        var _this$$refs$input2;\n\n        // For external handler that may want a setSelectionRange(a,b,c) method\n        (_this$$refs$input2 = this.$refs.input).setSelectionRange.apply(_this$$refs$input2, arguments);\n      },\n      setRangeText: function setRangeText()\n      /* istanbul ignore next */\n      {\n        var _this$$refs$input3;\n\n        // For external handler that may want a setRangeText(a,b,c) method\n        (_this$$refs$input3 = this.$refs.input).setRangeText.apply(_this$$refs$input3, arguments);\n      }\n    }\n  };\n\n  // @vue/component\n  var formValidityMixin = {\n    computed: {\n      validity: {\n        // Expose validity property\n        cache: false,\n        get: function get()\n        /* istanbul ignore next */\n        {\n          return this.$refs.input.validity;\n        }\n      },\n      validationMessage: {\n        // Expose validationMessage property\n        cache: false,\n        get: function get()\n        /* istanbul ignore next */\n        {\n          return this.$refs.input.validationMessage;\n        }\n      },\n      willValidate: {\n        // Expose willValidate property\n        cache: false,\n        get: function get()\n        /* istanbul ignore next */\n        {\n          return this.$refs.input.willValidate;\n        }\n      }\n    },\n    methods: {\n      setCustomValidity: function setCustomValidity()\n      /* istanbul ignore next */\n      {\n        var _this$$refs$input;\n\n        // For external handler that may want a setCustomValidity(...) method\n        return (_this$$refs$input = this.$refs.input).setCustomValidity.apply(_this$$refs$input, arguments);\n      },\n      checkValidity: function checkValidity()\n      /* istanbul ignore next */\n      {\n        var _this$$refs$input2;\n\n        // For external handler that may want a checkValidity(...) method\n        return (_this$$refs$input2 = this.$refs.input).checkValidity.apply(_this$$refs$input2, arguments);\n      },\n      reportValidity: function reportValidity()\n      /* istanbul ignore next */\n      {\n        var _this$$refs$input3;\n\n        // For external handler that may want a reportValidity(...) method\n        return (_this$$refs$input3 = this.$refs.input).reportValidity.apply(_this$$refs$input3, arguments);\n      }\n    }\n  };\n\n  var TYPES = ['text', 'password', 'email', 'number', 'url', 'tel', 'search', 'range', 'color', 'date', 'time', 'datetime', 'datetime-local', 'month', 'week']; // @vue/component\n\n  var BFormInput =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BFormInput',\n    mixins: [idMixin, formMixin, formSizeMixin, formStateMixin, formTextMixin, formSelectionMixin, formValidityMixin],\n    props: {\n      // value prop defined in form-text mixin\n      // value: { },\n      type: {\n        type: String,\n        default: 'text',\n        validator: function validator(type) {\n          return arrayIncludes(TYPES, type);\n        }\n      },\n      noWheel: {\n        // Disable mousewheel to prevent wheel from changing values (i.e. number/date).\n        type: Boolean,\n        default: false\n      },\n      min: {\n        type: [String, Number],\n        default: null\n      },\n      max: {\n        type: [String, Number],\n        default: null\n      },\n      step: {\n        type: [String, Number],\n        default: null\n      },\n      list: {\n        type: String,\n        default: null\n      }\n    },\n    computed: {\n      localType: function localType() {\n        // We only allow certain types\n        return arrayIncludes(TYPES, this.type) ? this.type : 'text';\n      }\n    },\n    watch: {\n      noWheel: function noWheel(newVal) {\n        this.setWheelStopper(newVal);\n      }\n    },\n    mounted: function mounted() {\n      this.setWheelStopper(this.noWheel);\n    },\n    deactivated: function deactivated() {\n      // Turn off listeners when keep-alive component deactivated\n\n      /* istanbul ignore next */\n      this.setWheelStopper(false);\n    },\n    activated: function activated() {\n      // Turn on listeners (if no-wheel) when keep-alive component activated\n\n      /* istanbul ignore next */\n      this.setWheelStopper(this.noWheel);\n    },\n    beforeDestroy: function beforeDestroy() {\n      /* istanbul ignore next */\n      this.setWheelStopper(false);\n    },\n    methods: {\n      setWheelStopper: function setWheelStopper(on) {\n        var input = this.$el; // We use native events, so that we don't interfere with propagation\n\n        eventOnOff(on, input, 'focus', this.onWheelFocus);\n        eventOnOff(on, input, 'blur', this.onWheelBlur);\n\n        if (!on) {\n          eventOff(document, 'wheel', this.stopWheel);\n        }\n      },\n      onWheelFocus: function onWheelFocus() {\n        eventOn(document, 'wheel', this.stopWheel);\n      },\n      onWheelBlur: function onWheelBlur() {\n        eventOff(document, 'wheel', this.stopWheel);\n      },\n      stopWheel: function stopWheel(evt) {\n        evt.preventDefault();\n        this.$el.blur();\n      }\n    },\n    render: function render(h) {\n      var self = this;\n      return h('input', {\n        ref: 'input',\n        class: self.computedClass,\n        directives: [{\n          name: 'model',\n          rawName: 'v-model',\n          value: self.localValue,\n          expression: 'localValue'\n        }],\n        attrs: {\n          id: self.safeId(),\n          name: self.name,\n          form: self.form || null,\n          type: self.localType,\n          disabled: self.disabled,\n          placeholder: self.placeholder,\n          required: self.required,\n          autocomplete: self.autocomplete || null,\n          readonly: self.readonly || self.plaintext,\n          min: self.min,\n          max: self.max,\n          step: self.step,\n          list: self.localType !== 'password' ? self.list : null,\n          'aria-required': self.required ? 'true' : null,\n          'aria-invalid': self.computedAriaInvalid\n        },\n        domProps: {\n          value: self.localValue\n        },\n        on: _objectSpread2({}, self.$listeners, {\n          input: self.onInput,\n          change: self.onChange,\n          blur: self.onBlur\n        })\n      });\n    }\n  });\n\n  var FormInputPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BFormInput: BFormInput,\n      BInput: BFormInput\n    }\n  });\n\n  var props$w = {\n    checked: {\n      // type: [String, Number, Boolean, Object],\n      default: null\n    }\n  }; // @vue/component\n\n  var BFormRadioGroup =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BFormRadioGroup',\n    mixins: [idMixin, formMixin, formRadioCheckGroupMixin, // Includes render function\n    formOptionsMixin, formSizeMixin, formStateMixin],\n    provide: function provide() {\n      return {\n        bvRadioGroup: this\n      };\n    },\n    props: props$w,\n    data: function data() {\n      return {\n        localChecked: this.checked\n      };\n    },\n    computed: {\n      isRadioGroup: function isRadioGroup() {\n        return true;\n      }\n    }\n  });\n\n  var FormRadioPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BFormRadio: BFormRadio,\n      BRadio: BFormRadio,\n      BFormRadioGroup: BFormRadioGroup,\n      BRadioGroup: BFormRadioGroup\n    }\n  });\n\n  var optionsMixin = {\n    mixins: [formOptionsMixin],\n    props: {\n      labelField: {\n        type: String,\n        default: 'label'\n      },\n      optionsField: {\n        type: String,\n        default: 'options'\n      }\n    },\n    methods: {\n      normalizeOption: function normalizeOption(option) {\n        var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        // When the option is an object, normalize it\n        if (isPlainObject(option)) {\n          var value = get(option, this.valueField);\n          var text = get(option, this.textField);\n          var options = get(option, this.optionsField); // When it has options, create an `<optgroup>` object\n\n          if (isArray(options)) {\n            return {\n              label: String(get(option, this.labelField) || text),\n              options: options\n            };\n          } // Otherwise create an `<option>` object\n\n\n          return {\n            value: isUndefined(value) ? key || text : value,\n            text: String(isUndefined(text) ? key : text),\n            html: get(option, this.htmlField),\n            disabled: Boolean(get(option, this.disabledField))\n          };\n        } // Otherwise create an `<option>` object from the given value\n\n\n        return {\n          value: key || option,\n          text: String(option),\n          disabled: false\n        };\n      }\n    }\n  };\n\n  var NAME$g = 'BFormSelectOption';\n  var props$x = {\n    value: {\n      // type: [String, Number, Boolean, Object],\n      required: true\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    }\n  }; // @vue/component\n\n  var BFormSelectOption =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$g,\n    functional: true,\n    props: props$x,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      var value = props.value,\n          disabled = props.disabled;\n      return h('option', a(data, {\n        attrs: {\n          disabled: disabled\n        },\n        domProps: {\n          value: value\n        }\n      }), children);\n    }\n  });\n\n  var BFormSelectOptionGroup =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BFormSelectOptionGroup',\n    mixins: [normalizeSlotMixin, formOptionsMixin],\n    props: {\n      label: {\n        type: String,\n        required: true\n      }\n    },\n    render: function render(h) {\n      return h('optgroup', {\n        attrs: {\n          label: this.label\n        }\n      }, [this.normalizeSlot('first'), this.formOptions.map(function (option, index) {\n        return h(BFormSelectOption, {\n          props: {\n            value: option.value,\n            disabled: option.disabled\n          },\n          domProps: htmlOrText(option.html, option.text),\n          key: \"option_\".concat(index, \"_opt\")\n        });\n      }), this.normalizeSlot('default')]);\n    }\n  });\n\n  var BFormSelect =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BFormSelect',\n    mixins: [idMixin, normalizeSlotMixin, formMixin, formSizeMixin, formStateMixin, formCustomMixin, optionsMixin],\n    model: {\n      prop: 'value',\n      event: 'input'\n    },\n    props: {\n      value: {// type: [Object, Array, String, Number, Boolean],\n        // default: undefined\n      },\n      multiple: {\n        type: Boolean,\n        default: false\n      },\n      selectSize: {\n        // Browsers default size to 0, which shows 4 rows in most browsers in multiple mode\n        // Size of 1 can bork out Firefox\n        type: Number,\n        default: 0\n      },\n      ariaInvalid: {\n        type: [Boolean, String],\n        default: false\n      }\n    },\n    data: function data() {\n      return {\n        localValue: this.value\n      };\n    },\n    computed: {\n      computedSelectSize: function computedSelectSize() {\n        // Custom selects with a size of zero causes the arrows to be hidden,\n        // so dont render the size attribute in this case\n        return !this.plain && this.selectSize === 0 ? null : this.selectSize;\n      },\n      inputClass: function inputClass() {\n        return [this.plain ? 'form-control' : 'custom-select', this.size && this.plain ? \"form-control-\".concat(this.size) : null, this.size && !this.plain ? \"custom-select-\".concat(this.size) : null, this.stateClass];\n      },\n      computedAriaInvalid: function computedAriaInvalid() {\n        if (this.ariaInvalid === true || this.ariaInvalid === 'true') {\n          return 'true';\n        }\n\n        return this.stateClass === 'is-invalid' ? 'true' : null;\n      }\n    },\n    watch: {\n      value: function value(newVal) {\n        this.localValue = newVal;\n      },\n      localValue: function localValue() {\n        this.$emit('input', this.localValue);\n      }\n    },\n    methods: {\n      focus: function focus() {\n        this.$refs.input.focus();\n      },\n      blur: function blur() {\n        this.$refs.input.blur();\n      }\n    },\n    render: function render(h) {\n      var _this = this;\n\n      return h('select', {\n        ref: 'input',\n        class: this.inputClass,\n        directives: [{\n          name: 'model',\n          rawName: 'v-model',\n          value: this.localValue,\n          expression: 'localValue'\n        }],\n        attrs: {\n          id: this.safeId(),\n          name: this.name,\n          form: this.form || null,\n          multiple: this.multiple || null,\n          size: this.computedSelectSize,\n          disabled: this.disabled,\n          required: this.required,\n          'aria-required': this.required ? 'true' : null,\n          'aria-invalid': this.computedAriaInvalid\n        },\n        on: {\n          change: function change(evt) {\n            var target = evt.target;\n            var selectedVal = from(target.options).filter(function (o) {\n              return o.selected;\n            }).map(function (o) {\n              return '_value' in o ? o._value : o.value;\n            });\n            _this.localValue = target.multiple ? selectedVal : selectedVal[0];\n\n            _this.$nextTick(function () {\n              _this.$emit('change', _this.localValue);\n            });\n          }\n        }\n      }, [this.normalizeSlot('first'), this.formOptions.map(function (option, index) {\n        var key = \"option_\".concat(index, \"_opt\");\n        var options = option.options;\n        return isArray(options) ? h(BFormSelectOptionGroup, {\n          props: {\n            label: option.label,\n            options: options\n          },\n          key: key\n        }) : h(BFormSelectOption, {\n          props: {\n            value: option.value,\n            disabled: option.disabled\n          },\n          domProps: htmlOrText(option.html, option.text),\n          key: key\n        });\n      }), this.normalizeSlot('default')]);\n    }\n  });\n\n  var FormSelectPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BFormSelect: BFormSelect,\n      BFormSelectOption: BFormSelectOption,\n      BFormSelectOptionGroup: BFormSelectOptionGroup,\n      BSelect: BFormSelect,\n      BSelectOption: BFormSelectOption,\n      BSelectOptionGroup: BFormSelectOptionGroup\n    }\n  });\n\n  var NAME$h = 'BFormSpinbutton';\n  var UP$1 = KEY_CODES.UP,\n      DOWN$1 = KEY_CODES.DOWN,\n      HOME$1 = KEY_CODES.HOME,\n      END$1 = KEY_CODES.END,\n      PAGEUP$1 = KEY_CODES.PAGEUP,\n      PAGEDOWN$1 = KEY_CODES.PAGEDOWN; // Default for spin button range and step\n\n  var DEFAULT_MIN = 1;\n  var DEFAULT_MAX = 100;\n  var DEFAULT_STEP = 1; // Delay before auto-repeat in ms\n\n  var DEFAULT_REPEAT_DELAY = 500; // Repeat interval in ms\n\n  var DEFAULT_REPEAT_INTERVAL = 100; // Repeat rate increased after number of repeats\n\n  var DEFAULT_REPEAT_THRESHOLD = 10; // Repeat speed multiplier (step multiplier, must be an integer)\n\n  var DEFAULT_REPEAT_MULTIPLIER = 4; // --- Helper functions ---\n\n  var defaultNumber = function defaultNumber(value) {\n    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    value = toFloat(value);\n    return isNaN(value) ? defaultValue : value;\n  };\n\n  var defaultInteger = function defaultInteger(value) {\n    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    value = toInteger(value);\n    return isNaN(value) ? Math.abs(defaultValue) : value;\n  }; // --- BFormSpinbutton ---\n  // @vue/component\n\n\n  var BFormSpinbutton =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$h,\n    mixins: [idMixin],\n    inheritAttrs: false,\n    props: {\n      value: {\n        // Should this really be String, to match native number inputs?\n        type: Number,\n        default: null\n      },\n      min: {\n        type: [Number, String],\n        default: DEFAULT_MIN\n      },\n      max: {\n        type: [Number, String],\n        default: DEFAULT_MAX\n      },\n      step: {\n        type: [Number, String],\n        default: DEFAULT_STEP\n      },\n      wrap: {\n        type: Boolean,\n        default: false\n      },\n      formatterFn: {\n        type: Function // default: null\n\n      },\n      size: {\n        type: String // default: null\n\n      },\n      placeholder: {\n        type: String,\n        default: null\n      },\n      disabled: {\n        type: Boolean,\n        default: false\n      },\n      readonly: {\n        type: Boolean,\n        default: false\n      },\n      required: {\n        // Only affects the `aria-invalid` attribute\n        type: Boolean,\n        default: false\n      },\n      name: {\n        type: String // default: null\n\n      },\n      form: {\n        type: String // default: null\n\n      },\n      state: {\n        // Tri-state prop: `true`, `false`, or `null`\n        type: Boolean,\n        default: null\n      },\n      inline: {\n        type: Boolean,\n        default: false\n      },\n      vertical: {\n        type: Boolean,\n        default: false\n      },\n      ariaLabel: {\n        type: String,\n        default: null\n      },\n      ariaControls: {\n        type: String,\n        default: null\n      },\n      labelDecrement: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$h, 'labelDecrement');\n        }\n      },\n      labelIncrement: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$h, 'labelIncrement');\n        }\n      },\n      locale: {\n        type: [String, Array],\n        default: null\n      },\n      repeatDelay: {\n        type: [Number, String],\n        default: DEFAULT_REPEAT_DELAY\n      },\n      repeatInterval: {\n        type: [Number, String],\n        default: DEFAULT_REPEAT_INTERVAL\n      },\n      repeatThreshold: {\n        type: [Number, String],\n        default: DEFAULT_REPEAT_THRESHOLD\n      },\n      repeatStepMultiplier: {\n        type: [Number, String],\n        default: DEFAULT_REPEAT_MULTIPLIER\n      }\n    },\n    data: function data() {\n      return {\n        localValue: defaultNumber(this.value),\n        hasFocus: false\n      };\n    },\n    computed: {\n      computedStep: function computedStep() {\n        return defaultNumber(this.step, DEFAULT_STEP);\n      },\n      computedMin: function computedMin() {\n        return defaultNumber(this.min, DEFAULT_MIN);\n      },\n      computedMax: function computedMax() {\n        return defaultNumber(this.max, DEFAULT_MAX);\n      },\n      computedDelay: function computedDelay() {\n        return defaultInteger(this.repeatDelay, DEFAULT_REPEAT_DELAY) || DEFAULT_REPEAT_DELAY;\n      },\n      computedInterval: function computedInterval() {\n        return defaultInteger(this.repeatInterval, DEFAULT_REPEAT_INTERVAL) || DEFAULT_REPEAT_INTERVAL;\n      },\n      computedThreshold: function computedThreshold() {\n        return defaultInteger(this.repeatThreshold, DEFAULT_REPEAT_THRESHOLD) || 1;\n      },\n      computedStepMultiplier: function computedStepMultiplier() {\n        return defaultInteger(this.repeatStepMultiplier, DEFAULT_REPEAT_MULTIPLIER) || 1;\n      },\n      computedPrecision: function computedPrecision() {\n        // Quick and dirty way to get the number of decimals\n        var step = this.computedStep;\n        return Math.floor(step) === step ? 0 : (step.toString().split('.')[1] || '').length;\n      },\n      computedMultiplier: function computedMultiplier() {\n        return Math.pow(10, this.computedPrecision || 0);\n      },\n      valueAsFixed: function valueAsFixed() {\n        var value = this.localValue;\n        return isNull(value) ? '' : value.toFixed(this.computedPrecision);\n      },\n      computedLocale: function computedLocale() {\n        var locales = concat(this.locale).filter(identity);\n        var nf = new Intl.NumberFormat(locales);\n        return nf.resolvedOptions().locale;\n      },\n      defaultFormatter: function defaultFormatter() {\n        // Returns and `Intl.NumberFormat` formatter method reference\n        var precision = this.computedPrecision;\n        var nf = new Intl.NumberFormat(this.computedLocale, {\n          style: 'decimal',\n          useGrouping: false,\n          minimumIntegerDigits: 1,\n          minimumFractionDigits: precision,\n          maximumFractionDigits: precision,\n          notation: 'standard'\n        }); // Return the format method reference\n\n        return nf.format;\n      }\n    },\n    watch: {\n      value: function value(_value) {\n        _value = toFloat(_value); // Will be `NaN` if `value` is `null`\n\n        this.localValue = isNaN(_value) ? null : _value;\n      },\n      localValue: function localValue(value) {\n        this.$emit('input', value);\n      },\n      disabled: function disabled(_disabled) {\n        if (_disabled) {\n          this.clearRepeat();\n        }\n      },\n      readonly: function readonly(_readonly) {\n        if (_readonly) {\n          this.clearRepeat();\n        }\n      }\n    },\n    created: function created() {\n      // Create non reactive properties\n      this.$_autoDelayTimer = null;\n      this.$_autoRepeatTimer = null;\n      this.$_keyIsDown = false;\n    },\n    beforeDestroy: function beforeDestroy() {\n      this.clearRepeat();\n    },\n    deactivated: function deactivated()\n    /* istanbul ignore next */\n    {\n      this.clearRepeat();\n    },\n    methods: {\n      // --- Public methods ---\n      focus: function focus() {\n        if (!this.disabled) {\n          try {\n            this.$refs.spinner.focus();\n          } catch (_unused) {}\n        }\n      },\n      blur: function blur() {\n        if (!this.disabled) {\n          try {\n            this.$refs.spinner.blur();\n          } catch (_unused2) {}\n        }\n      },\n      // --- Private methods ---\n      emitChange: function emitChange() {\n        this.$emit('change', this.localValue);\n      },\n      stepValue: function stepValue(direction) {\n        // Sets a new incremented or decremented value, supporting optional wrapping\n        // Direction is either +1 or -1 (or a multiple thereof)\n        var value = this.localValue;\n\n        if (!this.disabled && !isNull(value)) {\n          var step = this.computedStep * direction;\n          var min = this.computedMin;\n          var max = this.computedMax;\n          var multiplier = this.computedMultiplier;\n          var wrap = this.wrap; // We ensure that the value steps like a native input\n\n          value = Math.round((value - min) / step) * step + min + step; // We ensure that precision is maintained (decimals)\n\n          value = Math.round(value * multiplier) / multiplier; // Handle if wrapping is enabled\n\n          this.localValue = value > max ? wrap ? min : max : value < min ? wrap ? max : min : value;\n        }\n      },\n      onFocusBlur: function onFocusBlur(evt) {\n        if (!this.disabled) {\n          this.hasFocus = evt.type === 'focus';\n        } else {\n          this.hasFocus = false;\n        }\n      },\n      stepUp: function stepUp() {\n        var multiplier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        var value = this.localValue;\n\n        if (isNull(value)) {\n          this.localValue = this.computedMin;\n        } else {\n          this.stepValue(+1 * multiplier);\n        }\n      },\n      stepDown: function stepDown() {\n        var multiplier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        var value = this.localValue;\n\n        if (isNull(value)) {\n          this.localValue = this.wrap ? this.computedMax : this.computedMin;\n        } else {\n          this.stepValue(-1 * multiplier);\n        }\n      },\n      onKeydown: function onKeydown(evt) {\n        var keyCode = evt.keyCode,\n            altKey = evt.altKey,\n            ctrlKey = evt.ctrlKey,\n            metaKey = evt.metaKey;\n        /* istanbul ignore if */\n\n        if (this.disabled || this.readonly || altKey || ctrlKey || metaKey) {\n          return;\n        }\n\n        if (arrayIncludes([UP$1, DOWN$1, HOME$1, END$1, PAGEUP$1, PAGEDOWN$1], keyCode)) {\n          // https://w3c.github.io/aria-practices/#spinbutton\n          evt.preventDefault();\n          /* istanbul ignore if */\n\n          if (this.$_keyIsDown) {\n            // Keypress is already in progress\n            return;\n          }\n\n          this.resetTimers();\n\n          if (arrayIncludes([UP$1, DOWN$1], keyCode)) {\n            // The following use the custom auto-repeat handling\n            this.$_keyIsDown = true;\n\n            if (keyCode === UP$1) {\n              this.handleStepRepeat(evt, this.stepUp);\n            } else if (keyCode === DOWN$1) {\n              this.handleStepRepeat(evt, this.stepDown);\n            }\n          } else {\n            // These use native OS key repeating\n            if (keyCode === PAGEUP$1) {\n              this.stepUp(this.computedStepMultiplier);\n            } else if (keyCode === PAGEDOWN$1) {\n              this.stepDown(this.computedStepMultiplier);\n            } else if (keyCode === HOME$1) {\n              this.localValue = this.computedMin;\n            } else if (keyCode === END$1) {\n              this.localValue = this.computedMax;\n            }\n          }\n        }\n      },\n      onKeyup: function onKeyup(evt) {\n        // Emit a change event when the keyup happens\n        var keyCode = evt.keyCode,\n            altKey = evt.altKey,\n            ctrlKey = evt.ctrlKey,\n            metaKey = evt.metaKey;\n        /* istanbul ignore if */\n\n        if (this.disabled || this.readonly || altKey || ctrlKey || metaKey) {\n          return;\n        }\n\n        if (arrayIncludes([UP$1, DOWN$1, HOME$1, END$1, PAGEUP$1, PAGEDOWN$1], keyCode)) {\n          this.resetTimers();\n          this.$_keyIsDown = false;\n          evt.preventDefault();\n          this.emitChange();\n        }\n      },\n      handleStepRepeat: function handleStepRepeat(evt, stepper) {\n        var _this = this;\n\n        var _ref = evt || {},\n            type = _ref.type,\n            button = _ref.button;\n\n        if (!this.disabled && !this.readonly) {\n          /* istanbul ignore if */\n          if (type === 'mousedown' && button) {\n            // We only respond to left (main === 0) button clicks\n            return;\n          }\n\n          this.resetTimers(); // Enable body mouseup event handler\n\n          this.setMouseup(true); // Step the counter initially\n\n          stepper(1);\n          var threshold = this.computedThreshold;\n          var multiplier = this.computedStepMultiplier;\n          var delay = this.computedDelay;\n          var interval = this.computedInterval; // Initiate the delay/repeat interval\n\n          this.$_autoDelayTimer = setTimeout(function () {\n            var count = 0;\n            _this.$_autoRepeatTimer = setInterval(function () {\n              // After N initial repeats, we increase the incrementing step amount\n              // We do this to minimize screen reader announcements of the value\n              // (values are announced every change, which can be chatty for SR users)\n              // And to make it easer to select a value when the range is large\n              stepper(count < threshold ? 1 : multiplier);\n              count++;\n            }, interval);\n          }, delay);\n        }\n      },\n      onMouseup: function onMouseup(evt) {\n        // `<body>` listener, only enabled when mousedown starts\n        var _ref2 = evt || {},\n            type = _ref2.type,\n            button = _ref2.button;\n        /* istanbul ignore if */\n\n\n        if (type === 'mouseup' && button) {\n          // we only care about left (main === 0) mouse button click\n          return;\n        }\n\n        this.resetTimers();\n        this.setMouseup(false); // Trigger the change event\n\n        this.emitChange();\n      },\n      setMouseup: function setMouseup(on) {\n        // Enable or disabled the body mouseup/touchend handlers\n        // Use try/catch to handle case when called server side\n        try {\n          eventOnOff(on, document.body, 'mouseup', this.onMouseup, EVENT_OPTIONS_PASSIVE);\n          eventOnOff(on, document.body, 'touchend', this.onMouseup, EVENT_OPTIONS_PASSIVE);\n        } catch (_unused3) {}\n      },\n      resetTimers: function resetTimers() {\n        clearTimeout(this.$_autoDelayTimer);\n        clearInterval(this.$_autoRepeatTimer);\n      },\n      clearRepeat: function clearRepeat() {\n        this.resetTimers();\n        this.setMouseup(false);\n        this.$_keyIsDown = false;\n      }\n    },\n    render: function render(h) {\n      var _this2 = this,\n          _class;\n\n      var spinId = this.safeId();\n      var value = this.localValue;\n      var isVertical = this.vertical;\n      var isInline = this.inline && !isVertical;\n      var isDisabled = this.disabled;\n      var isReadonly = this.readonly && !isDisabled;\n      var isRequired = this.required && !isReadonly && !isDisabled;\n      var state = this.state;\n      var size = this.size;\n      var hasValue = !isNull(value);\n      var formatter = isFunction(this.formatterFn) ? this.formatterFn : this.defaultFormatter;\n\n      var makeButton = function makeButton(stepper, label, IconCmp, keyRef, shortcut, btnDisabled) {\n        var $icon = h(IconCmp, {\n          props: {\n            scale: _this2.hasFocus ? 1.5 : 1.25\n          },\n          attrs: {\n            'aria-hidden': 'true'\n          }\n        });\n\n        var handler = function handler(evt)\n        /* istanbul ignore next: until tests written */\n        {\n          if (!isDisabled && !isReadonly) {\n            _this2.handleStepRepeat(evt, stepper);\n          }\n        };\n\n        return h('button', {\n          key: keyRef || null,\n          ref: keyRef,\n          staticClass: 'btn btn-sm border-0 rounded-0',\n          class: {\n            'py-0': !isVertical\n          },\n          attrs: {\n            tabindex: '-1',\n            type: 'button',\n            disabled: isDisabled || isReadonly || btnDisabled,\n            'aria-disabled': isDisabled || isReadonly || btnDisabled ? 'true' : null,\n            'aria-controls': spinId,\n            'aria-label': label || null,\n            'aria-keyshortcuts': shortcut || null\n          },\n          on: {\n            mousedown: handler,\n            touchstart: handler\n          }\n        }, [h('div', {}, [$icon])]);\n      }; // TODO: Add button disabled state when `wrap` is `false` and at value max/min\n\n\n      var $increment = makeButton(this.stepUp, this.labelIncrement, BIconPlus, 'inc', 'ArrowUp');\n      var $decrement = makeButton(this.stepDown, this.labelDecrement, BIconDash, 'dec', 'ArrowDown');\n      var $hidden = h();\n\n      if (this.name && !isDisabled) {\n        $hidden = h('input', {\n          key: 'hidden',\n          attrs: {\n            type: 'hidden',\n            name: this.name,\n            form: this.form || null,\n            // TODO: Should this be set to '' if value is out of range?\n            value: this.valueAsFixed\n          }\n        });\n      }\n\n      var $spin = h( // We use 'output' element to make this accept a `<label for=\"id\">` (Except IE)\n      'output', {\n        ref: 'spinner',\n        key: 'output',\n        staticClass: 'flex-grow-1',\n        class: {\n          'w-100': !isVertical && !isInline,\n          'd-flex': isVertical,\n          'align-self-center': !isVertical,\n          'align-items-center': isVertical,\n          'py-1': isVertical,\n          'px-1': !isVertical,\n          'mx-1': isVertical,\n          'border-top': isVertical,\n          'border-bottom': isVertical,\n          'border-left': !isVertical,\n          'border-right': !isVertical\n        },\n        attrs: {\n          id: spinId,\n          role: 'spinbutton',\n          tabindex: isDisabled ? null : '0',\n          'aria-live': 'off',\n          'aria-label': this.ariaLabel || null,\n          'aria-controls': this.ariaControls || null,\n          // TODO: May want to check if the value is in range\n          'aria-invalid': state === false || !hasValue && isRequired ? 'true' : null,\n          'aria-required': isRequired ? 'true' : null,\n          // These attrs are required for role spinbutton\n          'aria-valuemin': toString$1(this.computedMin),\n          'aria-valuemax': toString$1(this.computedMax),\n          // These should be `null` if the value is out of range\n          // They must also be non-existent attrs if the value is out of range or `null`\n          'aria-valuenow': hasValue ? value : null,\n          'aria-valuetext': hasValue ? formatter(value) : null\n        }\n      }, [h('div', {\n        staticClass: 'w-100'\n      }, hasValue ? formatter(value) : this.placeholder || '')]);\n      return h('div', {\n        staticClass: 'b-form-spinbutton form-control p-0',\n        class: (_class = {\n          disabled: isDisabled,\n          readonly: isReadonly,\n          focus: this.hasFocus\n        }, _defineProperty(_class, \"form-control-\".concat(size), !!size), _defineProperty(_class, 'd-inline-flex', isInline || isVertical), _defineProperty(_class, 'd-flex', !isInline && !isVertical), _defineProperty(_class, 'align-items-stretch', !isVertical), _defineProperty(_class, 'flex-column', isVertical), _defineProperty(_class, 'is-valid', state === true), _defineProperty(_class, 'is-invalid', state === false), _class),\n        attrs: _objectSpread2({}, this.$attrs, {\n          role: 'group',\n          lang: this.computedLocale,\n          tabindex: isDisabled ? null : '-1',\n          // We want to keep the order of the buttons regardless\n          // of locale (flex will re-order based on rtl/ltr)\n          dir: 'ltr'\n        }),\n        on: {\n          keydown: this.onKeydown,\n          keyup: this.onKeyup,\n          // We use capture phase (`!` prefix) since focus and blur do not bubble\n          '!focus': this.onFocusBlur,\n          '!blur': this.onFocusBlur\n        }\n      }, isVertical ? [$increment, $hidden, $spin, $decrement] : [$decrement, $hidden, $spin, $increment]);\n    }\n  });\n\n  var FormSpinbuttonPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BFormSpinbutton: BFormSpinbutton,\n      BSpinbutton: BFormSpinbutton\n    }\n  });\n\n  var NAME$i = 'BFormTag';\n  var BFormTag =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$i,\n    mixins: [idMixin, normalizeSlotMixin],\n    props: {\n      variant: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$i, 'variant');\n        }\n      },\n      disabled: {\n        type: Boolean,\n        default: false\n      },\n      title: {\n        type: String,\n        default: null\n      },\n      pill: {\n        type: Boolean,\n        default: false\n      },\n      removeLabel: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$i, 'removeLabel');\n        }\n      },\n      tag: {\n        type: String,\n        default: 'span'\n      }\n    },\n    methods: {\n      onDelete: function onDelete(evt) {\n        var type = evt.type,\n            keyCode = evt.keyCode;\n\n        if (!this.disabled && (type === 'click' || type === 'keydown' && keyCode === KEY_CODES.DELETE)) {\n          this.$emit('remove');\n        }\n      }\n    },\n    render: function render(h) {\n      var tagId = this.safeId();\n      var tagLabelId = this.safeId('_taglabel_');\n      var $remove = h();\n\n      if (!this.disabled) {\n        $remove = h(BButtonClose, {\n          staticClass: 'b-form-tag-remove ml-1',\n          props: {\n            ariaLabel: this.removeLabel\n          },\n          attrs: {\n            'aria-controls': tagId,\n            'aria-describedby': tagLabelId,\n            'aria-keyshortcuts': 'Delete'\n          },\n          on: {\n            click: this.onDelete,\n            keydown: this.onDelete\n          }\n        });\n      }\n\n      var $tag = h('span', {\n        staticClass: 'b-form-tag-content flex-grow-1 text-truncate',\n        attrs: {\n          id: tagLabelId\n        }\n      }, this.normalizeSlot('default') || this.title || [h()]);\n      return h(BBadge, {\n        staticClass: 'b-form-tag d-inline-flex align-items-baseline mw-100',\n        class: {\n          disabled: this.disabled\n        },\n        attrs: {\n          id: tagId,\n          title: this.title || null,\n          'aria-labelledby': tagLabelId\n        },\n        props: {\n          tag: this.tag,\n          variant: this.variant,\n          pill: this.pill\n        }\n      }, [$tag, $remove]);\n    }\n  });\n\n  var NAME$j = 'BFormTags'; // Supported input types (for built in input)\n\n  var TYPES$1 = ['text', 'email', 'tel', 'url', 'number']; // Pre-compiled regular expressions for performance reasons\n\n  var RX_SPACES = /[\\s\\uFEFF\\xA0]+/g; // KeyCode constants\n\n  var ENTER$1 = KEY_CODES.ENTER,\n      BACKSPACE = KEY_CODES.BACKSPACE,\n      DELETE = KEY_CODES.DELETE; // --- Utility methods ---\n  // Escape special chars in string and replace\n  // contiguous spaces with a whitespace match\n\n  var escapeRegExpChars = function escapeRegExpChars(str) {\n    return escapeRegExp(str).replace(RX_SPACES, '\\\\s');\n  }; // Remove leading/trailing spaces from array of tags and remove duplicates\n\n\n  var cleanTags = function cleanTags(tags) {\n    return concat(tags).map(function (tag) {\n      return trim(toString$1(tag));\n    }).filter(function (tag, index, arr) {\n      return tag.length > 0 && arr.indexOf(tag) === index;\n    });\n  }; // Processes an input/change event, normalizing string or event argument\n\n\n  var processEventValue = function processEventValue(evt) {\n    return isString(evt) ? evt : isEvent(evt) ? evt.target.value || '' : '';\n  }; // Returns a fresh empty `tagsState` object\n\n\n  var cleanTagsState = function cleanTagsState() {\n    return {\n      all: [],\n      valid: [],\n      invalid: [],\n      duplicate: []\n    };\n  }; // @vue/component\n\n\n  var BFormTags =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$j,\n    mixins: [idMixin, normalizeSlotMixin],\n    model: {\n      // Even though this is the default that Vue assumes, we need\n      // to add it for the docs to reflect that this is the model\n      prop: 'value',\n      event: 'input'\n    },\n    props: {\n      inputId: {\n        type: String,\n        default: null\n      },\n      placeholder: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$j, 'placeholder');\n        }\n      },\n      disabled: {\n        type: Boolean,\n        default: false\n      },\n      name: {\n        type: String,\n        default: null\n      },\n      form: {\n        type: String,\n        default: null\n      },\n      autofocus: {\n        type: Boolean,\n        default: false\n      },\n      state: {\n        // Tri-state: `true`, `false`, `null`\n        type: Boolean,\n        default: null\n      },\n      size: {\n        type: String,\n        default: null\n      },\n      inputType: {\n        type: String,\n        default: 'text',\n        validator: function validator(type) {\n          return arrayIncludes(TYPES$1, type);\n        }\n      },\n      inputClass: {\n        type: [String, Array, Object],\n        default: null\n      },\n      inputAttrs: {\n        // Additional attributes to add to the input element\n        type: Object,\n        default: function _default() {\n          return {};\n        }\n      },\n      addButtonText: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$j, 'addButtonText');\n        }\n      },\n      addButtonVariant: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$j, 'addButtonVariant');\n        }\n      },\n      tagVariant: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$j, 'tagVariant');\n        }\n      },\n      tagClass: {\n        type: [String, Array, Object],\n        default: null\n      },\n      tagPills: {\n        type: Boolean,\n        default: false\n      },\n      tagRemoveLabel: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$j, 'tagRemoveLabel');\n        }\n      },\n      tagRemovedLabel: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$j, 'tagRemovedLabel');\n        }\n      },\n      tagValidator: {\n        type: Function,\n        default: null\n      },\n      duplicateTagText: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$j, 'duplicateTagText');\n        }\n      },\n      invalidTagText: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$j, 'invalidTagText');\n        }\n      },\n      separator: {\n        // Character (or characters) that trigger adding tags\n        type: [String, Array],\n        default: null\n      },\n      removeOnDelete: {\n        // Enable deleting last tag in list when BACKSPACE is\n        // pressed and input is empty\n        type: Boolean,\n        default: false\n      },\n      addOnChange: {\n        // Enable change event triggering tag addition\n        // Handy if using <select> as the input\n        type: Boolean,\n        default: false\n      },\n      noAddOnEnter: {\n        // Disable ENTER key from triggering tag addition\n        type: Boolean,\n        default: false\n      },\n      noOuterFocus: {\n        // Disable the focus ring on the root element\n        type: Boolean,\n        default: false\n      },\n      value: {\n        // The v-model prop\n        type: Array,\n        default: function _default() {\n          return [];\n        }\n      }\n    },\n    data: function data() {\n      return {\n        hasFocus: false,\n        newTag: '',\n        tags: [],\n        // Tags that were removed\n        removedTags: [],\n        // Populated when tags are parsed\n        tagsState: cleanTagsState()\n      };\n    },\n    computed: {\n      computedInputId: function computedInputId() {\n        return this.inputId || this.safeId('__input__');\n      },\n      computedInputType: function computedInputType() {\n        // We only allow certain types\n        return arrayIncludes(TYPES$1, this.inputType) ? this.inputType : 'text';\n      },\n      computedInputAttrs: function computedInputAttrs() {\n        return _objectSpread2({}, this.inputAttrs, {\n          // Must have attributes\n          id: this.computedInputId,\n          value: this.newTag,\n          disabled: this.disabled || null,\n          form: this.form || null\n        });\n      },\n      computedInputHandlers: function computedInputHandlers() {\n        return {\n          input: this.onInputInput,\n          change: this.onInputChange,\n          keydown: this.onInputKeydown\n        };\n      },\n      computedSeparator: function computedSeparator() {\n        // Merge the array into a string\n        return concat(this.separator).filter(isString).filter(identity).join('');\n      },\n      computedSeparatorRegExp: function computedSeparatorRegExp() {\n        // We use a computed prop here to precompile the RegExp\n        // The RegExp is a character class RE in the form of `/[abc]+/`\n        // where a, b, and c are the valid separator characters\n        // -> `tags = str.split(/[abc]+/).filter(t => t)`\n        var separator = this.computedSeparator;\n        return separator ? new RegExp(\"[\".concat(escapeRegExpChars(separator), \"]+\")) : null;\n      },\n      computedJoiner: function computedJoiner() {\n        // When tag(s) are invalid or duplicate, we leave them\n        // in the input so that the user can see them\n        // If there are more than one tag in the input, we use the\n        // first separator character as the separator in the input\n        // We append a space if the first separator is not a space\n        var joiner = this.computedSeparator.charAt(0);\n        return joiner !== ' ' ? \"\".concat(joiner, \" \") : joiner;\n      },\n      disableAddButton: function disableAddButton() {\n        var _this = this;\n\n        // If 'Add' button should be disabled\n        // If the input contains at least one tag that can\n        // be added, then the 'Add' button should be enabled\n        var newTag = trim(this.newTag);\n        return newTag === '' || !this.splitTags(newTag).some(function (t) {\n          return !arrayIncludes(_this.tags, t) && _this.validateTag(t);\n        });\n      },\n      duplicateTags: function duplicateTags() {\n        return this.tagsState.duplicate;\n      },\n      hasDuplicateTags: function hasDuplicateTags() {\n        return this.duplicateTags.length > 0;\n      },\n      invalidTags: function invalidTags() {\n        return this.tagsState.invalid;\n      },\n      hasInvalidTags: function hasInvalidTags() {\n        return this.invalidTags.length > 0;\n      }\n    },\n    watch: {\n      value: function value(newVal) {\n        this.tags = cleanTags(newVal);\n      },\n      tags: function tags(newVal, oldVal) {\n        // Update the `v-model` (if it differs from the value prop)\n        if (!looseEqual(newVal, this.value)) {\n          this.$emit('input', newVal);\n        }\n\n        if (!looseEqual(newVal, oldVal)) {\n          newVal = concat(newVal).filter(identity);\n          oldVal = concat(oldVal).filter(identity);\n          this.removedTags = oldVal.filter(function (old) {\n            return !arrayIncludes(newVal, old);\n          });\n        }\n      },\n      tagsState: function tagsState(newVal, oldVal) {\n        // Emit a tag-state event when the `tagsState` object changes\n        if (!looseEqual(newVal, oldVal)) {\n          this.$emit('tag-state', newVal.valid, newVal.invalid, newVal.duplicate);\n        }\n      }\n    },\n    created: function created() {\n      // We do this in created to make sure an input event emits\n      // if the cleaned tags are not equal to the value prop\n      this.tags = cleanTags(this.value);\n    },\n    mounted: function mounted() {\n      this.handleAutofocus();\n    },\n    activated: function activated()\n    /* istanbul ignore next */\n    {\n      this.handleAutofocus();\n    },\n    methods: {\n      addTag: function addTag(newTag) {\n        newTag = isString(newTag) ? newTag : this.newTag;\n        /* istanbul ignore next */\n\n        if (this.disabled || trim(newTag) === '') {\n          // Early exit\n          return;\n        }\n\n        var parsed = this.parseTags(newTag); // Add any new tags to the `tags` array, or if the\n        // array of `allTags` is empty, we clear the input\n\n        if (parsed.valid.length > 0 || parsed.all.length === 0) {\n          // Clear the user input element (and leave in any invalid/duplicate tag(s)\n\n          /* istanbul ignore if: full testing to be added later */\n          if (matches(this.getInput(), 'select')) {\n            // The following is needed to properly\n            // work with `<select>` elements\n            this.newTag = '';\n          } else {\n            var invalidAndDuplicates = [].concat(_toConsumableArray(parsed.invalid), _toConsumableArray(parsed.duplicate));\n            this.newTag = parsed.all.filter(function (tag) {\n              return arrayIncludes(invalidAndDuplicates, tag);\n            }).join(this.computedJoiner).concat(invalidAndDuplicates.length > 0 ? this.computedJoiner.charAt(0) : '');\n          }\n        }\n\n        if (parsed.valid.length > 0) {\n          // We add the new tags in one atomic operation\n          // to trigger reactivity once (instead of once per tag)\n          // We do this after we update the new tag input value\n          // `concat()` can be faster than array spread, when both args are arrays\n          this.tags = concat(this.tags, parsed.valid);\n        }\n\n        this.tagsState = parsed; // Attempt to re-focus the input (specifically for when using the Add\n        // button, as the button disappears after successfully adding a tag\n\n        this.focus();\n      },\n      removeTag: function removeTag(tag) {\n        var _this2 = this;\n\n        /* istanbul ignore next */\n        if (this.disabled) {\n          return;\n        } // TODO:\n        //   Add `onRemoveTag(tag)` user method, which if returns `false`\n        //   will prevent the tag from being removed (i.e. confirmation)\n        //   Or emit cancelable `BvEvent`\n\n\n        this.tags = this.tags.filter(function (t) {\n          return t !== tag;\n        }); // Return focus to the input (if possible)\n\n        this.$nextTick(function () {\n          _this2.focus();\n        });\n      },\n      // --- Input element event handlers ---\n      onInputInput: function onInputInput(evt) {\n        /* istanbul ignore next: hard to test composition events */\n        if (this.disabled || isEvent(evt) && evt.target.composing) {\n          // `evt.target.composing` is set by Vue (`v-model` directive)\n          // https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/directives/model.js\n          return;\n        }\n\n        var newTag = processEventValue(evt);\n        var separatorRe = this.computedSeparatorRegExp;\n\n        if (this.newTag !== newTag) {\n          this.newTag = newTag;\n        } // We ignore leading whitespace for the following\n\n\n        newTag = trimLeft(newTag);\n\n        if (separatorRe && separatorRe.test(newTag.slice(-1))) {\n          // A trailing separator character was entered, so add the tag(s)\n          // Note: More than one tag on input event is possible via copy/paste\n          this.addTag();\n        } else {\n          // Validate (parse tags) on input event\n          this.tagsState = newTag === '' ? cleanTagsState() : this.parseTags(newTag);\n        }\n      },\n      onInputChange: function onInputChange(evt) {\n        // Change is triggered on `<input>` blur, or `<select>` selected\n        // This event is opt-in\n        if (!this.disabled && this.addOnChange) {\n          var newTag = processEventValue(evt);\n          /* istanbul ignore next */\n\n          if (this.newTag !== newTag) {\n            this.newTag = newTag;\n          }\n\n          this.addTag();\n        }\n      },\n      onInputKeydown: function onInputKeydown(evt) {\n        // Early exit\n\n        /* istanbul ignore next */\n        if (this.disabled || !isEvent(evt)) {\n          return;\n        }\n\n        var keyCode = evt.keyCode;\n        var value = evt.target.value || '';\n        /* istanbul ignore else: testing to be added later */\n\n        if (!this.noAddOnEnter && keyCode === ENTER$1) {\n          // Attempt to add the tag when user presses enter\n          evt.preventDefault();\n          this.addTag();\n        } else if (this.removeOnDelete && (keyCode === BACKSPACE || keyCode === DELETE) && value === '') {\n          // Remove the last tag if the user pressed backspace/delete and the input is empty\n          evt.preventDefault();\n          this.tags = this.tags.slice(0, -1);\n        }\n      },\n      // --- Wrapper event handlers ---\n      onClick: function onClick(evt) {\n        var _this3 = this;\n\n        if (!this.disabled && isEvent(evt) && evt.target === evt.currentTarget) {\n          this.$nextTick(function () {\n            _this3.focus();\n          });\n        }\n      },\n      onFocusin: function onFocusin() {\n        this.hasFocus = true;\n      },\n      onFocusout: function onFocusout() {\n        this.hasFocus = false;\n      },\n      handleAutofocus: function handleAutofocus() {\n        var _this4 = this;\n\n        this.$nextTick(function () {\n          requestAF(function () {\n            if (_this4.autofocus && !_this4.disabled) {\n              _this4.focus();\n            }\n          });\n        });\n      },\n      // --- Public methods ---\n      focus: function focus() {\n        if (!this.disabled) {\n          try {\n            this.getInput().focus();\n          } catch (_unused) {}\n        }\n      },\n      blur: function blur() {\n        try {\n          this.getInput().blur();\n        } catch (_unused2) {}\n      },\n      // --- Private methods ---\n      splitTags: function splitTags(newTag) {\n        // Split the input into an array of raw tags\n        newTag = toString$1(newTag);\n        var separatorRe = this.computedSeparatorRegExp; // Split the tag(s) via the optional separator\n        // Normally only a single tag is provided, but copy/paste\n        // can enter multiple tags in a single operation\n\n        return (separatorRe ? newTag.split(separatorRe) : [newTag]).map(trim).filter(identity);\n      },\n      parseTags: function parseTags(newTag) {\n        var _this5 = this;\n\n        // Takes `newTag` value and parses it into `validTags`,\n        // `invalidTags`, and duplicate tags as an object\n        // Split the input into raw tags\n        var tags = this.splitTags(newTag); // Base results\n\n        var parsed = {\n          all: tags,\n          valid: [],\n          invalid: [],\n          duplicate: []\n        }; // Parse the unique tags\n\n        tags.forEach(function (tag) {\n          if (arrayIncludes(_this5.tags, tag) || arrayIncludes(parsed.valid, tag)) {\n            // Unique duplicate tags\n            if (!arrayIncludes(parsed.duplicate, tag)) {\n              parsed.duplicate.push(tag);\n            }\n          } else if (_this5.validateTag(tag)) {\n            // We only add unique/valid tags\n            parsed.valid.push(tag);\n          } else {\n            // Unique invalid tags\n            if (!arrayIncludes(parsed.invalid, tag)) {\n              parsed.invalid.push(tag);\n            }\n          }\n        });\n        return parsed;\n      },\n      validateTag: function validateTag(tag) {\n        // Call the user supplied tag validator\n        var validator = this.tagValidator;\n        return isFunction(validator) ? validator(tag) : true;\n      },\n      getInput: function getInput() {\n        // Returns the input element reference (or null if not found)\n        return select(\"#\".concat(this.computedInputId), this.$el);\n      },\n      // Default User Interface render\n      defaultRender: function defaultRender(_ref) {\n        var tags = _ref.tags,\n            addTag = _ref.addTag,\n            removeTag = _ref.removeTag,\n            inputType = _ref.inputType,\n            inputAttrs = _ref.inputAttrs,\n            inputHandlers = _ref.inputHandlers,\n            inputClass = _ref.inputClass,\n            tagClass = _ref.tagClass,\n            tagVariant = _ref.tagVariant,\n            tagPills = _ref.tagPills,\n            tagRemoveLabel = _ref.tagRemoveLabel,\n            invalidTagText = _ref.invalidTagText,\n            duplicateTagText = _ref.duplicateTagText,\n            isInvalid = _ref.isInvalid,\n            isDuplicate = _ref.isDuplicate,\n            disabled = _ref.disabled,\n            placeholder = _ref.placeholder,\n            addButtonText = _ref.addButtonText,\n            addButtonVariant = _ref.addButtonVariant,\n            disableAddButton = _ref.disableAddButton;\n        var h = this.$createElement; // Make the list of tags\n\n        var $tags = tags.map(function (tag) {\n          tag = toString$1(tag);\n          return h(BFormTag, {\n            key: \"li-tag__\".concat(tag),\n            staticClass: 'mt-1 mr-1',\n            class: tagClass,\n            props: {\n              // `BFormTag` will auto generate an ID\n              // so we do not need to set the ID prop\n              tag: 'li',\n              title: tag,\n              disabled: disabled,\n              variant: tagVariant,\n              pill: tagPills,\n              removeLabel: tagRemoveLabel\n            },\n            on: {\n              remove: function remove() {\n                return removeTag(tag);\n              }\n            }\n          }, tag);\n        }); // Feedback IDs if needed\n\n        var invalidFeedbackId = invalidTagText && isInvalid ? this.safeId('__invalid_feedback__') : null;\n        var duplicateFeedbackId = duplicateTagText && isDuplicate ? this.safeId('__duplicate_feedback__') : null; // Compute the `aria-describedby` attribute value\n\n        var ariaDescribedby = [inputAttrs['aria-describedby'], invalidFeedbackId, duplicateFeedbackId].filter(identity).join(' '); // Input\n\n        var $input = h('input', {\n          ref: 'input',\n          // Directive needed to get `evt.target.composing` set (if needed)\n          directives: [{\n            name: 'model',\n            value: inputAttrs.value\n          }],\n          staticClass: 'b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0',\n          class: inputClass,\n          style: {\n            outline: 0,\n            minWidth: '5rem'\n          },\n          attrs: _objectSpread2({}, inputAttrs, {\n            'aria-describedby': ariaDescribedby || null,\n            type: inputType,\n            placeholder: placeholder || null\n          }),\n          domProps: {\n            value: inputAttrs.value\n          },\n          on: inputHandlers\n        }); // Add button\n\n        var $button = h(BButton, {\n          ref: 'button',\n          staticClass: 'b-form-tags-button py-0',\n          class: {\n            // Only show the button if the tag can be added\n            // We use the `invisible` class instead of not rendering\n            // the button, so that we maintain layout to prevent\n            // the user input from jumping around\n            invisible: disableAddButton\n          },\n          style: {\n            fontSize: '90%'\n          },\n          props: {\n            variant: addButtonVariant,\n            disabled: disableAddButton\n          },\n          on: {\n            click: function click() {\n              return addTag();\n            }\n          }\n        }, [this.normalizeSlot('add-button-text') || addButtonText]); // ID of the tags+input `<ul>` list\n        // Note we could concatenate inputAttrs.id with `__TAG__LIST__`\n        // But note that the inputID may be null until after mount\n        // `safeId` returns `null`, if no user provided ID, until after\n        // mount when a unique ID is generated\n\n        var tagListId = this.safeId('__TAG__LIST__');\n        var $field = h('li', {\n          key: '__li-input__',\n          staticClass: 'flex-grow-1 mt-1',\n          attrs: {\n            role: 'none',\n            'aria-live': 'off',\n            'aria-controls': tagListId\n          }\n        }, [h('div', {\n          staticClass: 'd-flex',\n          attrs: {\n            role: 'group'\n          }\n        }, [$input, $button])]); // Wrap in an unordered list element (we use a list for accessibility)\n\n        var $ul = h('ul', {\n          key: '_tags_list_',\n          staticClass: 'list-unstyled mt-n1 mb-0 d-flex flex-wrap align-items-center',\n          attrs: {\n            id: tagListId\n          }\n        }, // `concat()` is faster than array spread when args are known to be arrays\n        concat($tags, $field)); // Assemble the feedback\n\n        var $feedback = h();\n\n        if (invalidTagText || duplicateTagText) {\n          // Add an aria live region for the invalid/duplicate tag\n          // messages if the user has not disabled the messages\n          var joiner = this.computedJoiner; // Invalid tag feedback if needed (error)\n\n          var $invalid = h();\n\n          if (invalidFeedbackId) {\n            $invalid = h(BFormInvalidFeedback, {\n              key: '_tags_invalid_feedback_',\n              props: {\n                id: invalidFeedbackId,\n                forceShow: true\n              }\n            }, [this.invalidTagText, ': ', this.invalidTags.join(joiner)]);\n          } // Duplicate tag feedback if needed (warning, not error)\n\n\n          var $duplicate = h();\n\n          if (duplicateFeedbackId) {\n            $duplicate = h(BFormText, {\n              key: '_tags_duplicate_feedback_',\n              props: {\n                id: duplicateFeedbackId\n              }\n            }, [this.duplicateTagText, ': ', this.duplicateTags.join(joiner)]);\n          }\n\n          $feedback = h('div', {\n            key: '_tags_feedback_',\n            attrs: {\n              'aria-live': 'polite',\n              'aria-atomic': 'true'\n            }\n          }, [$invalid, $duplicate]);\n        } // Return the content\n\n\n        return [$ul, $feedback];\n      }\n    },\n    render: function render(h) {\n      var _this6 = this;\n\n      // Scoped slot properties\n      var scope = {\n        // Array of tags (shallow copy to prevent mutations)\n        tags: this.tags.slice(),\n        // Methods\n        removeTag: this.removeTag,\n        addTag: this.addTag,\n        // We don't include this in the attrs, as users may want to override this\n        inputType: this.computedInputType,\n        // <input> v-bind:inputAttrs\n        inputAttrs: this.computedInputAttrs,\n        // <input> v-on:inputHandlers\n        inputHandlers: this.computedInputHandlers,\n        // <input> :id=\"inputId\"\n        inputId: this.computedInputId,\n        // Invalid/Duplicate state information\n        invalidTags: this.invalidTags.slice(),\n        isInvalid: this.hasInvalidTags,\n        duplicateTags: this.duplicateTags.slice(),\n        isDuplicate: this.hasDuplicateTags,\n        // If the 'Add' button should be disabled\n        disableAddButton: this.disableAddButton,\n        // Pass-though values\n        state: this.state,\n        separator: this.separator,\n        disabled: this.disabled,\n        size: this.size,\n        placeholder: this.placeholder,\n        inputClass: this.inputClass,\n        tagRemoveLabel: this.tagRemoveLabel,\n        tagVariant: this.tagVariant,\n        tagPills: this.tagPills,\n        tagClass: this.tagClass,\n        addButtonText: this.addButtonText,\n        addButtonVariant: this.addButtonVariant,\n        invalidTagText: this.invalidTagText,\n        duplicateTagText: this.duplicateTagText\n      }; // Generate the user interface\n\n      var $content = this.normalizeSlot('default', scope) || this.defaultRender(scope); // Generate the `aria-live` region for the current value(s)\n\n      var $output = h('output', {\n        staticClass: 'sr-only',\n        attrs: {\n          id: this.safeId('_selected-tags_'),\n          role: 'status',\n          for: this.computedInputId,\n          'aria-live': this.hasFocus ? 'polite' : 'off',\n          'aria-atomic': 'true',\n          'aria-relevant': 'additions text'\n        }\n      }, this.tags.join(', ')); // Removed tag live region\n\n      var $removed = h('div', {\n        staticClass: 'sr-only',\n        attrs: {\n          id: this.safeId('_removed-tags_'),\n          role: 'status',\n          'aria-live': this.hasFocus ? 'assertive' : 'off',\n          'aria-atomic': 'true'\n        }\n      }, this.removedTags.length > 0 ? \"(\".concat(this.tagRemovedLabel, \") \").concat(this.removedTags.join(', ')) : ''); // Add hidden inputs for form submission\n\n      var $hidden = h();\n\n      if (this.name && !this.disabled) {\n        // We add hidden inputs for each tag if a name is provided\n        // for native submission of forms\n        $hidden = this.tags.map(function (tag) {\n          return h('input', {\n            key: tag,\n            attrs: {\n              type: 'hidden',\n              value: tag,\n              name: _this6.name,\n              form: _this6.form || null\n            }\n          });\n        });\n      } // Return the rendered output\n\n\n      return h('div', {\n        staticClass: 'b-form-tags form-control h-auto',\n        class: _defineProperty({\n          focus: this.hasFocus && !this.noOuterFocus && !this.disabled,\n          disabled: this.disabled,\n          'is-valid': this.state === true,\n          'is-invalid': this.state === false\n        }, \"form-control-\".concat(this.size), this.size),\n        attrs: {\n          id: this.safeId(),\n          role: 'group',\n          tabindex: this.disabled || this.noOuterFocus ? null : '-1',\n          'aria-describedby': this.safeId('_selected_')\n        },\n        on: {\n          focusin: this.onFocusin,\n          focusout: this.onFocusout,\n          click: this.onClick\n        }\n      }, concat($output, $removed, $content, $hidden));\n    }\n  });\n\n  var FormTagsPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BFormTags: BFormTags,\n      BTags: BFormTags,\n      BFormTag: BFormTag,\n      BTag: BFormTag\n    }\n  });\n\n  var BFormTextarea =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BFormTextarea',\n    directives: {\n      'b-visible': VBVisible\n    },\n    mixins: [idMixin, listenOnRootMixin, formMixin, formSizeMixin, formStateMixin, formTextMixin, formSelectionMixin, formValidityMixin],\n    props: {\n      rows: {\n        type: [Number, String],\n        default: 2\n      },\n      maxRows: {\n        type: [Number, String],\n        default: null\n      },\n      wrap: {\n        // 'soft', 'hard' or 'off'. Browser default is 'soft'\n        type: String,\n        default: 'soft'\n      },\n      noResize: {\n        // Disable the resize handle of textarea\n        type: Boolean,\n        default: false\n      },\n      noAutoShrink: {\n        // When in auto resize mode, disable shrinking to content height\n        type: Boolean,\n        default: false\n      }\n    },\n    data: function data() {\n      return {\n        heightInPx: null\n      };\n    },\n    computed: {\n      computedStyle: function computedStyle() {\n        var styles = {\n          // Setting `noResize` to true will disable the ability for the user to\n          // manually resize the textarea. We also disable when in auto height mode\n          resize: !this.computedRows || this.noResize ? 'none' : null\n        };\n\n        if (!this.computedRows) {\n          // Conditionally set the computed CSS height when auto rows/height is enabled\n          // We avoid setting the style to `null`, which can override user manual resize handle\n          styles.height = this.heightInPx; // We always add a vertical scrollbar to the textarea when auto-height is\n          // enabled so that the computed height calculation returns a stable value\n\n          styles.overflowY = 'scroll';\n        }\n\n        return styles;\n      },\n      computedMinRows: function computedMinRows() {\n        // Ensure rows is at least 2 and positive (2 is the native textarea value)\n        // A value of 1 can cause issues in some browsers, and most browsers\n        // only support 2 as the smallest value\n        return Math.max(parseInt(this.rows, 10) || 2, 2);\n      },\n      computedMaxRows: function computedMaxRows() {\n        return Math.max(this.computedMinRows, parseInt(this.maxRows, 10) || 0);\n      },\n      computedRows: function computedRows() {\n        // This is used to set the attribute 'rows' on the textarea\n        // If auto-height is enabled, then we return `null` as we use CSS to control height\n        return this.computedMinRows === this.computedMaxRows ? this.computedMinRows : null;\n      }\n    },\n    watch: {\n      localValue: function localValue() {\n        this.setHeight();\n      }\n    },\n    mounted: function mounted() {\n      this.setHeight();\n    },\n    methods: {\n      // Called by intersection observer directive\n      visibleCallback: function visibleCallback(visible)\n      /* istanbul ignore next */\n      {\n        if (visible) {\n          // We use a `$nextTick()` here just to make sure any\n          // transitions or portalling have completed\n          this.$nextTick(this.setHeight);\n        }\n      },\n      setHeight: function setHeight() {\n        var _this = this;\n\n        this.$nextTick(function () {\n          requestAF(function () {\n            _this.heightInPx = _this.computeHeight();\n          });\n        });\n      },\n      computeHeight: function computeHeight()\n      /* istanbul ignore next: can't test getComputedStyle in JSDOM */\n      {\n        if (this.$isServer || !isNull(this.computedRows)) {\n          return null;\n        }\n\n        var el = this.$el; // Element must be visible (not hidden) and in document\n        // Must be checked after above checks\n\n        if (!isVisible(el)) {\n          return null;\n        } // Get current computed styles\n\n\n        var computedStyle = getCS(el); // Height of one line of text in px\n\n        var lineHeight = parseFloat(computedStyle.lineHeight); // Calculate height of border and padding\n\n        var border = (parseFloat(computedStyle.borderTopWidth) || 0) + (parseFloat(computedStyle.borderBottomWidth) || 0);\n        var padding = (parseFloat(computedStyle.paddingTop) || 0) + (parseFloat(computedStyle.paddingBottom) || 0); // Calculate offset\n\n        var offset = border + padding; // Minimum height for min rows (which must be 2 rows or greater for cross-browser support)\n\n        var minHeight = lineHeight * this.computedMinRows + offset; // Get the current style height (with `px` units)\n\n        var oldHeight = el.style.height || computedStyle.height; // Probe scrollHeight by temporarily changing the height to `auto`\n\n        el.style.height = 'auto';\n        var scrollHeight = el.scrollHeight; // Place the original old height back on the element, just in case `computedProp`\n        // returns the same value as before\n\n        el.style.height = oldHeight; // Calculate content height in 'rows' (scrollHeight includes padding but not border)\n\n        var contentRows = Math.max((scrollHeight - padding) / lineHeight, 2); // Calculate number of rows to display (limited within min/max rows)\n\n        var rows = Math.min(Math.max(contentRows, this.computedMinRows), this.computedMaxRows); // Calculate the required height of the textarea including border and padding (in pixels)\n\n        var height = Math.max(Math.ceil(rows * lineHeight + offset), minHeight); // Computed height remains the larger of `oldHeight` and new `height`,\n        // when height is in `sticky` mode (prop `no-auto-shrink` is true)\n\n        if (this.noAutoShrink && (parseFloat(oldHeight) || 0) > height) {\n          return oldHeight;\n        } // Return the new computed CSS height in px units\n\n\n        return \"\".concat(height, \"px\");\n      }\n    },\n    render: function render(h) {\n      // Using self instead of this helps reduce code size during minification\n      var self = this;\n      return h('textarea', {\n        ref: 'input',\n        class: self.computedClass,\n        style: self.computedStyle,\n        directives: [{\n          name: 'model',\n          value: self.localValue\n        }, {\n          name: 'b-visible',\n          value: this.visibleCallback,\n          // If textarea is within 640px of viewport, consider it visible\n          modifiers: {\n            '640': true\n          }\n        }],\n        attrs: {\n          id: self.safeId(),\n          name: self.name,\n          form: self.form || null,\n          disabled: self.disabled,\n          placeholder: self.placeholder,\n          required: self.required,\n          autocomplete: self.autocomplete || null,\n          readonly: self.readonly || self.plaintext,\n          rows: self.computedRows,\n          wrap: self.wrap || null,\n          'aria-required': self.required ? 'true' : null,\n          'aria-invalid': self.computedAriaInvalid\n        },\n        domProps: {\n          value: self.localValue\n        },\n        on: _objectSpread2({}, self.$listeners, {\n          input: self.onInput,\n          change: self.onChange,\n          blur: self.onBlur\n        })\n      });\n    }\n  });\n\n  var FormTextareaPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BFormTextarea: BFormTextarea,\n      BTextarea: BFormTextarea\n    }\n  });\n\n  var ImagePlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BImg: BImg,\n      BImgLazy: BImgLazy\n    }\n  });\n\n  var props$y = {\n    tag: {\n      type: String,\n      default: 'div'\n    }\n  }; // @vue/component\n\n  var BInputGroupText =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BInputGroupText',\n    functional: true,\n    props: props$y,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h(props.tag, a(data, {\n        staticClass: 'input-group-text'\n      }), children);\n    }\n  });\n\n  var commonProps = {\n    id: {\n      type: String,\n      default: null\n    },\n    tag: {\n      type: String,\n      default: 'div'\n    },\n    isText: {\n      type: Boolean,\n      default: false\n    }\n  }; // @vue/component\n\n  var BInputGroupAddon =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BInputGroupAddon',\n    functional: true,\n    props: _objectSpread2({}, commonProps, {\n      append: {\n        type: Boolean,\n        default: false\n      }\n    }),\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h(props.tag, a(data, {\n        class: {\n          'input-group-append': props.append,\n          'input-group-prepend': !props.append\n        },\n        attrs: {\n          id: props.id\n        }\n      }), props.isText ? [h(BInputGroupText, children)] : children);\n    }\n  });\n\n  var BInputGroupPrepend =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BInputGroupPrepend',\n    functional: true,\n    props: commonProps,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      // pass all our props/attrs down to child, and set`append` to false\n      return h(BInputGroupAddon, a(data, {\n        props: _objectSpread2({}, props, {\n          append: false\n        })\n      }), children);\n    }\n  });\n\n  var BInputGroupAppend =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BInputGroupAppend',\n    functional: true,\n    props: commonProps,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      // pass all our props/attrs down to child, and set`append` to true\n      return h(BInputGroupAddon, a(data, {\n        props: _objectSpread2({}, props, {\n          append: true\n        })\n      }), children);\n    }\n  });\n\n  var NAME$k = 'BInputGroup';\n  var props$z = {\n    id: {\n      type: String\n    },\n    size: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$k, 'size');\n      }\n    },\n    prepend: {\n      type: String\n    },\n    prependHtml: {\n      type: String\n    },\n    append: {\n      type: String\n    },\n    appendHtml: {\n      type: String\n    },\n    tag: {\n      type: String,\n      default: 'div'\n    }\n  }; // @vue/component\n\n  var BInputGroup =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$k,\n    functional: true,\n    props: props$z,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          slots = _ref.slots,\n          scopedSlots = _ref.scopedSlots;\n      var $slots = slots();\n      var $scopedSlots = scopedSlots || {};\n      var childNodes = []; // Prepend prop/slot\n\n      if (props.prepend || props.prependHtml || hasNormalizedSlot('prepend', $scopedSlots, $slots)) {\n        childNodes.push(h(BInputGroupPrepend, [// Prop\n        props.prepend || props.prependHtml ? h(BInputGroupText, {\n          domProps: htmlOrText(props.prependHtml, props.prepend)\n        }) : h(), // Slot\n        normalizeSlot('prepend', {}, $scopedSlots, $slots) || h()]));\n      } else {\n        childNodes.push(h());\n      } // Default slot\n\n\n      if (hasNormalizedSlot('default', $scopedSlots, $slots)) {\n        childNodes.push.apply(childNodes, _toConsumableArray(normalizeSlot('default', {}, $scopedSlots, $slots)));\n      } else {\n        childNodes.push(h());\n      } // Append prop\n\n\n      if (props.append || props.appendHtml || hasNormalizedSlot('append', $scopedSlots, $slots)) {\n        childNodes.push(h(BInputGroupAppend, [// prop\n        props.append || props.appendHtml ? h(BInputGroupText, {\n          domProps: htmlOrText(props.appendHtml, props.append)\n        }) : h(), // Slot\n        normalizeSlot('append', {}, $scopedSlots, $slots) || h()]));\n      } else {\n        childNodes.push(h());\n      }\n\n      return h(props.tag, a(data, {\n        staticClass: 'input-group',\n        class: _defineProperty({}, \"input-group-\".concat(props.size), props.size),\n        attrs: {\n          id: props.id || null,\n          role: 'group'\n        }\n      }), childNodes);\n    }\n  });\n\n  var InputGroupPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BInputGroup: BInputGroup,\n      BInputGroupAddon: BInputGroupAddon,\n      BInputGroupPrepend: BInputGroupPrepend,\n      BInputGroupAppend: BInputGroupAppend,\n      BInputGroupText: BInputGroupText\n    }\n  });\n\n  var props$A = {\n    tag: {\n      type: String,\n      default: 'div'\n    },\n    fluid: {\n      // String breakpoint name new in Bootstrap v4.4.x\n      type: [Boolean, String],\n      default: false\n    }\n  }; // @vue/component\n\n  var BContainer =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BContainer',\n    functional: true,\n    props: props$A,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h(props.tag, a(data, {\n        class: _defineProperty({\n          container: !(props.fluid || props.fluid === ''),\n          'container-fluid': props.fluid === true || props.fluid === ''\n        }, \"container-\".concat(props.fluid), props.fluid && props.fluid !== true)\n      }), children);\n    }\n  });\n\n  var NAME$l = 'BJumbotron';\n  var props$B = {\n    fluid: {\n      type: Boolean,\n      default: false\n    },\n    containerFluid: {\n      type: [Boolean, String],\n      default: false\n    },\n    header: {\n      type: String,\n      default: null\n    },\n    headerHtml: {\n      type: String,\n      default: null\n    },\n    headerTag: {\n      type: String,\n      default: 'h1'\n    },\n    headerLevel: {\n      type: [Number, String],\n      default: '3'\n    },\n    lead: {\n      type: String,\n      default: null\n    },\n    leadHtml: {\n      type: String,\n      default: null\n    },\n    leadTag: {\n      type: String,\n      default: 'p'\n    },\n    tag: {\n      type: String,\n      default: 'div'\n    },\n    bgVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$l, 'bgVariant');\n      }\n    },\n    borderVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$l, 'borderVariant');\n      }\n    },\n    textVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$l, 'textVariant');\n      }\n    }\n  }; // @vue/component\n\n  var BJumbotron =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$l,\n    functional: true,\n    props: props$B,\n    render: function render(h, _ref) {\n      var _class2;\n\n      var props = _ref.props,\n          data = _ref.data,\n          slots = _ref.slots,\n          scopedSlots = _ref.scopedSlots;\n      // The order of the conditionals matter.\n      // We are building the component markup in order.\n      var childNodes = [];\n      var $slots = slots();\n      var $scopedSlots = scopedSlots || {}; // Header\n\n      if (props.header || hasNormalizedSlot('header', $scopedSlots, $slots) || props.headerHtml) {\n        childNodes.push(h(props.headerTag, {\n          class: _defineProperty({}, \"display-\".concat(props.headerLevel), props.headerLevel)\n        }, normalizeSlot('header', {}, $scopedSlots, $slots) || props.headerHtml || stripTags(props.header)));\n      } // Lead\n\n\n      if (props.lead || hasNormalizedSlot('lead', $scopedSlots, $slots) || props.leadHtml) {\n        childNodes.push(h(props.leadTag, {\n          staticClass: 'lead'\n        }, normalizeSlot('lead', {}, $scopedSlots, $slots) || props.leadHtml || stripTags(props.lead)));\n      } // Default slot\n\n\n      if (hasNormalizedSlot('default', $scopedSlots, $slots)) {\n        childNodes.push(normalizeSlot('default', {}, $scopedSlots, $slots));\n      } // If fluid, wrap content in a container/container-fluid\n\n\n      if (props.fluid) {\n        // Children become a child of a container\n        childNodes = [h(BContainer, {\n          props: {\n            fluid: props.containerFluid\n          }\n        }, childNodes)];\n      } // Return the jumbotron\n\n\n      return h(props.tag, a(data, {\n        staticClass: 'jumbotron',\n        class: (_class2 = {\n          'jumbotron-fluid': props.fluid\n        }, _defineProperty(_class2, \"text-\".concat(props.textVariant), props.textVariant), _defineProperty(_class2, \"bg-\".concat(props.bgVariant), props.bgVariant), _defineProperty(_class2, \"border-\".concat(props.borderVariant), props.borderVariant), _defineProperty(_class2, \"border\", props.borderVariant), _class2)\n      }), childNodes);\n    }\n  });\n\n  var JumbotronPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BJumbotron: BJumbotron\n    }\n  });\n\n  var COMMON_ALIGNMENT = ['start', 'end', 'center']; // Generates a prop object with a type of `[String, Number]`\n\n  var strNum$1 = function strNum() {\n    return {\n      type: [String, Number],\n      default: null\n    };\n  }; // Compute a `row-cols-{breakpoint}-{cols}` class name\n  // Memoized function for better performance on generating class names\n\n\n  var computeRowColsClass = memoize(function (breakpoint, cols) {\n    cols = trim(toString$1(cols));\n    return cols ? lowerCase(['row-cols', breakpoint, cols].filter(identity).join('-')) : null;\n  }); // Get the breakpoint name from the `rowCols` prop name\n  // Memoized function for better performance on extracting breakpoint names\n\n  var computeRowColsBreakpoint = memoize(function (prop) {\n    return lowerCase(prop.replace('cols', ''));\n  }); // Cached copy of the `row-cols` breakpoint prop names\n  // Will be populated when the props are generated\n\n  var rowColsPropList = []; // Lazy evaled props factory for <b-row> (called only once,\n  // the first time the component is used)\n\n  var generateProps$2 = function generateProps() {\n    // Grab the breakpoints from the cached config (including the '' (xs) breakpoint)\n    var breakpoints = getBreakpointsUpCached(); // Supports classes like: `row-cols-2`, `row-cols-md-4`, `row-cols-xl-6`\n\n    var rowColsProps = breakpoints.reduce(function (props, breakpoint) {\n      props[suffixPropName(breakpoint, 'cols')] = strNum$1();\n      return props;\n    }, create(null)); // Cache the row-cols prop names\n\n    rowColsPropList = keys(rowColsProps); // Return the generated props\n\n    return _objectSpread2({\n      tag: {\n        type: String,\n        default: 'div'\n      },\n      noGutters: {\n        type: Boolean,\n        default: false\n      },\n      alignV: {\n        type: String,\n        default: null,\n        validator: function validator(str) {\n          return arrayIncludes(COMMON_ALIGNMENT.concat(['baseline', 'stretch']), str);\n        }\n      },\n      alignH: {\n        type: String,\n        default: null,\n        validator: function validator(str) {\n          return arrayIncludes(COMMON_ALIGNMENT.concat(['between', 'around']), str);\n        }\n      },\n      alignContent: {\n        type: String,\n        default: null,\n        validator: function validator(str) {\n          return arrayIncludes(COMMON_ALIGNMENT.concat(['between', 'around', 'stretch']), str);\n        }\n      }\n    }, rowColsProps);\n  }; // We do not use `Vue.extend()` here as that would evaluate the props\n  // immediately, which we do not want to happen\n  // @vue/component\n\n\n  var BRow = {\n    name: 'BRow',\n    functional: true,\n\n    get props() {\n      // Allow props to be lazy evaled on first access and\n      // then they become a non-getter afterwards\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#Smart_self-overwriting_lazy_getters\n      delete this.props;\n      this.props = generateProps$2();\n      return this.props;\n    },\n\n    render: function render(h, _ref) {\n      var _classList$push;\n\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      var classList = []; // Loop through row-cols breakpoint props and generate the classes\n\n      rowColsPropList.forEach(function (prop) {\n        var c = computeRowColsClass(computeRowColsBreakpoint(prop), props[prop]); // If a class is returned, push it onto the array\n\n        if (c) {\n          classList.push(c);\n        }\n      });\n      classList.push((_classList$push = {\n        'no-gutters': props.noGutters\n      }, _defineProperty(_classList$push, \"align-items-\".concat(props.alignV), props.alignV), _defineProperty(_classList$push, \"justify-content-\".concat(props.alignH), props.alignH), _defineProperty(_classList$push, \"align-content-\".concat(props.alignContent), props.alignContent), _classList$push));\n      return h(props.tag, a(data, {\n        staticClass: 'row',\n        class: classList\n      }), children);\n    }\n  };\n\n  var LayoutPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BContainer: BContainer,\n      BRow: BRow,\n      BCol: BCol,\n      BFormRow: BFormRow\n    }\n  });\n\n  var LinkPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BLink: BLink\n    }\n  });\n\n  var props$C = {\n    tag: {\n      type: String,\n      default: 'div'\n    },\n    flush: {\n      type: Boolean,\n      default: false\n    },\n    horizontal: {\n      type: [Boolean, String],\n      default: false\n    }\n  }; // @vue/component\n\n  var BListGroup =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BListGroup',\n    functional: true,\n    props: props$C,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      var horizontal = props.horizontal === '' ? true : props.horizontal;\n      horizontal = props.flush ? false : horizontal;\n      var componentData = {\n        staticClass: 'list-group',\n        class: _defineProperty({\n          'list-group-flush': props.flush,\n          'list-group-horizontal': horizontal === true\n        }, \"list-group-horizontal-\".concat(horizontal), isString(horizontal))\n      };\n      return h(props.tag, a(data, componentData), children);\n    }\n  });\n\n  var NAME$m = 'BListGroupItem';\n  var actionTags = ['a', 'router-link', 'button', 'b-link'];\n  var linkProps$2 = propsFactory();\n  delete linkProps$2.href.default;\n  delete linkProps$2.to.default;\n  var props$D = _objectSpread2({\n    tag: {\n      type: String,\n      default: 'div'\n    },\n    action: {\n      type: Boolean,\n      default: null\n    },\n    button: {\n      type: Boolean,\n      default: null\n    },\n    variant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$m, 'variant');\n      }\n    }\n  }, linkProps$2); // @vue/component\n\n  var BListGroupItem =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$m,\n    functional: true,\n    props: props$D,\n    render: function render(h, _ref) {\n      var _class;\n\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      var tag = props.button ? 'button' : !props.href && !props.to ? props.tag : BLink;\n      var isAction = Boolean(props.href || props.to || props.action || props.button || arrayIncludes(actionTags, props.tag));\n      var attrs = {};\n      var itemProps = {};\n\n      if (tag === 'button') {\n        if (!data.attrs || !data.attrs.type) {\n          // Add a type for button is one not provided in passed attributes\n          attrs.type = 'button';\n        }\n\n        if (props.disabled) {\n          // Set disabled attribute if button and disabled\n          attrs.disabled = true;\n        }\n      } else {\n        itemProps = pluckProps(linkProps$2, props);\n      }\n\n      var componentData = {\n        attrs: attrs,\n        props: itemProps,\n        staticClass: 'list-group-item',\n        class: (_class = {}, _defineProperty(_class, \"list-group-item-\".concat(props.variant), props.variant), _defineProperty(_class, 'list-group-item-action', isAction), _defineProperty(_class, \"active\", props.active), _defineProperty(_class, \"disabled\", props.disabled), _class)\n      };\n      return h(tag, a(data, componentData), children);\n    }\n  });\n\n  var ListGroupPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BListGroup: BListGroup,\n      BListGroupItem: BListGroupItem\n    }\n  });\n\n  var props$E = {\n    tag: {\n      type: String,\n      default: 'div'\n    }\n  }; // @vue/component\n\n  var BMediaBody =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BMediaBody',\n    functional: true,\n    props: props$E,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h(props.tag, a(data, {\n        staticClass: 'media-body'\n      }), children);\n    }\n  });\n\n  var props$F = {\n    tag: {\n      type: String,\n      default: 'div'\n    },\n    verticalAlign: {\n      type: String,\n      default: 'top'\n    }\n  }; // @vue/component\n\n  var BMediaAside =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BMediaAside',\n    functional: true,\n    props: props$F,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      var align = props.verticalAlign === 'top' ? 'start' : props.verticalAlign === 'bottom' ? 'end' : props.verticalAlign;\n      return h(props.tag, a(data, {\n        staticClass: 'd-flex',\n        class: _defineProperty({}, \"align-self-\".concat(align), align)\n      }), children);\n    }\n  });\n\n  var props$G = {\n    tag: {\n      type: String,\n      default: 'div'\n    },\n    rightAlign: {\n      type: Boolean,\n      default: false\n    },\n    verticalAlign: {\n      type: String,\n      default: 'top'\n    },\n    noBody: {\n      type: Boolean,\n      default: false\n    }\n  }; // @vue/component\n\n  var BMedia =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BMedia',\n    functional: true,\n    props: props$G,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          slots = _ref.slots,\n          scopedSlots = _ref.scopedSlots,\n          children = _ref.children;\n      var childNodes = props.noBody ? children : [];\n\n      if (!props.noBody) {\n        var $slots = slots();\n        var $scopedSlots = scopedSlots || {};\n        var $aside = normalizeSlot('aside', {}, $scopedSlots, $slots);\n        var $default = normalizeSlot('default', {}, $scopedSlots, $slots);\n\n        if ($aside && !props.rightAlign) {\n          childNodes.push(h(BMediaAside, {\n            staticClass: 'mr-3',\n            props: {\n              verticalAlign: props.verticalAlign\n            }\n          }, $aside));\n        }\n\n        childNodes.push(h(BMediaBody, $default));\n\n        if ($aside && props.rightAlign) {\n          childNodes.push(h(BMediaAside, {\n            staticClass: 'ml-3',\n            props: {\n              verticalAlign: props.verticalAlign\n            }\n          }, $aside));\n        }\n      }\n\n      return h(props.tag, a(data, {\n        staticClass: 'media'\n      }), childNodes);\n    }\n  });\n\n  var MediaPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BMedia: BMedia,\n      BMediaAside: BMediaAside,\n      BMediaBody: BMediaBody\n    }\n  });\n\n  //\n  // Single root node portaling of content, which retains parent/child hierarchy\n  // Unlike Portal-Vue where portaled content is no longer a descendent of its\n  // intended parent components\n  //\n  // Private components for use by Tooltips, Popovers and Modals\n  //\n  // Based on vue-simple-portal\n  // https://github.com/LinusBorg/vue-simple-portal\n  // Transporter target used by BTransporterSingle\n  // Supports only a single root element\n  // @vue/component\n\n  var BTransporterTargetSingle =\n  /*#__PURE__*/\n  Vue.extend({\n    // As an abstract component, it doesn't appear in the $parent chain of\n    // components, which means the next parent of any component rendered inside\n    // of this one will be the parent from which is was portal'd\n    abstract: true,\n    name: 'BTransporterTargetSingle',\n    props: {\n      nodes: {\n        // Even though we only support a single root element,\n        // VNodes are always passed as an array\n        type: [Array, Function] // default: undefined\n\n      }\n    },\n    data: function data(vm) {\n      return {\n        updatedNodes: vm.nodes\n      };\n    },\n    destroyed: function destroyed() {\n      removeNode(this.$el);\n    },\n    render: function render(h) {\n      var nodes = isFunction(this.updatedNodes) ? this.updatedNodes({}) : this.updatedNodes;\n      nodes = concat(nodes).filter(Boolean);\n      /* istanbul ignore else */\n\n      if (nodes && nodes.length > 0 && !nodes[0].text) {\n        return nodes[0];\n      } else {\n        /* istanbul ignore next */\n        return h();\n      }\n    }\n  }); // This component has no root element, so only a single VNode is allowed\n  // @vue/component\n\n  var BTransporterSingle =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BTransporterSingle',\n    mixins: [normalizeSlotMixin],\n    props: {\n      disabled: {\n        type: Boolean,\n        default: false\n      },\n      container: {\n        // String: CSS selector,\n        // HTMLElement: Element reference\n        // Mainly needed for tooltips/popovers inside modals\n        type: [String, HTMLElement],\n        default: 'body'\n      },\n      tag: {\n        // This should be set to match the root element type\n        type: String,\n        default: 'div'\n      }\n    },\n    watch: {\n      disabled: {\n        immediate: true,\n        handler: function handler(disabled) {\n          disabled ? this.unmountTarget() : this.$nextTick(this.mountTarget);\n        }\n      }\n    },\n    created: function created() {\n      this._bv_defaultFn = null;\n      this._bv_target = null;\n    },\n    beforeMount: function beforeMount() {\n      this.mountTarget();\n    },\n    updated: function updated() {\n      // We need to make sure that all children have completed updating\n      // before rendering in the target\n      // `vue-simple-portal` has the this in a `$nextTick()`,\n      // while `portal-vue` doesn't\n      // Just trying to see if the `$nextTick()` delay is required or not\n      // Since all slots in Vue 2.6.x are always functions\n      this.updateTarget();\n    },\n    beforeDestroy: function beforeDestroy() {\n      this.unmountTarget();\n      this._bv_defaultFn = null;\n    },\n    methods: {\n      // Get the element which the target should be appended to\n      getContainer: function getContainer() {\n        /* istanbul ignore else */\n        if (isBrowser) {\n          var container = this.container;\n          return isString(container) ? select(container) : container;\n        } else {\n          return null;\n        }\n      },\n      // Mount the target\n      mountTarget: function mountTarget() {\n        if (!this._bv_target) {\n          var container = this.getContainer();\n\n          if (container) {\n            var el = document.createElement('div');\n            container.appendChild(el);\n            this._bv_target = new BTransporterTargetSingle({\n              el: el,\n              parent: this,\n              propsData: {\n                // Initial nodes to be rendered\n                nodes: concat(this.normalizeSlot('default'))\n              }\n            });\n          }\n        }\n      },\n      // Update the content of the target\n      updateTarget: function updateTarget() {\n        if (isBrowser && this._bv_target) {\n          var defaultFn = this.$scopedSlots.default;\n\n          if (!this.disabled) {\n            /* istanbul ignore else: only applicable in Vue 2.5.x */\n            if (defaultFn && this._bv_defaultFn !== defaultFn) {\n              // We only update the target component if the scoped slot\n              // function is a fresh one. The new slot syntax (since Vue 2.6)\n              // can cache unchanged slot functions and we want to respect that here\n              this._bv_target.updatedNodes = defaultFn;\n            } else if (!defaultFn) {\n              // We also need to be back compatible with non-scoped default slot (i.e. 2.5.x)\n              this._bv_target.updatedNodes = this.$slots.default;\n            }\n          } // Update the scoped slot function cache\n\n\n          this._bv_defaultFn = defaultFn;\n        }\n      },\n      // Unmount the target\n      unmountTarget: function unmountTarget() {\n        if (this._bv_target) {\n          this._bv_target.$destroy();\n\n          this._bv_target = null;\n        }\n      }\n    },\n    render: function render(h) {\n      if (this.disabled) {\n        var nodes = concat(this.normalizeSlot('default')).filter(identity);\n\n        if (nodes.length > 0 && !nodes[0].text) {\n          return nodes[0];\n        }\n      }\n\n      return h();\n    }\n  });\n\n  var PROP$1 = '$_bv_documentHandlers_'; // @vue/component\n\n  var listenOnDocumentMixin = {\n    created: function created() {\n      var _this = this;\n\n      /* istanbul ignore next */\n      if (!isBrowser) {\n        return;\n      } // Declare non-reactive property\n      // Object of arrays, keyed by event name,\n      // where value is an array of handlers\n      // Prop will be defined on client only\n\n\n      this[PROP$1] = {}; // Set up our beforeDestroy handler (client only)\n\n      this.$once('hook:beforeDestroy', function () {\n        var items = _this[PROP$1] || {}; // Immediately delete this[PROP] to prevent the\n        // listenOn/Off methods from running (which may occur\n        // due to requestAnimationFrame/transition delays)\n\n        delete _this[PROP$1]; // Remove all registered event handlers\n\n        keys(items).forEach(function (evtName) {\n          var handlers = items[evtName] || [];\n          handlers.forEach(function (handler) {\n            return eventOff(document, evtName, handler, EVENT_OPTIONS_NO_CAPTURE);\n          });\n        });\n      });\n    },\n    methods: {\n      listenDocument: function listenDocument(on, evtName, handler) {\n        on ? this.listenOnDocument(evtName, handler) : this.listenOffDocument(evtName, handler);\n      },\n      listenOnDocument: function listenOnDocument(evtName, handler) {\n        if (this[PROP$1] && isString(evtName) && isFunction(handler)) {\n          this[PROP$1][evtName] = this[PROP$1][evtName] || [];\n\n          if (!arrayIncludes(this[PROP$1][evtName], handler)) {\n            this[PROP$1][evtName].push(handler);\n            eventOn(document, evtName, handler, EVENT_OPTIONS_NO_CAPTURE);\n          }\n        }\n      },\n      listenOffDocument: function listenOffDocument(evtName, handler) {\n        if (this[PROP$1] && isString(evtName) && isFunction(handler)) {\n          eventOff(document, evtName, handler, EVENT_OPTIONS_NO_CAPTURE);\n          this[PROP$1][evtName] = (this[PROP$1][evtName] || []).filter(function (h) {\n            return h !== handler;\n          });\n        }\n      }\n    }\n  };\n\n  var PROP$2 = '$_bv_windowHandlers_'; // @vue/component\n\n  var listenOnWindowMixin = {\n    beforeCreate: function beforeCreate() {\n      // Declare non-reactive property\n      // Object of arrays, keyed by event name,\n      // where value is an array of handlers\n      this[PROP$2] = {};\n    },\n    beforeDestroy: function beforeDestroy() {\n      if (isBrowser) {\n        var items = this[PROP$2]; // Immediately delete this[PROP] to prevent the\n        // listenOn/Off methods from running (which may occur\n        // due to requestAnimationFrame delays)\n\n        delete this[PROP$2]; // Remove all registered event handlers\n\n        keys(items).forEach(function (evtName) {\n          var handlers = items[evtName] || [];\n          handlers.forEach(function (handler) {\n            return eventOff(window, evtName, handler, EVENT_OPTIONS_NO_CAPTURE);\n          });\n        });\n      }\n    },\n    methods: {\n      listenWindow: function listenWindow(on, evtName, handler) {\n        on ? this.listenOnWindow(evtName, handler) : this.listenOffWindow(evtName, handler);\n      },\n      listenOnWindow: function listenOnWindow(evtName, handler) {\n        if (isBrowser && this[PROP$2] && isString(evtName) && isFunction(handler)) {\n          this[PROP$2][evtName] = this[PROP$2][evtName] || [];\n\n          if (!arrayIncludes(this[PROP$2][evtName], handler)) {\n            this[PROP$2][evtName].push(handler);\n            eventOn(window, evtName, handler, EVENT_OPTIONS_NO_CAPTURE);\n          }\n        }\n      },\n      listenOffWindow: function listenOffWindow(evtName, handler) {\n        if (isBrowser && this[PROP$2] && isString(evtName) && isFunction(handler)) {\n          eventOff(window, evtName, handler, EVENT_OPTIONS_NO_CAPTURE);\n          this[PROP$2][evtName] = (this[PROP$2][evtName] || []).filter(function (h) {\n            return h !== handler;\n          });\n        }\n      }\n    }\n  };\n\n  // This method returns a component's scoped style attribute name: `data-v-xxxxxxx`\n  // The `_scopeId` options property is added by vue-loader when using scoped styles\n  // and will be `undefined` if no scoped styles are in use\n  var getScopeId = function getScopeId(vm) {\n    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return vm ? vm.$options._scopeId || defaultValue : defaultValue;\n  };\n\n  var scopedStyleAttrsMixin = {\n    computed: {\n      scopedStyleAttrs: function scopedStyleAttrs() {\n        var scopeId = getScopeId(this.$parent);\n        return scopeId ? _defineProperty({}, scopeId, '') : {};\n      }\n    }\n  };\n\n  /**\n   * Private ModalManager helper\n   * Handles controlling modal stacking zIndexes and body adjustments/classes\n   */\n  // Default modal backdrop z-index\n\n  var DEFAULT_ZINDEX = 1040; // Selectors for padding/margin adjustments\n\n  var Selector$1 = {\n    FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',\n    STICKY_CONTENT: '.sticky-top',\n    NAVBAR_TOGGLER: '.navbar-toggler'\n  }; // @vue/component\n\n  var ModalManager =\n  /*#__PURE__*/\n  Vue.extend({\n    data: function data() {\n      return {\n        modals: [],\n        baseZIndex: null,\n        scrollbarWidth: null,\n        isBodyOverflowing: false\n      };\n    },\n    computed: {\n      modalCount: function modalCount() {\n        return this.modals.length;\n      },\n      modalsAreOpen: function modalsAreOpen() {\n        return this.modalCount > 0;\n      }\n    },\n    watch: {\n      modalCount: function modalCount(newCount, oldCount) {\n        if (isBrowser) {\n          this.getScrollbarWidth();\n\n          if (newCount > 0 && oldCount === 0) {\n            // Transitioning to modal(s) open\n            this.checkScrollbar();\n            this.setScrollbar();\n            addClass(document.body, 'modal-open');\n          } else if (newCount === 0 && oldCount > 0) {\n            // Transitioning to modal(s) closed\n            this.resetScrollbar();\n            removeClass(document.body, 'modal-open');\n          }\n\n          setAttr(document.body, 'data-modal-open-count', String(newCount));\n        }\n      },\n      modals: function modals(newVal) {\n        var _this = this;\n\n        this.checkScrollbar();\n        requestAF(function () {\n          _this.updateModals(newVal || []);\n        });\n      }\n    },\n    methods: {\n      // Public methods\n      registerModal: function registerModal(modal) {\n        var _this2 = this;\n\n        // Register the modal if not already registered\n        if (modal && this.modals.indexOf(modal) === -1) {\n          // Add modal to modals array\n          this.modals.push(modal);\n          modal.$once('hook:beforeDestroy', function () {\n            _this2.unregisterModal(modal);\n          });\n        }\n      },\n      unregisterModal: function unregisterModal(modal) {\n        var index = this.modals.indexOf(modal);\n\n        if (index > -1) {\n          // Remove modal from modals array\n          this.modals.splice(index, 1); // Reset the modal's data\n\n          if (!(modal._isBeingDestroyed || modal._isDestroyed)) {\n            this.resetModal(modal);\n          }\n        }\n      },\n      getBaseZIndex: function getBaseZIndex() {\n        if (isNull(this.baseZIndex) && isBrowser) {\n          // Create a temporary `div.modal-backdrop` to get computed z-index\n          var div = document.createElement('div');\n          div.className = 'modal-backdrop d-none';\n          div.style.display = 'none';\n          document.body.appendChild(div);\n          this.baseZIndex = toInteger(getCS(div).zIndex || DEFAULT_ZINDEX);\n          document.body.removeChild(div);\n        }\n\n        return this.baseZIndex || DEFAULT_ZINDEX;\n      },\n      getScrollbarWidth: function getScrollbarWidth() {\n        if (isNull(this.scrollbarWidth) && isBrowser) {\n          // Create a temporary `div.measure-scrollbar` to get computed z-index\n          var div = document.createElement('div');\n          div.className = 'modal-scrollbar-measure';\n          document.body.appendChild(div);\n          this.scrollbarWidth = getBCR(div).width - div.clientWidth;\n          document.body.removeChild(div);\n        }\n\n        return this.scrollbarWidth || 0;\n      },\n      // Private methods\n      updateModals: function updateModals(modals) {\n        var _this3 = this;\n\n        var baseZIndex = this.getBaseZIndex();\n        var scrollbarWidth = this.getScrollbarWidth();\n        modals.forEach(function (modal, index) {\n          // We update data values on each modal\n          modal.zIndex = baseZIndex + index;\n          modal.scrollbarWidth = scrollbarWidth;\n          modal.isTop = index === _this3.modals.length - 1;\n          modal.isBodyOverflowing = _this3.isBodyOverflowing;\n        });\n      },\n      resetModal: function resetModal(modal) {\n        if (modal) {\n          modal.zIndex = this.getBaseZIndex();\n          modal.isTop = true;\n          modal.isBodyOverflowing = false;\n        }\n      },\n      checkScrollbar: function checkScrollbar() {\n        // Determine if the body element is overflowing\n        var _getBCR = getBCR(document.body),\n            left = _getBCR.left,\n            right = _getBCR.right;\n\n        this.isBodyOverflowing = left + right < window.innerWidth;\n      },\n      setScrollbar: function setScrollbar() {\n        var body = document.body; // Storage place to cache changes to margins and padding\n        // Note: This assumes the following element types are not added to the\n        // document after the modal has opened.\n\n        body._paddingChangedForModal = body._paddingChangedForModal || [];\n        body._marginChangedForModal = body._marginChangedForModal || [];\n\n        if (this.isBodyOverflowing) {\n          var scrollbarWidth = this.scrollbarWidth; // Adjust fixed content padding\n\n          /* istanbul ignore next: difficult to test in JSDOM */\n\n          selectAll(Selector$1.FIXED_CONTENT).forEach(function (el) {\n            var actualPadding = el.style.paddingRight;\n            var calculatedPadding = getCS(el).paddingRight || 0;\n            setAttr(el, 'data-padding-right', actualPadding);\n            el.style.paddingRight = \"\".concat(toFloat(calculatedPadding) + scrollbarWidth, \"px\");\n\n            body._paddingChangedForModal.push(el);\n          }); // Adjust sticky content margin\n\n          /* istanbul ignore next: difficult to test in JSDOM */\n\n          selectAll(Selector$1.STICKY_CONTENT).forEach(function (el)\n          /* istanbul ignore next */\n          {\n            var actualMargin = el.style.marginRight;\n            var calculatedMargin = getCS(el).marginRight || 0;\n            setAttr(el, 'data-margin-right', actualMargin);\n            el.style.marginRight = \"\".concat(toFloat(calculatedMargin) - scrollbarWidth, \"px\");\n\n            body._marginChangedForModal.push(el);\n          }); // Adjust <b-navbar-toggler> margin\n\n          /* istanbul ignore next: difficult to test in JSDOM */\n\n          selectAll(Selector$1.NAVBAR_TOGGLER).forEach(function (el)\n          /* istanbul ignore next */\n          {\n            var actualMargin = el.style.marginRight;\n            var calculatedMargin = getCS(el).marginRight || 0;\n            setAttr(el, 'data-margin-right', actualMargin);\n            el.style.marginRight = \"\".concat(toFloat(calculatedMargin) + scrollbarWidth, \"px\");\n\n            body._marginChangedForModal.push(el);\n          }); // Adjust body padding\n\n          var actualPadding = body.style.paddingRight;\n          var calculatedPadding = getCS(body).paddingRight;\n          setAttr(body, 'data-padding-right', actualPadding);\n          body.style.paddingRight = \"\".concat(toFloat(calculatedPadding) + scrollbarWidth, \"px\");\n        }\n      },\n      resetScrollbar: function resetScrollbar() {\n        var body = document.body;\n\n        if (body._paddingChangedForModal) {\n          // Restore fixed content padding\n          body._paddingChangedForModal.forEach(function (el) {\n            /* istanbul ignore next: difficult to test in JSDOM */\n            if (hasAttr(el, 'data-padding-right')) {\n              el.style.paddingRight = getAttr(el, 'data-padding-right') || '';\n              removeAttr(el, 'data-padding-right');\n            }\n          });\n        }\n\n        if (body._marginChangedForModal) {\n          // Restore sticky content and navbar-toggler margin\n          body._marginChangedForModal.forEach(function (el) {\n            /* istanbul ignore next: difficult to test in JSDOM */\n            if (hasAttr(el, 'data-margin-right')) {\n              el.style.marginRight = getAttr(el, 'data-margin-right') || '';\n              removeAttr(el, 'data-margin-right');\n            }\n          });\n        }\n\n        body._paddingChangedForModal = null;\n        body._marginChangedForModal = null; // Restore body padding\n\n        if (hasAttr(body, 'data-padding-right')) {\n          body.style.paddingRight = getAttr(body, 'data-padding-right') || '';\n          removeAttr(body, 'data-padding-right');\n        }\n      }\n    }\n  }); // Create and export our modal manager instance\n\n  var modalManager = new ModalManager();\n\n  var BvModalEvent =\n  /*#__PURE__*/\n  function (_BvEvent) {\n    _inherits(BvModalEvent, _BvEvent);\n\n    function BvModalEvent(type) {\n      var _this;\n\n      var eventInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, BvModalEvent);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(BvModalEvent).call(this, type, eventInit)); // Freeze our new props as readonly, but leave them enumerable\n\n      defineProperties(_assertThisInitialized(_this), {\n        trigger: readonlyDescriptor()\n      });\n      return _this;\n    }\n\n    _createClass(BvModalEvent, null, [{\n      key: \"Defaults\",\n      get: function get() {\n        return _objectSpread2({}, _get(_getPrototypeOf(BvModalEvent), \"Defaults\", this), {\n          trigger: null\n        });\n      }\n    }]);\n\n    return BvModalEvent;\n  }(BvEvent); // Named exports\n\n  var NAME$n = 'BModal'; // ObserveDom config to detect changes in modal content\n  // so that we can adjust the modal padding if needed\n\n  var OBSERVER_CONFIG = {\n    subtree: true,\n    childList: true,\n    characterData: true,\n    attributes: true,\n    attributeFilter: ['style', 'class']\n  }; // Query selector to find all tabbable elements\n  // (includes tabindex=\"-1\", which we filter out after)\n\n  var TABABLE_SELECTOR = ['button', '[href]:not(.disabled)', 'input', 'select', 'textarea', '[tabindex]', '[contenteditable]'].map(function (s) {\n    return \"\".concat(s, \":not(:disabled):not([disabled])\");\n  }).join(', '); // --- Utility methods ---\n  // Attempt to focus an element, and return true if successful\n\n  var attemptFocus = function attemptFocus(el) {\n    if (el && isVisible(el) && el.focus) {\n      try {\n        el.focus();\n      } catch (_unused) {}\n    } // If the element has focus, then return true\n\n\n    return document.activeElement === el;\n  }; // --- Props ---\n\n\n  var props$H = {\n    size: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'size');\n      }\n    },\n    centered: {\n      type: Boolean,\n      default: false\n    },\n    scrollable: {\n      type: Boolean,\n      default: false\n    },\n    buttonSize: {\n      type: String,\n      default: ''\n    },\n    noStacking: {\n      type: Boolean,\n      default: false\n    },\n    noFade: {\n      type: Boolean,\n      default: false\n    },\n    noCloseOnBackdrop: {\n      type: Boolean,\n      default: false\n    },\n    noCloseOnEsc: {\n      type: Boolean,\n      default: false\n    },\n    noEnforceFocus: {\n      type: Boolean,\n      default: false\n    },\n    ignoreEnforceFocusSelector: {\n      type: [Array, String],\n      default: ''\n    },\n    title: {\n      type: String,\n      default: ''\n    },\n    titleHtml: {\n      type: String\n    },\n    titleTag: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'titleTag');\n      }\n    },\n    titleClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    titleSrOnly: {\n      type: Boolean,\n      default: false\n    },\n    ariaLabel: {\n      type: String,\n      default: null\n    },\n    headerBgVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'headerBgVariant');\n      }\n    },\n    headerBorderVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'headerBorderVariant');\n      }\n    },\n    headerTextVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'headerTextVariant');\n      }\n    },\n    headerCloseVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'headerCloseVariant');\n      }\n    },\n    headerClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    bodyBgVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'bodyBgVariant');\n      }\n    },\n    bodyTextVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'bodyTextVariant');\n      }\n    },\n    modalClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    dialogClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    contentClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    bodyClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    footerBgVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'footerBgVariant');\n      }\n    },\n    footerBorderVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'footerBorderVariant');\n      }\n    },\n    footerTextVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'footerTextVariant');\n      }\n    },\n    footerClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    hideHeader: {\n      type: Boolean,\n      default: false\n    },\n    hideFooter: {\n      type: Boolean,\n      default: false\n    },\n    hideHeaderClose: {\n      type: Boolean,\n      default: false\n    },\n    hideBackdrop: {\n      type: Boolean,\n      default: false\n    },\n    okOnly: {\n      type: Boolean,\n      default: false\n    },\n    okDisabled: {\n      type: Boolean,\n      default: false\n    },\n    cancelDisabled: {\n      type: Boolean,\n      default: false\n    },\n    visible: {\n      type: Boolean,\n      default: false\n    },\n    returnFocus: {\n      // HTML Element, CSS selector string or Vue component instance\n      type: [HTMLElement, String, Object],\n      default: null\n    },\n    headerCloseContent: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'headerCloseContent');\n      }\n    },\n    headerCloseLabel: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'headerCloseLabel');\n      }\n    },\n    cancelTitle: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'cancelTitle');\n      }\n    },\n    cancelTitleHtml: {\n      type: String\n    },\n    okTitle: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'okTitle');\n      }\n    },\n    okTitleHtml: {\n      type: String\n    },\n    cancelVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'cancelVariant');\n      }\n    },\n    okVariant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$n, 'okVariant');\n      }\n    },\n    lazy: {\n      type: Boolean,\n      default: false\n    },\n    busy: {\n      type: Boolean,\n      default: false\n    },\n    static: {\n      type: Boolean,\n      default: false\n    },\n    autoFocusButton: {\n      type: String,\n      default: null,\n      validator: function validator(val) {\n        /* istanbul ignore next */\n        return isUndefinedOrNull(val) || arrayIncludes(['ok', 'cancel', 'close'], val);\n      }\n    }\n  }; // @vue/component\n\n  var BModal =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$n,\n    mixins: [idMixin, listenOnDocumentMixin, listenOnRootMixin, listenOnWindowMixin, normalizeSlotMixin, scopedStyleAttrsMixin],\n    inheritAttrs: false,\n    model: {\n      prop: 'visible',\n      event: 'change'\n    },\n    props: props$H,\n    data: function data() {\n      return {\n        isHidden: true,\n        // If modal should not be in document\n        isVisible: false,\n        // Controls modal visible state\n        isTransitioning: false,\n        // Used for style control\n        isShow: false,\n        // Used for style control\n        isBlock: false,\n        // Used for style control\n        isOpening: false,\n        // To signal that the modal is in the process of opening\n        isClosing: false,\n        // To signal that the modal is in the process of closing\n        ignoreBackdropClick: false,\n        // Used to signify if click out listener should ignore the click\n        isModalOverflowing: false,\n        return_focus: this.returnFocus || null,\n        // The following items are controlled by the modalManager instance\n        scrollbarWidth: 0,\n        zIndex: modalManager.getBaseZIndex(),\n        isTop: true,\n        isBodyOverflowing: false\n      };\n    },\n    computed: {\n      modalClasses: function modalClasses() {\n        return [{\n          fade: !this.noFade,\n          show: this.isShow\n        }, this.modalClass];\n      },\n      modalStyles: function modalStyles() {\n        var sbWidth = \"\".concat(this.scrollbarWidth, \"px\");\n        return {\n          paddingLeft: !this.isBodyOverflowing && this.isModalOverflowing ? sbWidth : '',\n          paddingRight: this.isBodyOverflowing && !this.isModalOverflowing ? sbWidth : '',\n          // Needed to fix issue https://github.com/bootstrap-vue/bootstrap-vue/issues/3457\n          // Even though we are using v-show, we must ensure 'none' is restored in the styles\n          display: this.isBlock ? 'block' : 'none'\n        };\n      },\n      dialogClasses: function dialogClasses() {\n        var _ref;\n\n        return [(_ref = {}, _defineProperty(_ref, \"modal-\".concat(this.size), this.size), _defineProperty(_ref, 'modal-dialog-centered', this.centered), _defineProperty(_ref, 'modal-dialog-scrollable', this.scrollable), _ref), this.dialogClass];\n      },\n      headerClasses: function headerClasses() {\n        var _ref2;\n\n        return [(_ref2 = {}, _defineProperty(_ref2, \"bg-\".concat(this.headerBgVariant), this.headerBgVariant), _defineProperty(_ref2, \"text-\".concat(this.headerTextVariant), this.headerTextVariant), _defineProperty(_ref2, \"border-\".concat(this.headerBorderVariant), this.headerBorderVariant), _ref2), this.headerClass];\n      },\n      titleClasses: function titleClasses() {\n        return [{\n          'sr-only': this.titleSrOnly\n        }, this.titleClass];\n      },\n      bodyClasses: function bodyClasses() {\n        var _ref3;\n\n        return [(_ref3 = {}, _defineProperty(_ref3, \"bg-\".concat(this.bodyBgVariant), this.bodyBgVariant), _defineProperty(_ref3, \"text-\".concat(this.bodyTextVariant), this.bodyTextVariant), _ref3), this.bodyClass];\n      },\n      footerClasses: function footerClasses() {\n        var _ref4;\n\n        return [(_ref4 = {}, _defineProperty(_ref4, \"bg-\".concat(this.footerBgVariant), this.footerBgVariant), _defineProperty(_ref4, \"text-\".concat(this.footerTextVariant), this.footerTextVariant), _defineProperty(_ref4, \"border-\".concat(this.footerBorderVariant), this.footerBorderVariant), _ref4), this.footerClass];\n      },\n      modalOuterStyle: function modalOuterStyle() {\n        // Styles needed for proper stacking of modals\n        return {\n          position: 'absolute',\n          zIndex: this.zIndex\n        };\n      },\n      slotScope: function slotScope() {\n        return {\n          ok: this.onOk,\n          cancel: this.onCancel,\n          close: this.onClose,\n          hide: this.hide,\n          visible: this.isVisible\n        };\n      },\n      computeIgnoreEnforceFocusSelector: function computeIgnoreEnforceFocusSelector() {\n        // Normalize to an single selector with selectors separated by `,`\n        return concat(this.ignoreEnforceFocusSelector).filter(identity).join(',').trim();\n      }\n    },\n    watch: {\n      visible: function visible(newVal, oldVal) {\n        if (newVal !== oldVal) {\n          this[newVal ? 'show' : 'hide']();\n        }\n      }\n    },\n    created: function created() {\n      // Define non-reactive properties\n      this._observer = null;\n    },\n    mounted: function mounted() {\n      // Set initial z-index as queried from the DOM\n      this.zIndex = modalManager.getBaseZIndex(); // Listen for events from others to either open or close ourselves\n      // and listen to all modals to enable/disable enforce focus\n\n      this.listenOnRoot('bv::show::modal', this.showHandler);\n      this.listenOnRoot('bv::hide::modal', this.hideHandler);\n      this.listenOnRoot('bv::toggle::modal', this.toggleHandler); // Listen for `bv:modal::show events`, and close ourselves if the\n      // opening modal not us\n\n      this.listenOnRoot('bv::modal::show', this.modalListener); // Initially show modal?\n\n      if (this.visible === true) {\n        this.$nextTick(this.show);\n      }\n    },\n    beforeDestroy: function beforeDestroy() {\n      // Ensure everything is back to normal\n      if (this._observer) {\n        this._observer.disconnect();\n\n        this._observer = null;\n      }\n\n      if (this.isVisible) {\n        this.isVisible = false;\n        this.isShow = false;\n        this.isTransitioning = false;\n      }\n    },\n    methods: {\n      // Private method to update the v-model\n      updateModel: function updateModel(val) {\n        if (val !== this.visible) {\n          this.$emit('change', val);\n        }\n      },\n      // Private method to create a BvModalEvent object\n      buildEvent: function buildEvent(type) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return new BvModalEvent(type, _objectSpread2({\n          // Default options\n          cancelable: false,\n          target: this.$refs.modal || this.$el || null,\n          relatedTarget: null,\n          trigger: null\n        }, options, {\n          // Options that can't be overridden\n          vueTarget: this,\n          componentId: this.safeId()\n        }));\n      },\n      // Public method to show modal\n      show: function show() {\n        if (this.isVisible || this.isOpening) {\n          // If already open, or in the process of opening, do nothing\n\n          /* istanbul ignore next */\n          return;\n        }\n        /* istanbul ignore next */\n\n\n        if (this.isClosing) {\n          // If we are in the process of closing, wait until hidden before re-opening\n\n          /* istanbul ignore next */\n          this.$once('hidden', this.show);\n          /* istanbul ignore next */\n\n          return;\n        }\n\n        this.isOpening = true; // Set the element to return focus to when closed\n\n        this.return_focus = this.return_focus || this.getActiveElement();\n        var showEvt = this.buildEvent('show', {\n          cancelable: true\n        });\n        this.emitEvent(showEvt); // Don't show if canceled\n\n        if (showEvt.defaultPrevented || this.isVisible) {\n          this.isOpening = false; // Ensure the v-model reflects the current state\n\n          this.updateModel(false);\n          return;\n        } // Show the modal\n\n\n        this.doShow();\n      },\n      // Public method to hide modal\n      hide: function hide() {\n        var trigger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n        if (!this.isVisible || this.isClosing) {\n          /* istanbul ignore next */\n          return;\n        }\n\n        this.isClosing = true;\n        var hideEvt = this.buildEvent('hide', {\n          cancelable: trigger !== 'FORCE',\n          trigger: trigger || null\n        }); // We emit specific event for one of the three built-in buttons\n\n        if (trigger === 'ok') {\n          this.$emit('ok', hideEvt);\n        } else if (trigger === 'cancel') {\n          this.$emit('cancel', hideEvt);\n        } else if (trigger === 'headerclose') {\n          this.$emit('close', hideEvt);\n        }\n\n        this.emitEvent(hideEvt); // Hide if not canceled\n\n        if (hideEvt.defaultPrevented || !this.isVisible) {\n          this.isClosing = false; // Ensure v-model reflects current state\n\n          this.updateModel(true);\n          return;\n        } // Stop observing for content changes\n\n\n        if (this._observer) {\n          this._observer.disconnect();\n\n          this._observer = null;\n        } // Trigger the hide transition\n\n\n        this.isVisible = false; // Update the v-model\n\n        this.updateModel(false);\n      },\n      // Public method to toggle modal visibility\n      toggle: function toggle(triggerEl) {\n        if (triggerEl) {\n          this.return_focus = triggerEl;\n        }\n\n        if (this.isVisible) {\n          this.hide('toggle');\n        } else {\n          this.show();\n        }\n      },\n      // Private method to get the current document active element\n      getActiveElement: function getActiveElement() {\n        if (isBrowser) {\n          var activeElement = document.activeElement; // Note: On IE 11, `document.activeElement` may be null.\n          // So we test it for truthiness first.\n          // https://github.com/bootstrap-vue/bootstrap-vue/issues/3206\n          // Returning focus to document.body may cause unwanted scrolls, so we\n          // exclude setting focus on body\n\n          if (activeElement && activeElement !== document.body && activeElement.focus) {\n            // Preset the fallback return focus value if it is not set\n            // `document.activeElement` should be the trigger element that was clicked or\n            // in the case of using the v-model, which ever element has current focus\n            // Will be overridden by some commands such as toggle, etc.\n            return activeElement;\n          }\n        }\n\n        return null;\n      },\n      // Private method to get a list of all tabable elements within modal content\n      getTabables: function getTabables() {\n        // Find all tabable elements in the modal content\n        // Assumes users have not used tabindex > 0 on elements!\n        return selectAll(TABABLE_SELECTOR, this.$refs.content).filter(isVisible).filter(function (i) {\n          return i.tabIndex > -1 && !i.disabled;\n        });\n      },\n      // Private method to finish showing modal\n      doShow: function doShow() {\n        var _this = this;\n\n        /* istanbul ignore next: commenting out for now until we can test stacking */\n        if (modalManager.modalsAreOpen && this.noStacking) {\n          // If another modal(s) is already open, wait for it(them) to close\n          this.listenOnRootOnce('bv::modal::hidden', this.doShow);\n          return;\n        }\n\n        modalManager.registerModal(this); // Place modal in DOM\n\n        this.isHidden = false;\n        this.$nextTick(function () {\n          // We do this in `$nextTick()` to ensure the modal is in DOM first\n          // before we show it\n          _this.isVisible = true;\n          _this.isOpening = false; // Update the v-model\n\n          _this.updateModel(true);\n\n          _this.$nextTick(function () {\n            // In a nextTick in case modal content is lazy\n            // Observe changes in modal content and adjust if necessary\n            _this._observer = observeDom(_this.$refs.content, _this.checkModalOverflow.bind(_this), OBSERVER_CONFIG);\n          });\n        });\n      },\n      // Transition handlers\n      onBeforeEnter: function onBeforeEnter() {\n        this.isTransitioning = true;\n        this.setResizeEvent(true);\n      },\n      onEnter: function onEnter() {\n        var _this2 = this;\n\n        this.isBlock = true; // We add the `show` class 1 frame later\n        // `requestAF()` runs the callback before the next repaint, so we need\n        // two calls to guarantee the next frame has been rendered\n\n        requestAF(function () {\n          requestAF(function () {\n            _this2.isShow = true;\n          });\n        });\n      },\n      onAfterEnter: function onAfterEnter() {\n        var _this3 = this;\n\n        this.checkModalOverflow();\n        this.isTransitioning = false; // We use `requestAF()` to allow transition hooks to complete\n        // before passing control over to the other handlers\n        // This will allow users to not have to use `$nextTick()` or `requestAF()`\n        // when trying to pre-focus an element\n\n        requestAF(function () {\n          _this3.emitEvent(_this3.buildEvent('shown'));\n\n          _this3.setEnforceFocus(true);\n\n          _this3.$nextTick(function () {\n            // Delayed in a `$nextTick()` to allow users time to pre-focus\n            // an element if the wish\n            _this3.focusFirst();\n          });\n        });\n      },\n      onBeforeLeave: function onBeforeLeave() {\n        this.isTransitioning = true;\n        this.setResizeEvent(false);\n        this.setEnforceFocus(false);\n      },\n      onLeave: function onLeave() {\n        // Remove the 'show' class\n        this.isShow = false;\n      },\n      onAfterLeave: function onAfterLeave() {\n        var _this4 = this;\n\n        this.isBlock = false;\n        this.isTransitioning = false;\n        this.isModalOverflowing = false;\n        this.isHidden = true;\n        this.$nextTick(function () {\n          _this4.isClosing = false;\n          modalManager.unregisterModal(_this4);\n\n          _this4.returnFocusTo(); // TODO: Need to find a way to pass the `trigger` property\n          //       to the `hidden` event, not just only the `hide` event\n\n\n          _this4.emitEvent(_this4.buildEvent('hidden'));\n        });\n      },\n      // Event emitter\n      emitEvent: function emitEvent(bvModalEvt) {\n        var type = bvModalEvt.type; // We emit on root first incase a global listener wants to cancel\n        // the event first before the instance emits its event\n\n        this.emitOnRoot(\"bv::modal::\".concat(type), bvModalEvt, bvModalEvt.componentId);\n        this.$emit(type, bvModalEvt);\n      },\n      // UI event handlers\n      onDialogMousedown: function onDialogMousedown() {\n        var _this5 = this;\n\n        // Watch to see if the matching mouseup event occurs outside the dialog\n        // And if it does, cancel the clickOut handler\n        var modal = this.$refs.modal;\n\n        var onceModalMouseup = function onceModalMouseup(evt) {\n          eventOff(modal, 'mouseup', onceModalMouseup, EVENT_OPTIONS_NO_CAPTURE);\n\n          if (evt.target === modal) {\n            _this5.ignoreBackdropClick = true;\n          }\n        };\n\n        eventOn(modal, 'mouseup', onceModalMouseup, EVENT_OPTIONS_NO_CAPTURE);\n      },\n      onClickOut: function onClickOut(evt) {\n        if (this.ignoreBackdropClick) {\n          // Click was initiated inside the modal content, but finished outside.\n          // Set by the above onDialogMousedown handler\n          this.ignoreBackdropClick = false;\n          return;\n        } // Do nothing if not visible, backdrop click disabled, or element\n        // that generated click event is no longer in document body\n\n\n        if (!this.isVisible || this.noCloseOnBackdrop || !contains(document.body, evt.target)) {\n          return;\n        } // If backdrop clicked, hide modal\n\n\n        if (!contains(this.$refs.content, evt.target)) {\n          this.hide('backdrop');\n        }\n      },\n      onOk: function onOk() {\n        this.hide('ok');\n      },\n      onCancel: function onCancel() {\n        this.hide('cancel');\n      },\n      onClose: function onClose() {\n        this.hide('headerclose');\n      },\n      onEsc: function onEsc(evt) {\n        // If ESC pressed, hide modal\n        if (evt.keyCode === KEY_CODES.ESC && this.isVisible && !this.noCloseOnEsc) {\n          this.hide('esc');\n        }\n      },\n      // Document focusin listener\n      focusHandler: function focusHandler(evt) {\n        // If focus leaves modal content, bring it back\n        var content = this.$refs.content;\n        var target = evt.target;\n\n        if (this.noEnforceFocus || !this.isTop || !this.isVisible || !content || document === target || contains(content, target) || this.computeIgnoreEnforceFocusSelector && closest(this.computeIgnoreEnforceFocusSelector, target, true)) {\n          return;\n        }\n\n        var tabables = this.getTabables();\n        var _this$$refs = this.$refs,\n            bottomTrap = _this$$refs.bottomTrap,\n            topTrap = _this$$refs.topTrap;\n\n        if (bottomTrap && target === bottomTrap) {\n          // If user pressed TAB out of modal into our bottom trab trap element\n          // Find the first tabable element in the modal content and focus it\n          if (attemptFocus(tabables[0])) {\n            // Focus was successful\n            return;\n          }\n        } else if (topTrap && target === topTrap) {\n          // If user pressed CTRL-TAB out of modal and into our top tab trap element\n          // Find the last tabable element in the modal content and focus it\n          if (attemptFocus(tabables[tabables.length - 1])) {\n            // Focus was successful\n            return;\n          }\n        } // Otherwise focus the modal content container\n\n\n        content.focus({\n          preventScroll: true\n        });\n      },\n      // Turn on/off focusin listener\n      setEnforceFocus: function setEnforceFocus(on) {\n        this.listenDocument(on, 'focusin', this.focusHandler);\n      },\n      // Resize listener\n      setResizeEvent: function setResizeEvent(on) {\n        this.listenWindow(on, 'resize', this.checkModalOverflow);\n        this.listenWindow(on, 'orientationchange', this.checkModalOverflow);\n      },\n      // Root listener handlers\n      showHandler: function showHandler(id, triggerEl) {\n        if (id === this.safeId()) {\n          this.return_focus = triggerEl || this.getActiveElement();\n          this.show();\n        }\n      },\n      hideHandler: function hideHandler(id) {\n        if (id === this.safeId()) {\n          this.hide('event');\n        }\n      },\n      toggleHandler: function toggleHandler(id, triggerEl) {\n        if (id === this.safeId()) {\n          this.toggle(triggerEl);\n        }\n      },\n      modalListener: function modalListener(bvEvt) {\n        // If another modal opens, close this one if stacking not permitted\n        if (this.noStacking && bvEvt.vueTarget !== this) {\n          this.hide();\n        }\n      },\n      // Focus control handlers\n      focusFirst: function focusFirst() {\n        var _this6 = this;\n\n        // Don't try and focus if we are SSR\n        if (isBrowser) {\n          requestAF(function () {\n            var modal = _this6.$refs.modal;\n            var content = _this6.$refs.content;\n\n            var activeElement = _this6.getActiveElement(); // If the modal contains the activeElement, we don't do anything\n\n\n            if (modal && content && !(activeElement && contains(content, activeElement))) {\n              var ok = _this6.$refs['ok-button'];\n              var cancel = _this6.$refs['cancel-button'];\n              var close = _this6.$refs['close-button']; // Focus the appropriate button or modal content wrapper\n\n              var autoFocus = _this6.autoFocusButton;\n              var el = autoFocus === 'ok' && ok ? ok.$el || ok : autoFocus === 'cancel' && cancel ? cancel.$el || cancel : autoFocus === 'close' && close ? close.$el || close : content; // Focus the element\n\n              attemptFocus(el);\n\n              if (el === content) {\n                // Make sure top of modal is showing (if longer than the viewport)\n                _this6.$nextTick(function () {\n                  modal.scrollTop = 0;\n                });\n              }\n            }\n          });\n        }\n      },\n      returnFocusTo: function returnFocusTo() {\n        // Prefer `returnFocus` prop over event specified\n        // `return_focus` value\n        var el = this.returnFocus || this.return_focus || null;\n        this.return_focus = null;\n        this.$nextTick(function () {\n          // Is el a string CSS selector?\n          el = isString(el) ? select(el) : el;\n\n          if (el) {\n            // Possibly could be a component reference\n            el = el.$el || el;\n            attemptFocus(el);\n          }\n        });\n      },\n      checkModalOverflow: function checkModalOverflow() {\n        if (this.isVisible) {\n          var modal = this.$refs.modal;\n          this.isModalOverflowing = modal.scrollHeight > document.documentElement.clientHeight;\n        }\n      },\n      makeModal: function makeModal(h) {\n        // Modal header\n        var header = h();\n\n        if (!this.hideHeader) {\n          var modalHeader = this.normalizeSlot('modal-header', this.slotScope);\n\n          if (!modalHeader) {\n            var closeButton = h();\n\n            if (!this.hideHeaderClose) {\n              closeButton = h(BButtonClose, {\n                ref: 'close-button',\n                props: {\n                  content: this.headerCloseContent,\n                  disabled: this.isTransitioning,\n                  ariaLabel: this.headerCloseLabel,\n                  textVariant: this.headerCloseVariant || this.headerTextVariant\n                },\n                on: {\n                  click: this.onClose\n                }\n              }, [this.normalizeSlot('modal-header-close')]);\n            }\n\n            var domProps = !this.hasNormalizedSlot('modal-title') && this.titleHtml ? {\n              innerHTML: this.titleHtml\n            } : {};\n            modalHeader = [h(this.titleTag, {\n              staticClass: 'modal-title',\n              class: this.titleClasses,\n              attrs: {\n                id: this.safeId('__BV_modal_title_')\n              },\n              domProps: domProps\n            }, [this.normalizeSlot('modal-title', this.slotScope) || stripTags(this.title)]), closeButton];\n          }\n\n          header = h('header', {\n            ref: 'header',\n            staticClass: 'modal-header',\n            class: this.headerClasses,\n            attrs: {\n              id: this.safeId('__BV_modal_header_')\n            }\n          }, [modalHeader]);\n        } // Modal body\n\n\n        var body = h('div', {\n          ref: 'body',\n          staticClass: 'modal-body',\n          class: this.bodyClasses,\n          attrs: {\n            id: this.safeId('__BV_modal_body_')\n          }\n        }, this.normalizeSlot('default', this.slotScope)); // Modal footer\n\n        var footer = h();\n\n        if (!this.hideFooter) {\n          var modalFooter = this.normalizeSlot('modal-footer', this.slotScope);\n\n          if (!modalFooter) {\n            var cancelButton = h();\n\n            if (!this.okOnly) {\n              var cancelHtml = this.cancelTitleHtml ? {\n                innerHTML: this.cancelTitleHtml\n              } : null;\n              cancelButton = h(BButton, {\n                ref: 'cancel-button',\n                props: {\n                  variant: this.cancelVariant,\n                  size: this.buttonSize,\n                  disabled: this.cancelDisabled || this.busy || this.isTransitioning\n                },\n                on: {\n                  click: this.onCancel\n                }\n              }, [this.normalizeSlot('modal-cancel') || (cancelHtml ? h('span', {\n                domProps: cancelHtml\n              }) : stripTags(this.cancelTitle))]);\n            }\n\n            var okHtml = this.okTitleHtml ? {\n              innerHTML: this.okTitleHtml\n            } : null;\n            var okButton = h(BButton, {\n              ref: 'ok-button',\n              props: {\n                variant: this.okVariant,\n                size: this.buttonSize,\n                disabled: this.okDisabled || this.busy || this.isTransitioning\n              },\n              on: {\n                click: this.onOk\n              }\n            }, [this.normalizeSlot('modal-ok') || (okHtml ? h('span', {\n              domProps: okHtml\n            }) : stripTags(this.okTitle))]);\n            modalFooter = [cancelButton, okButton];\n          }\n\n          footer = h('footer', {\n            ref: 'footer',\n            staticClass: 'modal-footer',\n            class: this.footerClasses,\n            attrs: {\n              id: this.safeId('__BV_modal_footer_')\n            }\n          }, [modalFooter]);\n        } // Assemble modal content\n\n\n        var modalContent = h('div', {\n          ref: 'content',\n          staticClass: 'modal-content',\n          class: this.contentClass,\n          attrs: {\n            role: 'document',\n            id: this.safeId('__BV_modal_content_'),\n            tabindex: '-1'\n          }\n        }, [header, body, footer]); // Tab trap to prevent page from scrolling to next element in\n        // tab index during enforce focus tab cycle\n\n        var tabTrapTop = h();\n        var tabTrapBottom = h();\n\n        if (this.isVisible && !this.noEnforceFocus) {\n          tabTrapTop = h('span', {\n            ref: 'topTrap',\n            attrs: {\n              tabindex: '0'\n            }\n          });\n          tabTrapBottom = h('span', {\n            ref: 'bottomTrap',\n            attrs: {\n              tabindex: '0'\n            }\n          });\n        } // Modal dialog wrapper\n\n\n        var modalDialog = h('div', {\n          ref: 'dialog',\n          staticClass: 'modal-dialog',\n          class: this.dialogClasses,\n          on: {\n            mousedown: this.onDialogMousedown\n          }\n        }, [tabTrapTop, modalContent, tabTrapBottom]); // Modal\n\n        var modal = h('div', {\n          ref: 'modal',\n          staticClass: 'modal',\n          class: this.modalClasses,\n          style: this.modalStyles,\n          directives: [{\n            name: 'show',\n            rawName: 'v-show',\n            value: this.isVisible,\n            expression: 'isVisible'\n          }],\n          attrs: {\n            id: this.safeId(),\n            role: 'dialog',\n            'aria-hidden': this.isVisible ? null : 'true',\n            'aria-modal': this.isVisible ? 'true' : null,\n            'aria-label': this.ariaLabel,\n            'aria-labelledby': this.hideHeader || this.ariaLabel || !(this.hasNormalizedSlot('modal-title') || this.titleHtml || this.title) ? null : this.safeId('__BV_modal_title_'),\n            'aria-describedby': this.safeId('__BV_modal_body_')\n          },\n          on: {\n            keydown: this.onEsc,\n            click: this.onClickOut\n          }\n        }, [modalDialog]); // Wrap modal in transition\n        // Sadly, we can't use BVTransition here due to the differences in\n        // transition durations for .modal and .modal-dialog. Not until\n        // issue https://github.com/vuejs/vue/issues/9986 is resolved\n\n        modal = h('transition', {\n          props: {\n            enterClass: '',\n            enterToClass: '',\n            enterActiveClass: '',\n            leaveClass: '',\n            leaveActiveClass: '',\n            leaveToClass: ''\n          },\n          on: {\n            beforeEnter: this.onBeforeEnter,\n            enter: this.onEnter,\n            afterEnter: this.onAfterEnter,\n            beforeLeave: this.onBeforeLeave,\n            leave: this.onLeave,\n            afterLeave: this.onAfterLeave\n          }\n        }, [modal]); // Modal backdrop\n\n        var backdrop = h();\n\n        if (!this.hideBackdrop && this.isVisible) {\n          backdrop = h('div', {\n            staticClass: 'modal-backdrop',\n            attrs: {\n              id: this.safeId('__BV_modal_backdrop_')\n            }\n          }, [this.normalizeSlot('modal-backdrop')]);\n        }\n\n        backdrop = h(BVTransition, {\n          props: {\n            noFade: this.noFade\n          }\n        }, [backdrop]); // If the parent has a scoped style attribute, and the modal\n        // is portalled, add the scoped attribute to the modal wrapper\n\n        var scopedStyleAttrs = !this.static ? this.scopedStyleAttrs : {}; // Assemble modal and backdrop in an outer <div>\n\n        return h('div', {\n          key: \"modal-outer-\".concat(this._uid),\n          style: this.modalOuterStyle,\n          attrs: _objectSpread2({}, scopedStyleAttrs, {}, this.$attrs, {\n            id: this.safeId('__BV_modal_outer_')\n          })\n        }, [modal, backdrop]);\n      }\n    },\n    render: function render(h) {\n      if (this.static) {\n        return this.lazy && this.isHidden ? h() : this.makeModal(h);\n      } else {\n        return this.isHidden ? h() : h(BTransporterSingle, [this.makeModal(h)]);\n      }\n    }\n  });\n\n  var EVENT_SHOW = 'bv::show::modal'; // Prop name we use to store info on root element\n\n  var PROPERTY = '__bv_modal_directive__';\n\n  var getTarget = function getTarget(_ref) {\n    var _ref$modifiers = _ref.modifiers,\n        modifiers = _ref$modifiers === void 0 ? {} : _ref$modifiers,\n        arg = _ref.arg,\n        value = _ref.value;\n    // Try value, then arg, otherwise pick last modifier\n    return isString(value) ? value : isString(arg) ? arg : keys(modifiers).reverse()[0];\n  };\n\n  var getTriggerElement = function getTriggerElement(el) {\n    // If root element is a dropdown-item or nav-item, we\n    // need to target the inner link or button instead\n    return el && matches(el, '.dropdown-menu > li, li.nav-item') ? select('a, button', el) || el : el;\n  };\n\n  var setRole = function setRole(trigger) {\n    // Ensure accessibility on non button elements\n    if (trigger && trigger.tagName !== 'BUTTON') {\n      // Only set a role if the trigger element doesn't have one\n      if (!hasAttr(trigger, 'role')) {\n        setAttr(trigger, 'role', 'button');\n      } // Add a tabindex is not a button or link, and tabindex is not provided\n\n\n      if (trigger.tagName !== 'A' && !hasAttr(trigger, 'tabindex')) {\n        setAttr(trigger, 'tabindex', '0');\n      }\n    }\n  };\n\n  var bind$1 = function bind(el, binding, vnode) {\n    var target = getTarget(binding);\n    var trigger = getTriggerElement(el);\n\n    if (target && trigger) {\n      var handler = function handler(evt) {\n        // `currentTarget` is the element with the listener on it\n        var currentTarget = evt.currentTarget;\n\n        if (!isDisabled(currentTarget)) {\n          var type = evt.type;\n          var key = evt.keyCode; // Open modal only if trigger is not disabled\n\n          if (type === 'click' || type === 'keydown' && (key === KEY_CODES.ENTER || key === KEY_CODES.SPACE)) {\n            vnode.context.$root.$emit(EVENT_SHOW, target, currentTarget);\n          }\n        }\n      };\n\n      el[PROPERTY] = {\n        handler: handler,\n        target: target,\n        trigger: trigger\n      }; // If element is not a button, we add `role=\"button\"` for accessibility\n\n      setRole(trigger); // Listen for click events\n\n      eventOn(trigger, 'click', handler, EVENT_OPTIONS_PASSIVE);\n\n      if (trigger.tagName !== 'BUTTON' && getAttr(trigger, 'role') === 'button') {\n        // If trigger isn't a button but has role button,\n        // we also listen for `keydown.space` && `keydown.enter`\n        eventOn(trigger, 'keydown', handler, EVENT_OPTIONS_PASSIVE);\n      }\n    }\n  };\n\n  var unbind$1 = function unbind(el) {\n    var oldProp = el[PROPERTY] || {};\n    var trigger = oldProp.trigger;\n    var handler = oldProp.handler;\n\n    if (trigger && handler) {\n      eventOff(trigger, 'click', handler, EVENT_OPTIONS_PASSIVE);\n      eventOff(trigger, 'keydown', handler, EVENT_OPTIONS_PASSIVE);\n      eventOff(el, 'click', handler, EVENT_OPTIONS_PASSIVE);\n      eventOff(el, 'keydown', handler, EVENT_OPTIONS_PASSIVE);\n    }\n\n    delete el[PROPERTY];\n  };\n\n  var componentUpdated$1 = function componentUpdated(el, binding, vnode) {\n    var oldProp = el[PROPERTY] || {};\n    var target = getTarget(binding);\n    var trigger = getTriggerElement(el);\n\n    if (target !== oldProp.target || trigger !== oldProp.trigger) {\n      // We bind and rebind if the target or trigger changes\n      unbind$1(el);\n      bind$1(el, binding, vnode);\n    } // If trigger element is not a button, ensure `role=\"button\"`\n    // is still set for accessibility\n\n\n    setRole(trigger);\n  };\n\n  var updated = function updated() {};\n  /*\n   * Export our directive\n   */\n\n\n  var VBModal = {\n    inserted: componentUpdated$1,\n    updated: updated,\n    componentUpdated: componentUpdated$1,\n    unbind: unbind$1\n  };\n\n  var PROP_NAME$2 = '$bvModal';\n  var PROP_NAME_PRIV = '_bv__modal'; // Base modal props that are allowed\n  // Some may be ignored or overridden on some message boxes\n  // Prop ID is allowed, but really only should be used for testing\n  // We need to add it in explicitly as it comes from the `idMixin`\n\n  var BASE_PROPS = ['id'].concat(_toConsumableArray(keys(omit(props$H, ['busy', 'lazy', 'noStacking', \"static\", 'visible'])))); // Fallback event resolver (returns undefined)\n\n  var defaultResolver = function defaultResolver() {}; // Map prop names to modal slot names\n\n\n  var propsToSlots = {\n    msgBoxContent: 'default',\n    title: 'modal-title',\n    okTitle: 'modal-ok',\n    cancelTitle: 'modal-cancel'\n  }; // --- Utility methods ---\n  // Method to filter only recognized props that are not undefined\n\n  var filterOptions = function filterOptions(options) {\n    return BASE_PROPS.reduce(function (memo, key) {\n      if (!isUndefined(options[key])) {\n        memo[key] = options[key];\n      }\n\n      return memo;\n    }, {});\n  }; // Method to install `$bvModal` VM injection\n\n\n  var plugin = function plugin(Vue) {\n    // Create a private sub-component that extends BModal\n    // which self-destructs after hidden\n    // @vue/component\n    var BMsgBox = Vue.extend({\n      name: 'BMsgBox',\n      extends: BModal,\n      destroyed: function destroyed() {\n        // Make sure we not in document any more\n        if (this.$el && this.$el.parentNode) {\n          this.$el.parentNode.removeChild(this.$el);\n        }\n      },\n      mounted: function mounted() {\n        var _this = this;\n\n        // Self destruct handler\n        var handleDestroy = function handleDestroy() {\n          var self = _this;\n\n          _this.$nextTick(function () {\n            // In a `setTimeout()` to release control back to application\n            setTimeout(function () {\n              return self.$destroy();\n            }, 0);\n          });\n        }; // Self destruct if parent destroyed\n\n\n        this.$parent.$once('hook:destroyed', handleDestroy); // Self destruct after hidden\n\n        this.$once('hidden', handleDestroy); // Self destruct on route change\n\n        /* istanbul ignore if */\n\n        if (this.$router && this.$route) {\n          // Destroy ourselves if route changes\n\n          /* istanbul ignore next */\n          this.$once('hook:beforeDestroy', this.$watch('$router', handleDestroy));\n        } // Show the `BMsgBox`\n\n\n        this.show();\n      }\n    }); // Method to generate the on-demand modal message box\n    // Returns a promise that resolves to a value returned by the resolve\n\n    var asyncMsgBox = function asyncMsgBox($parent, props) {\n      var resolver = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultResolver;\n\n      if (warnNotClient(PROP_NAME$2) || warnNoPromiseSupport(PROP_NAME$2)) {\n        /* istanbul ignore next */\n        return;\n      } // Create an instance of `BMsgBox` component\n\n\n      var msgBox = new BMsgBox({\n        // We set parent as the local VM so these modals can emit events on\n        // the app `$root`, as needed by things like tooltips and popovers\n        // And it helps to ensure `BMsgBox` is destroyed when parent is destroyed\n        parent: $parent,\n        // Preset the prop values\n        propsData: _objectSpread2({}, filterOptions(getComponentConfig('BModal') || {}), {\n          // Defaults that user can override\n          hideHeaderClose: true,\n          hideHeader: !(props.title || props.titleHtml)\n        }, omit(props, keys(propsToSlots)), {\n          // Props that can't be overridden\n          lazy: false,\n          busy: false,\n          visible: false,\n          noStacking: false,\n          noEnforceFocus: false\n        })\n      }); // Convert certain props to scoped slots\n\n      keys(propsToSlots).forEach(function (prop) {\n        if (!isUndefined(props[prop])) {\n          // Can be a string, or array of VNodes.\n          // Alternatively, user can use HTML version of prop to pass an HTML string.\n          msgBox.$slots[propsToSlots[prop]] = concat(props[prop]);\n        }\n      }); // Return a promise that resolves when hidden, or rejects on destroyed\n\n      return new Promise(function (resolve, reject) {\n        var resolved = false;\n        msgBox.$once('hook:destroyed', function () {\n          if (!resolved) {\n            /* istanbul ignore next */\n            reject(new Error('BootstrapVue MsgBox destroyed before resolve'));\n          }\n        });\n        msgBox.$on('hide', function (bvModalEvt) {\n          if (!bvModalEvt.defaultPrevented) {\n            var result = resolver(bvModalEvt); // If resolver didn't cancel hide, we resolve\n\n            if (!bvModalEvt.defaultPrevented) {\n              resolved = true;\n              resolve(result);\n            }\n          }\n        }); // Create a mount point (a DIV) and mount the msgBo which will trigger it to show\n\n        var div = document.createElement('div');\n        document.body.appendChild(div);\n        msgBox.$mount(div);\n      });\n    }; // Private utility method to open a user defined message box and returns a promise.\n    // Not to be used directly by consumers, as this method may change calling syntax\n\n\n    var makeMsgBox = function makeMsgBox($parent, content) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var resolver = arguments.length > 3 ? arguments[3] : undefined;\n\n      if (!content || warnNoPromiseSupport(PROP_NAME$2) || warnNotClient(PROP_NAME$2) || !isFunction(resolver)) {\n        /* istanbul ignore next */\n        return;\n      }\n\n      return asyncMsgBox($parent, _objectSpread2({}, filterOptions(options), {\n        msgBoxContent: content\n      }), resolver);\n    }; // BvModal instance class\n\n\n    var BvModal =\n    /*#__PURE__*/\n    function () {\n      function BvModal(vm) {\n        _classCallCheck(this, BvModal);\n\n        // Assign the new properties to this instance\n        assign(this, {\n          _vm: vm,\n          _root: vm.$root\n        }); // Set these properties as read-only and non-enumerable\n\n        defineProperties(this, {\n          _vm: readonlyDescriptor(),\n          _root: readonlyDescriptor()\n        });\n      } // --- Instance methods ---\n      // Show modal with the specified ID args are for future use\n\n\n      _createClass(BvModal, [{\n        key: \"show\",\n        value: function show(id) {\n          if (id && this._root) {\n            var _this$_root;\n\n            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n              args[_key - 1] = arguments[_key];\n            }\n\n            (_this$_root = this._root).$emit.apply(_this$_root, ['bv::show::modal', id].concat(args));\n          }\n        } // Hide modal with the specified ID args are for future use\n\n      }, {\n        key: \"hide\",\n        value: function hide(id) {\n          if (id && this._root) {\n            var _this$_root2;\n\n            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n              args[_key2 - 1] = arguments[_key2];\n            }\n\n            (_this$_root2 = this._root).$emit.apply(_this$_root2, ['bv::hide::modal', id].concat(args));\n          }\n        } // The following methods require Promise support!\n        // IE 11 and others do not support Promise natively, so users\n        // should have a Polyfill loaded (which they need anyways for IE 11 support)\n        // Open a message box with OK button only and returns a promise\n\n      }, {\n        key: \"msgBoxOk\",\n        value: function msgBoxOk(message) {\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          // Pick the modal props we support from options\n          var props = _objectSpread2({}, options, {\n            // Add in overrides and our content prop\n            okOnly: true,\n            okDisabled: false,\n            hideFooter: false,\n            msgBoxContent: message\n          });\n\n          return makeMsgBox(this._vm, message, props, function () {\n            // Always resolve to true for OK\n            return true;\n          });\n        } // Open a message box modal with OK and CANCEL buttons\n        // and returns a promise\n\n      }, {\n        key: \"msgBoxConfirm\",\n        value: function msgBoxConfirm(message) {\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          // Set the modal props we support from options\n          var props = _objectSpread2({}, options, {\n            // Add in overrides and our content prop\n            okOnly: false,\n            okDisabled: false,\n            cancelDisabled: false,\n            hideFooter: false\n          });\n\n          return makeMsgBox(this._vm, message, props, function (bvModalEvt) {\n            var trigger = bvModalEvt.trigger;\n            return trigger === 'ok' ? true : trigger === 'cancel' ? false : null;\n          });\n        }\n      }]);\n\n      return BvModal;\n    }(); // Add our instance mixin\n\n\n    Vue.mixin({\n      beforeCreate: function beforeCreate() {\n        // Because we need access to `$root` for `$emits`, and VM for parenting,\n        // we have to create a fresh instance of `BvModal` for each VM\n        this[PROP_NAME_PRIV] = new BvModal(this);\n      }\n    }); // Define our read-only `$bvModal` instance property\n    // Placed in an if just in case in HMR mode\n    // eslint-disable-next-line no-prototype-builtins\n\n    if (!Vue.prototype.hasOwnProperty(PROP_NAME$2)) {\n      defineProperty(Vue.prototype, PROP_NAME$2, {\n        get: function get() {\n          /* istanbul ignore next */\n          if (!this || !this[PROP_NAME_PRIV]) {\n            warn(\"\\\"\".concat(PROP_NAME$2, \"\\\" must be accessed from a Vue instance \\\"this\\\" context.\"), 'BModal');\n          }\n\n          return this[PROP_NAME_PRIV];\n        }\n      });\n    }\n  };\n\n  var BVModalPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    plugins: {\n      plugin: plugin\n    }\n  });\n\n  var ModalPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BModal: BModal\n    },\n    directives: {\n      VBModal: VBModal\n    },\n    // $bvModal injection\n    plugins: {\n      BVModalPlugin: BVModalPlugin\n    }\n  });\n\n  var props$I = {\n    tag: {\n      type: String,\n      default: 'ul'\n    },\n    fill: {\n      type: Boolean,\n      default: false\n    },\n    justified: {\n      type: Boolean,\n      default: false\n    },\n    align: {\n      type: String,\n      default: null\n    },\n    tabs: {\n      type: Boolean,\n      default: false\n    },\n    pills: {\n      type: Boolean,\n      default: false\n    },\n    vertical: {\n      type: Boolean,\n      default: false\n    },\n    small: {\n      type: Boolean,\n      default: false\n    },\n    cardHeader: {\n      // Set to true if placing in a card header\n      type: Boolean,\n      default: false\n    }\n  }; // -- Utils --\n\n  var computeJustifyContent = function computeJustifyContent(value) {\n    // Normalize value\n    value = value === 'left' ? 'start' : value === 'right' ? 'end' : value;\n    return \"justify-content-\".concat(value);\n  }; // @vue/component\n\n\n  var BNav =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BNav',\n    functional: true,\n    props: props$I,\n    render: function render(h, _ref) {\n      var _class;\n\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h(props.tag, a(data, {\n        staticClass: 'nav',\n        class: (_class = {\n          'nav-tabs': props.tabs,\n          'nav-pills': props.pills && !props.tabs,\n          'card-header-tabs': !props.vertical && props.cardHeader && props.tabs,\n          'card-header-pills': !props.vertical && props.cardHeader && props.pills && !props.tabs,\n          'flex-column': props.vertical,\n          'nav-fill': !props.vertical && props.fill,\n          'nav-justified': !props.vertical && props.justified\n        }, _defineProperty(_class, computeJustifyContent(props.align), !props.vertical && props.align), _defineProperty(_class, \"small\", props.small), _class)\n      }), children);\n    }\n  });\n\n  var props$J = propsFactory(); // @vue/component\n\n  var BNavItem =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BNavItem',\n    functional: true,\n    props: _objectSpread2({}, props$J, {\n      linkAttrs: {\n        type: Object,\n        default: function _default() {}\n      },\n      linkClasses: {\n        type: [String, Object, Array],\n        default: null\n      }\n    }),\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          listeners = _ref.listeners,\n          children = _ref.children;\n      // We transfer the listeners to the link\n      delete data.on;\n      return h('li', a(data, {\n        staticClass: 'nav-item'\n      }), [h(BLink, {\n        staticClass: 'nav-link',\n        class: props.linkClasses,\n        attrs: props.linkAttrs,\n        props: props,\n        on: listeners\n      }, children)]);\n    }\n  });\n\n  var props$K = {}; // @vue/component\n\n  var BNavText =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BNavText',\n    functional: true,\n    props: props$K,\n    render: function render(h, _ref) {\n      var data = _ref.data,\n          children = _ref.children;\n      return h('li', a(data, {\n        staticClass: 'navbar-text'\n      }), children);\n    }\n  });\n\n  var props$L = _objectSpread2({}, omit(props$o, ['inline']), {\n    formClass: {\n      type: [String, Array, Object],\n      default: null\n    }\n  }); // @vue/component\n\n  var BNavForm =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BNavForm',\n    functional: true,\n    props: props$L,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children,\n          _ref$listeners = _ref.listeners,\n          listeners = _ref$listeners === void 0 ? {} : _ref$listeners;\n      var attrs = data.attrs; // The following data properties are cleared out\n      // as they will be passed to BForm directly\n\n      data.attrs = {};\n      data.on = {};\n      var $form = h(BForm, {\n        class: props.formClass,\n        props: _objectSpread2({}, props, {\n          inline: true\n        }),\n        attrs: attrs,\n        on: listeners\n      }, children);\n      return h('li', a(data, {\n        staticClass: 'form-inline'\n      }), [$form]);\n    }\n  });\n\n  var props$M = pluckProps(['text', 'html', 'menuClass', 'toggleClass', 'noCaret', 'role', 'lazy'], props$j); // @vue/component\n\n  var BNavItemDropdown =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BNavItemDropdown',\n    mixins: [idMixin, dropdownMixin, normalizeSlotMixin],\n    props: props$M,\n    computed: {\n      isNav: function isNav() {\n        // Signal to dropdown mixin that we are in a navbar\n        return true;\n      },\n      dropdownClasses: function dropdownClasses() {\n        return [this.directionClass, {\n          show: this.visible\n        }];\n      },\n      menuClasses: function menuClasses() {\n        return [this.menuClass, {\n          'dropdown-menu-right': this.right,\n          show: this.visible\n        }];\n      },\n      toggleClasses: function toggleClasses() {\n        return [this.toggleClass, {\n          'dropdown-toggle-no-caret': this.noCaret\n        }];\n      }\n    },\n    render: function render(h) {\n      var button = h(BLink, {\n        ref: 'toggle',\n        staticClass: 'nav-link dropdown-toggle',\n        class: this.toggleClasses,\n        props: {\n          href: '#',\n          disabled: this.disabled\n        },\n        attrs: {\n          id: this.safeId('_BV_button_'),\n          'aria-haspopup': 'true',\n          'aria-expanded': this.visible ? 'true' : 'false'\n        },\n        on: {\n          mousedown: this.onMousedown,\n          click: this.toggle,\n          keydown: this.toggle // Handle ENTER, SPACE and DOWN\n\n        }\n      }, [this.$slots['button-content'] || this.$slots.text || h('span', {\n        domProps: htmlOrText(this.html, this.text)\n      })]);\n      var menu = h('ul', {\n        staticClass: 'dropdown-menu',\n        class: this.menuClasses,\n        ref: 'menu',\n        attrs: {\n          tabindex: '-1',\n          'aria-labelledby': this.safeId('_BV_button_')\n        },\n        on: {\n          keydown: this.onKeydown // Handle UP, DOWN and ESC\n\n        }\n      }, !this.lazy || this.visible ? this.normalizeSlot('default', {\n        hide: this.hide\n      }) : [h()]);\n      return h('li', {\n        staticClass: 'nav-item b-nav-dropdown dropdown',\n        class: this.dropdownClasses,\n        attrs: {\n          id: this.safeId()\n        }\n      }, [button, menu]);\n    }\n  });\n\n  var NavPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BNav: BNav,\n      BNavItem: BNavItem,\n      BNavText: BNavText,\n      BNavForm: BNavForm,\n      BNavItemDropdown: BNavItemDropdown,\n      BNavItemDd: BNavItemDropdown,\n      BNavDropdown: BNavItemDropdown,\n      BNavDd: BNavItemDropdown\n    },\n    plugins: {\n      DropdownPlugin: DropdownPlugin\n    }\n  });\n\n  var NAME$o = 'BNavbar';\n  var props$N = {\n    tag: {\n      type: String,\n      default: 'nav'\n    },\n    type: {\n      type: String,\n      default: 'light'\n    },\n    variant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$o, 'variant');\n      }\n    },\n    toggleable: {\n      type: [Boolean, String],\n      default: false\n    },\n    fixed: {\n      type: String\n    },\n    sticky: {\n      type: Boolean,\n      default: false\n    },\n    print: {\n      type: Boolean,\n      default: false\n    }\n  }; // @vue/component\n\n  var BNavbar =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$o,\n    mixins: [normalizeSlotMixin],\n    props: props$N,\n    provide: function provide() {\n      return {\n        bvNavbar: this\n      };\n    },\n    computed: {\n      breakpointClass: function breakpointClass() {\n        var breakpoint = null;\n        var xs = getBreakpoints()[0];\n        var toggleable = this.toggleable;\n\n        if (toggleable && isString(toggleable) && toggleable !== xs) {\n          breakpoint = \"navbar-expand-\".concat(toggleable);\n        } else if (toggleable === false) {\n          breakpoint = 'navbar-expand';\n        }\n\n        return breakpoint;\n      }\n    },\n    render: function render(h) {\n      var _ref;\n\n      return h(this.tag, {\n        staticClass: 'navbar',\n        class: [(_ref = {\n          'd-print': this.print,\n          'sticky-top': this.sticky\n        }, _defineProperty(_ref, \"navbar-\".concat(this.type), this.type), _defineProperty(_ref, \"bg-\".concat(this.variant), this.variant), _defineProperty(_ref, \"fixed-\".concat(this.fixed), this.fixed), _ref), this.breakpointClass],\n        attrs: {\n          role: this.tag === 'nav' ? null : 'navigation'\n        }\n      }, [this.normalizeSlot('default')]);\n    }\n  });\n\n  var props$O = pluckProps(['tag', 'fill', 'justified', 'align', 'small'], props$I); // -- Utils --\n\n  var computeJustifyContent$1 = function computeJustifyContent(value) {\n    // Normalize value\n    value = value === 'left' ? 'start' : value === 'right' ? 'end' : value;\n    return \"justify-content-\".concat(value);\n  }; // @vue/component\n\n\n  var BNavbarNav =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BNavbarNav',\n    functional: true,\n    props: props$O,\n    render: function render(h, _ref) {\n      var _class;\n\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      return h(props.tag, a(data, {\n        staticClass: 'navbar-nav',\n        class: (_class = {\n          'nav-fill': props.fill,\n          'nav-justified': props.justified\n        }, _defineProperty(_class, computeJustifyContent$1(props.align), props.align), _defineProperty(_class, \"small\", props.small), _class)\n      }), children);\n    }\n  });\n\n  var linkProps$3 = propsFactory();\n  linkProps$3.href.default = undefined;\n  linkProps$3.to.default = undefined;\n  var props$P = _objectSpread2({}, linkProps$3, {\n    tag: {\n      type: String,\n      default: 'div'\n    }\n  }); // @vue/component\n\n  var BNavbarBrand =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BNavbarBrand',\n    functional: true,\n    props: props$P,\n    render: function render(h, _ref) {\n      var props = _ref.props,\n          data = _ref.data,\n          children = _ref.children;\n      var isLink = props.to || props.href;\n      var tag = isLink ? BLink : props.tag;\n      return h(tag, a(data, {\n        staticClass: 'navbar-brand',\n        props: isLink ? pluckProps(linkProps$3, props) : {}\n      }), children);\n    }\n  });\n\n  var NAME$p = 'BNavbarToggle'; // TODO: Switch to using VBToggle directive, will reduce code footprint\n  // Events we emit on $root\n\n  var EVENT_TOGGLE$2 = 'bv::toggle::collapse'; // Events we listen to on $root\n\n  var EVENT_STATE$2 = 'bv::collapse::state'; // This private event is NOT to be documented as people should not be using it.\n\n  var EVENT_STATE_SYNC$2 = 'bv::collapse::sync::state'; // @vue/component\n\n  var BNavbarToggle =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$p,\n    mixins: [listenOnRootMixin, normalizeSlotMixin],\n    props: {\n      label: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$p, 'label');\n        }\n      },\n      target: {\n        type: String,\n        required: true\n      }\n    },\n    data: function data() {\n      return {\n        toggleState: false\n      };\n    },\n    created: function created() {\n      this.listenOnRoot(EVENT_STATE$2, this.handleStateEvt);\n      this.listenOnRoot(EVENT_STATE_SYNC$2, this.handleStateEvt);\n    },\n    methods: {\n      onClick: function onClick(evt) {\n        this.$emit('click', evt);\n\n        if (!evt.defaultPrevented) {\n          this.$root.$emit(EVENT_TOGGLE$2, this.target);\n        }\n      },\n      handleStateEvt: function handleStateEvt(id, state) {\n        if (id === this.target) {\n          this.toggleState = state;\n        }\n      }\n    },\n    render: function render(h) {\n      return h('button', {\n        class: ['navbar-toggler'],\n        attrs: {\n          type: 'button',\n          'aria-label': this.label,\n          'aria-controls': this.target,\n          'aria-expanded': this.toggleState ? 'true' : 'false'\n        },\n        on: {\n          click: this.onClick\n        }\n      }, [this.normalizeSlot('default') || h('span', {\n        class: ['navbar-toggler-icon']\n      })]);\n    }\n  });\n\n  var NavbarPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BNavbar: BNavbar,\n      BNavbarNav: BNavbarNav,\n      BNavbarBrand: BNavbarBrand,\n      BNavbarToggle: BNavbarToggle,\n      BNavToggle: BNavbarToggle\n    },\n    plugins: {\n      NavPlugin: NavPlugin,\n      CollapsePlugin: CollapsePlugin,\n      DropdownPlugin: DropdownPlugin\n    }\n  });\n\n  /**\n   * @param {number} length\n   * @return {Array}\n   */\n  var range = function range(length) {\n    return Array.apply(null, {\n      length: length\n    });\n  };\n\n  // for `<b-pagination>` and `<b-pagination-nav>`\n  // --- Constants ---\n  // Threshold of limit size when we start/stop showing ellipsis\n\n  var ELLIPSIS_THRESHOLD = 3; // Default # of buttons limit\n\n  var DEFAULT_LIMIT = 5; // --- Helper methods ---\n  // Make an array of N to N+X\n\n  var makePageArray = function makePageArray(startNumber, numberOfPages) {\n    return range(numberOfPages).map(function (val, i) {\n      return {\n        number: startNumber + i,\n        classes: null\n      };\n    });\n  }; // Sanitize the provided limit value (converting to a number)\n\n\n  var sanitizeLimit = function sanitizeLimit(val) {\n    var limit = toInteger(val) || 1;\n    return limit < 1 ? DEFAULT_LIMIT : limit;\n  }; // Sanitize the provided current page number (converting to a number)\n\n\n  var sanitizeCurrentPage = function sanitizeCurrentPage(val, numberOfPages) {\n    var page = toInteger(val) || 1;\n    return page > numberOfPages ? numberOfPages : page < 1 ? 1 : page;\n  }; // Links don't normally respond to SPACE, so we add that\n  // functionality via this handler\n\n\n  var onSpaceKey = function onSpaceKey(evt) {\n    if (evt.keyCode === KEY_CODES.SPACE) {\n      evt.preventDefault(); // Stop page from scrolling\n\n      evt.stopImmediatePropagation();\n      evt.stopPropagation(); // Trigger the click event on the link\n\n      evt.currentTarget.click();\n      return false;\n    }\n  }; // --- Props ---\n\n\n  var props$Q = {\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    value: {\n      type: [Number, String],\n      default: null,\n      validator: function validator(value)\n      /* istanbul ignore next */\n      {\n        var number = toInteger(value);\n\n        if (!isNull(value) && (isNaN(number) || number < 1)) {\n          warn('\"v-model\" value must be a number greater than \"0\"', 'BPagination');\n          return false;\n        }\n\n        return true;\n      }\n    },\n    limit: {\n      type: [Number, String],\n      default: DEFAULT_LIMIT,\n      validator: function validator(value)\n      /* istanbul ignore next */\n      {\n        var number = toInteger(value);\n\n        if (isNaN(number) || number < 1) {\n          warn('Prop \"limit\" must be a number greater than \"0\"', 'BPagination');\n          return false;\n        }\n\n        return true;\n      }\n    },\n    align: {\n      type: String,\n      default: 'left'\n    },\n    pills: {\n      type: Boolean,\n      default: false\n    },\n    hideGotoEndButtons: {\n      type: Boolean,\n      default: false\n    },\n    ariaLabel: {\n      type: String,\n      default: 'Pagination'\n    },\n    labelFirstPage: {\n      type: String,\n      default: 'Go to first page'\n    },\n    firstText: {\n      type: String,\n      default: \"\\xAB\" // ''\n\n    },\n    firstNumber: {\n      type: Boolean,\n      default: false\n    },\n    firstClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    labelPrevPage: {\n      type: String,\n      default: 'Go to previous page'\n    },\n    prevText: {\n      type: String,\n      default: \"\\u2039\" // ''\n\n    },\n    prevClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    labelNextPage: {\n      type: String,\n      default: 'Go to next page'\n    },\n    nextText: {\n      type: String,\n      default: \"\\u203A\" // ''\n\n    },\n    nextClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    labelLastPage: {\n      type: String,\n      default: 'Go to last page'\n    },\n    lastText: {\n      type: String,\n      default: \"\\xBB\" // ''\n\n    },\n    lastNumber: {\n      type: Boolean,\n      default: false\n    },\n    lastClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    labelPage: {\n      type: [String, Function],\n      default: 'Go to page'\n    },\n    pageClass: {\n      type: [String, Array, Object],\n      default: null\n    },\n    hideEllipsis: {\n      type: Boolean,\n      default: false\n    },\n    ellipsisText: {\n      type: String,\n      default: \"\\u2026\" // ''\n\n    },\n    ellipsisClass: {\n      type: [String, Array, Object],\n      default: null\n    }\n  }; // @vue/component\n\n  var paginationMixin = {\n    mixins: [normalizeSlotMixin],\n    model: {\n      prop: 'value',\n      event: 'input'\n    },\n    props: props$Q,\n    data: function data() {\n      var curr = toInteger(this.value);\n      return {\n        // -1 signifies no page initially selected\n        currentPage: curr > 0 ? curr : -1,\n        localNumberOfPages: 1,\n        localLimit: DEFAULT_LIMIT\n      };\n    },\n    computed: {\n      btnSize: function btnSize() {\n        return this.size ? \"pagination-\".concat(this.size) : '';\n      },\n      alignment: function alignment() {\n        var align = this.align;\n\n        if (align === 'center') {\n          return 'justify-content-center';\n        } else if (align === 'end' || align === 'right') {\n          return 'justify-content-end';\n        } else if (align === 'fill') {\n          // The page-items will also have 'flex-fill' added\n          // We add text centering to make the button appearance better in fill mode\n          return 'text-center';\n        }\n\n        return '';\n      },\n      styleClass: function styleClass() {\n        return this.pills ? 'b-pagination-pills' : '';\n      },\n      computedCurrentPage: function computedCurrentPage() {\n        return sanitizeCurrentPage(this.currentPage, this.localNumberOfPages);\n      },\n      paginationParams: function paginationParams() {\n        // Determine if we should show the the ellipsis\n        var limit = this.localLimit;\n        var numberOfPages = this.localNumberOfPages;\n        var currentPage = this.computedCurrentPage;\n        var hideEllipsis = this.hideEllipsis;\n        var firstNumber = this.firstNumber;\n        var lastNumber = this.lastNumber;\n        var showFirstDots = false;\n        var showLastDots = false;\n        var numberOfLinks = limit;\n        var startNumber = 1;\n\n        if (numberOfPages <= limit) {\n          // Special case: Less pages available than the limit of displayed pages\n          numberOfLinks = numberOfPages;\n        } else if (currentPage < limit - 1 && limit > ELLIPSIS_THRESHOLD) {\n          if (!hideEllipsis || lastNumber) {\n            showLastDots = true;\n            numberOfLinks = limit - (firstNumber ? 0 : 1);\n          }\n\n          numberOfLinks = Math.min(numberOfLinks, limit);\n        } else if (numberOfPages - currentPage + 2 < limit && limit > ELLIPSIS_THRESHOLD) {\n          if (!hideEllipsis || firstNumber) {\n            showFirstDots = true;\n            numberOfLinks = limit - (lastNumber ? 0 : 1);\n          }\n\n          startNumber = numberOfPages - numberOfLinks + 1;\n        } else {\n          // We are somewhere in the middle of the page list\n          if (limit > ELLIPSIS_THRESHOLD) {\n            numberOfLinks = limit - 2;\n            showFirstDots = !!(!hideEllipsis || firstNumber);\n            showLastDots = !!(!hideEllipsis || lastNumber);\n          }\n\n          startNumber = currentPage - Math.floor(numberOfLinks / 2);\n        } // Sanity checks\n\n        /* istanbul ignore if */\n\n\n        if (startNumber < 1) {\n          startNumber = 1;\n          showFirstDots = false;\n        } else if (startNumber > numberOfPages - numberOfLinks) {\n          startNumber = numberOfPages - numberOfLinks + 1;\n          showLastDots = false;\n        }\n\n        if (showFirstDots && firstNumber && startNumber < 4) {\n          numberOfLinks = numberOfLinks + 2;\n          startNumber = 1;\n          showFirstDots = false;\n        }\n\n        var lastPageNumber = startNumber + numberOfLinks - 1;\n\n        if (showLastDots && lastNumber && lastPageNumber > numberOfPages - 3) {\n          numberOfLinks = numberOfLinks + (lastPageNumber === numberOfPages - 2 ? 2 : 3);\n          showLastDots = false;\n        } // Special handling for lower limits (where ellipsis are never shown)\n\n\n        if (limit <= ELLIPSIS_THRESHOLD) {\n          if (firstNumber && startNumber === 1) {\n            numberOfLinks = Math.min(numberOfLinks + 1, numberOfPages, limit + 1);\n          } else if (lastNumber && numberOfPages === startNumber + numberOfLinks - 1) {\n            startNumber = Math.max(startNumber - 1, 1);\n            numberOfLinks = Math.min(numberOfPages - startNumber + 1, numberOfPages, limit + 1);\n          }\n        }\n\n        numberOfLinks = Math.min(numberOfLinks, numberOfPages - startNumber + 1);\n        return {\n          showFirstDots: showFirstDots,\n          showLastDots: showLastDots,\n          numberOfLinks: numberOfLinks,\n          startNumber: startNumber\n        };\n      },\n      pageList: function pageList() {\n        // Generates the pageList array\n        var _this$paginationParam = this.paginationParams,\n            numberOfLinks = _this$paginationParam.numberOfLinks,\n            startNumber = _this$paginationParam.startNumber;\n        var currentPage = this.computedCurrentPage; // Generate list of page numbers\n\n        var pages = makePageArray(startNumber, numberOfLinks); // We limit to a total of 3 page buttons on XS screens\n        // So add classes to page links to hide them for XS breakpoint\n        // Note: Ellipsis will also be hidden on XS screens\n        // TODO: Make this visual limit configurable based on breakpoint(s)\n\n        if (pages.length > 3) {\n          var idx = currentPage - startNumber; // THe following is a bootstrap-vue custom utility class\n\n          var classes = 'bv-d-xs-down-none';\n\n          if (idx === 0) {\n            // Keep leftmost 3 buttons visible when current page is first page\n            for (var i = 3; i < pages.length; i++) {\n              pages[i].classes = classes;\n            }\n          } else if (idx === pages.length - 1) {\n            // Keep rightmost 3 buttons visible when current page is last page\n            for (var _i = 0; _i < pages.length - 3; _i++) {\n              pages[_i].classes = classes;\n            }\n          } else {\n            // Hide all except current page, current page - 1 and current page + 1\n            for (var _i2 = 0; _i2 < idx - 1; _i2++) {\n              // hide some left button(s)\n              pages[_i2].classes = classes;\n            }\n\n            for (var _i3 = pages.length - 1; _i3 > idx + 1; _i3--) {\n              // hide some right button(s)\n              pages[_i3].classes = classes;\n            }\n          }\n        }\n\n        return pages;\n      }\n    },\n    watch: {\n      value: function value(newValue, oldValue) {\n        if (newValue !== oldValue) {\n          this.currentPage = sanitizeCurrentPage(newValue, this.localNumberOfPages);\n        }\n      },\n      currentPage: function currentPage(newValue, oldValue) {\n        if (newValue !== oldValue) {\n          // Emit null if no page selected\n          this.$emit('input', newValue > 0 ? newValue : null);\n        }\n      },\n      limit: function limit(newValue, oldValue) {\n        if (newValue !== oldValue) {\n          this.localLimit = sanitizeLimit(newValue);\n        }\n      }\n    },\n    created: function created() {\n      var _this = this;\n\n      // Set our default values in data\n      this.localLimit = sanitizeLimit(this.limit);\n      this.$nextTick(function () {\n        // Sanity check\n        _this.currentPage = _this.currentPage > _this.localNumberOfPages ? _this.localNumberOfPages : _this.currentPage;\n      });\n    },\n    methods: {\n      handleKeyNav: function handleKeyNav(evt) {\n        var keyCode = evt.keyCode,\n            shiftKey = evt.shiftKey;\n\n        if (keyCode === KEY_CODES.LEFT || keyCode === KEY_CODES.UP) {\n          evt.preventDefault();\n          shiftKey ? this.focusFirst() : this.focusPrev();\n        } else if (keyCode === KEY_CODES.RIGHT || keyCode === KEY_CODES.DOWN) {\n          evt.preventDefault();\n          shiftKey ? this.focusLast() : this.focusNext();\n        }\n      },\n      getButtons: function getButtons() {\n        // Return only buttons that are visible\n        return selectAll('a.page-link', this.$el).filter(function (btn) {\n          return isVisible(btn);\n        });\n      },\n      setBtnFocus: function setBtnFocus(btn) {\n        btn.focus();\n      },\n      focusCurrent: function focusCurrent() {\n        var _this2 = this;\n\n        // We do this in `$nextTick()` to ensure buttons have finished rendering\n        this.$nextTick(function () {\n          var btn = _this2.getButtons().find(function (el) {\n            return toInteger(getAttr(el, 'aria-posinset')) === _this2.computedCurrentPage;\n          });\n\n          if (btn && btn.focus) {\n            _this2.setBtnFocus(btn);\n          } else {\n            // Fallback if current page is not in button list\n            _this2.focusFirst();\n          }\n        });\n      },\n      focusFirst: function focusFirst() {\n        var _this3 = this;\n\n        // We do this in `$nextTick()` to ensure buttons have finished rendering\n        this.$nextTick(function () {\n          var btn = _this3.getButtons().find(function (el) {\n            return !isDisabled(el);\n          });\n\n          if (btn && btn.focus && btn !== document.activeElement) {\n            _this3.setBtnFocus(btn);\n          }\n        });\n      },\n      focusLast: function focusLast() {\n        var _this4 = this;\n\n        // We do this in `$nextTick()` to ensure buttons have finished rendering\n        this.$nextTick(function () {\n          var btn = _this4.getButtons().reverse().find(function (el) {\n            return !isDisabled(el);\n          });\n\n          if (btn && btn.focus && btn !== document.activeElement) {\n            _this4.setBtnFocus(btn);\n          }\n        });\n      },\n      focusPrev: function focusPrev() {\n        var _this5 = this;\n\n        // We do this in `$nextTick()` to ensure buttons have finished rendering\n        this.$nextTick(function () {\n          var buttons = _this5.getButtons();\n\n          var idx = buttons.indexOf(document.activeElement);\n\n          if (idx > 0 && !isDisabled(buttons[idx - 1]) && buttons[idx - 1].focus) {\n            _this5.setBtnFocus(buttons[idx - 1]);\n          }\n        });\n      },\n      focusNext: function focusNext() {\n        var _this6 = this;\n\n        // We do this in `$nextTick()` to ensure buttons have finished rendering\n        this.$nextTick(function () {\n          var buttons = _this6.getButtons();\n\n          var idx = buttons.indexOf(document.activeElement);\n          var cnt = buttons.length - 1;\n\n          if (idx < cnt && !isDisabled(buttons[idx + 1]) && buttons[idx + 1].focus) {\n            _this6.setBtnFocus(buttons[idx + 1]);\n          }\n        });\n      }\n    },\n    render: function render(h) {\n      var _this7 = this;\n\n      var buttons = [];\n      var numberOfPages = this.localNumberOfPages;\n      var pageNumbers = this.pageList.map(function (p) {\n        return p.number;\n      });\n      var disabled = this.disabled;\n      var _this$paginationParam2 = this.paginationParams,\n          showFirstDots = _this$paginationParam2.showFirstDots,\n          showLastDots = _this$paginationParam2.showLastDots;\n      var currentPage = this.computedCurrentPage;\n      var fill = this.align === 'fill'; // Helper function and flag\n\n      var isActivePage = function isActivePage(pageNum) {\n        return pageNum === currentPage;\n      };\n\n      var noCurrentPage = this.currentPage < 1; // Factory function for prev/next/first/last buttons\n\n      var makeEndBtn = function makeEndBtn(linkTo, ariaLabel, btnSlot, btnText, btnClass, pageTest, key) {\n        var isDisabled = disabled || isActivePage(pageTest) || noCurrentPage || linkTo < 1 || linkTo > numberOfPages;\n        var pageNum = linkTo < 1 ? 1 : linkTo > numberOfPages ? numberOfPages : linkTo;\n        var scope = {\n          disabled: isDisabled,\n          page: pageNum,\n          index: pageNum - 1\n        };\n        var btnContent = _this7.normalizeSlot(btnSlot, scope) || toString$1(btnText) || h();\n        var inner = h(isDisabled ? 'span' : BLink, {\n          staticClass: 'page-link',\n          props: isDisabled ? {} : _this7.linkProps(linkTo),\n          attrs: {\n            role: 'menuitem',\n            tabindex: isDisabled ? null : '-1',\n            'aria-label': ariaLabel,\n            'aria-controls': _this7.ariaControls || null,\n            'aria-disabled': isDisabled ? 'true' : null\n          },\n          on: isDisabled ? {} : {\n            click: function click(evt) {\n              _this7.onClick(linkTo, evt);\n            },\n            keydown: onSpaceKey\n          }\n        }, [btnContent]);\n        return h('li', {\n          key: key,\n          staticClass: 'page-item',\n          class: [{\n            disabled: isDisabled,\n            'flex-fill': fill\n          }, btnClass],\n          attrs: {\n            role: 'presentation',\n            'aria-hidden': isDisabled ? 'true' : null\n          }\n        }, [inner]);\n      }; // Ellipsis factory\n\n\n      var makeEllipsis = function makeEllipsis(isLast) {\n        return h('li', {\n          key: \"ellipsis-\".concat(isLast ? 'last' : 'first'),\n          staticClass: 'page-item',\n          class: ['disabled', 'bv-d-xs-down-none', fill ? 'flex-fill' : '', _this7.ellipsisClass],\n          attrs: {\n            role: 'separator'\n          }\n        }, [h('span', {\n          staticClass: 'page-link'\n        }, [_this7.normalizeSlot('ellipsis-text') || toString$1(_this7.ellipsisText) || h()])]);\n      }; // Page button factory\n\n\n      var makePageButton = function makePageButton(page, idx) {\n        var active = isActivePage(page.number) && !noCurrentPage; // Active page will have tabindex of 0, or if no current page and first page button\n\n        var tabIndex = disabled ? null : active || noCurrentPage && idx === 0 ? '0' : '-1';\n        var attrs = {\n          role: 'menuitemradio',\n          'aria-disabled': disabled ? 'true' : null,\n          'aria-controls': _this7.ariaControls || null,\n          'aria-label': isFunction(_this7.labelPage) ? _this7.labelPage(page.number) : \"\".concat(_this7.labelPage, \" \").concat(page.number),\n          'aria-checked': active ? 'true' : 'false',\n          'aria-posinset': page.number,\n          'aria-setsize': numberOfPages,\n          // ARIA \"roving tabindex\" method\n          tabindex: tabIndex\n        };\n        var btnContent = toString$1(_this7.makePage(page.number));\n        var scope = {\n          page: page.number,\n          index: page.number - 1,\n          content: btnContent,\n          active: active,\n          disabled: disabled\n        };\n        var inner = h(disabled ? 'span' : BLink, {\n          props: disabled ? {} : _this7.linkProps(page.number),\n          staticClass: 'page-link',\n          attrs: attrs,\n          on: disabled ? {} : {\n            click: function click(evt) {\n              _this7.onClick(page.number, evt);\n            },\n            keydown: onSpaceKey\n          }\n        }, [_this7.normalizeSlot('page', scope) || btnContent]);\n        return h('li', {\n          key: \"page-\".concat(page.number),\n          staticClass: 'page-item',\n          class: [{\n            disabled: disabled,\n            active: active,\n            'flex-fill': fill\n          }, page.classes, _this7.pageClass],\n          attrs: {\n            role: 'presentation'\n          }\n        }, [inner]);\n      }; // Goto first page button\n      // Don't render button when `hideGotoEndButtons` or `firstNumber` is set\n\n\n      var $firstPageBtn = h();\n\n      if (!this.firstNumber && !this.hideGotoEndButtons) {\n        $firstPageBtn = makeEndBtn(1, this.labelFirstPage, 'first-text', this.firstText, this.firstClass, 1, 'pagination-goto-first');\n      }\n\n      buttons.push($firstPageBtn); // Goto previous page button\n\n      buttons.push(makeEndBtn(currentPage - 1, this.labelPrevPage, 'prev-text', this.prevText, this.prevClass, 1, 'pagination-goto-prev')); // Show first (1) button?\n\n      buttons.push(this.firstNumber && pageNumbers[0] !== 1 ? makePageButton({\n        number: 1\n      }, 0) : h()); // First ellipsis\n\n      buttons.push(showFirstDots ? makeEllipsis(false) : h()); // Individual page links\n\n      this.pageList.forEach(function (page, idx) {\n        var offset = showFirstDots && _this7.firstNumber && pageNumbers[0] !== 1 ? 1 : 0;\n        buttons.push(makePageButton(page, idx + offset));\n      }); // Last ellipsis\n\n      buttons.push(showLastDots ? makeEllipsis(true) : h()); // Show last page button?\n\n      buttons.push(this.lastNumber && pageNumbers[pageNumbers.length - 1] !== numberOfPages ? makePageButton({\n        number: numberOfPages\n      }, -1) : h()); // Goto next page button\n\n      buttons.push(makeEndBtn(currentPage + 1, this.labelNextPage, 'next-text', this.nextText, this.nextClass, numberOfPages, 'pagination-goto-next')); // Goto last page button\n      // Don't render button when `hideGotoEndButtons` or `lastNumber` is set\n\n      var $lastPageBtn = h();\n\n      if (!this.lastNumber && !this.hideGotoEndButtons) {\n        $lastPageBtn = makeEndBtn(numberOfPages, this.labelLastPage, 'last-text', this.lastText, this.lastClass, numberOfPages, 'pagination-goto-last');\n      }\n\n      buttons.push($lastPageBtn); // Assemble the pagination buttons\n\n      var $pagination = h('ul', {\n        ref: 'ul',\n        staticClass: 'pagination',\n        class: ['b-pagination', this.btnSize, this.alignment, this.styleClass],\n        attrs: {\n          role: 'menubar',\n          'aria-disabled': disabled ? 'true' : 'false',\n          'aria-label': this.ariaLabel || null\n        },\n        on: {\n          keydown: this.handleKeyNav\n        }\n      }, buttons); // If we are `<b-pagination-nav>`, wrap in `<nav>` wrapper\n\n      if (this.isNav) {\n        return h('nav', {\n          attrs: {\n            'aria-disabled': disabled ? 'true' : null,\n            'aria-hidden': disabled ? 'true' : 'false'\n          }\n        }, [$pagination]);\n      }\n\n      return $pagination;\n    }\n  };\n\n  var NAME$q = 'BPagination';\n  var DEFAULT_PER_PAGE = 20;\n  var DEFAULT_TOTAL_ROWS = 0;\n  var props$R = {\n    size: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$q, 'size');\n      }\n    },\n    perPage: {\n      type: [Number, String],\n      default: DEFAULT_PER_PAGE\n    },\n    totalRows: {\n      type: [Number, String],\n      default: DEFAULT_TOTAL_ROWS\n    },\n    ariaControls: {\n      type: String,\n      default: null\n    }\n  }; // --- Helper functions ---\n  // Sanitize the provided per page number (converting to a number)\n\n  var sanitizePerPage = function sanitizePerPage(val) {\n    var perPage = toInteger(val) || DEFAULT_PER_PAGE;\n    return perPage < 1 ? 1 : perPage;\n  }; // Sanitize the provided total rows number (converting to a number)\n\n\n  var sanitizeTotalRows = function sanitizeTotalRows(val) {\n    var totalRows = toInteger(val) || DEFAULT_TOTAL_ROWS;\n    return totalRows < 0 ? 0 : totalRows;\n  }; // The render function is brought in via the `paginationMixin`\n  // @vue/component\n\n\n  var BPagination =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$q,\n    mixins: [paginationMixin],\n    props: props$R,\n    computed: {\n      numberOfPages: function numberOfPages() {\n        var result = Math.ceil(sanitizeTotalRows(this.totalRows) / sanitizePerPage(this.perPage));\n        return result < 1 ? 1 : result;\n      },\n      pageSizeNumberOfPages: function pageSizeNumberOfPages() {\n        // Used for watching changes to `perPage` and `numberOfPages`\n        return {\n          perPage: sanitizePerPage(this.perPage),\n          totalRows: sanitizeTotalRows(this.totalRows),\n          numberOfPages: this.numberOfPages\n        };\n      }\n    },\n    watch: {\n      pageSizeNumberOfPages: function pageSizeNumberOfPages(newVal, oldVal) {\n        if (!isUndefinedOrNull(oldVal)) {\n          if (newVal.perPage !== oldVal.perPage && newVal.totalRows === oldVal.totalRows) {\n            // If the page size changes, reset to page 1\n            this.currentPage = 1;\n          } else if (newVal.numberOfPages !== oldVal.numberOfPages && this.currentPage > newVal.numberOfPages) {\n            // If `numberOfPages` changes and is less than\n            // the `currentPage` number, reset to page 1\n            this.currentPage = 1;\n          }\n        }\n\n        this.localNumberOfPages = newVal.numberOfPages;\n      }\n    },\n    created: function created() {\n      var _this = this;\n\n      // Set the initial page count\n      this.localNumberOfPages = this.numberOfPages; // Set the initial page value\n\n      var currentPage = toInteger(this.value) || 0;\n\n      if (currentPage > 0) {\n        this.currentPage = currentPage;\n      } else {\n        this.$nextTick(function () {\n          // If this value parses to NaN or a value less than 1\n          // Trigger an initial emit of 'null' if no page specified\n          _this.currentPage = 0;\n        });\n      }\n    },\n    mounted: function mounted() {\n      // Set the initial page count\n      this.localNumberOfPages = this.numberOfPages;\n    },\n    methods: {\n      // These methods are used by the render function\n      onClick: function onClick(num, evt) {\n        var _this2 = this;\n\n        // Handle edge cases where number of pages has changed (i.e. if perPage changes)\n        // This should normally not happen, but just in case.\n        if (num > this.numberOfPages) {\n          /* istanbul ignore next */\n          num = this.numberOfPages;\n        } else if (num < 1) {\n          /* istanbul ignore next */\n          num = 1;\n        } // Update the v-model\n\n\n        this.currentPage = num; // Emit event triggered by user interaction\n\n        this.$emit('change', this.currentPage);\n        this.$nextTick(function () {\n          // Keep the current button focused if possible\n          var target = evt.target;\n\n          if (isVisible(target) && _this2.$el.contains(target) && target.focus) {\n            target.focus();\n          } else {\n            _this2.focusCurrent();\n          }\n        });\n      },\n      makePage: function makePage(pageNum) {\n        return pageNum;\n      },\n      linkProps: function linkProps() {\n        // Always '#' for pagination component\n        return {\n          href: '#'\n        };\n      }\n    }\n  });\n\n  var PaginationPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BPagination: BPagination\n    }\n  });\n\n  var NAME$r = 'BPaginationNav'; // Sanitize the provided number of pages (converting to a number)\n\n  var sanitizeNumberOfPages = function sanitizeNumberOfPages(value) {\n    var numberOfPages = toInteger(value) || 1;\n    return numberOfPages < 1 ? 1 : numberOfPages;\n  };\n  var props$S = {\n    size: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$r, 'size');\n      }\n    },\n    numberOfPages: {\n      type: [Number, String],\n      default: 1,\n      validator: function validator(value)\n      /* istanbul ignore next */\n      {\n        var num = toInteger(value);\n\n        if (isNaN(num) || num < 1) {\n          warn('Prop \"number-of-pages\" must be a number greater than \"0\"', NAME$r);\n          return false;\n        }\n\n        return true;\n      }\n    },\n    baseUrl: {\n      type: String,\n      default: '/'\n    },\n    useRouter: {\n      type: Boolean,\n      default: false\n    },\n    linkGen: {\n      type: Function,\n      default: null\n    },\n    pageGen: {\n      type: Function,\n      default: null\n    },\n    pages: {\n      // Optional array of page links\n      type: Array,\n      default: null\n    },\n    noPageDetect: {\n      // Disable auto page number detection if true\n      type: Boolean,\n      default: false\n    },\n    // router-link specific props\n    activeClass: {\n      type: String // default: undefined\n\n    },\n    exact: {\n      type: Boolean,\n      default: false\n    },\n    exactActiveClass: {\n      type: String // default: undefined\n\n    },\n    // nuxt-link specific prop(s)\n    noPrefetch: {\n      type: Boolean,\n      default: false\n    }\n  }; // The render function is brought in via the pagination mixin\n  // @vue/component\n\n  var BPaginationNav =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$r,\n    mixins: [paginationMixin],\n    props: props$S,\n    computed: {\n      // Used by render function to trigger wrapping in '<nav>' element\n      isNav: function isNav() {\n        return true;\n      },\n      computedValue: function computedValue() {\n        // Returns the value prop as a number or `null` if undefined or < 1\n        var val = toInteger(this.value);\n        return isNaN(val) || val < 1 ? null : val;\n      }\n    },\n    watch: {\n      numberOfPages: function numberOfPages() {\n        var _this = this;\n\n        this.$nextTick(function () {\n          _this.setNumberOfPages();\n        });\n      },\n      pages: function pages() {\n        var _this2 = this;\n\n        this.$nextTick(function () {\n          _this2.setNumberOfPages();\n        });\n      }\n    },\n    created: function created() {\n      this.setNumberOfPages();\n    },\n    mounted: function mounted() {\n      var _this3 = this;\n\n      if (this.$router) {\n        // We only add the watcher if vue router is detected\n        this.$watch('$route', function () {\n          _this3.$nextTick(function () {\n            requestAF(function () {\n              _this3.guessCurrentPage();\n            });\n          });\n        });\n      }\n    },\n    methods: {\n      setNumberOfPages: function setNumberOfPages() {\n        var _this4 = this;\n\n        if (isArray(this.pages) && this.pages.length > 0) {\n          this.localNumberOfPages = this.pages.length;\n        } else {\n          this.localNumberOfPages = sanitizeNumberOfPages(this.numberOfPages);\n        }\n\n        this.$nextTick(function () {\n          _this4.guessCurrentPage();\n        });\n      },\n      onClick: function onClick(pageNum, evt) {\n        var _this5 = this;\n\n        // Dont do anything if clicking the current active page\n        if (pageNum === this.currentPage) {\n          return;\n        }\n\n        requestAF(function () {\n          // Update the v-model\n          // Done in in requestAF() to allow browser to complete the\n          // native browser click handling of a link\n          _this5.currentPage = pageNum;\n\n          _this5.$emit('change', pageNum);\n        });\n        this.$nextTick(function () {\n          // Done in a nextTick() to ensure rendering complete\n          try {\n            // Emulate native link click page reloading behaviour by blurring the\n            // paginator and returning focus to the document\n            var target = evt.currentTarget || evt.target;\n            target.blur();\n          } catch (e) {}\n        });\n      },\n      getPageInfo: function getPageInfo(pageNum) {\n        if (!isArray(this.pages) || this.pages.length === 0 || isUndefined(this.pages[pageNum - 1])) {\n          var link = \"\".concat(this.baseUrl).concat(pageNum);\n          return {\n            link: this.useRouter ? {\n              path: link\n            } : link,\n            text: toString$1(pageNum)\n          };\n        }\n\n        var info = this.pages[pageNum - 1];\n\n        if (isObject(info)) {\n          var _link = info.link;\n          return {\n            // Normalize link for router use\n            link: isObject(_link) ? _link : this.useRouter ? {\n              path: _link\n            } : _link,\n            // Make sure text has a value\n            text: toString$1(info.text || pageNum)\n          };\n        } else {\n          return {\n            link: toString$1(info),\n            text: toString$1(pageNum)\n          };\n        }\n      },\n      makePage: function makePage(pageNum) {\n        var info = this.getPageInfo(pageNum);\n\n        if (this.pageGen && isFunction(this.pageGen)) {\n          return this.pageGen(pageNum, info);\n        }\n\n        return info.text;\n      },\n      makeLink: function makeLink(pageNum) {\n        var info = this.getPageInfo(pageNum);\n\n        if (this.linkGen && isFunction(this.linkGen)) {\n          return this.linkGen(pageNum, info);\n        }\n\n        return info.link;\n      },\n      linkProps: function linkProps(pageNum) {\n        var link = this.makeLink(pageNum);\n        var props = {\n          target: this.target || null,\n          rel: this.rel || null,\n          disabled: this.disabled,\n          // The following props are only used if BLink detects router\n          exact: this.exact,\n          activeClass: this.activeClass,\n          exactActiveClass: this.exactActiveClass,\n          append: this.append,\n          replace: this.replace,\n          // nuxt-link specific prop\n          noPrefetch: this.noPrefetch\n        };\n\n        if (this.useRouter || isObject(link)) {\n          props.to = link;\n        } else {\n          props.href = link;\n        }\n\n        return props;\n      },\n      resolveLink: function resolveLink() {\n        var to = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        // Given a to (or href string), convert to normalized route-like structure\n        // Works only client side!!\n        var link;\n\n        try {\n          // Convert the `to` to a HREF via a temporary `a` tag\n          link = document.createElement('a');\n          link.href = computeHref({\n            to: to\n          }, 'a', '/', '/'); // We need to add the anchor to the document to make sure the\n          // `pathname` is correctly detected in any browser (i.e. IE)\n\n          document.body.appendChild(link); // Once href is assigned, the link will be normalized to the full URL bits\n\n          var _link2 = link,\n              pathname = _link2.pathname,\n              hash = _link2.hash,\n              search = _link2.search; // Remove link from document\n\n          document.body.removeChild(link); // Return the location in a route-like object\n\n          return {\n            path: pathname,\n            hash: hash,\n            query: parseQuery(search)\n          };\n        } catch (e) {\n          /* istanbul ignore next */\n          try {\n            link && link.parentNode && link.parentNode.removeChild(link);\n          } catch (e) {}\n          /* istanbul ignore next */\n\n\n          return {};\n        }\n      },\n      resolveRoute: function resolveRoute() {\n        var to = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n        // Given a to (or href string), convert to normalized route location structure\n        // works only when router available!!\n        try {\n          var route = this.$router.resolve(to, this.$route).route;\n          return {\n            path: route.path,\n            hash: route.hash,\n            query: route.query\n          };\n        } catch (e) {\n          /* istanbul ignore next */\n          return {};\n        }\n      },\n      guessCurrentPage: function guessCurrentPage() {\n        var guess = this.computedValue;\n        var $router = this.$router;\n        var $route = this.$route; // This section only occurs if we are client side, or server-side with $router\n\n        /* istanbul ignore else */\n\n        if (!this.noPageDetect && !guess && (isBrowser || !isBrowser && $router)) {\n          // Current route (if router available)\n          var currRoute = $router && $route ? {\n            path: $route.path,\n            hash: $route.hash,\n            query: $route.query\n          } : {}; // Current page full HREF (if client side). Can't be done as a computed prop!\n\n          var loc = isBrowser ? window.location || document.location : null;\n          var currLink = loc ? {\n            path: loc.pathname,\n            hash: loc.hash,\n            query: parseQuery(loc.search)\n          } : {}; // Loop through the possible pages looking for a match until found\n\n          for (var page = 1; !guess && page <= this.localNumberOfPages; page++) {\n            var to = this.makeLink(page);\n\n            if ($router && (isObject(to) || this.useRouter)) {\n              // Resolve the page via the $router\n              guess = looseEqual(this.resolveRoute(to), currRoute) ? page : null;\n            } else if (isBrowser) {\n              // If no $router available (or !this.useRouter when `to` is a string)\n              // we compare using parsed URIs\n              guess = looseEqual(this.resolveLink(to), currLink) ? page : null;\n            } else {\n              // probably SSR, but no $router so we can't guess, so lets break out of\n              // the loop early\n\n              /* istanbul ignore next */\n              guess = -1;\n            }\n          }\n        } // We set currentPage to 0 to trigger an $emit('input', null)\n        // As the default for this.currentPage is -1 when no value is specified\n        // And valid page numbers are greater than 0\n\n\n        this.currentPage = guess > 0 ? guess : 0;\n      }\n    }\n  });\n\n  var PaginationNavPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BPaginationNav: BPaginationNav\n    }\n  });\n\n  // Base on-demand component for tooltip / popover templates\n  var NAME$s = 'BVPopper';\n  var AttachmentMap$1 = {\n    AUTO: 'auto',\n    TOP: 'top',\n    RIGHT: 'right',\n    BOTTOM: 'bottom',\n    LEFT: 'left',\n    TOPLEFT: 'top',\n    TOPRIGHT: 'top',\n    RIGHTTOP: 'right',\n    RIGHTBOTTOM: 'right',\n    BOTTOMLEFT: 'bottom',\n    BOTTOMRIGHT: 'bottom',\n    LEFTTOP: 'left',\n    LEFTBOTTOM: 'left'\n  };\n  var OffsetMap = {\n    AUTO: 0,\n    TOPLEFT: -1,\n    TOP: 0,\n    TOPRIGHT: +1,\n    RIGHTTOP: -1,\n    RIGHT: 0,\n    RIGHTBOTTOM: +1,\n    BOTTOMLEFT: -1,\n    BOTTOM: 0,\n    BOTTOMRIGHT: +1,\n    LEFTTOP: -1,\n    LEFT: 0,\n    LEFTBOTTOM: +1\n  }; // @vue/component\n\n  var BVPopper =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$s,\n    props: {\n      target: {\n        // Element that the tooltip/popover is positioned relative to\n        type: [HTMLElement, SVGElement],\n        default: null\n      },\n      placement: {\n        type: String,\n        default: 'top'\n      },\n      fallbackPlacement: {\n        type: [String, Array],\n        default: 'flip'\n      },\n      offset: {\n        type: Number,\n        default: 0\n      },\n      boundary: {\n        // 'scrollParent', 'viewport', 'window', or Element\n        type: [String, HTMLElement],\n        default: 'scrollParent'\n      },\n      boundaryPadding: {\n        // Tooltip/popover will try and stay away from\n        // boundary edge by this many pixels\n        type: Number,\n        default: 5\n      },\n      arrowPadding: {\n        // The minimum distance (in `px`) from the edge of the\n        // tooltip/popover that the arrow can be positioned\n        type: Number,\n        default: 6\n      }\n    },\n    data: function data() {\n      return {\n        // reactive props set by parent\n        noFade: false,\n        // State related data\n        localShow: true,\n        attachment: this.getAttachment(this.placement)\n      };\n    },\n    computed: {\n      templateType: function templateType()\n      /* istanbul ignore next */\n      {\n        // Overridden by template component\n        return 'unknown';\n      },\n      popperConfig: function popperConfig() {\n        var _this = this;\n\n        var placement = this.placement;\n        return {\n          placement: this.getAttachment(placement),\n          modifiers: {\n            offset: {\n              offset: this.getOffset(placement)\n            },\n            flip: {\n              behavior: this.fallbackPlacement\n            },\n            // `arrow.element` can also be a reference to an HTML Element\n            // maybe we should make this a `$ref` in the templates?\n            arrow: {\n              element: '.arrow'\n            },\n            preventOverflow: {\n              padding: this.boundaryPadding,\n              boundariesElement: this.boundary\n            }\n          },\n          onCreate: function onCreate(data) {\n            // Handle flipping arrow classes\n            if (data.originalPlacement !== data.placement) {\n              /* istanbul ignore next: can't test in JSDOM */\n              _this.popperPlacementChange(data);\n            }\n          },\n          onUpdate: function onUpdate(data) {\n            // Handle flipping arrow classes\n            _this.popperPlacementChange(data);\n          }\n        };\n      }\n    },\n    created: function created() {\n      var _this2 = this;\n\n      // Note: We are created on-demand, and should be guaranteed that\n      // DOM is rendered/ready by the time the created hook runs\n      this.$_popper = null; // Ensure we show as we mount\n\n      this.localShow = true; // Create popper instance before shown\n\n      this.$on('show', function (el) {\n        _this2.popperCreate(el);\n      }); // Self destruct once hidden\n\n      this.$on('hidden', function () {\n        _this2.$nextTick(_this2.$destroy);\n      }); // If parent is destroyed, ensure we are destroyed\n\n      this.$parent.$once('hook:destroyed', this.$destroy);\n    },\n    beforeMount: function beforeMount() {\n      // Ensure that the attachment position is correct before mounting\n      // as our propsData is added after `new Template({...})`\n      this.attachment = this.getAttachment(this.placement);\n    },\n    mounted: function mounted() {// TBD\n    },\n    updated: function updated() {\n      // Update popper if needed\n      // TODO: Should this be a watcher on `this.popperConfig` instead?\n      this.popperUpdate();\n    },\n    beforeDestroy: function beforeDestroy() {\n      this.popperDestroy();\n    },\n    destroyed: function destroyed() {\n      // Make sure template is removed from DOM\n      var el = this.$el;\n      el && el.parentNode && el.parentNode.removeChild(el);\n    },\n    methods: {\n      // \"Public\" method to trigger hide template\n      hide: function hide() {\n        this.localShow = false;\n      },\n      // Private\n      getAttachment: function getAttachment(placement) {\n        return AttachmentMap$1[String(placement).toUpperCase()] || 'auto';\n      },\n      getOffset: function getOffset(placement) {\n        if (!this.offset) {\n          // Could set a ref for the arrow element\n          var arrow = this.$refs.arrow || select('.arrow', this.$el);\n          var arrowOffset = (parseFloat(getCS(arrow).width) || 0) + (parseFloat(this.arrowPadding) || 0);\n\n          switch (OffsetMap[String(placement).toUpperCase()] || 0) {\n            case +1:\n              /* istanbul ignore next: can't test in JSDOM */\n              return \"+50%p - \".concat(arrowOffset, \"px\");\n\n            case -1:\n              /* istanbul ignore next: can't test in JSDOM */\n              return \"-50%p + \".concat(arrowOffset, \"px\");\n\n            default:\n              return 0;\n          }\n        }\n        /* istanbul ignore next */\n\n\n        return this.offset;\n      },\n      popperCreate: function popperCreate(el) {\n        this.popperDestroy(); // We use `el` rather than `this.$el` just in case the original\n        // mountpoint root element type was changed by the template\n\n        this.$_popper = new Popper(this.target, el, this.popperConfig);\n      },\n      popperDestroy: function popperDestroy() {\n        this.$_popper && this.$_popper.destroy();\n        this.$_popper = null;\n      },\n      popperUpdate: function popperUpdate() {\n        this.$_popper && this.$_popper.scheduleUpdate();\n      },\n      popperPlacementChange: function popperPlacementChange(data) {\n        // Callback used by popper to adjust the arrow placement\n        this.attachment = this.getAttachment(data.placement);\n      },\n      renderTemplate: function renderTemplate(h)\n      /* istanbul ignore next */\n      {\n        // Will be overridden by templates\n        return h('div');\n      }\n    },\n    render: function render(h) {\n      var _this3 = this;\n\n      // Note: `show` and 'fade' classes are only appled during transition\n      return h(BVTransition, {\n        // Transitions as soon as mounted\n        props: {\n          appear: true,\n          noFade: this.noFade\n        },\n        on: {\n          // Events used by parent component/instance\n          beforeEnter: function beforeEnter(el) {\n            return _this3.$emit('show', el);\n          },\n          afterEnter: function afterEnter(el) {\n            return _this3.$emit('shown', el);\n          },\n          beforeLeave: function beforeLeave(el) {\n            return _this3.$emit('hide', el);\n          },\n          afterLeave: function afterLeave(el) {\n            return _this3.$emit('hidden', el);\n          }\n        }\n      }, [this.localShow ? this.renderTemplate(h) : h()]);\n    }\n  });\n\n  var NAME$t = 'BVTooltipTemplate'; // @vue/component\n\n  var BVTooltipTemplate =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$t,\n    extends: BVPopper,\n    mixins: [scopedStyleAttrsMixin],\n    props: {\n      // Other non-reactive (while open) props are pulled in from BVPopper\n      id: {\n        type: String,\n        default: null\n      },\n      html: {\n        // Used only by the directive versions\n        type: Boolean,\n        default: false\n      }\n    },\n    data: function data() {\n      // We use data, rather than props to ensure reactivity\n      // Parent component will directly set this data\n      return {\n        title: '',\n        content: '',\n        variant: null,\n        customClass: null,\n        interactive: true\n      };\n    },\n    computed: {\n      templateType: function templateType() {\n        return 'tooltip';\n      },\n      templateClasses: function templateClasses() {\n        var _ref;\n\n        return [(_ref = {\n          // Disables pointer events to hide the tooltip when the user\n          // hovers over its content\n          noninteractive: !this.interactive\n        }, _defineProperty(_ref, \"b-\".concat(this.templateType, \"-\").concat(this.variant), this.variant), _defineProperty(_ref, \"bs-\".concat(this.templateType, \"-\").concat(this.attachment), this.attachment), _ref), this.customClass];\n      },\n      templateAttributes: function templateAttributes() {\n        return _objectSpread2({\n          id: this.id,\n          role: 'tooltip',\n          tabindex: '-1'\n        }, this.scopedStyleAttrs);\n      },\n      templateListeners: function templateListeners() {\n        var _this = this;\n\n        // Used for hover/focus trigger listeners\n        return {\n          mouseenter: function mouseenter(evt) {\n            /* istanbul ignore next: difficult to test in JSDOM */\n            _this.$emit('mouseenter', evt);\n          },\n          mouseleave: function mouseleave(evt) {\n            /* istanbul ignore next: difficult to test in JSDOM */\n            _this.$emit('mouseleave', evt);\n          },\n          focusin: function focusin(evt) {\n            /* istanbul ignore next: difficult to test in JSDOM */\n            _this.$emit('focusin', evt);\n          },\n          focusout: function focusout(evt) {\n            /* istanbul ignore next: difficult to test in JSDOM */\n            _this.$emit('focusout', evt);\n          }\n        };\n      }\n    },\n    methods: {\n      renderTemplate: function renderTemplate(h) {\n        // Title can be a scoped slot function\n        var $title = isFunction(this.title) ? this.title({}) : isUndefinedOrNull(this.title) ? h() : this.title; // Directive versions only\n\n        var domProps = this.html && !isFunction(this.title) ? {\n          innerHTML: this.title\n        } : {};\n        return h('div', {\n          staticClass: 'tooltip b-tooltip',\n          class: this.templateClasses,\n          attrs: this.templateAttributes,\n          on: this.templateListeners\n        }, [h('div', {\n          ref: 'arrow',\n          staticClass: 'arrow'\n        }), h('div', {\n          staticClass: 'tooltip-inner',\n          domProps: domProps\n        }, [$title])]);\n      }\n    }\n  });\n\n  var NAME$u = 'BVTooltip'; // Modal container selector for appending tooltip/popover\n\n  var MODAL_SELECTOR = '.modal-content'; // Modal `$root` hidden event\n\n  var MODAL_CLOSE_EVENT = 'bv::modal::hidden'; // For dropdown sniffing\n\n  var DROPDOWN_CLASS = 'dropdown';\n  var DROPDOWN_OPEN_SELECTOR = '.dropdown-menu.show'; // Data specific to popper and template\n  // We don't use props, as we need reactivity (we can't pass reactive props)\n\n  var templateData = {\n    // Text string or Scoped slot function\n    title: '',\n    // Text string or Scoped slot function\n    content: '',\n    // String\n    variant: null,\n    // String, Array, Object\n    customClass: null,\n    // String or array of Strings (overwritten by BVPopper)\n    triggers: '',\n    // String (overwritten by BVPopper)\n    placement: 'auto',\n    // String or array of strings\n    fallbackPlacement: 'flip',\n    // Element or Component reference (or function that returns element) of\n    // the element that will have the trigger events bound, and is also\n    // default element for positioning\n    target: null,\n    // HTML ID, Element or Component reference\n    container: null,\n    // 'body'\n    // Boolean\n    noFade: false,\n    // 'scrollParent', 'viewport', 'window', Element, or Component reference\n    boundary: 'scrollParent',\n    // Tooltip/popover will try and stay away from\n    // boundary edge by this many pixels (Number)\n    boundaryPadding: 5,\n    // Arrow offset (Number)\n    offset: 0,\n    // Hover/focus delay (Number or Object)\n    delay: 0,\n    // Arrow of Tooltip/popover will try and stay away from\n    // the edge of tooltip/popover edge by this many pixels\n    arrowPadding: 6,\n    // Interactive state (Boolean)\n    interactive: true,\n    // Disabled state (Boolean)\n    disabled: false,\n    // ID to use for tooltip/popover\n    id: null,\n    // Flag used by directives only, for HTML content\n    html: false\n  }; // @vue/component\n\n  var BVTooltip =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$u,\n    props: {// None\n    },\n    data: function data() {\n      return _objectSpread2({}, templateData, {\n        // State management data\n        activeTrigger: {\n          // manual: false,\n          hover: false,\n          click: false,\n          focus: false\n        },\n        localShow: false\n      });\n    },\n    computed: {\n      templateType: function templateType() {\n        // Overwritten by BVPopover\n        return 'tooltip';\n      },\n      computedId: function computedId() {\n        return this.id || \"__bv_\".concat(this.templateType, \"_\").concat(this._uid, \"__\");\n      },\n      computedDelay: function computedDelay() {\n        // Normalizes delay into object form\n        var delay = {\n          show: 0,\n          hide: 0\n        };\n\n        if (isPlainObject(this.delay)) {\n          delay.show = Math.max(parseInt(this.delay.show, 10) || 0, 0);\n          delay.hide = Math.max(parseInt(this.delay.hide, 10) || 0, 0);\n        } else if (isNumber(this.delay) || isString(this.delay)) {\n          delay.show = delay.hide = Math.max(parseInt(this.delay, 10) || 0, 0);\n        }\n\n        return delay;\n      },\n      computedTriggers: function computedTriggers() {\n        // Returns the triggers in sorted array form\n        // TODO: Switch this to object form for easier lookup\n        return concat(this.triggers).filter(Boolean).join(' ').trim().toLowerCase().split(/\\s+/).sort();\n      },\n      isWithActiveTrigger: function isWithActiveTrigger() {\n        for (var trigger in this.activeTrigger) {\n          if (this.activeTrigger[trigger]) {\n            return true;\n          }\n        }\n\n        return false;\n      },\n      computedTemplateData: function computedTemplateData() {\n        return {\n          title: this.title,\n          content: this.content,\n          variant: this.variant,\n          customClass: this.customClass,\n          noFade: this.noFade,\n          interactive: this.interactive\n        };\n      }\n    },\n    watch: {\n      computedTriggers: function computedTriggers(newTriggers, oldTriggers) {\n        var _this = this;\n\n        // Triggers have changed, so re-register them\n\n        /* istanbul ignore next */\n        if (!looseEqual(newTriggers, oldTriggers)) {\n          this.$nextTick(function () {\n            // Disable trigger listeners\n            _this.unListen(); // Clear any active triggers that are no longer in the list of triggers\n\n\n            oldTriggers.forEach(function (trigger) {\n              if (!arrayIncludes(newTriggers, trigger)) {\n                if (_this.activeTrigger[trigger]) {\n                  _this.activeTrigger[trigger] = false;\n                }\n              }\n            }); // Re-enable the trigger listeners\n\n            _this.listen();\n          });\n        }\n      },\n      computedTemplateData: function computedTemplateData() {\n        // If any of the while open reactive \"props\" change,\n        // ensure that the template updates accordingly\n        this.handleTemplateUpdate();\n      },\n      disabled: function disabled(newVal) {\n        newVal ? this.disable() : this.enable();\n      }\n    },\n    created: function created() {\n      var _this2 = this;\n\n      // Create non-reactive properties\n      this.$_tip = null;\n      this.$_hoverTimeout = null;\n      this.$_hoverState = '';\n      this.$_visibleInterval = null;\n      this.$_enabled = !this.disabled;\n      this.$_noop = noop.bind(this); // Destroy ourselves when the parent is destroyed\n\n      if (this.$parent) {\n        this.$parent.$once('hook:beforeDestroy', this.$destroy);\n      }\n\n      this.$nextTick(function () {\n        var target = _this2.getTarget();\n\n        if (target && contains(document.body, target)) {\n          // Copy the parent's scoped style attribute\n          _this2.scopeId = getScopeId(_this2.$parent); // Set up all trigger handlers and listeners\n\n          _this2.listen();\n        } else {\n          /* istanbul ignore next */\n          warn('Unable to find target element in document.', _this2.templateType);\n        }\n      });\n    },\n    updated: function updated()\n    /* istanbul ignore next */\n    {\n      // Usually called when the slots/data changes\n      this.$nextTick(this.handleTemplateUpdate);\n    },\n    deactivated: function deactivated()\n    /* istanbul ignore next */\n    {\n      // In a keepalive that has been deactivated, so hide\n      // the tooltip/popover if it is showing\n      this.forceHide();\n    },\n    beforeDestroy: function beforeDestroy()\n    /* istanbul ignore next */\n    {\n      // Remove all handler/listeners\n      this.unListen();\n      this.setWhileOpenListeners(false); // Clear any timeouts/intervals\n\n      this.clearHoverTimeout();\n      this.clearVisibilityInterval(); // Destroy the template\n\n      this.destroyTemplate();\n    },\n    methods: {\n      // --- Methods for creating and destroying the template ---\n      getTemplate: function getTemplate() {\n        // Overridden by BVPopover\n        return BVTooltipTemplate;\n      },\n      updateData: function updateData() {\n        var _this3 = this;\n\n        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        // Method for updating popper/template data\n        // We only update data if it exists, and has not changed\n        var titleUpdated = false;\n        keys(templateData).forEach(function (prop) {\n          if (!isUndefined(data[prop]) && _this3[prop] !== data[prop]) {\n            _this3[prop] = data[prop];\n\n            if (prop === 'title') {\n              titleUpdated = true;\n            }\n          }\n        });\n\n        if (titleUpdated && this.localShow) {\n          // If the title has updated, we may need to handle the title\n          // attribute on the trigger target. We only do this while the\n          // template is open\n          this.fixTitle();\n        }\n      },\n      createTemplateAndShow: function createTemplateAndShow() {\n        // Creates the template instance and show it\n        var container = this.getContainer();\n        var Template = this.getTemplate();\n        var $tip = this.$_tip = new Template({\n          parent: this,\n          // The following is not reactive to changes in the props data\n          propsData: {\n            // These values cannot be changed while template is showing\n            id: this.computedId,\n            html: this.html,\n            placement: this.placement,\n            fallbackPlacement: this.fallbackPlacement,\n            target: this.getPlacementTarget(),\n            boundary: this.getBoundary(),\n            // Ensure the following are integers\n            offset: parseInt(this.offset, 10) || 0,\n            arrowPadding: parseInt(this.arrowPadding, 10) || 0,\n            boundaryPadding: parseInt(this.boundaryPadding, 10) || 0\n          }\n        }); // We set the initial reactive data (values that can be changed while open)\n\n        this.handleTemplateUpdate(); // Template transition phase events (handled once only)\n        // When the template has mounted, but not visibly shown yet\n\n        $tip.$once('show', this.onTemplateShow); // When the template has completed showing\n\n        $tip.$once('shown', this.onTemplateShown); // When the template has started to hide\n\n        $tip.$once('hide', this.onTemplateHide); // When the template has completed hiding\n\n        $tip.$once('hidden', this.onTemplateHidden); // When the template gets destroyed for any reason\n\n        $tip.$once('hook:destroyed', this.destroyTemplate); // Convenience events from template\n        // To save us from manually adding/removing DOM\n        // listeners to tip element when it is open\n\n        $tip.$on('focusin', this.handleEvent);\n        $tip.$on('focusout', this.handleEvent);\n        $tip.$on('mouseenter', this.handleEvent);\n        $tip.$on('mouseleave', this.handleEvent); // Mount (which triggers the `show`)\n\n        $tip.$mount(container.appendChild(document.createElement('div'))); // Template will automatically remove its markup from DOM when hidden\n      },\n      hideTemplate: function hideTemplate() {\n        // Trigger the template to start hiding\n        // The template will emit the `hide` event after this and\n        // then emit the `hidden` event once it is fully hidden\n        // The `hook:destroyed` will also be called (safety measure)\n        this.$_tip && this.$_tip.hide(); // Clear out any stragging active triggers\n\n        this.clearActiveTriggers(); // Reset the hover state\n\n        this.$_hoverState = '';\n      },\n      // Destroy the template instance and reset state\n      destroyTemplate: function destroyTemplate() {\n        this.setWhileOpenListeners(false);\n        this.clearHoverTimeout();\n        this.$_hoverState = '';\n        this.clearActiveTriggers();\n        this.localPlacementTarget = null;\n\n        try {\n          this.$_tip && this.$_tip.$destroy();\n        } catch (_unused) {}\n\n        this.$_tip = null;\n        this.removeAriaDescribedby();\n        this.restoreTitle();\n        this.localShow = false;\n      },\n      getTemplateElement: function getTemplateElement() {\n        return this.$_tip ? this.$_tip.$el : null;\n      },\n      handleTemplateUpdate: function handleTemplateUpdate() {\n        var _this4 = this;\n\n        // Update our template title/content \"props\"\n        // So that the template updates accordingly\n        var $tip = this.$_tip;\n\n        if ($tip) {\n          var props = ['title', 'content', 'variant', 'customClass', 'noFade', 'interactive']; // Only update the values if they have changed\n\n          props.forEach(function (prop) {\n            if ($tip[prop] !== _this4[prop]) {\n              $tip[prop] = _this4[prop];\n            }\n          });\n        }\n      },\n      // --- Show/Hide handlers ---\n      // Show the tooltip\n      show: function show() {\n        var target = this.getTarget();\n\n        if (!target || !contains(document.body, target) || !isVisible(target) || this.dropdownOpen() || (isUndefinedOrNull(this.title) || this.title === '') && (isUndefinedOrNull(this.content) || this.content === '')) {\n          // If trigger element isn't in the DOM or is not visible, or\n          // is on an open dropdown toggle, or has no content, then\n          // we exit without showing\n          return;\n        } // If tip already exists, exit early\n\n\n        if (this.$_tip || this.localShow) {\n          /* istanbul ignore next */\n          return;\n        } // In the process of showing\n\n\n        this.localShow = true; // Create a cancelable BvEvent\n\n        var showEvt = this.buildEvent('show', {\n          cancelable: true\n        });\n        this.emitEvent(showEvt); // Don't show if event cancelled\n\n        /* istanbul ignore next: ignore for now */\n\n        if (showEvt.defaultPrevented) {\n          // Destroy the template (if for some reason it was created)\n\n          /* istanbul ignore next */\n          this.destroyTemplate();\n          /* istanbul ignore next */\n\n          return;\n        } // Fix the title attribute on target\n\n\n        this.fixTitle(); // Set aria-describedby on target\n\n        this.addAriaDescribedby(); // Create and show the tooltip\n\n        this.createTemplateAndShow();\n      },\n      hide: function hide() {\n        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        // Hide the tooltip\n        var tip = this.getTemplateElement();\n\n        if (!tip || !this.localShow) {\n          /* istanbul ignore next */\n          this.restoreTitle();\n          /* istanbul ignore next */\n\n          return;\n        } // Emit cancelable BvEvent 'hide'\n        // We disable cancelling if `force` is true\n\n\n        var hideEvt = this.buildEvent('hide', {\n          cancelable: !force\n        });\n        this.emitEvent(hideEvt);\n        /* istanbul ignore next: ignore for now */\n\n        if (hideEvt.defaultPrevented) {\n          // Don't hide if event cancelled\n\n          /* istanbul ignore next */\n          return;\n        } // Tell the template to hide\n\n\n        this.hideTemplate();\n      },\n      forceHide: function forceHide() {\n        // Forcefully hides/destroys the template, regardless of any active triggers\n        var tip = this.getTemplateElement();\n\n        if (!tip || !this.localShow) {\n          /* istanbul ignore next */\n          return;\n        } // Disable while open listeners/watchers\n        // This is also done in the template `hide` evt handler\n\n\n        this.setWhileOpenListeners(false); // Clear any hover enter/leave event\n\n        this.clearHoverTimeout();\n        this.$_hoverState = '';\n        this.clearActiveTriggers(); // Disable the fade animation on the template\n\n        if (this.$_tip) {\n          this.$_tip.noFade = true;\n        } // Hide the tip (with force = true)\n\n\n        this.hide(true);\n      },\n      enable: function enable() {\n        this.$_enabled = true; // Create a non-cancelable BvEvent\n\n        this.emitEvent(this.buildEvent('enabled'));\n      },\n      disable: function disable() {\n        this.$_enabled = false; // Create a non-cancelable BvEvent\n\n        this.emitEvent(this.buildEvent('disabled'));\n      },\n      // --- Handlers for template events ---\n      // When template is inserted into DOM, but not yet shown\n      onTemplateShow: function onTemplateShow() {\n        // Enable while open listeners/watchers\n        this.setWhileOpenListeners(true);\n      },\n      // When template show transition completes\n      onTemplateShown: function onTemplateShown() {\n        var prevHoverState = this.$_hoverState;\n        this.$_hoverState = '';\n\n        if (prevHoverState === 'out') {\n          this.leave(null);\n        } // Emit a non-cancelable BvEvent 'shown'\n\n\n        this.emitEvent(this.buildEvent('shown'));\n      },\n      // When template is starting to hide\n      onTemplateHide: function onTemplateHide() {\n        // Disable while open listeners/watchers\n        this.setWhileOpenListeners(false);\n      },\n      // When template has completed closing (just before it self destructs)\n      onTemplateHidden: function onTemplateHidden() {\n        // Destroy the template\n        this.destroyTemplate(); // Emit a non-cancelable BvEvent 'shown'\n\n        this.emitEvent(this.buildEvent('hidden'));\n      },\n      // --- Utility methods ---\n      getTarget: function getTarget() {\n        // Handle case where target may be a component ref\n        var target = this.target ? this.target.$el || this.target : null; // If an ID\n\n        target = isString(target) ? getById(target.replace(/^#/, '')) : target; // If a function\n\n        target = isFunction(target) ? target() : target; // If an element ref\n\n        return isElement(target) ? target : null;\n      },\n      getPlacementTarget: function getPlacementTarget() {\n        // This is the target that the tooltip will be placed on, which may not\n        // necessarily be the same element that has the trigger event listeners\n        // For now, this is the same as target\n        // TODO:\n        //   Add in child selector support\n        //   Add in visibility checks for this element\n        //   Fallback to target if not found\n        return this.getTarget();\n      },\n      getTargetId: function getTargetId() {\n        // Returns the ID of the trigger element\n        var target = this.getTarget();\n        return target && target.id ? target.id : null;\n      },\n      getContainer: function getContainer() {\n        // Handle case where container may be a component ref\n        var container = this.container ? this.container.$el || this.container : false;\n        var body = document.body;\n        var target = this.getTarget(); // If we are in a modal, we append to the modal instead\n        // of body, unless a container is specified\n        // TODO:\n        //   Template should periodically check to see if it is in dom\n        //   And if not, self destruct (if container got v-if'ed out of DOM)\n        //   Or this could possibly be part of the visibility check\n\n        return container === false ? closest(MODAL_SELECTOR, target) || body : isString(container) ? getById(container.replace(/^#/, '')) || body : body;\n      },\n      getBoundary: function getBoundary() {\n        return this.boundary ? this.boundary.$el || this.boundary : 'scrollParent';\n      },\n      isInModal: function isInModal() {\n        var target = this.getTarget();\n        return target && closest(MODAL_SELECTOR, target);\n      },\n      isDropdown: function isDropdown() {\n        // Returns true if trigger is a dropdown\n        var target = this.getTarget();\n        return target && hasClass(target, DROPDOWN_CLASS);\n      },\n      dropdownOpen: function dropdownOpen() {\n        // Returns true if trigger is a dropdown and the dropdown menu is open\n        var target = this.getTarget();\n        return this.isDropdown() && target && select(DROPDOWN_OPEN_SELECTOR, target);\n      },\n      clearHoverTimeout: function clearHoverTimeout() {\n        if (this.$_hoverTimeout) {\n          clearTimeout(this.$_hoverTimeout);\n          this.$_hoverTimeout = null;\n        }\n      },\n      clearVisibilityInterval: function clearVisibilityInterval() {\n        if (this.$_visibleInterval) {\n          clearInterval(this.$_visibleInterval);\n          this.$_visibleInterval = null;\n        }\n      },\n      clearActiveTriggers: function clearActiveTriggers() {\n        for (var trigger in this.activeTrigger) {\n          this.activeTrigger[trigger] = false;\n        }\n      },\n      addAriaDescribedby: function addAriaDescribedby() {\n        // Add aria-describedby on trigger element, without removing any other IDs\n        var target = this.getTarget();\n        var desc = getAttr(target, 'aria-describedby') || '';\n        desc = desc.split(/\\s+/).concat(this.computedId).join(' ').trim(); // Update/add aria-described by\n\n        setAttr(target, 'aria-describedby', desc);\n      },\n      removeAriaDescribedby: function removeAriaDescribedby() {\n        var _this5 = this;\n\n        // Remove aria-describedby on trigger element, without removing any other IDs\n        var target = this.getTarget();\n        var desc = getAttr(target, 'aria-describedby') || '';\n        desc = desc.split(/\\s+/).filter(function (d) {\n          return d !== _this5.computedId;\n        }).join(' ').trim(); // Update or remove aria-describedby\n\n        if (desc) {\n          /* istanbul ignore next */\n          setAttr(target, 'aria-describedby', desc);\n        } else {\n          removeAttr(target, 'aria-describedby');\n        }\n      },\n      fixTitle: function fixTitle() {\n        // If the target has a title attribute, null it out and\n        // store on data-title\n        var target = this.getTarget();\n\n        if (target && getAttr(target, 'title')) {\n          // We only update title attribute if it has a value\n          setAttr(target, 'data-original-title', getAttr(target, 'title') || '');\n          setAttr(target, 'title', '');\n        }\n      },\n      restoreTitle: function restoreTitle() {\n        // If target had a title, restore the title attribute\n        // and remove the data-title attribute\n        var target = this.getTarget();\n\n        if (target && hasAttr(target, 'data-original-title')) {\n          setAttr(target, 'title', getAttr(target, 'data-original-title') || '');\n          removeAttr(target, 'data-original-title');\n        }\n      },\n      // --- BvEvent helpers ---\n      buildEvent: function buildEvent(type) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        // Defaults to a non-cancellable event\n        return new BvEvent(type, _objectSpread2({\n          cancelable: false,\n          target: this.getTarget(),\n          relatedTarget: this.getTemplateElement() || null,\n          componentId: this.computedId,\n          vueTarget: this\n        }, options));\n      },\n      emitEvent: function emitEvent(bvEvt) {\n        // Emits a BvEvent on $root and this instance\n        var evtName = bvEvt.type;\n        var $root = this.$root;\n\n        if ($root && $root.$emit) {\n          // Emit an event on $root\n          $root.$emit(\"bv::\".concat(this.templateType, \"::\").concat(evtName), bvEvt);\n        }\n\n        this.$emit(evtName, bvEvt);\n      },\n      // --- Event handler setup methods ---\n      listen: function listen() {\n        var _this6 = this;\n\n        // Enable trigger event handlers\n        var el = this.getTarget();\n\n        if (!el) {\n          /* istanbul ignore next */\n          return;\n        } // Listen for global show/hide events\n\n\n        this.setRootListener(true); // Set up our listeners on the target trigger element\n\n        this.computedTriggers.forEach(function (trigger) {\n          if (trigger === 'click') {\n            eventOn(el, 'click', _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);\n          } else if (trigger === 'focus') {\n            eventOn(el, 'focusin', _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);\n            eventOn(el, 'focusout', _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);\n          } else if (trigger === 'blur') {\n            // Used to close $tip when element looses focus\n\n            /* istanbul ignore next */\n            eventOn(el, 'focusout', _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);\n          } else if (trigger === 'hover') {\n            eventOn(el, 'mouseenter', _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);\n            eventOn(el, 'mouseleave', _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);\n          }\n        }, this);\n      },\n      unListen: function unListen()\n      /* istanbul ignore next */\n      {\n        var _this7 = this;\n\n        // Remove trigger event handlers\n        var events = ['click', 'focusin', 'focusout', 'mouseenter', 'mouseleave'];\n        var target = this.getTarget(); // Stop listening for global show/hide/enable/disable events\n\n        this.setRootListener(false); // Clear out any active target listeners\n\n        events.forEach(function (evt) {\n          target && eventOff(target, evt, _this7.handleEvent, EVENT_OPTIONS_NO_CAPTURE);\n        }, this);\n      },\n      setRootListener: function setRootListener(on) {\n        // Listen for global `bv::{hide|show}::{tooltip|popover}` hide request event\n        var $root = this.$root;\n\n        if ($root) {\n          var method = on ? '$on' : '$off';\n          var type = this.templateType;\n          $root[method](\"bv::hide::\".concat(type), this.doHide);\n          $root[method](\"bv::show::\".concat(type), this.doShow);\n          $root[method](\"bv::disable::\".concat(type), this.doDisable);\n          $root[method](\"bv::enable::\".concat(type), this.doEnable);\n        }\n      },\n      setWhileOpenListeners: function setWhileOpenListeners(on) {\n        // Events that are only registered when the template is showing\n        // Modal close events\n        this.setModalListener(on); // Dropdown open events (if we are attached to a dropdown)\n\n        this.setDropdownListener(on); // Periodic $element visibility check\n        // For handling when tip target is in <keepalive>, tabs, carousel, etc\n\n        this.visibleCheck(on); // On-touch start listeners\n\n        this.setOnTouchStartListener(on);\n      },\n      // Handler for periodic visibility check\n      visibleCheck: function visibleCheck(on) {\n        var _this8 = this;\n\n        this.clearVisibilityInterval();\n        var target = this.getTarget();\n        var tip = this.getTemplateElement();\n\n        if (on) {\n          this.$_visibleInterval = setInterval(function () {\n            if (tip && _this8.localShow && (!target.parentNode || !isVisible(target))) {\n              // Target element is no longer visible or not in DOM, so force-hide the tooltip\n              _this8.forceHide();\n            }\n          }, 100);\n        }\n      },\n      setModalListener: function setModalListener(on) {\n        // Handle case where tooltip/target is in a modal\n        if (this.isInModal()) {\n          // We can listen for modal hidden events on `$root`\n          this.$root[on ? '$on' : '$off'](MODAL_CLOSE_EVENT, this.forceHide);\n        }\n      },\n      setOnTouchStartListener: function setOnTouchStartListener(on)\n      /* istanbul ignore next: JSDOM doesn't support `ontouchstart` */\n      {\n        var _this9 = this;\n\n        // If this is a touch-enabled device we add extra empty\n        // `mouseover` listeners to the body's immediate children\n        // Only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n        if ('ontouchstart' in document.documentElement) {\n          from(document.body.children).forEach(function (el) {\n            eventOnOff(on, el, 'mouseover', _this9.$_noop);\n          });\n        }\n      },\n      setDropdownListener: function setDropdownListener(on) {\n        var target = this.getTarget();\n\n        if (!target || !this.$root || !this.isDropdown) {\n          return;\n        } // We can listen for dropdown shown events on its instance\n        // TODO:\n        //   We could grab the ID from the dropdown, and listen for\n        //   $root events for that particular dropdown id\n        //   Dropdown shown and hidden events will need to emit\n        //   Note: Dropdown auto-ID happens in a `$nextTick()` after mount\n        //         So the ID lookup would need to be done in a `$nextTick()`\n\n\n        if (target.__vue__) {\n          target.__vue__[on ? '$on' : '$off']('shown', this.forceHide);\n        }\n      },\n      // --- Event handlers ---\n      handleEvent: function handleEvent(evt) {\n        // General trigger event handler\n        // target is the trigger element\n        var target = this.getTarget();\n\n        if (!target || isDisabled(target) || !this.$_enabled || this.dropdownOpen()) {\n          // If disabled or not enabled, or if a dropdown that is open, don't do anything\n          // If tip is shown before element gets disabled, then tip will not\n          // close until no longer disabled or forcefully closed\n          return;\n        }\n\n        var type = evt.type;\n        var triggers = this.computedTriggers;\n\n        if (type === 'click' && arrayIncludes(triggers, 'click')) {\n          this.click(evt);\n        } else if (type === 'mouseenter' && arrayIncludes(triggers, 'hover')) {\n          // `mouseenter` is a non-bubbling event\n          this.enter(evt);\n        } else if (type === 'focusin' && arrayIncludes(triggers, 'focus')) {\n          // `focusin` is a bubbling event\n          // `evt` includes `relatedTarget` (element loosing focus)\n          this.enter(evt);\n        } else if (type === 'focusout' && (arrayIncludes(triggers, 'focus') || arrayIncludes(triggers, 'blur')) || type === 'mouseleave' && arrayIncludes(triggers, 'hover')) {\n          // `focusout` is a bubbling event\n          // `mouseleave` is a non-bubbling event\n          // `tip` is the template (will be null if not open)\n          var tip = this.getTemplateElement(); // `evtTarget` is the element which is loosing focus/hover and\n\n          var evtTarget = evt.target; // `relatedTarget` is the element gaining focus/hover\n\n          var relatedTarget = evt.relatedTarget;\n          /* istanbul ignore next */\n\n          if ( // From tip to target\n          tip && contains(tip, evtTarget) && contains(target, relatedTarget) || // From target to tip\n          tip && contains(target, evtTarget) && contains(tip, relatedTarget) || // Within tip\n          tip && contains(tip, evtTarget) && contains(tip, relatedTarget) || // Within target\n          contains(target, evtTarget) && contains(target, relatedTarget)) {\n            // If focus/hover moves within `tip` and `target`, don't trigger a leave\n            return;\n          } // Otherwise trigger a leave\n\n\n          this.leave(evt);\n        }\n      },\n      doHide: function doHide(id) {\n        // Programmatically hide tooltip or popover\n        if (!id || this.getTargetId() === id || this.computedId === id) {\n          // Close all tooltips or popovers, or this specific tip (with ID)\n          this.forceHide();\n        }\n      },\n      doShow: function doShow(id) {\n        // Programmatically show tooltip or popover\n        if (!id || this.getTargetId() === id || this.computedId === id) {\n          // Open all tooltips or popovers, or this specific tip (with ID)\n          this.show();\n        }\n      },\n      doDisable: function doDisable(id)\n      /*istanbul ignore next: ignore for now */\n      {\n        // Programmatically disable tooltip or popover\n        if (!id || this.getTargetId() === id || this.computedId === id) {\n          // Disable all tooltips or popovers (no ID), or this specific tip (with ID)\n          this.disable();\n        }\n      },\n      doEnable: function doEnable(id)\n      /*istanbul ignore next: ignore for now */\n      {\n        // Programmatically enable tooltip or popover\n        if (!id || this.getTargetId() === id || this.computedId === id) {\n          // Enable all tooltips or popovers (no ID), or this specific tip (with ID)\n          this.enable();\n        }\n      },\n      click: function click() {\n        if (!this.$_enabled || this.dropdownOpen()) {\n          /* istanbul ignore next */\n          return;\n        }\n\n        this.activeTrigger.click = !this.activeTrigger.click;\n\n        if (this.isWithActiveTrigger) {\n          this.enter(null);\n        } else {\n          /* istanbul ignore next */\n          this.leave(null);\n        }\n      },\n      toggle: function toggle()\n      /* istanbul ignore next */\n      {\n        // Manual toggle handler\n        if (!this.$_enabled || this.dropdownOpen()) {\n          /* istanbul ignore next */\n          return;\n        } // Should we register as an active trigger?\n        // this.activeTrigger.manual = !this.activeTrigger.manual\n\n\n        if (this.localShow) {\n          this.leave(null);\n        } else {\n          this.enter(null);\n        }\n      },\n      enter: function enter() {\n        var _this10 = this;\n\n        var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n        // Opening trigger handler\n        // Note: Click events are sent with evt === null\n        if (evt) {\n          this.activeTrigger[evt.type === 'focusin' ? 'focus' : 'hover'] = true;\n        }\n        /* istanbul ignore next */\n\n\n        if (this.localShow || this.$_hoverState === 'in') {\n          this.$_hoverState = 'in';\n          return;\n        }\n\n        this.clearHoverTimeout();\n        this.$_hoverState = 'in';\n\n        if (!this.computedDelay.show) {\n          this.show();\n        } else {\n          // Hide any title attribute while enter delay is active\n          this.fixTitle();\n          this.$_hoverTimeout = setTimeout(function () {\n            /* istanbul ignore else */\n            if (_this10.$_hoverState === 'in') {\n              _this10.show();\n            } else if (!_this10.localShow) {\n              _this10.restoreTitle();\n            }\n          }, this.computedDelay.show);\n        }\n      },\n      leave: function leave() {\n        var _this11 = this;\n\n        var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n        // Closing trigger handler\n        // Note: Click events are sent with evt === null\n        if (evt) {\n          this.activeTrigger[evt.type === 'focusout' ? 'focus' : 'hover'] = false;\n          /* istanbul ignore next */\n\n          if (evt.type === 'focusout' && arrayIncludes(this.computedTriggers, 'blur')) {\n            // Special case for `blur`: we clear out the other triggers\n            this.activeTrigger.click = false;\n            this.activeTrigger.hover = false;\n          }\n        }\n        /* istanbul ignore next: ignore for now */\n\n\n        if (this.isWithActiveTrigger) {\n          return;\n        }\n\n        this.clearHoverTimeout();\n        this.$_hoverState = 'out';\n\n        if (!this.computedDelay.hide) {\n          this.hide();\n        } else {\n          this.$_hoverTimeout = setTimeout(function () {\n            if (_this11.$_hoverState === 'out') {\n              _this11.hide();\n            }\n          }, this.computedDelay.hide);\n        }\n      }\n    }\n  });\n\n  var NAME$v = 'BTooltip'; // @vue/component\n\n  var BTooltip =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$v,\n    props: {\n      title: {\n        type: String // default: undefined\n\n      },\n      // Added in by BPopover\n      // content: {\n      //   type: String,\n      //   default: undefined\n      // },\n      target: {\n        // String ID of element, or element/component reference\n        // Or function that returns one of the above\n        type: [String, HTMLElement, SVGElement, Function, Object],\n        // default: undefined,\n        required: true\n      },\n      triggers: {\n        type: [String, Array],\n        default: 'hover focus'\n      },\n      placement: {\n        type: String,\n        default: 'top'\n      },\n      fallbackPlacement: {\n        type: [String, Array],\n        default: 'flip',\n        validator: function validator(value) {\n          return isArray(value) && value.every(function (v) {\n            return isString(v);\n          }) || arrayIncludes(['flip', 'clockwise', 'counterclockwise'], value);\n        }\n      },\n      variant: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$v, 'variant');\n        }\n      },\n      customClass: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$v, 'customClass');\n        }\n      },\n      delay: {\n        type: [Number, Object, String],\n        default: function _default() {\n          return getComponentConfig(NAME$v, 'delay');\n        }\n      },\n      boundary: {\n        // String: scrollParent, window, or viewport\n        // Element: element reference\n        // Object: Vue component\n        type: [String, HTMLElement, Object],\n        default: function _default() {\n          return getComponentConfig(NAME$v, 'boundary');\n        }\n      },\n      boundaryPadding: {\n        type: [Number, String],\n        default: function _default() {\n          return getComponentConfig(NAME$v, 'boundaryPadding');\n        }\n      },\n      offset: {\n        type: [Number, String],\n        default: 0\n      },\n      noFade: {\n        type: Boolean,\n        default: false\n      },\n      container: {\n        // String: HTML ID of container, if null body is used (default)\n        // HTMLElement: element reference reference\n        // Object: Vue Component\n        type: [String, HTMLElement, Object] // default: undefined\n\n      },\n      show: {\n        type: Boolean,\n        default: false\n      },\n      noninteractive: {\n        type: Boolean,\n        default: false\n      },\n      disabled: {\n        type: Boolean,\n        default: false\n      },\n      id: {\n        // ID to use for tooltip element\n        // If not provided on will automatically be generated\n        type: String,\n        default: null\n      }\n    },\n    data: function data() {\n      return {\n        localShow: this.show,\n        localTitle: '',\n        localContent: ''\n      };\n    },\n    computed: {\n      templateData: function templateData() {\n        // Data that will be passed to the template and popper\n        return {\n          // We use massaged versions of the title and content props/slots\n          title: this.localTitle,\n          content: this.localContent,\n          // Pass these props as is\n          target: this.target,\n          triggers: this.triggers,\n          placement: this.placement,\n          fallbackPlacement: this.fallbackPlacement,\n          variant: this.variant,\n          customClass: this.customClass,\n          container: this.container,\n          boundary: this.boundary,\n          boundaryPadding: this.boundaryPadding,\n          delay: this.delay,\n          offset: this.offset,\n          noFade: this.noFade,\n          interactive: !this.noninteractive,\n          disabled: this.disabled,\n          id: this.id\n        };\n      },\n      templateTitleContent: function templateTitleContent() {\n        // Used to watch for changes to the title and content props\n        return {\n          title: this.title,\n          content: this.content\n        };\n      }\n    },\n    watch: {\n      show: function show(_show, oldVal) {\n        if (_show !== oldVal && _show !== this.localShow && this.$_bv_toolpop) {\n          if (_show) {\n            this.$_bv_toolpop.show();\n          } else {\n            // We use `forceHide()` to override any active triggers\n            this.$_bv_toolpop.forceHide();\n          }\n        }\n      },\n      disabled: function disabled(newVal) {\n        if (newVal) {\n          this.doDisable();\n        } else {\n          this.doEnable();\n        }\n      },\n      localShow: function localShow(newVal) {\n        // TODO: May need to be done in a `$nextTick()`\n        this.$emit('update:show', newVal);\n      },\n      templateData: function templateData() {\n        var _this = this;\n\n        this.$nextTick(function () {\n          if (_this.$_bv_toolpop) {\n            _this.$_bv_toolpop.updateData(_this.templateData);\n          }\n        });\n      },\n      // Watchers for title/content props (prop changes do not trigger the `updated()` hook)\n      templateTitleContent: function templateTitleContent() {\n        this.$nextTick(this.updateContent);\n      }\n    },\n    created: function created() {\n      // Non reactive properties\n      this.$_bv_toolpop = null;\n    },\n    updated: function updated() {\n      // Update the `propData` object\n      // Done in a `$nextTick()` to ensure slot(s) have updated\n      this.$nextTick(this.updateContent);\n    },\n    beforeDestroy: function beforeDestroy() {\n      // Shutdown our local event listeners\n      this.$off('open', this.doOpen);\n      this.$off('close', this.doClose);\n      this.$off('disable', this.doDisable);\n      this.$off('enable', this.doEnable); // Destroy the tip instance\n\n      this.$_bv_toolpop && this.$_bv_toolpop.$destroy();\n      this.$_bv_toolpop = null;\n    },\n    mounted: function mounted() {\n      var _this2 = this;\n\n      // Instantiate a new BVTooltip instance\n      // Done in a `$nextTick()` to ensure DOM has completed rendering\n      // so that target can be found\n      this.$nextTick(function () {\n        // Load the on demand child instance\n        var Component = _this2.getComponent(); // Ensure we have initial content\n\n\n        _this2.updateContent(); // Pass down the scoped style attribute if available\n\n\n        var scopeId = getScopeId(_this2) || getScopeId(_this2.$parent); // Create the instance\n\n        var $toolpop = _this2.$_bv_toolpop = new Component({\n          parent: _this2,\n          // Pass down the scoped style ID\n          _scopeId: scopeId || undefined\n        }); // Set the initial data\n\n        $toolpop.updateData(_this2.templateData); // Set listeners\n\n        $toolpop.$on('show', _this2.onShow);\n        $toolpop.$on('shown', _this2.onShown);\n        $toolpop.$on('hide', _this2.onHide);\n        $toolpop.$on('hidden', _this2.onHidden);\n        $toolpop.$on('disabled', _this2.onDisabled);\n        $toolpop.$on('enabled', _this2.onEnabled); // Initially disabled?\n\n        if (_this2.disabled) {\n          // Initially disabled\n          _this2.doDisable();\n        } // Listen to open signals from others\n\n\n        _this2.$on('open', _this2.doOpen); // Listen to close signals from others\n\n\n        _this2.$on('close', _this2.doClose); // Listen to disable signals from others\n\n\n        _this2.$on('disable', _this2.doDisable); // Listen to enable signals from others\n\n\n        _this2.$on('enable', _this2.doEnable); // Initially show tooltip?\n\n\n        if (_this2.localShow) {\n          _this2.$_bv_toolpop && _this2.$_bv_toolpop.show();\n        }\n      });\n    },\n    methods: {\n      getComponent: function getComponent() {\n        // Overridden by BPopover\n        return BVTooltip;\n      },\n      updateContent: function updateContent() {\n        // Overridden by BPopover\n        // Tooltip: Default slot is `title`\n        // Popover: Default slot is `content`, `title` slot is title\n        // We pass a scoped slot function reference by default (Vue v2.6x)\n        // And pass the title prop as a fallback\n        this.setTitle(this.$scopedSlots.default || this.title);\n      },\n      // Helper methods for `updateContent()`\n      setTitle: function setTitle(val) {\n        val = isUndefinedOrNull(val) ? '' : val; // We only update the value if it has changed\n\n        if (this.localTitle !== val) {\n          this.localTitle = val;\n        }\n      },\n      setContent: function setContent(val) {\n        val = isUndefinedOrNull(val) ? '' : val; // We only update the value if it has changed\n\n        if (this.localContent !== val) {\n          this.localContent = val;\n        }\n      },\n      // --- Template event handlers ---\n      onShow: function onShow(bvEvt) {\n        // Placeholder\n        this.$emit('show', bvEvt);\n\n        if (bvEvt) {\n          this.localShow = !bvEvt.defaultPrevented;\n        }\n      },\n      onShown: function onShown(bvEvt) {\n        // Tip is now showing\n        this.localShow = true;\n        this.$emit('shown', bvEvt);\n      },\n      onHide: function onHide(bvEvt) {\n        this.$emit('hide', bvEvt);\n      },\n      onHidden: function onHidden(bvEvt) {\n        // Tip is no longer showing\n        this.$emit('hidden', bvEvt);\n        this.localShow = false;\n      },\n      onDisabled: function onDisabled(bvEvt) {\n        // Prevent possible endless loop if user mistakenly\n        // fires `disabled` instead of `disable`\n        if (bvEvt && bvEvt.type === 'disabled') {\n          this.$emit('update:disabled', true);\n          this.$emit('disabled', bvEvt);\n        }\n      },\n      onEnabled: function onEnabled(bvEvt) {\n        // Prevent possible endless loop if user mistakenly\n        // fires `enabled` instead of `enable`\n        if (bvEvt && bvEvt.type === 'enabled') {\n          this.$emit('update:disabled', false);\n          this.$emit('enabled', bvEvt);\n        }\n      },\n      // --- Local event listeners ---\n      doOpen: function doOpen() {\n        !this.localShow && this.$_bv_toolpop && this.$_bv_toolpop.show();\n      },\n      doClose: function doClose() {\n        this.localShow && this.$_bv_toolpop && this.$_bv_toolpop.hide();\n      },\n      doDisable: function doDisable() {\n        this.$_bv_toolpop && this.$_bv_toolpop.disable();\n      },\n      doEnable: function doEnable() {\n        this.$_bv_toolpop && this.$_bv_toolpop.enable();\n      }\n    },\n    render: function render(h) {\n      // Always renders a comment node\n      // TODO:\n      //   Future: Possibly render a target slot (single root element)\n      //   which we can apply the listeners to (pass `this.$el` to BVTooltip)\n      return h();\n    }\n  });\n\n  var NAME$w = 'BVPopoverTemplate'; // @vue/component\n\n  var BVPopoverTemplate =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$w,\n    extends: BVTooltipTemplate,\n    computed: {\n      templateType: function templateType() {\n        return 'popover';\n      }\n    },\n    methods: {\n      renderTemplate: function renderTemplate(h) {\n        // Title and content could be a scoped slot function\n        var $title = isFunction(this.title) ? this.title({}) : this.title;\n        var $content = isFunction(this.content) ? this.content({}) : this.content; // Directive usage only\n\n        var titleDomProps = this.html && !isFunction(this.title) ? {\n          innerHTML: this.title\n        } : {};\n        var contentDomProps = this.html && !isFunction(this.content) ? {\n          innerHTML: this.content\n        } : {};\n        return h('div', {\n          staticClass: 'popover b-popover',\n          class: this.templateClasses,\n          attrs: this.templateAttributes,\n          on: this.templateListeners\n        }, [h('div', {\n          ref: 'arrow',\n          staticClass: 'arrow'\n        }), isUndefinedOrNull($title) || $title === '' ? h() : h('h3', {\n          staticClass: 'popover-header',\n          domProps: titleDomProps\n        }, [$title]), isUndefinedOrNull($content) || $content === '' ? h() : h('div', {\n          staticClass: 'popover-body',\n          domProps: contentDomProps\n        }, [$content])]);\n      }\n    }\n  });\n\n  // Popover \"Class\" (Built as a renderless Vue instance)\n  var NAME$x = 'BVPopover'; // @vue/component\n\n  var BVPopover =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$x,\n    extends: BVTooltip,\n    computed: {\n      // Overwrites BVTooltip\n      templateType: function templateType() {\n        return 'popover';\n      }\n    },\n    methods: {\n      getTemplate: function getTemplate() {\n        // Overwrites BVTooltip\n        return BVPopoverTemplate;\n      }\n    }\n  });\n\n  var NAME$y = 'BPopover';\n  var BPopover =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$y,\n    extends: BTooltip,\n    inheritAttrs: false,\n    props: {\n      title: {\n        type: String // default: undefined\n\n      },\n      content: {\n        type: String // default: undefined\n\n      },\n      triggers: {\n        type: [String, Array],\n        default: 'click'\n      },\n      placement: {\n        type: String,\n        default: 'right'\n      },\n      variant: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$y, 'variant');\n        }\n      },\n      customClass: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$y, 'customClass');\n        }\n      },\n      delay: {\n        type: [Number, Object, String],\n        default: function _default() {\n          return getComponentConfig(NAME$y, 'delay');\n        }\n      },\n      boundary: {\n        // String: scrollParent, window, or viewport\n        // Element: element reference\n        // Object: Vue component\n        type: [String, HTMLElement, Object],\n        default: function _default() {\n          return getComponentConfig(NAME$y, 'boundary');\n        }\n      },\n      boundaryPadding: {\n        type: [Number, String],\n        default: function _default() {\n          return getComponentConfig(NAME$y, 'boundaryPadding');\n        }\n      }\n    },\n    methods: {\n      getComponent: function getComponent() {\n        // Overridden by BPopover\n        return BVPopover;\n      },\n      updateContent: function updateContent() {\n        // Tooltip: Default slot is `title`\n        // Popover: Default slot is `content`, `title` slot is title\n        // We pass a scoped slot function references by default (Vue v2.6x)\n        // And pass the title prop as a fallback\n        this.setContent(this.$scopedSlots.default || this.content);\n        this.setTitle(this.$scopedSlots.title || this.title);\n      }\n    } // Render function provided by BTooltip\n\n  });\n\n  var BV_POPOVER = '__BV_Popover__'; // Default trigger\n\n  var DefaultTrigger = 'click'; // Valid event triggers\n\n  var validTriggers = {\n    focus: true,\n    hover: true,\n    click: true,\n    blur: true,\n    manual: true\n  }; // Directive modifier test regular expressions. Pre-compile for performance\n\n  var htmlRE = /^html$/i;\n  var noFadeRE = /^nofade$/i;\n  var placementRE = /^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/i;\n  var boundaryRE = /^(window|viewport|scrollParent)$/i;\n  var delayRE = /^d\\d+$/i;\n  var delayShowRE = /^ds\\d+$/i;\n  var delayHideRE = /^dh\\d+$/i;\n  var offsetRE = /^o-?\\d+$/i;\n  var variantRE = /^v-.+$/i;\n  var spacesRE = /\\s+/; // Build a Popover config based on bindings (if any)\n  // Arguments and modifiers take precedence over passed value config object\n\n  var parseBindings = function parseBindings(bindings, vnode)\n  /* istanbul ignore next: not easy to test */\n  {\n    // We start out with a basic config\n    var NAME = 'BPopover';\n    var config = {\n      title: undefined,\n      content: undefined,\n      trigger: '',\n      // Default set below if needed\n      placement: 'right',\n      fallbackPlacement: 'flip',\n      container: false,\n      // Default of body\n      animation: true,\n      offset: 0,\n      disabled: false,\n      id: null,\n      html: false,\n      delay: getComponentConfig(NAME, 'delay'),\n      boundary: String(getComponentConfig(NAME, 'boundary')),\n      boundaryPadding: parseInt(getComponentConfig(NAME, 'boundaryPadding'), 10) || 0,\n      variant: getComponentConfig(NAME, 'variant'),\n      customClass: getComponentConfig(NAME, 'customClass')\n    }; // Process `bindings.value`\n\n    if (isString(bindings.value) || isNumber(bindings.value)) {\n      // Value is popover content (html optionally supported)\n      config.content = bindings.value;\n    } else if (isFunction(bindings.value)) {\n      // Content generator function\n      config.content = bindings.value;\n    } else if (isPlainObject(bindings.value)) {\n      // Value is config object, so merge\n      config = _objectSpread2({}, config, {}, bindings.value);\n    } // If argument, assume element ID of container element\n\n\n    if (bindings.arg) {\n      // Element ID specified as arg\n      // We must prepend '#' to become a CSS selector\n      config.container = \"#\".concat(bindings.arg);\n    } // If title is not provided, try title attribute\n\n\n    if (isUndefined(config.title)) {\n      // Try attribute\n      var data = vnode.data || {};\n      config.title = data.attrs && !isUndefinedOrNull(data.attrs.title) ? data.attrs.title : undefined;\n    } // Normalize delay\n\n\n    if (!isPlainObject(config.delay)) {\n      config.delay = {\n        show: parseInt(config.delay, 10) || 0,\n        hide: parseInt(config.delay, 10) || 0\n      };\n    } // Process modifiers\n\n\n    keys(bindings.modifiers).forEach(function (mod) {\n      if (htmlRE.test(mod)) {\n        // Title/content allows HTML\n        config.html = true;\n      } else if (noFadeRE.test(mod)) {\n        // No animation\n        config.animation = false;\n      } else if (placementRE.test(mod)) {\n        // Placement of popover\n        config.placement = mod;\n      } else if (boundaryRE.test(mod)) {\n        // Boundary of popover\n        mod = mod === 'scrollparent' ? 'scrollParent' : mod;\n        config.boundary = mod;\n      } else if (delayRE.test(mod)) {\n        // Delay value\n        var delay = parseInt(mod.slice(1), 10) || 0;\n        config.delay.show = delay;\n        config.delay.hide = delay;\n      } else if (delayShowRE.test(mod)) {\n        // Delay show value\n        config.delay.show = parseInt(mod.slice(2), 10) || 0;\n      } else if (delayHideRE.test(mod)) {\n        // Delay hide value\n        config.delay.hide = parseInt(mod.slice(2), 10) || 0;\n      } else if (offsetRE.test(mod)) {\n        // Offset value, negative allowed\n        config.offset = parseInt(mod.slice(1), 10) || 0;\n      } else if (variantRE.test(mod)) {\n        // Variant\n        config.variant = mod.slice(2) || null;\n      }\n    }); // Special handling of event trigger modifiers trigger is\n    // a space separated list\n\n    var selectedTriggers = {}; // Parse current config object trigger\n\n    concat(config.trigger || '').filter(identity).join(' ').trim().toLowerCase().split(spacesRE).forEach(function (trigger) {\n      if (validTriggers[trigger]) {\n        selectedTriggers[trigger] = true;\n      }\n    }); // Parse modifiers for triggers\n\n    keys(bindings.modifiers).forEach(function (mod) {\n      mod = mod.toLowerCase();\n\n      if (validTriggers[mod]) {\n        // If modifier is a valid trigger\n        selectedTriggers[mod] = true;\n      }\n    }); // Sanitize triggers\n\n    config.trigger = keys(selectedTriggers).join(' ');\n\n    if (config.trigger === 'blur') {\n      // Blur by itself is useless, so convert it to 'focus'\n      config.trigger = 'focus';\n    }\n\n    if (!config.trigger) {\n      // Use default trigger\n      config.trigger = DefaultTrigger;\n    }\n\n    return config;\n  }; // Add or update Popover on our element\n\n\n  var applyPopover = function applyPopover(el, bindings, vnode) {\n    if (!isBrowser) {\n      /* istanbul ignore next */\n      return;\n    }\n\n    var config = parseBindings(bindings, vnode);\n\n    if (!el[BV_POPOVER]) {\n      var $parent = vnode.context;\n      el[BV_POPOVER] = new BVPopover({\n        parent: $parent,\n        // Add the parent's scoped style attribute data\n        _scopeId: getScopeId($parent, undefined)\n      });\n      el[BV_POPOVER].__bv_prev_data__ = {};\n      el[BV_POPOVER].$on('show', function ()\n      /* istanbul ignore next: for now */\n      {\n        // Before showing the popover, we update the title\n        // and content if they are functions\n        var data = {};\n\n        if (isFunction(config.title)) {\n          data.title = config.title(el);\n        }\n\n        if (isFunction(config.content)) {\n          data.content = config.content(el);\n        }\n\n        if (keys(data).length > 0) {\n          el[BV_POPOVER].updateData(data);\n        }\n      });\n    }\n\n    var data = {\n      title: config.title,\n      content: config.content,\n      triggers: config.trigger,\n      placement: config.placement,\n      fallbackPlacement: config.fallbackPlacement,\n      variant: config.variant,\n      customClass: config.customClass,\n      container: config.container,\n      boundary: config.boundary,\n      delay: config.delay,\n      offset: config.offset,\n      noFade: !config.animation,\n      id: config.id,\n      disabled: config.disabled,\n      html: config.html\n    };\n    var oldData = el[BV_POPOVER].__bv_prev_data__;\n    el[BV_POPOVER].__bv_prev_data__ = data;\n\n    if (!looseEqual(data, oldData)) {\n      // We only update the instance if data has changed\n      var newData = {\n        target: el\n      };\n      keys(data).forEach(function (prop) {\n        // We only pass data properties that have changed\n        if (data[prop] !== oldData[prop]) {\n          // If title/content is a function, we execute it here\n          newData[prop] = (prop === 'title' || prop === 'content') && isFunction(data[prop]) ? data[prop](el) : data[prop];\n        }\n      });\n      el[BV_POPOVER].updateData(newData);\n    }\n  }; // Remove Popover from our element\n\n\n  var removePopover = function removePopover(el) {\n    if (el[BV_POPOVER]) {\n      el[BV_POPOVER].$destroy();\n      el[BV_POPOVER] = null;\n    }\n\n    delete el[BV_POPOVER];\n  }; // Export our directive\n\n\n  var VBPopover = {\n    bind: function bind(el, bindings, vnode) {\n      applyPopover(el, bindings, vnode);\n    },\n    // We use `componentUpdated` here instead of `update`, as the former\n    // waits until the containing component and children have finished updating\n    componentUpdated: function componentUpdated(el, bindings, vnode) {\n      // Performed in a `$nextTick()` to prevent endless render/update loops\n      vnode.context.$nextTick(function () {\n        applyPopover(el, bindings, vnode);\n      });\n    },\n    unbind: function unbind(el) {\n      removePopover(el);\n    }\n  };\n\n  var VBPopoverPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    directives: {\n      VBPopover: VBPopover\n    }\n  });\n\n  var PopoverPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BPopover: BPopover\n    },\n    plugins: {\n      VBPopoverPlugin: VBPopoverPlugin\n    }\n  });\n\n  var NAME$z = 'BProgressBar'; // @vue/component\n\n  var BProgressBar =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$z,\n    mixins: [normalizeSlotMixin],\n    inject: {\n      bvProgress: {\n        default: function _default()\n        /* istanbul ignore next */\n        {\n          return {};\n        }\n      }\n    },\n    props: {\n      value: {\n        type: [Number, String],\n        default: 0\n      },\n      label: {\n        type: String,\n        default: null\n      },\n      labelHtml: {\n        type: String\n      },\n      // $parent (this.bvProgress) prop values may take precedence over the following props\n      // Which is why they are defaulted to null\n      max: {\n        type: [Number, String],\n        default: null\n      },\n      precision: {\n        type: [Number, String],\n        default: null\n      },\n      variant: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$z, 'variant');\n        }\n      },\n      striped: {\n        type: Boolean,\n        default: null\n      },\n      animated: {\n        type: Boolean,\n        default: null\n      },\n      showProgress: {\n        type: Boolean,\n        default: null\n      },\n      showValue: {\n        type: Boolean,\n        default: null\n      }\n    },\n    computed: {\n      progressBarClasses: function progressBarClasses() {\n        return [this.computedVariant ? \"bg-\".concat(this.computedVariant) : '', this.computedStriped || this.computedAnimated ? 'progress-bar-striped' : '', this.computedAnimated ? 'progress-bar-animated' : ''];\n      },\n      progressBarStyles: function progressBarStyles() {\n        return {\n          width: 100 * (this.computedValue / this.computedMax) + '%'\n        };\n      },\n      computedValue: function computedValue() {\n        return toFloat(this.value) || 0;\n      },\n      computedMax: function computedMax() {\n        // Prefer our max over parent setting\n        var max = toFloat(this.max);\n        return isNaN(max) ? toFloat(this.bvProgress.max) || 100 : max;\n      },\n      computedPrecision: function computedPrecision() {\n        // Prefer our precision over parent setting\n        var precision = toInteger(this.precision);\n        return isNaN(precision) ? toInteger(this.bvProgress.precision) || 0 : precision;\n      },\n      computedProgress: function computedProgress() {\n        var precision = this.computedPrecision;\n        var p = Math.pow(10, precision);\n        return toFixed(100 * p * this.computedValue / this.computedMax / p, precision);\n      },\n      computedVariant: function computedVariant() {\n        // Prefer our variant over parent setting\n        return this.variant || this.bvProgress.variant;\n      },\n      computedStriped: function computedStriped() {\n        // Prefer our striped over parent setting\n        return isBoolean(this.striped) ? this.striped : this.bvProgress.striped || false;\n      },\n      computedAnimated: function computedAnimated() {\n        // Prefer our animated over parent setting\n        return isBoolean(this.animated) ? this.animated : this.bvProgress.animated || false;\n      },\n      computedShowProgress: function computedShowProgress() {\n        // Prefer our showProgress over parent setting\n        return isBoolean(this.showProgress) ? this.showProgress : this.bvProgress.showProgress || false;\n      },\n      computedShowValue: function computedShowValue() {\n        // Prefer our showValue over parent setting\n        return isBoolean(this.showValue) ? this.showValue : this.bvProgress.showValue || false;\n      }\n    },\n    render: function render(h) {\n      var childNodes = h();\n\n      if (this.hasNormalizedSlot('default')) {\n        childNodes = this.normalizeSlot('default');\n      } else if (this.label || this.labelHtml) {\n        childNodes = h('span', {\n          domProps: htmlOrText(this.labelHtml, this.label)\n        });\n      } else if (this.computedShowProgress) {\n        childNodes = this.computedProgress;\n      } else if (this.computedShowValue) {\n        childNodes = toFixed(this.computedValue, this.computedPrecision);\n      }\n\n      return h('div', {\n        staticClass: 'progress-bar',\n        class: this.progressBarClasses,\n        style: this.progressBarStyles,\n        attrs: {\n          role: 'progressbar',\n          'aria-valuemin': '0',\n          'aria-valuemax': toString$1(this.computedMax),\n          'aria-valuenow': toFixed(this.computedValue, this.computedPrecision)\n        }\n      }, [childNodes]);\n    }\n  });\n\n  var NAME$A = 'BProgress'; // @vue/component\n\n  var BProgress =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$A,\n    mixins: [normalizeSlotMixin],\n    provide: function provide() {\n      return {\n        bvProgress: this\n      };\n    },\n    props: {\n      // These props can be inherited via the child b-progress-bar(s)\n      variant: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$A, 'variant');\n        }\n      },\n      striped: {\n        type: Boolean,\n        default: false\n      },\n      animated: {\n        type: Boolean,\n        default: false\n      },\n      height: {\n        type: String,\n        default: null\n      },\n      precision: {\n        type: [Number, String],\n        default: 0\n      },\n      showProgress: {\n        type: Boolean,\n        default: false\n      },\n      showValue: {\n        type: Boolean,\n        default: false\n      },\n      max: {\n        type: [Number, String],\n        default: 100\n      },\n      // This prop is not inherited by child b-progress-bar(s)\n      value: {\n        type: [Number, String],\n        default: 0\n      }\n    },\n    computed: {\n      progressHeight: function progressHeight() {\n        return {\n          height: this.height || null\n        };\n      }\n    },\n    render: function render(h) {\n      var childNodes = this.normalizeSlot('default');\n\n      if (!childNodes) {\n        childNodes = h(BProgressBar, {\n          props: {\n            value: this.value,\n            max: this.max,\n            precision: this.precision,\n            variant: this.variant,\n            animated: this.animated,\n            striped: this.striped,\n            showProgress: this.showProgress,\n            showValue: this.showValue\n          }\n        });\n      }\n\n      return h('div', {\n        class: ['progress'],\n        style: this.progressHeight\n      }, [childNodes]);\n    }\n  });\n\n  var ProgressPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BProgress: BProgress,\n      BProgressBar: BProgressBar\n    }\n  });\n\n  var NAME$B = 'BSpinner'; // @vue/component\n\n  var BSpinner =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$B,\n    functional: true,\n    props: {\n      type: {\n        type: String,\n        default: 'border' // SCSS currently supports 'border' or 'grow'\n\n      },\n      label: {\n        type: String,\n        default: null\n      },\n      variant: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig(NAME$B, 'variant');\n        }\n      },\n      small: {\n        type: Boolean,\n        default: false\n      },\n      role: {\n        type: String,\n        default: 'status'\n      },\n      tag: {\n        type: String,\n        default: 'span'\n      }\n    },\n    render: function render(h, _ref) {\n      var _class;\n\n      var props = _ref.props,\n          data = _ref.data,\n          slots = _ref.slots,\n          scopedSlots = _ref.scopedSlots;\n      var $slots = slots();\n      var $scopedSlots = scopedSlots || {};\n      var label = normalizeSlot('label', {}, $scopedSlots, $slots) || props.label;\n\n      if (label) {\n        label = h('span', {\n          staticClass: 'sr-only'\n        }, label);\n      }\n\n      return h(props.tag, a(data, {\n        attrs: {\n          role: label ? props.role || 'status' : null,\n          'aria-hidden': label ? null : 'true'\n        },\n        class: (_class = {}, _defineProperty(_class, \"spinner-\".concat(props.type), props.type), _defineProperty(_class, \"spinner-\".concat(props.type, \"-sm\"), props.small), _defineProperty(_class, \"text-\".concat(props.variant), props.variant), _class)\n      }), [label || h()]);\n    }\n  });\n\n  var SpinnerPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BSpinner: BSpinner\n    }\n  });\n\n  // Mixin to determine if an event listener has been registered\n\n  var hasListenerMixin = {\n    methods: {\n      hasListener: function hasListener(name) {\n        // Only includes listeners registerd via `v-on:name`\n        var $listeners = this.$listeners || {}; // Includes `v-on:name` and `this.$on('name')` registerd listeners\n        // Note this property is not part of the public Vue API, but it is\n        // the only way to determine if a listener was added via `vm.$on`\n\n        var $events = this._events || {}; // Registered listeners in `this._events` are always an array,\n        // but might be zero length\n\n        return !isUndefined($listeners[name]) || isArray($events[name]) && $events[name].length > 0;\n      }\n    }\n  };\n\n  /**\n   * Converts a string, including strings in camelCase or snake_case, into Start Case (a variant\n   * of Title Case where all words start with a capital letter), it keeps original single quote\n   * and hyphen in the word.\n   *\n   * Copyright (c) 2017 Compass (MIT)\n   * https://github.com/UrbanCompass/to-start-case\n   * @author Zhuoyuan Zhang <https://github.com/drawyan>\n   * @author Wei Wang <https://github.com/onlywei>\n   *\n   *\n   *   'management_companies' to 'Management Companies'\n   *   'managementCompanies' to 'Management Companies'\n   *   `hell's kitchen` to `Hell's Kitchen`\n   *   `co-op` to `Co-op`\n   *\n   * @param {String} str\n   * @returns {String}\n   */\n  // Precompile regular expressions for performance\n  var RX_UNDERSCORE = /_/g;\n  var RX_LOWER_UPPER = /([a-z])([A-Z])/g;\n  var RX_START_SPACE_WORD = /(\\s|^)(\\w)/g;\n\n  var startCase = function startCase(str) {\n    return str.replace(RX_UNDERSCORE, ' ').replace(RX_LOWER_UPPER, function (str, $1, $2) {\n      return $1 + ' ' + $2;\n    }).replace(RX_START_SPACE_WORD, function (str, $1, $2) {\n      return $1 + $2.toUpperCase();\n    });\n  };\n\n  // Constants used by table helpers\n  // Object of item keys that should be ignored for headers and\n  // stringification and filter events\n  var IGNORED_FIELD_KEYS = {\n    _rowVariant: true,\n    _cellVariants: true,\n    _showDetails: true\n  }; // Filter CSS selector for click/dblclick/etc. events\n  // If any of these selectors match the clicked element, we ignore the event\n\n  var EVENT_FILTER = ['a', 'a *', // Include content inside links\n  'button', 'button *', // Include content inside buttons\n  'input:not(.disabled):not([disabled])', 'select:not(.disabled):not([disabled])', 'textarea:not(.disabled):not([disabled])', '[role=\"link\"]', '[role=\"link\"] *', '[role=\"button\"]', '[role=\"button\"] *', '[tabindex]:not(.disabled):not([disabled])'].join(',');\n\n  var processField = function processField(key, value) {\n    var field = null;\n\n    if (isString(value)) {\n      // Label shortcut\n      field = {\n        key: key,\n        label: value\n      };\n    } else if (isFunction(value)) {\n      // Formatter shortcut\n      field = {\n        key: key,\n        formatter: value\n      };\n    } else if (isObject(value)) {\n      field = clone(value);\n      field.key = field.key || key;\n    } else if (value !== false) {\n      // Fallback to just key\n\n      /* istanbul ignore next */\n      field = {\n        key: key\n      };\n    }\n\n    return field;\n  }; // We normalize fields into an array of objects\n  // [ { key:..., label:..., ...}, {...}, ..., {..}]\n\n\n  var normalizeFields = function normalizeFields(origFields, items) {\n    var fields = [];\n\n    if (isArray(origFields)) {\n      // Normalize array Form\n      origFields.filter(identity).forEach(function (f) {\n        if (isString(f)) {\n          fields.push({\n            key: f,\n            label: startCase(f)\n          });\n        } else if (isObject(f) && f.key && isString(f.key)) {\n          // Full object definition. We use assign so that we don't mutate the original\n          fields.push(clone(f));\n        } else if (isObject(f) && keys(f).length === 1) {\n          // Shortcut object (i.e. { 'foo_bar': 'This is Foo Bar' }\n          var key = keys(f)[0];\n          var field = processField(key, f[key]);\n\n          if (field) {\n            fields.push(field);\n          }\n        }\n      });\n    } // If no field provided, take a sample from first record (if exits)\n\n\n    if (fields.length === 0 && isArray(items) && items.length > 0) {\n      var sample = items[0];\n      keys(sample).forEach(function (k) {\n        if (!IGNORED_FIELD_KEYS[k]) {\n          fields.push({\n            key: k,\n            label: startCase(k)\n          });\n        }\n      });\n    } // Ensure we have a unique array of fields and that they have String labels\n\n\n    var memo = {};\n    return fields.filter(function (f) {\n      if (!memo[f.key]) {\n        memo[f.key] = true;\n        f.label = isString(f.label) ? f.label : startCase(f.key);\n        return true;\n      }\n\n      return false;\n    });\n  };\n\n  var itemsMixin = {\n    props: {\n      items: {\n        // Provider mixin adds in `Function` type\n        type: Array,\n        default: function _default()\n        /* istanbul ignore next */\n        {\n          return [];\n        }\n      },\n      fields: {\n        type: Array,\n        default: null\n      },\n      primaryKey: {\n        // Primary key for record\n        // If provided the value in each row must be unique!\n        type: String,\n        default: null\n      },\n      value: {\n        // `v-model` for retrieving the current displayed rows\n        type: Array,\n        default: function _default() {\n          return [];\n        }\n      }\n    },\n    data: function data() {\n      return {\n        // Our local copy of the items\n        // Must be an array\n        localItems: isArray(this.items) ? this.items.slice() : []\n      };\n    },\n    computed: {\n      computedFields: function computedFields() {\n        // We normalize fields into an array of objects\n        // `[ { key:..., label:..., ...}, {...}, ..., {..}]`\n        return normalizeFields(this.fields, this.localItems);\n      },\n      computedFieldsObj: function computedFieldsObj() {\n        // Fields as a simple lookup hash object\n        // Mainly for formatter lookup and use in `scopedSlots` for convenience\n        // If the field has a formatter, it normalizes formatter to a\n        // function ref or `undefined` if no formatter\n        var parent = this.$parent;\n        return this.computedFields.reduce(function (obj, f) {\n          // We use object spread here so we don't mutate the original field object\n          obj[f.key] = clone(f);\n\n          if (f.formatter) {\n            // Normalize formatter to a function ref or `undefined`\n            var formatter = f.formatter;\n\n            if (isString(formatter) && isFunction(parent[formatter])) {\n              formatter = parent[formatter];\n            } else if (!isFunction(formatter)) {\n              /* istanbul ignore next */\n              formatter = undefined;\n            } // Return formatter function or `undefined` if none\n\n\n            obj[f.key].formatter = formatter;\n          }\n\n          return obj;\n        }, {});\n      },\n      computedItems: function computedItems() {\n        // Fallback if various mixins not provided\n        return (this.paginatedItems || this.sortedItems || this.filteredItems || this.localItems || []).slice();\n      },\n      context: function context() {\n        // Current state of sorting, filtering and pagination props/values\n        return {\n          filter: this.localFilter,\n          sortBy: this.localSortBy,\n          sortDesc: this.localSortDesc,\n          perPage: parseInt(this.perPage, 10) || 0,\n          currentPage: parseInt(this.currentPage, 10) || 1,\n          apiUrl: this.apiUrl\n        };\n      }\n    },\n    watch: {\n      items: function items(newItems) {\n        /* istanbul ignore else */\n        if (isArray(newItems)) {\n          // Set `localItems`/`filteredItems` to a copy of the provided array\n          this.localItems = newItems.slice();\n        } else if (isUndefinedOrNull(newItems)) {\n          /* istanbul ignore next */\n          this.localItems = [];\n        }\n      },\n      // Watch for changes on `computedItems` and update the `v-model`\n      computedItems: function computedItems(newVal) {\n        this.$emit('input', newVal);\n      },\n      // Watch for context changes\n      context: function context(newVal, oldVal) {\n        // Emit context information for external paging/filtering/sorting handling\n        if (!looseEqual(newVal, oldVal)) {\n          this.$emit('context-changed', newVal);\n        }\n      }\n    },\n    mounted: function mounted() {\n      // Initially update the `v-model` of displayed items\n      this.$emit('input', this.computedItems);\n    },\n    methods: {\n      // Method to get the formatter method for a given field key\n      getFieldFormatter: function getFieldFormatter(key) {\n        var field = this.computedFieldsObj[key]; // `this.computedFieldsObj` has pre-normalized the formatter to a\n        // function ref if present, otherwise `undefined`\n\n        return field ? field.formatter : undefined;\n      }\n    }\n  };\n\n  // Mixin for providing stacked tables\n  var stackedMixin = {\n    props: {\n      stacked: {\n        type: [Boolean, String],\n        default: false\n      }\n    },\n    computed: {\n      isStacked: function isStacked() {\n        // `true` when always stacked, or returns breakpoint specified\n        return this.stacked === '' ? true : this.stacked;\n      },\n      isStackedAlways: function isStackedAlways() {\n        return this.isStacked === true;\n      },\n      stackedTableClasses: function stackedTableClasses() {\n        return _defineProperty({\n          'b-table-stacked': this.isStackedAlways\n        }, \"b-table-stacked-\".concat(this.stacked), !this.isStackedAlways && this.isStacked);\n      }\n    }\n  };\n\n  var sanitizeRow = function sanitizeRow(row, ignoreFields, includeFields) {\n    var fieldsObj = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    return keys(row).reduce(function (obj, key) {\n      // Ignore special fields that start with `_`\n      // Ignore fields in the `ignoreFields` array\n      // Include only fields in the `includeFields` array\n      if (!IGNORED_FIELD_KEYS[key] && !(ignoreFields && ignoreFields.length > 0 && arrayIncludes(ignoreFields, key)) && !(includeFields && includeFields.length > 0 && !arrayIncludes(includeFields, key))) {\n        var f = fieldsObj[key] || {};\n        var val = row[key]; // `f.filterByFormatted` will either be a function or boolean\n        // `f.formater` will have already been noramlized into a function ref\n\n        var filterByFormatted = f.filterByFormatted;\n        var formatter = isFunction(filterByFormatted) ? filterByFormatted : filterByFormatted ? f.formatter : null;\n        obj[key] = isFunction(formatter) ? formatter(val, key, row) : val;\n      }\n\n      return obj;\n    }, {});\n  };\n\n  // SSR safe deterministic way (keys are sorted before stringification)\n  //\n  //   ex:\n  //     { b: 3, c: { z: 'zzz', d: null, e: 2 }, d: [10, 12, 11], a: 'one' }\n  //   becomes\n  //     'one 3 2 zzz 10 12 11'\n  //\n  // Primitives (numbers/strings) are returned as-is\n  // Null and undefined values are filtered out\n  // Dates are converted to their native string format\n\n  var stringifyObjectValues = function stringifyObjectValues(val) {\n    if (isUndefinedOrNull(val)) {\n      /* istanbul ignore next */\n      return '';\n    } // Arrays are also object, and keys just returns the array indexes\n    // Date objects we convert to strings\n\n\n    if (isObject(val) && !isDate(val)) {\n      return keys(val).sort() // Sort to prevent SSR issues on pre-rendered sorted tables\n      .filter(function (v) {\n        return !isUndefinedOrNull(v);\n      }) // Ignore undefined/null values\n      .map(function (k) {\n        return stringifyObjectValues(val[k]);\n      }).join(' ');\n    }\n\n    return toString$1(val);\n  };\n\n  // TODO: Add option to stringify `scopedSlot` items\n\n  var stringifyRecordValues = function stringifyRecordValues(row, ignoreFields, includeFields, fieldsObj) {\n    return isObject(row) ? stringifyObjectValues(sanitizeRow(row, ignoreFields, includeFields, fieldsObj)) : '';\n  };\n\n  var DEBOUNCE_DEPRECATED_MSG = 'Prop \"filter-debounce\" is deprecated. Use the debounce feature of \"<b-form-input>\" instead.';\n  var RX_SPACES$1 = /[\\s\\uFEFF\\xA0]+/g;\n  var filteringMixin = {\n    props: {\n      filter: {\n        type: [String, RegExp, Object, Array],\n        default: null\n      },\n      filterFunction: {\n        type: Function,\n        default: null\n      },\n      filterIgnoredFields: {\n        type: Array // default: undefined\n\n      },\n      filterIncludedFields: {\n        type: Array // default: undefined\n\n      },\n      filterDebounce: {\n        type: [Number, String],\n        deprecated: DEBOUNCE_DEPRECATED_MSG,\n        default: 0,\n        validator: function validator(val) {\n          return /^\\d+/.test(String(val));\n        }\n      }\n    },\n    data: function data() {\n      return {\n        // Flag for displaying which empty slot to show and some event triggering\n        isFiltered: false,\n        // Where we store the copy of the filter criteria after debouncing\n        // We pre-set it with the sanitized filter value\n        localFilter: this.filterSanitize(this.filter)\n      };\n    },\n    computed: {\n      computedFilterIgnored: function computedFilterIgnored() {\n        return this.filterIgnoredFields ? concat(this.filterIgnoredFields).filter(Boolean) : null;\n      },\n      computedFilterIncluded: function computedFilterIncluded() {\n        return this.filterIncludedFields ? concat(this.filterIncludedFields).filter(Boolean) : null;\n      },\n      computedFilterDebounce: function computedFilterDebounce() {\n        var ms = toInteger(this.filterDebounce) || 0;\n        /* istanbul ignore next */\n\n        if (ms > 0) {\n          warn(DEBOUNCE_DEPRECATED_MSG, 'BTable');\n        }\n\n        return ms;\n      },\n      localFiltering: function localFiltering() {\n        return this.hasProvider ? !!this.noProviderFiltering : true;\n      },\n      // For watching changes to `filteredItems` vs `localItems`\n      filteredCheck: function filteredCheck() {\n        return {\n          filteredItems: this.filteredItems,\n          localItems: this.localItems,\n          localFilter: this.localFilter\n        };\n      },\n      // Sanitized/normalize filter-function prop\n      localFilterFn: function localFilterFn() {\n        // Return `null` to signal to use internal filter function\n        return isFunction(this.filterFunction) ? this.filterFunction : null;\n      },\n      // Returns the records in `localItems` that match the filter criteria\n      // Returns the original `localItems` array if not sorting\n      filteredItems: function filteredItems() {\n        var items = this.localItems || []; // Note the criteria is debounced and sanitized\n\n        var criteria = this.localFilter; // Resolve the filtering function, when requested\n        // We prefer the provided filtering function and fallback to the internal one\n        // When no filtering criteria is specified the filtering factories will return `null`\n\n        var filterFn = this.localFiltering ? this.filterFnFactory(this.localFilterFn, criteria) || this.defaultFilterFnFactory(criteria) : null; // We only do local filtering when requested and there are records to filter\n\n        return filterFn && items.length > 0 ? items.filter(filterFn) : items;\n      }\n    },\n    watch: {\n      // Watch for debounce being set to 0\n      computedFilterDebounce: function computedFilterDebounce(newVal) {\n        if (!newVal && this.$_filterTimer) {\n          clearTimeout(this.$_filterTimer);\n          this.$_filterTimer = null;\n          this.localFilter = this.filterSanitize(this.filter);\n        }\n      },\n      // Watch for changes to the filter criteria, and debounce if necessary\n      filter: {\n        // We need a deep watcher in case the user passes\n        // an object when using `filter-function`\n        deep: true,\n        handler: function handler(newCriteria) {\n          var _this = this;\n\n          var timeout = this.computedFilterDebounce;\n          clearTimeout(this.$_filterTimer);\n          this.$_filterTimer = null;\n\n          if (timeout && timeout > 0) {\n            // If we have a debounce time, delay the update of `localFilter`\n            this.$_filterTimer = setTimeout(function () {\n              _this.localFilter = _this.filterSanitize(newCriteria);\n            }, timeout);\n          } else {\n            // Otherwise, immediately update `localFilter` with `newFilter` value\n            this.localFilter = this.filterSanitize(newCriteria);\n          }\n        }\n      },\n      // Watch for changes to the filter criteria and filtered items vs `localItems`\n      // Set visual state and emit events as required\n      filteredCheck: function filteredCheck(_ref) {\n        var filteredItems = _ref.filteredItems,\n            localFilter = _ref.localFilter;\n        // Determine if the dataset is filtered or not\n        var isFiltered = false;\n\n        if (!localFilter) {\n          // If filter criteria is falsey\n          isFiltered = false;\n        } else if (looseEqual(localFilter, []) || looseEqual(localFilter, {})) {\n          // If filter criteria is an empty array or object\n          isFiltered = false;\n        } else if (localFilter) {\n          // If filter criteria is truthy\n          isFiltered = true;\n        }\n\n        if (isFiltered) {\n          this.$emit('filtered', filteredItems, filteredItems.length);\n        }\n\n        this.isFiltered = isFiltered;\n      },\n      isFiltered: function isFiltered(newVal, oldVal) {\n        if (newVal === false && oldVal === true) {\n          // We need to emit a filtered event if isFiltered transitions from true to\n          // false so that users can update their pagination controls.\n          this.$emit('filtered', this.localItems, this.localItems.length);\n        }\n      }\n    },\n    created: function created() {\n      var _this2 = this;\n\n      // Create non-reactive prop where we store the debounce timer id\n      this.$_filterTimer = null; // If filter is \"pre-set\", set the criteria\n      // This will trigger any watchers/dependents\n      // this.localFilter = this.filterSanitize(this.filter)\n      // Set the initial filtered state in a `$nextTick()` so that\n      // we trigger a filtered event if needed\n\n      this.$nextTick(function () {\n        _this2.isFiltered = Boolean(_this2.localFilter);\n      });\n    },\n    beforeDestroy: function beforeDestroy()\n    /* istanbul ignore next */\n    {\n      clearTimeout(this.$_filterTimer);\n      this.$_filterTimer = null;\n    },\n    methods: {\n      filterSanitize: function filterSanitize(criteria) {\n        // Sanitizes filter criteria based on internal or external filtering\n        if (this.localFiltering && !this.localFilterFn && !(isString(criteria) || isRegExp(criteria))) {\n          // If using internal filter function, which only accepts string or RegExp,\n          // return '' to signify no filter\n          return '';\n        } // Could be a string, object or array, as needed by external filter function\n        // We use `cloneDeep` to ensure we have a new copy of an object or array\n        // without Vue's reactive observers\n\n\n        return cloneDeep(criteria);\n      },\n      // Filter Function factories\n      filterFnFactory: function filterFnFactory(filterFn, criteria) {\n        // Wrapper factory for external filter functions\n        // Wrap the provided filter-function and return a new function\n        // Returns `null` if no filter-function defined or if criteria is falsey\n        // Rather than directly grabbing `this.computedLocalFilterFn` or `this.filterFunction`\n        // we have it passed, so that the caller computed prop will be reactive to changes\n        // in the original filter-function (as this routine is a method)\n        if (!filterFn || !isFunction(filterFn) || !criteria || looseEqual(criteria, []) || looseEqual(criteria, {})) {\n          return null;\n        } // Build the wrapped filter test function, passing the criteria to the provided function\n\n\n        var fn = function fn(item) {\n          // Generated function returns true if the criteria matches part\n          // of the serialized data, otherwise false\n          return filterFn(item, criteria);\n        }; // Return the wrapped function\n\n\n        return fn;\n      },\n      defaultFilterFnFactory: function defaultFilterFnFactory(criteria) {\n        var _this3 = this;\n\n        // Generates the default filter function, using the given filter criteria\n        // Returns `null` if no criteria or criteria format not supported\n        if (!criteria || !(isString(criteria) || isRegExp(criteria))) {\n          // Built in filter can only support strings or RegExp criteria (at the moment)\n          return null;\n        } // Build the RegExp needed for filtering\n\n\n        var regExp = criteria;\n\n        if (isString(regExp)) {\n          // Escape special RegExp characters in the string and convert contiguous\n          // whitespace to \\s+ matches\n          var pattern = escapeRegExp(criteria).replace(RX_SPACES$1, '\\\\s+'); // Build the RegExp (no need for global flag, as we only need\n          // to find the value once in the string)\n\n          regExp = new RegExp(\".*\".concat(pattern, \".*\"), 'i');\n        } // Generate the wrapped filter test function to use\n\n\n        var fn = function fn(item) {\n          // This searches all row values (and sub property values) in the entire (excluding\n          // special `_` prefixed keys), because we convert the record to a space-separated\n          // string containing all the value properties (recursively), even ones that are\n          // not visible (not specified in this.fields)\n          // Users can ignore filtering on specific fields, or on only certain fields,\n          // and can optionall specify searching results of fields with formatter\n          //\n          // TODO: Enable searching on scoped slots (optional, as it will be SLOW)\n          //\n          // Generated function returns true if the criteria matches part of\n          // the serialized data, otherwise false\n          //\n          // We set `lastIndex = 0` on the `RegExp` in case someone specifies the `/g` global flag\n          regExp.lastIndex = 0;\n          return regExp.test(stringifyRecordValues(item, _this3.computedFilterIgnored, _this3.computedFilterIncluded, _this3.computedFieldsObj));\n        }; // Return the generated function\n\n\n        return fn;\n      }\n    }\n  };\n\n  /*\n   * Consistent and stable sort function across JavaScript platforms\n   *\n   * Inconsistent sorts can cause SSR problems between client and server\n   * such as in <b-table> if sortBy is applied to the data on server side render.\n   * Chrome and V8 native sorts are inconsistent/unstable\n   *\n   * This function uses native sort with fallback to index compare when the a and b\n   * compare returns 0\n   *\n   * Algorithm based on:\n   * https://stackoverflow.com/questions/1427608/fast-stable-sorting-algorithm-implementation-in-javascript/45422645#45422645\n   *\n   * @param {array} array to sort\n   * @param {function} sort compare function\n   * @return {array}\n   */\n  var stableSort = function stableSort(array, compareFn) {\n    // Using `.bind(compareFn)` on the wrapped anonymous function improves\n    // performance by avoiding the function call setup. We don't use an arrow\n    // function here as it binds `this` to the `stableSort` context rather than\n    // the `compareFn` context, which wouldn't give us the performance increase.\n    return array.map(function (a, index) {\n      return [index, a];\n    }).sort(function (a, b) {\n      return this(a[1], b[1]) || a[0] - b[0];\n    }.bind(compareFn)).map(function (e) {\n      return e[1];\n    });\n  };\n\n  //\n  // TODO: Add option to sort by multiple columns (tri-state per column,\n  //       plus order of columns in sort)  where sortBy could be an array\n  //       of objects `[ {key: 'foo', sortDir: 'asc'}, {key:'bar', sortDir: 'desc'} ...]`\n  //       or an array of arrays `[ ['foo','asc'], ['bar','desc'] ]`\n  //       Multisort will most likely be handled in mixin-sort.js by\n  //       calling this method for each sortBy\n\n  var defaultSortCompare = function defaultSortCompare(a, b, sortBy, sortDesc, formatter, localeOpts, locale, nullLast) {\n    var aa = get(a, sortBy, null);\n    var bb = get(b, sortBy, null);\n\n    if (isFunction(formatter)) {\n      aa = formatter(aa, sortBy, a);\n      bb = formatter(bb, sortBy, b);\n    }\n\n    aa = isUndefinedOrNull(aa) ? '' : aa;\n    bb = isUndefinedOrNull(bb) ? '' : bb;\n\n    if (isDate(aa) && isDate(bb) || isNumber(aa) && isNumber(bb)) {\n      // Special case for comparing dates and numbers\n      // Internally dates are compared via their epoch number values\n      return aa < bb ? -1 : aa > bb ? 1 : 0;\n    } else if (nullLast && aa === '' && bb !== '') {\n      // Special case when sorting null/undefined/empty string last\n      return 1;\n    } else if (nullLast && aa !== '' && bb === '') {\n      // Special case when sorting null/undefined/empty string last\n      return -1;\n    } // Do localized string comparison\n\n\n    return stringifyObjectValues(aa).localeCompare(stringifyObjectValues(bb), locale, localeOpts);\n  };\n\n  var sortingMixin = {\n    props: {\n      sortBy: {\n        type: String,\n        default: ''\n      },\n      sortDesc: {\n        // TODO: Make this tri-state: true, false, null\n        type: Boolean,\n        default: false\n      },\n      sortDirection: {\n        // This prop is named incorrectly\n        // It should be `initialSortDirection` as it is a bit misleading\n        // (not to mention it screws up the ARIA label on the headers)\n        type: String,\n        default: 'asc',\n        validator: function validator(direction) {\n          return arrayIncludes(['asc', 'desc', 'last'], direction);\n        }\n      },\n      sortCompare: {\n        type: Function,\n        default: null\n      },\n      sortCompareOptions: {\n        // Supported localCompare options, see `options` section of:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\n        type: Object,\n        default: function _default() {\n          return {\n            numeric: true\n          };\n        }\n      },\n      sortCompareLocale: {\n        // String: locale code\n        // Array: array of Locale strings\n        type: [String, Array] // default: undefined\n\n      },\n      sortNullLast: {\n        // Sort null and undefined to appear last\n        type: Boolean,\n        default: false\n      },\n      noSortReset: {\n        // Another prop that should have had a better name.\n        // It should be noSortClear (on non-sortable headers).\n        // We will need to make sure the documentation is clear on what\n        // this prop does (as well as in the code for future reference)\n        type: Boolean,\n        default: false\n      },\n      labelSortAsc: {\n        type: String,\n        default: 'Click to sort Ascending'\n      },\n      labelSortDesc: {\n        type: String,\n        default: 'Click to sort Descending'\n      },\n      labelSortClear: {\n        type: String,\n        default: 'Click to clear sorting'\n      },\n      noLocalSorting: {\n        type: Boolean,\n        default: false\n      },\n      noFooterSorting: {\n        type: Boolean,\n        default: false\n      },\n      sortIconLeft: {\n        // Place the sorting icon on the left of the header cells\n        type: Boolean,\n        default: false\n      }\n    },\n    data: function data() {\n      return {\n        localSortBy: this.sortBy || '',\n        localSortDesc: this.sortDesc || false\n      };\n    },\n    computed: {\n      localSorting: function localSorting() {\n        return this.hasProvider ? !!this.noProviderSorting : !this.noLocalSorting;\n      },\n      isSortable: function isSortable() {\n        return this.computedFields.some(function (f) {\n          return f.sortable;\n        });\n      },\n      sortedItems: function sortedItems() {\n        // Sorts the filtered items and returns a new array of the sorted items\n        // or the original items array if not sorted.\n        var items = (this.filteredItems || this.localItems || []).slice();\n        var sortBy = this.localSortBy;\n        var sortDesc = this.localSortDesc;\n        var sortCompare = this.sortCompare;\n        var localSorting = this.localSorting;\n\n        var sortOptions = _objectSpread2({}, this.sortCompareOptions, {\n          usage: 'sort'\n        });\n\n        var sortLocale = this.sortCompareLocale || undefined;\n        var nullLast = this.sortNullLast;\n\n        if (sortBy && localSorting) {\n          var field = this.computedFieldsObj[sortBy] || {};\n          var sortByFormatted = field.sortByFormatted;\n          var formatter = isFunction(sortByFormatted) ? sortByFormatted : sortByFormatted ? this.getFieldFormatter(sortBy) : undefined; // `stableSort` returns a new array, and leaves the original array intact\n\n          return stableSort(items, function (a, b) {\n            var result = null;\n\n            if (isFunction(sortCompare)) {\n              // Call user provided sortCompare routine\n              result = sortCompare(a, b, sortBy, sortDesc, formatter, sortOptions, sortLocale);\n            }\n\n            if (isUndefinedOrNull(result) || result === false) {\n              // Fallback to built-in defaultSortCompare if sortCompare\n              // is not defined or returns null/false\n              result = defaultSortCompare(a, b, sortBy, sortDesc, formatter, sortOptions, sortLocale, nullLast);\n            } // Negate result if sorting in descending order\n\n\n            return (result || 0) * (sortDesc ? -1 : 1);\n          });\n        }\n\n        return items;\n      }\n    },\n    watch: {\n      isSortable: function isSortable(newVal)\n      /* istanbul ignore next: pain in the butt to test */\n      {\n        if (newVal) {\n          if (this.isSortable) {\n            this.$on('head-clicked', this.handleSort);\n          }\n        } else {\n          this.$off('head-clicked', this.handleSort);\n        }\n      },\n      sortDesc: function sortDesc(newVal) {\n        if (newVal === this.localSortDesc) {\n          /* istanbul ignore next */\n          return;\n        }\n\n        this.localSortDesc = newVal || false;\n      },\n      sortBy: function sortBy(newVal) {\n        if (newVal === this.localSortBy) {\n          /* istanbul ignore next */\n          return;\n        }\n\n        this.localSortBy = newVal || '';\n      },\n      // Update .sync props\n      localSortDesc: function localSortDesc(newVal, oldVal) {\n        // Emit update to sort-desc.sync\n        if (newVal !== oldVal) {\n          this.$emit('update:sortDesc', newVal);\n        }\n      },\n      localSortBy: function localSortBy(newVal, oldVal) {\n        if (newVal !== oldVal) {\n          this.$emit('update:sortBy', newVal);\n        }\n      }\n    },\n    created: function created() {\n      if (this.isSortable) {\n        this.$on('head-clicked', this.handleSort);\n      }\n    },\n    methods: {\n      // Handlers\n      // Need to move from thead-mixin\n      handleSort: function handleSort(key, field, evt, isFoot) {\n        var _this = this;\n\n        if (!this.isSortable) {\n          /* istanbul ignore next */\n          return;\n        }\n\n        if (isFoot && this.noFooterSorting) {\n          return;\n        } // TODO: make this tri-state sorting\n        // cycle desc => asc => none => desc => ...\n\n\n        var sortChanged = false;\n\n        var toggleLocalSortDesc = function toggleLocalSortDesc() {\n          var sortDirection = field.sortDirection || _this.sortDirection;\n\n          if (sortDirection === 'asc') {\n            _this.localSortDesc = false;\n          } else if (sortDirection === 'desc') {\n            _this.localSortDesc = true;\n          }\n        };\n\n        if (field.sortable) {\n          if (key === this.localSortBy) {\n            // Change sorting direction on current column\n            this.localSortDesc = !this.localSortDesc;\n          } else {\n            // Start sorting this column ascending\n            this.localSortBy = key; // this.localSortDesc = false\n\n            toggleLocalSortDesc();\n          }\n\n          sortChanged = true;\n        } else if (this.localSortBy && !this.noSortReset) {\n          this.localSortBy = '';\n          toggleLocalSortDesc();\n          sortChanged = true;\n        }\n\n        if (sortChanged) {\n          // Sorting parameters changed\n          this.$emit('sort-changed', this.context);\n        }\n      },\n      // methods to compute classes and attrs for thead>th cells\n      sortTheadThClasses: function sortTheadThClasses(key, field, isFoot) {\n        return {\n          // If sortable and sortIconLeft are true, then place sort icon on the left\n          'b-table-sort-icon-left': field.sortable && this.sortIconLeft && !(isFoot && this.noFooterSorting)\n        };\n      },\n      sortTheadThAttrs: function sortTheadThAttrs(key, field, isFoot) {\n        if (!this.isSortable || isFoot && this.noFooterSorting) {\n          // No attributes if not a sortable table\n          return {};\n        }\n\n        var sortable = field.sortable; // Assemble the aria-sort attribute value\n\n        var ariaSort = sortable && this.localSortBy === key ? this.localSortDesc ? 'descending' : 'ascending' : sortable ? 'none' : null; // Return the attribute\n\n        return {\n          'aria-sort': ariaSort\n        };\n      },\n      sortTheadThLabel: function sortTheadThLabel(key, field, isFoot) {\n        // A label to be placed in an `.sr-only` element in the header cell\n        if (!this.isSortable || isFoot && this.noFooterSorting) {\n          // No label if not a sortable table\n          return null;\n        }\n\n        var sortable = field.sortable; // The correctness of these labels is very important for screen-reader users.\n\n        var labelSorting = '';\n\n        if (sortable) {\n          if (this.localSortBy === key) {\n            // currently sorted sortable column.\n            labelSorting = this.localSortDesc ? this.labelSortAsc : this.labelSortDesc;\n          } else {\n            // Not currently sorted sortable column.\n            // Not using nested ternary's here for clarity/readability\n            // Default for ariaLabel\n            labelSorting = this.localSortDesc ? this.labelSortDesc : this.labelSortAsc; // Handle sortDirection setting\n\n            var sortDirection = this.sortDirection || field.sortDirection;\n\n            if (sortDirection === 'asc') {\n              labelSorting = this.labelSortAsc;\n            } else if (sortDirection === 'desc') {\n              labelSorting = this.labelSortDesc;\n            }\n          }\n        } else if (!this.noSortReset) {\n          // Non sortable column\n          labelSorting = this.localSortBy ? this.labelSortClear : '';\n        } // Return the sr-only sort label or null if no label\n\n\n        return trim(labelSorting) || null;\n      }\n    }\n  };\n\n  var paginationMixin$1 = {\n    props: {\n      perPage: {\n        type: [Number, String],\n        default: 0\n      },\n      currentPage: {\n        type: [Number, String],\n        default: 1\n      }\n    },\n    computed: {\n      localPaging: function localPaging() {\n        return this.hasProvider ? !!this.noProviderPaging : true;\n      },\n      paginatedItems: function paginatedItems() {\n        var items = this.sortedItems || this.filteredItems || this.localItems || [];\n        var currentPage = Math.max(parseInt(this.currentPage, 10) || 1, 1);\n        var perPage = Math.max(parseInt(this.perPage, 10) || 0, 0); // Apply local pagination\n\n        if (this.localPaging && !!perPage) {\n          // Grab the current page of data (which may be past filtered items limit)\n          items = items.slice((currentPage - 1) * perPage, currentPage * perPage);\n        } // Return the items to display in the table\n\n\n        return items;\n      }\n    }\n  };\n\n  var captionMixin = {\n    props: {\n      // `caption-top` is part of table-redere mixin (styling)\n      // captionTop: {\n      //   type: Boolean,\n      //   default: false\n      // },\n      caption: {\n        type: String,\n        default: null\n      },\n      captionHtml: {\n        type: String\n      }\n    },\n    computed: {\n      captionId: function captionId() {\n        // Even though `this.safeId` looks like a method, it is a computed prop\n        // that returns a new function if the underlying ID changes\n        return this.isStacked ? this.safeId('_caption_') : null;\n      }\n    },\n    methods: {\n      renderCaption: function renderCaption() {\n        var h = this.$createElement; // Build the caption\n\n        var $captionSlot = this.normalizeSlot('table-caption');\n        var $caption = h();\n\n        if ($captionSlot || this.caption || this.captionHtml) {\n          var data = {\n            key: 'caption',\n            attrs: {\n              id: this.captionId\n            }\n          };\n\n          if (!$captionSlot) {\n            data.domProps = htmlOrText(this.captionHtml, this.caption);\n          }\n\n          $caption = h('caption', data, [$captionSlot]);\n        }\n\n        return $caption;\n      }\n    }\n  };\n\n  var colgroupMixin = {\n    methods: {\n      renderColgroup: function renderColgroup() {\n        var h = this.$createElement;\n        var fields = this.computedFields;\n        var $colgroup = h();\n\n        if (this.hasNormalizedSlot('table-colgroup')) {\n          $colgroup = h('colgroup', {\n            key: 'colgroup'\n          }, [this.normalizeSlot('table-colgroup', {\n            columns: fields.length,\n            fields: fields\n          })]);\n        }\n\n        return $colgroup;\n      }\n    }\n  };\n\n  var TABLE_TAG_NAMES = ['TD', 'TH', 'TR']; // Returns `true` if we should ignore the click/double-click/keypress event\n  // Avoids having the user need to use `@click.stop` on the form control\n\n  var filterEvent = function filterEvent(evt) {\n    // Exit early when we don't have a target element\n    if (!evt || !evt.target) {\n      /* istanbul ignore next */\n      return false;\n    }\n\n    var el = evt.target; // Exit early when element is disabled or a table element\n\n    if (el.disabled || TABLE_TAG_NAMES.indexOf(el.tagName) !== -1) {\n      return false;\n    } // Ignore the click when it was inside a dropdown menu\n\n\n    if (closest('.dropdown-menu', el)) {\n      return true;\n    }\n\n    var label = el.tagName === 'LABEL' ? el : closest('label', el); // If the label's form control is not disabled then we don't propagate event\n    // Modern browsers have `label.control` that references the associated input, but IE 11\n    // does not have this property on the label element, so we resort to DOM lookups\n\n    if (label) {\n      var labelFor = getAttr(label, 'for');\n      var input = labelFor ? getById(labelFor) : select('input, select, textarea', label);\n\n      if (input && !input.disabled) {\n        return true;\n      }\n    } // Otherwise check if the event target matches one of the selectors in the\n    // event filter (i.e. anchors, non disabled inputs, etc.)\n    // Return `true` if we should ignore the event\n\n\n    return matches(el, EVENT_FILTER);\n  };\n\n  // Used to filter out click events caused by the mouse up at end of selection\n  //\n  // Accepts an element as only argument to test to see if selection overlaps or is\n  // contained within the element\n\n  var textSelectionActive = function textSelectionActive() {\n    var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;\n    var sel = getSel();\n    return sel && sel.toString().trim() !== '' && sel.containsNode && isElement(el) ? sel.containsNode(el, true) : false;\n  };\n\n  var props$T = {\n    headVariant: {\n      // Also sniffed by <b-tr> / <b-td> / <b-th>\n      type: String,\n      // supported values: 'lite', 'dark', or null\n      default: null\n    }\n  }; // @vue/component\n\n  var BThead =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BThead',\n    mixins: [normalizeSlotMixin],\n    inheritAttrs: false,\n    provide: function provide() {\n      return {\n        bvTableRowGroup: this\n      };\n    },\n    inject: {\n      bvTable: {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        default: function _default()\n        /* istanbul ignore next */\n        {\n          return {};\n        }\n      }\n    },\n    props: props$T,\n    computed: {\n      isThead: function isThead() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        return true;\n      },\n      isDark: function isDark() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        return this.bvTable.dark;\n      },\n      isStacked: function isStacked() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        return this.bvTable.isStacked;\n      },\n      isResponsive: function isResponsive() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        return this.bvTable.isResponsive;\n      },\n      isStickyHeader: function isStickyHeader() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        // Needed to handle header background classes, due to lack of\n        // background color inheritance with Bootstrap v4 table CSS\n        // Sticky headers only apply to cells in table `thead`\n        return !this.isStacked && this.bvTable.stickyHeader;\n      },\n      hasStickyHeader: function hasStickyHeader() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        // Needed to handle header background classes, due to lack of\n        // background color inheritance with Bootstrap v4 table CSS\n        return !this.isStacked && this.bvTable.stickyHeader;\n      },\n      tableVariant: function tableVariant() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        return this.bvTable.tableVariant;\n      },\n      theadClasses: function theadClasses() {\n        return [this.headVariant ? \"thead-\".concat(this.headVariant) : null];\n      },\n      theadAttrs: function theadAttrs() {\n        return _objectSpread2({\n          role: 'rowgroup'\n        }, this.$attrs);\n      }\n    },\n    render: function render(h) {\n      return h('thead', {\n        class: this.theadClasses,\n        attrs: this.theadAttrs,\n        // Pass down any native listeners\n        on: this.$listeners\n      }, this.normalizeSlot('default'));\n    }\n  });\n\n  var props$U = {\n    footVariant: {\n      type: String,\n      // supported values: 'lite', 'dark', or null\n      default: null\n    }\n  }; // @vue/component\n\n  var BTfoot =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BTfoot',\n    mixins: [normalizeSlotMixin],\n    inheritAttrs: false,\n    provide: function provide() {\n      return {\n        bvTableRowGroup: this\n      };\n    },\n    inject: {\n      bvTable: {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        default: function _default()\n        /* istanbul ignore next */\n        {\n          return {};\n        }\n      }\n    },\n    props: props$U,\n    computed: {\n      isTfoot: function isTfoot() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        return true;\n      },\n      isDark: function isDark()\n      /* istanbul ignore next: Not currently sniffed in tests */\n      {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        return this.bvTable.dark;\n      },\n      isStacked: function isStacked() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        return this.bvTable.isStacked;\n      },\n      isResponsive: function isResponsive() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        return this.bvTable.isResponsive;\n      },\n      isStickyHeader: function isStickyHeader() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        // Sticky headers are only supported in thead\n        return false;\n      },\n      hasStickyHeader: function hasStickyHeader() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        // Needed to handle header background classes, due to lack of\n        // background color inheritance with Bootstrap v4 table CSS\n        return !this.isStacked && this.bvTable.stickyHeader;\n      },\n      tableVariant: function tableVariant()\n      /* istanbul ignore next: Not currently sniffed in tests */\n      {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        return this.bvTable.tableVariant;\n      },\n      tfootClasses: function tfootClasses() {\n        return [this.footVariant ? \"thead-\".concat(this.footVariant) : null];\n      },\n      tfootAttrs: function tfootAttrs() {\n        return _objectSpread2({\n          role: 'rowgroup'\n        }, this.$attrs);\n      }\n    },\n    render: function render(h) {\n      return h('tfoot', {\n        class: this.tfootClasses,\n        attrs: this.tfootAttrs,\n        // Pass down any native listeners\n        on: this.$listeners\n      }, this.normalizeSlot('default'));\n    }\n  });\n\n  var props$V = {\n    variant: {\n      type: String,\n      default: null\n    }\n  };\n  var LIGHT = 'light';\n  var DARK = 'dark'; // @vue/component\n\n  var BTr =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BTr',\n    mixins: [normalizeSlotMixin],\n    inheritAttrs: false,\n    provide: function provide() {\n      return {\n        bvTableTr: this\n      };\n    },\n    inject: {\n      bvTableRowGroup: {\n        default: function _default()\n        /* istanbul ignore next */\n        {\n          return {};\n        }\n      }\n    },\n    props: props$V,\n    computed: {\n      inTbody: function inTbody() {\n        // Sniffed by <b-td> / <b-th>\n        return this.bvTableRowGroup.isTbody;\n      },\n      inThead: function inThead() {\n        // Sniffed by <b-td> / <b-th>\n        return this.bvTableRowGroup.isThead;\n      },\n      inTfoot: function inTfoot() {\n        // Sniffed by <b-td> / <b-th>\n        return this.bvTableRowGroup.isTfoot;\n      },\n      isDark: function isDark() {\n        // Sniffed by <b-td> / <b-th>\n        return this.bvTableRowGroup.isDark;\n      },\n      isStacked: function isStacked() {\n        // Sniffed by <b-td> / <b-th>\n        return this.bvTableRowGroup.isStacked;\n      },\n      isResponsive: function isResponsive() {\n        // Sniffed by <b-td> / <b-th>\n        return this.bvTableRowGroup.isResponsive;\n      },\n      isStickyHeader: function isStickyHeader() {\n        // Sniffed by <b-td> / <b-th>\n        // Sticky headers are only supported in thead\n        return this.bvTableRowGroup.isStickyHeader;\n      },\n      hasStickyHeader: function hasStickyHeader() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        // Needed to handle header background classes, due to lack of\n        // background color inheritance with Bootstrap v4 table CSS\n        return !this.isStacked && this.bvTableRowGroup.hasStickyHeader;\n      },\n      tableVariant: function tableVariant() {\n        // Sniffed by <b-td> / <b-th>\n        return this.bvTableRowGroup.tableVariant;\n      },\n      headVariant: function headVariant() {\n        // Sniffed by <b-td> / <b-th>\n        return this.inThead ? this.bvTableRowGroup.headVariant : null;\n      },\n      footVariant: function footVariant() {\n        // Sniffed by <b-td> / <b-th>\n        return this.inTfoot ? this.bvTableRowGroup.footVariant : null;\n      },\n      isRowDark: function isRowDark() {\n        return this.headVariant === LIGHT || this.footVariant === LIGHT ? false : this.headVariant === DARK || this.footVariant === DARK ? true : this.isDark;\n      },\n      trClasses: function trClasses() {\n        return [this.variant ? \"\".concat(this.isRowDark ? 'bg' : 'table', \"-\").concat(this.variant) : null];\n      },\n      trAttrs: function trAttrs() {\n        return _objectSpread2({\n          role: 'row'\n        }, this.$attrs);\n      }\n    },\n    render: function render(h) {\n      return h('tr', {\n        class: this.trClasses,\n        attrs: this.trAttrs,\n        // Pass native listeners to child\n        on: this.$listeners\n      }, this.normalizeSlot('default'));\n    }\n  });\n\n  var digitsRx = /^\\d+$/; // Parse a rowspan or colspan into a digit (or null if < 1 or NaN)\n\n  var parseSpan = function parseSpan(val) {\n    val = parseInt(val, 10);\n    return digitsRx.test(String(val)) && val > 0 ? val : null;\n  };\n  /* istanbul ignore next */\n\n\n  var spanValidator = function spanValidator(val) {\n    return isUndefinedOrNull(val) || parseSpan(val) > 0;\n  };\n\n  var props$W = {\n    variant: {\n      type: String,\n      default: null\n    },\n    colspan: {\n      type: [Number, String],\n      default: null,\n      validator: spanValidator\n    },\n    rowspan: {\n      type: [Number, String],\n      default: null,\n      validator: spanValidator\n    },\n    stackedHeading: {\n      type: String,\n      default: null\n    },\n    stickyColumn: {\n      type: Boolean,\n      default: false\n    }\n  }; // @vue/component\n\n  var BTd =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BTableCell',\n    mixins: [normalizeSlotMixin],\n    inheritAttrs: false,\n    inject: {\n      bvTableTr: {\n        default: function _default()\n        /* istanbul ignore next */\n        {\n          return {};\n        }\n      }\n    },\n    props: props$W,\n    computed: {\n      tag: function tag() {\n        // Overridden by <b-th>\n        return 'td';\n      },\n      inTbody: function inTbody() {\n        return this.bvTableTr.inTbody;\n      },\n      inThead: function inThead() {\n        return this.bvTableTr.inThead;\n      },\n      inTfoot: function inTfoot() {\n        return this.bvTableTr.inTfoot;\n      },\n      isDark: function isDark() {\n        return this.bvTableTr.isDark;\n      },\n      isStacked: function isStacked() {\n        return this.bvTableTr.isStacked;\n      },\n      isStackedCell: function isStackedCell() {\n        // We only support stacked-heading in tbody in stacked mode\n        return this.inTbody && this.isStacked;\n      },\n      isResponsive: function isResponsive() {\n        return this.bvTableTr.isResponsive;\n      },\n      isStickyHeader: function isStickyHeader() {\n        // Needed to handle header background classes, due to lack of\n        // background color inheritance with Bootstrap v4 table CSS\n        // Sticky headers only apply to cells in table `thead`\n        return this.bvTableTr.isStickyHeader;\n      },\n      hasStickyHeader: function hasStickyHeader() {\n        // Needed to handle header background classes, due to lack of\n        // background color inheritance with Bootstrap v4 table CSS\n        return this.bvTableTr.hasStickyHeader;\n      },\n      isStickyColumn: function isStickyColumn() {\n        // Needed to handle background classes, due to lack of\n        // background color inheritance with Bootstrap v4 table CSS\n        // Sticky column cells are only available in responsive\n        // mode (horizontal scrolling) or when sticky header mode\n        // Applies to cells in `thead`, `tbody` and `tfoot`\n        return !this.isStacked && (this.isResponsive || this.hasStickyHeader) && this.stickyColumn;\n      },\n      rowVariant: function rowVariant() {\n        return this.bvTableTr.variant;\n      },\n      headVariant: function headVariant() {\n        return this.bvTableTr.headVariant;\n      },\n      footVariant: function footVariant()\n      /* istanbul ignore next: need to add in tests for footer variant */\n      {\n        return this.bvTableTr.footVariant;\n      },\n      tableVariant: function tableVariant() {\n        return this.bvTableTr.tableVariant;\n      },\n      computedColspan: function computedColspan() {\n        return parseSpan(this.colspan);\n      },\n      computedRowspan: function computedRowspan() {\n        return parseSpan(this.rowspan);\n      },\n      cellClasses: function cellClasses() {\n        // We use computed props here for improved performance by caching\n        // the results of the string interpolation\n        // TODO: need to add handling for footVariant\n        var variant = this.variant;\n\n        if (!variant && this.isStickyHeader && !this.headVariant || !variant && this.isStickyColumn) {\n          // Needed for sticky-header mode as Bootstrap v4 table cells do\n          // not inherit parent's background-color. Boo!\n          variant = this.rowVariant || this.tableVariant || 'b-table-default';\n        }\n\n        return [variant ? \"\".concat(this.isDark ? 'bg' : 'table', \"-\").concat(variant) : null, this.isStickyColumn ? 'b-table-sticky-column' : null];\n      },\n      cellAttrs: function cellAttrs() {\n        // We use computed props here for improved performance by caching\n        // the results of the object spread (Object.assign)\n        var headOrFoot = this.inThead || this.inTfoot; // Make sure col/rowspan's are > 0 or null\n\n        var colspan = this.computedColspan;\n        var rowspan = this.computedRowspan; // Default role and scope\n\n        var role = 'cell';\n        var scope = null; // Compute role and scope\n        // We only add scopes with an explicit span of 1 or greater\n\n        if (headOrFoot) {\n          // Header or footer cells\n          role = 'columnheader';\n          scope = colspan > 0 ? 'colspan' : 'col';\n        } else if (this.tag === 'th') {\n          // th's in tbody\n          role = 'rowheader';\n          scope = rowspan > 0 ? 'rowgroup' : 'row';\n        }\n\n        return _objectSpread2({\n          colspan: colspan,\n          rowspan: rowspan,\n          role: role,\n          scope: scope\n        }, this.$attrs, {\n          // Add in the stacked cell label data-attribute if in\n          // stacked mode (if a stacked heading label is provided)\n          'data-label': this.isStackedCell && !isUndefinedOrNull(this.stackedHeading) ? toString$1(this.stackedHeading) : null\n        });\n      }\n    },\n    render: function render(h) {\n      var content = [this.normalizeSlot('default')];\n      return h(this.tag, {\n        class: this.cellClasses,\n        attrs: this.cellAttrs,\n        // Transfer any native listeners\n        on: this.$listeners\n      }, [this.isStackedCell ? h('div', [content]) : content]);\n    }\n  });\n\n  var BTh =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BTh',\n    extends: BTd,\n    computed: {\n      tag: function tag() {\n        return 'th';\n      }\n    }\n  });\n\n  var theadMixin = {\n    props: {\n      headVariant: {\n        type: String,\n        // 'light', 'dark' or `null` (or custom)\n        default: function _default() {\n          return getComponentConfig('BTable', 'headVariant');\n        }\n      },\n      headRowVariant: {\n        type: String,\n        // Any Bootstrap theme variant (or custom)\n        default: null\n      },\n      theadClass: {\n        type: [String, Array, Object] // default: undefined\n\n      },\n      theadTrClass: {\n        type: [String, Array, Object] // default: undefined\n\n      }\n    },\n    methods: {\n      fieldClasses: function fieldClasses(field) {\n        // Header field (<th>) classes\n        return [field.class ? field.class : '', field.thClass ? field.thClass : ''];\n      },\n      headClicked: function headClicked(evt, field, isFoot) {\n        if (this.stopIfBusy && this.stopIfBusy(evt)) {\n          // If table is busy (via provider) then don't propagate\n          return;\n        } else if (filterEvent(evt)) {\n          // Clicked on a non-disabled control so ignore\n          return;\n        } else if (textSelectionActive(this.$el)) {\n          // User is selecting text, so ignore\n\n          /* istanbul ignore next: JSDOM doesn't support getSelection() */\n          return;\n        }\n\n        evt.stopPropagation();\n        evt.preventDefault();\n        this.$emit('head-clicked', field.key, field, evt, isFoot);\n      },\n      renderThead: function renderThead() {\n        var _this = this;\n\n        var isFoot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var h = this.$createElement;\n        var fields = this.computedFields || [];\n\n        if (this.isStackedAlways || fields.length === 0) {\n          // In always stacked mode, we don't bother rendering the head/foot\n          // Or if no field headings (empty table)\n          return h();\n        } // Reference to `selectAllRows` and `clearSelected()`, if table is selectable\n\n\n        var selectAllRows = this.isSelectable ? this.selectAllRows : function () {};\n        var clearSelected = this.isSelectable ? this.clearSelected : function () {}; // Helper function to generate a field <th> cell\n\n        var makeCell = function makeCell(field, colIndex) {\n          var ariaLabel = null;\n\n          if (!field.label.trim() && !field.headerTitle) {\n            // In case field's label and title are empty/blank\n            // We need to add a hint about what the column is about for non-sighted users\n\n            /* istanbul ignore next */\n            ariaLabel = startCase(field.key);\n          }\n\n          var hasHeadClickListener = _this.hasListener('head-clicked') || _this.isSortable;\n\n          var handlers = {};\n\n          if (hasHeadClickListener) {\n            handlers.click = function (evt) {\n              _this.headClicked(evt, field, isFoot);\n            };\n\n            handlers.keydown = function (evt) {\n              var keyCode = evt.keyCode;\n\n              if (keyCode === KEY_CODES.ENTER || keyCode === KEY_CODES.SPACE) {\n                _this.headClicked(evt, field, isFoot);\n              }\n            };\n          }\n\n          var sortAttrs = _this.isSortable ? _this.sortTheadThAttrs(field.key, field, isFoot) : {};\n          var sortClass = _this.isSortable ? _this.sortTheadThClasses(field.key, field, isFoot) : null;\n          var sortLabel = _this.isSortable ? _this.sortTheadThLabel(field.key, field, isFoot) : null;\n          var data = {\n            key: field.key,\n            class: [_this.fieldClasses(field), sortClass],\n            props: {\n              variant: field.variant,\n              stickyColumn: field.stickyColumn\n            },\n            style: field.thStyle || {},\n            attrs: _objectSpread2({\n              // We only add a tabindex of 0 if there is a head-clicked listener\n              tabindex: hasHeadClickListener ? '0' : null,\n              abbr: field.headerAbbr || null,\n              title: field.headerTitle || null,\n              'aria-colindex': colIndex + 1,\n              'aria-label': ariaLabel\n            }, _this.getThValues(null, field.key, field.thAttr, isFoot ? 'foot' : 'head', {}), {}, sortAttrs),\n            on: handlers\n          }; // Handle edge case where in-document templates are used with new\n          // `v-slot:name` syntax where the browser lower-cases the v-slot's\n          // name (attributes become lower cased when parsed by the browser)\n          // We have replaced the square bracket syntax with round brackets\n          // to prevent confusion with dynamic slot names\n\n          var slotNames = [\"head(\".concat(field.key, \")\"), \"head(\".concat(field.key.toLowerCase(), \")\"), 'head()'];\n\n          if (isFoot) {\n            // Footer will fallback to header slot names\n            slotNames = [\"foot(\".concat(field.key, \")\"), \"foot(\".concat(field.key.toLowerCase(), \")\"), 'foot()'].concat(_toConsumableArray(slotNames));\n          }\n\n          var scope = {\n            label: field.label,\n            column: field.key,\n            field: field,\n            isFoot: isFoot,\n            // Add in row select methods\n            selectAllRows: selectAllRows,\n            clearSelected: clearSelected\n          };\n          var content = _this.normalizeSlot(slotNames, scope) || (field.labelHtml ? h('div', {\n            domProps: htmlOrText(field.labelHtml)\n          }) : field.label);\n          var srLabel = sortLabel ? h('span', {\n            staticClass: 'sr-only'\n          }, \" (\".concat(sortLabel, \")\")) : null; // Return the header cell\n\n          return h(BTh, data, [content, srLabel].filter(identity));\n        }; // Generate the array of <th> cells\n\n\n        var $cells = fields.map(makeCell).filter(identity); // Genrate the row(s)\n\n        var $trs = [];\n\n        if (isFoot) {\n          var trProps = {\n            variant: isUndefinedOrNull(this.footRowVariant) ? this.headRowVariant : this.footRowVariant\n          };\n          $trs.push(h(BTr, {\n            class: this.tfootTrClass,\n            props: trProps\n          }, $cells));\n        } else {\n          var scope = {\n            columns: fields.length,\n            fields: fields,\n            // Add in row select methods\n            selectAllRows: selectAllRows,\n            clearSelected: clearSelected\n          };\n          $trs.push(this.normalizeSlot('thead-top', scope) || h());\n          $trs.push(h(BTr, {\n            class: this.theadTrClass,\n            props: {\n              variant: this.headRowVariant\n            }\n          }, $cells));\n        }\n\n        return h(isFoot ? BTfoot : BThead, {\n          key: isFoot ? 'bv-tfoot' : 'bv-thead',\n          class: (isFoot ? this.tfootClass : this.theadClass) || null,\n          props: isFoot ? {\n            footVariant: this.footVariant || this.headVariant || null\n          } : {\n            headVariant: this.headVariant || null\n          }\n        }, $trs);\n      }\n    }\n  };\n\n  var tfootMixin = {\n    props: {\n      footClone: {\n        type: Boolean,\n        default: false\n      },\n      footVariant: {\n        type: String,\n        // 'dark', 'light', or `null` (or custom)\n        default: function _default() {\n          return getComponentConfig('BTable', 'footVariant');\n        }\n      },\n      footRowVariant: {\n        type: String,\n        // Any Bootstrap theme variant (or custom). Falls back to `headRowVariant`\n        default: null\n      },\n      tfootClass: {\n        type: [String, Array, Object],\n        default: null\n      },\n      tfootTrClass: {\n        type: [String, Array, Object],\n        default: null\n      }\n    },\n    methods: {\n      renderTFootCustom: function renderTFootCustom() {\n        var h = this.$createElement;\n\n        if (this.hasNormalizedSlot('custom-foot')) {\n          return h(BTfoot, {\n            key: 'bv-tfoot-custom',\n            class: this.tfootClass || null,\n            props: {\n              footVariant: this.footVariant || this.headVariant || null\n            }\n          }, this.normalizeSlot('custom-foot', {\n            items: this.computedItems.slice(),\n            fields: this.computedFields.slice(),\n            columns: this.computedFields.length\n          }));\n        } else {\n          return h();\n        }\n      },\n      renderTfoot: function renderTfoot() {\n        // Passing true to renderThead will make it render a tfoot\n        return this.footClone ? this.renderThead(true) : this.renderTFootCustom();\n      }\n    }\n  };\n\n  var props$X = {\n    tbodyTransitionProps: {\n      type: Object // default: undefined\n\n    },\n    tbodyTransitionHandlers: {\n      type: Object // default: undefined\n\n    }\n  }; // @vue/component\n\n  var BTbody =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BTbody',\n    mixins: [normalizeSlotMixin],\n    inheritAttrs: false,\n    provide: function provide() {\n      return {\n        bvTableRowGroup: this\n      };\n    },\n    inject: {\n      bvTable: {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        default: function _default()\n        /* istanbul ignore next */\n        {\n          return {};\n        }\n      }\n    },\n    props: props$X,\n    computed: {\n      isTbody: function isTbody() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        return true;\n      },\n      isDark: function isDark() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        return this.bvTable.dark;\n      },\n      isStacked: function isStacked() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        return this.bvTable.isStacked;\n      },\n      isResponsive: function isResponsive() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        return this.bvTable.isResponsive;\n      },\n      isStickyHeader: function isStickyHeader() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        // Sticky headers are only supported in thead\n        return false;\n      },\n      hasStickyHeader: function hasStickyHeader() {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        // Needed to handle header background classes, due to lack of\n        // background color inheritance with Bootstrap v4 table CSS\n        return !this.isStacked && this.bvTable.stickyHeader;\n      },\n      tableVariant: function tableVariant()\n      /* istanbul ignore next: Not currently sniffed in tests */\n      {\n        // Sniffed by <b-tr> / <b-td> / <b-th>\n        return this.bvTable.tableVariant;\n      },\n      isTransitionGroup: function isTransitionGroup() {\n        return this.tbodyTransitionProps || this.tbodyTransitionHandlers;\n      },\n      tbodyAttrs: function tbodyAttrs() {\n        return _objectSpread2({\n          role: 'rowgroup'\n        }, this.$attrs);\n      },\n      tbodyProps: function tbodyProps() {\n        return this.tbodyTransitionProps ? _objectSpread2({}, this.tbodyTransitionProps, {\n          tag: 'tbody'\n        }) : {};\n      }\n    },\n    render: function render(h) {\n      var data = {\n        props: this.tbodyProps,\n        attrs: this.tbodyAttrs\n      };\n\n      if (this.isTransitionGroup) {\n        // We use native listeners if a transition group\n        // for any delegated events\n        data.on = this.tbodyTransitionHandlers || {};\n        data.nativeOn = this.$listeners || {};\n      } else {\n        // Otherwise we place any listeners on the tbody element\n        data.on = this.$listeners || {};\n      }\n\n      return h(this.isTransitionGroup ? 'transition-group' : 'tbody', data, this.normalizeSlot('default'));\n    }\n  });\n\n  var detailsSlotName = 'row-details';\n  var tbodyRowMixin = {\n    props: {\n      tbodyTrClass: {\n        type: [String, Array, Object, Function],\n        default: null\n      },\n      tbodyTrAttr: {\n        type: [Object, Function],\n        default: null\n      },\n      detailsTdClass: {\n        type: [String, Array, Object],\n        default: null\n      }\n    },\n    methods: {\n      // Methods for computing classes, attributes and styles for table cells\n      getTdValues: function getTdValues(item, key, tdValue, defValue) {\n        var parent = this.$parent;\n\n        if (tdValue) {\n          var value = get(item, key, '');\n\n          if (isFunction(tdValue)) {\n            return tdValue(value, key, item);\n          } else if (isString(tdValue) && isFunction(parent[tdValue])) {\n            return parent[tdValue](value, key, item);\n          }\n\n          return tdValue;\n        }\n\n        return defValue;\n      },\n      getThValues: function getThValues(item, key, thValue, type, defValue) {\n        var parent = this.$parent;\n\n        if (thValue) {\n          var value = get(item, key, '');\n\n          if (isFunction(thValue)) {\n            return thValue(value, key, item, type);\n          } else if (isString(thValue) && isFunction(parent[thValue])) {\n            return parent[thValue](value, key, item, type);\n          }\n\n          return thValue;\n        }\n\n        return defValue;\n      },\n      // Method to get the value for a field\n      getFormattedValue: function getFormattedValue(item, field) {\n        var key = field.key;\n        var formatter = this.getFieldFormatter(key);\n        var value = get(item, key, null);\n\n        if (isFunction(formatter)) {\n          value = formatter(value, key, item);\n        }\n\n        return isUndefinedOrNull(value) ? '' : value;\n      },\n      // Factory function methods\n      toggleDetailsFactory: function toggleDetailsFactory(hasDetailsSlot, item) {\n        var _this = this;\n\n        // Returns a function to toggle a row's details slot\n        return function () {\n          if (hasDetailsSlot) {\n            _this.$set(item, '_showDetails', !item._showDetails);\n          }\n        };\n      },\n      // Row event handlers\n      rowHovered: function rowHovered(evt) {\n        // `mouseenter` handler (non-bubbling)\n        // `this.tbodyRowEvtStopped` from tbody mixin\n        if (!this.tbodyRowEvtStopped(evt)) {\n          // `this.emitTbodyRowEvent` from tbody mixin\n          this.emitTbodyRowEvent('row-hovered', evt);\n        }\n      },\n      rowUnhovered: function rowUnhovered(evt) {\n        // `mouseleave` handler (non-bubbling)\n        // `this.tbodyRowEvtStopped` from tbody mixin\n        if (!this.tbodyRowEvtStopped(evt)) {\n          // `this.emitTbodyRowEvent` from tbody mixin\n          this.emitTbodyRowEvent('row-unhovered', evt);\n        }\n      },\n      // Render helpers\n      renderTbodyRowCell: function renderTbodyRowCell(field, colIndex, item, rowIndex) {\n        var _this2 = this;\n\n        // Renders a TD or TH for a row's field\n        var h = this.$createElement;\n        var hasDetailsSlot = this.hasNormalizedSlot(detailsSlotName);\n        var formatted = this.getFormattedValue(item, field);\n        var key = field.key;\n        var stickyColumn = !this.isStacked && (this.isResponsive || this.stickyHeader) && field.stickyColumn; // We only uses the helper components for sticky columns to\n        // improve performance of BTable/BTableLite by reducing the\n        // total number of vue instances created during render\n\n        var cellTag = stickyColumn ? field.isRowHeader ? BTh : BTd : field.isRowHeader ? 'th' : 'td';\n        var cellVariant = item._cellVariants && item._cellVariants[key] ? item._cellVariants[key] : field.variant || null;\n        var data = {\n          // For the Vue key, we concatenate the column index and\n          // field key (as field keys could be duplicated)\n          // TODO: Although we do prevent duplicate field keys...\n          //   So we could change this to: `row-${rowIndex}-cell-${key}`\n          key: \"row-\".concat(rowIndex, \"-cell-\").concat(colIndex, \"-\").concat(key),\n          class: [field.class ? field.class : '', this.getTdValues(item, key, field.tdClass, '')],\n          props: {},\n          attrs: _objectSpread2({\n            'aria-colindex': String(colIndex + 1)\n          }, field.isRowHeader ? this.getThValues(item, key, field.thAttr, 'row', {}) : this.getTdValues(item, key, field.tdAttr, {}))\n        };\n\n        if (stickyColumn) {\n          // We are using the helper BTd or BTh\n          data.props = {\n            stackedHeading: this.isStacked ? field.label : null,\n            stickyColumn: true,\n            variant: cellVariant\n          };\n        } else {\n          // Using native TD or TH element, so we need to\n          // add in the attributes and variant class\n          data.attrs['data-label'] = this.isStacked && !isUndefinedOrNull(field.label) ? toString$1(field.label) : null;\n          data.attrs.role = field.isRowHeader ? 'rowheader' : 'cell';\n          data.attrs.scope = field.isRowHeader ? 'row' : null; // Add in the variant class\n\n          if (cellVariant) {\n            data.class.push(\"\".concat(this.dark ? 'bg' : 'table', \"-\").concat(cellVariant));\n          }\n        }\n\n        var slotScope = {\n          item: item,\n          index: rowIndex,\n          field: field,\n          unformatted: get(item, key, ''),\n          value: formatted,\n          toggleDetails: this.toggleDetailsFactory(hasDetailsSlot, item),\n          detailsShowing: Boolean(item._showDetails)\n        }; // If table supports selectable mode, then add in the following scope\n        // this.supportsSelectableRows will be undefined if mixin isn't loaded\n\n        if (this.supportsSelectableRows) {\n          slotScope.rowSelected = this.isRowSelected(rowIndex);\n\n          slotScope.selectRow = function () {\n            return _this2.selectRow(rowIndex);\n          };\n\n          slotScope.unselectRow = function () {\n            return _this2.unselectRow(rowIndex);\n          };\n        } // The new `v-slot` syntax doesn't like a slot name starting with\n        // a square bracket and if using in-document HTML templates, the\n        // v-slot attributes are lower-cased by the browser.\n        // Switched to round bracket syntax to prevent confusion with\n        // dynamic slot name syntax.\n        // We look for slots in this order: `cell(${key})`, `cell(${key.toLowerCase()})`, 'cell()'\n        // Slot names are now cached by mixin tbody in `this.$_bodyFieldSlotNameCache`\n        // Will be `null` if no slot (or fallback slot) exists\n\n\n        var slotName = this.$_bodyFieldSlotNameCache[key];\n        var $childNodes = slotName ? this.normalizeSlot(slotName, slotScope) : toString$1(formatted);\n\n        if (this.isStacked) {\n          // We wrap in a DIV to ensure rendered as a single cell when visually stacked!\n          $childNodes = [h('div', [$childNodes])];\n        } // Render either a td or th cell\n\n\n        return h(cellTag, data, [$childNodes]);\n      },\n      renderTbodyRow: function renderTbodyRow(item, rowIndex) {\n        var _this3 = this;\n\n        // Renders an item's row (or rows if details supported)\n        var h = this.$createElement;\n        var fields = this.computedFields;\n        var tableStriped = this.striped;\n        var hasDetailsSlot = this.hasNormalizedSlot(detailsSlotName);\n        var rowShowDetails = item._showDetails && hasDetailsSlot;\n        var hasRowClickHandler = this.$listeners['row-clicked'] || this.hasSelectableRowClick; // We can return more than one TR if rowDetails enabled\n\n        var $rows = []; // Details ID needed for `aria-details` when details showing\n        // We set it to `null` when not showing so that attribute\n        // does not appear on the element\n\n        var detailsId = rowShowDetails ? this.safeId(\"_details_\".concat(rowIndex, \"_\")) : null; // For each item data field in row\n\n        var $tds = fields.map(function (field, colIndex) {\n          return _this3.renderTbodyRowCell(field, colIndex, item, rowIndex);\n        }); // Calculate the row number in the dataset (indexed from 1)\n\n        var ariaRowIndex = null;\n\n        if (this.currentPage && this.perPage && this.perPage > 0) {\n          ariaRowIndex = String((this.currentPage - 1) * this.perPage + rowIndex + 1);\n        } // Create a unique :key to help ensure that sub components are re-rendered rather than\n        // re-used, which can cause issues. If a primary key is not provided we use the rendered\n        // rows index within the tbody.\n        // See: https://github.com/bootstrap-vue/bootstrap-vue/issues/2410\n\n\n        var primaryKey = this.primaryKey;\n        var primaryKeyValue = toString$1(get(item, primaryKey)) || null;\n        var rowKey = primaryKeyValue || toString$1(rowIndex); // If primary key is provided, use it to generate a unique ID on each tbody > tr\n        // In the format of '{tableId}__row_{primaryKeyValue}'\n\n        var rowId = primaryKeyValue ? this.safeId(\"_row_\".concat(primaryKeyValue)) : null; // Selectable classes and attributes\n\n        var selectableClasses = this.selectableRowClasses ? this.selectableRowClasses(rowIndex) : {};\n        var selectableAttrs = this.selectableRowAttrs ? this.selectableRowAttrs(rowIndex) : {}; // Additional classes and attributes\n\n        var userTrClasses = isFunction(this.tbodyTrClass) ? this.tbodyTrClass(item, 'row') : this.tbodyTrClass;\n        var userTrAttrs = isFunction(this.tbodyTrAttr) ? this.tbodyTrAttr(item, 'row') : this.tbodyTrAttr; // Add the item row\n\n        $rows.push(h(BTr, {\n          key: \"__b-table-row-\".concat(rowKey, \"__\"),\n          ref: 'itemRows',\n          refInFor: true,\n          class: [userTrClasses, selectableClasses, rowShowDetails ? 'b-table-has-details' : ''],\n          props: {\n            variant: item._rowVariant || null\n          },\n          attrs: _objectSpread2({\n            id: rowId\n          }, userTrAttrs, {\n            // Users cannot override the following attributes\n            tabindex: hasRowClickHandler ? '0' : null,\n            'data-pk': primaryKeyValue || null,\n            'aria-details': detailsId,\n            'aria-owns': detailsId,\n            'aria-rowindex': ariaRowIndex\n          }, selectableAttrs),\n          on: {\n            // Note: These events are not A11Y friendly!\n            mouseenter: this.rowHovered,\n            mouseleave: this.rowUnhovered\n          }\n        }, $tds)); // Row Details slot\n\n        if (rowShowDetails) {\n          var detailsScope = {\n            item: item,\n            index: rowIndex,\n            fields: fields,\n            toggleDetails: this.toggleDetailsFactory(hasDetailsSlot, item)\n          }; // If table supports selectable mode, then add in the following scope\n          // this.supportsSelectableRows will be undefined if mixin isn't loaded\n\n          if (this.supportsSelectableRows) {\n            detailsScope.rowSelected = this.isRowSelected(rowIndex);\n\n            detailsScope.selectRow = function () {\n              return _this3.selectRow(rowIndex);\n            };\n\n            detailsScope.unselectRow = function () {\n              return _this3.unselectRow(rowIndex);\n            };\n          } // Render the details slot in a TD\n\n\n          var $details = h(BTd, {\n            props: {\n              colspan: fields.length\n            },\n            class: this.detailsTdClass\n          }, [this.normalizeSlot(detailsSlotName, detailsScope)]); // Add a hidden row to keep table row striping consistent when details showing\n          // Only added if the table is striped\n\n          if (tableStriped) {\n            $rows.push( // We don't use `BTr` here as we don't need the extra functionality\n            h('tr', {\n              key: \"__b-table-details-stripe__\".concat(rowKey),\n              staticClass: 'd-none',\n              attrs: {\n                'aria-hidden': 'true',\n                role: 'presentation'\n              }\n            }));\n          } // Add the actual details row\n\n\n          var userDetailsTrClasses = isFunction(this.tbodyTrClass) ? this.tbodyTrClass(item, detailsSlotName) : this.tbodyTrClass;\n          var userDetailsTrAttrs = isFunction(this.tbodyTrAttr) ? this.tbodyTrAttr(item, detailsSlotName) : this.tbodyTrAttr;\n          $rows.push(h(BTr, {\n            key: \"__b-table-details__\".concat(rowKey),\n            staticClass: 'b-table-details',\n            class: [userDetailsTrClasses],\n            props: {\n              variant: item._rowVariant || null\n            },\n            attrs: _objectSpread2({}, userDetailsTrAttrs, {\n              // Users cannot override the following attributes\n              id: detailsId,\n              tabindex: '-1'\n            })\n          }, [$details]));\n        } else if (hasDetailsSlot) {\n          // Only add the placeholder if a the table has a row-details slot defined (but not shown)\n          $rows.push(h());\n\n          if (tableStriped) {\n            // Add extra placeholder if table is striped\n            $rows.push(h());\n          }\n        } // Return the row(s)\n\n\n        return $rows;\n      }\n    }\n  };\n\n  var props$Y = _objectSpread2({}, props$X, {\n    tbodyClass: {\n      type: [String, Array, Object] // default: undefined\n\n    }\n  });\n\n  var tbodyMixin = {\n    mixins: [tbodyRowMixin],\n    props: props$Y,\n    methods: {\n      // Helper methods\n      getTbodyTrs: function getTbodyTrs() {\n        // Returns all the item TR elements (excludes detail and spacer rows)\n        // `this.$refs.itemRows` is an array of item TR components/elements\n        // Rows should all be B-TR components, but we map to TR elements\n        // Also note that `this.$refs.itemRows` may not always be in document order\n        var refs = this.$refs || {};\n        var tbody = refs.tbody ? refs.tbody.$el || refs.tbody : null;\n        var trs = (refs.itemRows || []).map(function (tr) {\n          return tr.$el || tr;\n        });\n        return tbody && tbody.children && tbody.children.length > 0 && trs && trs.length > 0 ? from(tbody.children).filter(function (tr) {\n          return arrayIncludes(trs, tr);\n        }) : [];\n      },\n      getTbodyTrIndex: function getTbodyTrIndex(el) {\n        // Returns index of a particular TBODY item TR\n        // We set `true` on closest to include self in result\n\n        /* istanbul ignore next: should not normally happen */\n        if (!isElement(el)) {\n          return -1;\n        }\n\n        var tr = el.tagName === 'TR' ? el : closest('tr', el, true);\n        return tr ? this.getTbodyTrs().indexOf(tr) : -1;\n      },\n      emitTbodyRowEvent: function emitTbodyRowEvent(type, evt) {\n        // Emits a row event, with the item object, row index and original event\n        if (type && this.hasListener(type) && evt && evt.target) {\n          var rowIndex = this.getTbodyTrIndex(evt.target);\n\n          if (rowIndex > -1) {\n            // The array of TRs correlate to the `computedItems` array\n            var item = this.computedItems[rowIndex];\n            this.$emit(type, item, rowIndex, evt);\n          }\n        }\n      },\n      tbodyRowEvtStopped: function tbodyRowEvtStopped(evt) {\n        return this.stopIfBusy && this.stopIfBusy(evt);\n      },\n      // Delegated row event handlers\n      onTbodyRowKeydown: function onTbodyRowKeydown(evt) {\n        // Keyboard navigation and row click emulation\n        var target = evt.target;\n\n        if (this.tbodyRowEvtStopped(evt) || target.tagName !== 'TR' || target !== document.activeElement || target.tabIndex !== 0) {\n          // Early exit if not an item row TR\n          return;\n        }\n\n        var keyCode = evt.keyCode;\n\n        if (arrayIncludes([KEY_CODES.ENTER, KEY_CODES.SPACE], keyCode)) {\n          // Emulated click for keyboard users, transfer to click handler\n          evt.stopPropagation();\n          evt.preventDefault();\n          this.onTBodyRowClicked(evt);\n        } else if (arrayIncludes([KEY_CODES.UP, KEY_CODES.DOWN, KEY_CODES.HOME, KEY_CODES.END], keyCode)) {\n          // Keyboard navigation\n          var rowIndex = this.getTbodyTrIndex(target);\n\n          if (rowIndex > -1) {\n            evt.stopPropagation();\n            evt.preventDefault();\n            var trs = this.getTbodyTrs();\n            var shift = evt.shiftKey;\n\n            if (keyCode === KEY_CODES.HOME || shift && keyCode === KEY_CODES.UP) {\n              // Focus first row\n              trs[0].focus();\n            } else if (keyCode === KEY_CODES.END || shift && keyCode === KEY_CODES.DOWN) {\n              // Focus last row\n              trs[trs.length - 1].focus();\n            } else if (keyCode === KEY_CODES.UP && rowIndex > 0) {\n              // Focus previous row\n              trs[rowIndex - 1].focus();\n            } else if (keyCode === KEY_CODES.DOWN && rowIndex < trs.length - 1) {\n              // Focus next row\n              trs[rowIndex + 1].focus();\n            }\n          }\n        }\n      },\n      onTBodyRowClicked: function onTBodyRowClicked(evt) {\n        if (this.tbodyRowEvtStopped(evt)) {\n          // If table is busy, then don't propagate\n          return;\n        } else if (filterEvent(evt) || textSelectionActive(this.$el)) {\n          // Clicked on a non-disabled control so ignore\n          // Or user is selecting text, so ignore\n          return;\n        }\n\n        this.emitTbodyRowEvent('row-clicked', evt);\n      },\n      onTbodyRowMiddleMouseRowClicked: function onTbodyRowMiddleMouseRowClicked(evt) {\n        if (!this.tbodyRowEvtStopped(evt) && evt.which === 2) {\n          this.emitTbodyRowEvent('row-middle-clicked', evt);\n        }\n      },\n      onTbodyRowContextmenu: function onTbodyRowContextmenu(evt) {\n        if (!this.tbodyRowEvtStopped(evt)) {\n          this.emitTbodyRowEvent('row-contextmenu', evt);\n        }\n      },\n      onTbodyRowDblClicked: function onTbodyRowDblClicked(evt) {\n        if (!this.tbodyRowEvtStopped(evt) && !filterEvent(evt)) {\n          this.emitTbodyRowEvent('row-dblclicked', evt);\n        }\n      },\n      // Note: Row hover handlers are handled by the tbody-row mixin\n      // As mouseenter/mouseleave events do not bubble\n      //\n      // Render Helper\n      renderTbody: function renderTbody() {\n        var _this = this;\n\n        // Render the tbody element and children\n        var items = this.computedItems; // Shortcut to `createElement` (could use `this._c()` instead)\n\n        var h = this.$createElement;\n        var hasRowClickHandler = this.hasListener('row-clicked') || this.hasSelectableRowClick; // Prepare the tbody rows\n\n        var $rows = []; // Add the item data rows or the busy slot\n\n        var $busy = this.renderBusy ? this.renderBusy() : null;\n\n        if ($busy) {\n          // If table is busy and a busy slot, then return only the busy \"row\" indicator\n          $rows.push($busy);\n        } else {\n          // Table isn't busy, or we don't have a busy slot\n          // Create a slot cache for improved performance when looking up cell slot names\n          // Values will be keyed by the field's `key` and will store the slot's name\n          // Slots could be dynamic (i.e. `v-if`), so we must compute on each render\n          // Used by tbody-row mixin render helper\n          var cache = {};\n          var defaultSlotName = this.hasNormalizedSlot('cell()') ? 'cell()' : null;\n          this.computedFields.forEach(function (field) {\n            var key = field.key;\n            var fullName = \"cell(\".concat(key, \")\");\n            var lowerName = \"cell(\".concat(key.toLowerCase(), \")\");\n            cache[key] = _this.hasNormalizedSlot(fullName) ? fullName : _this.hasNormalizedSlot(lowerName) ? lowerName : defaultSlotName;\n          }); // Created as a non-reactive property so to not trigger component updates\n          // Must be a fresh object each render\n\n          this.$_bodyFieldSlotNameCache = cache; // Add static top row slot (hidden in visibly stacked mode\n          // as we can't control `data-label` attr)\n\n          $rows.push(this.renderTopRow ? this.renderTopRow() : h()); // Render the rows\n\n          items.forEach(function (item, rowIndex) {\n            // Render the individual item row (rows if details slot)\n            $rows.push(_this.renderTbodyRow(item, rowIndex));\n          }); // Empty items / empty filtered row slot (only shows if `items.length < 1`)\n\n          $rows.push(this.renderEmpty ? this.renderEmpty() : h()); // Static bottom row slot (hidden in visibly stacked mode\n          // as we can't control `data-label` attr)\n\n          $rows.push(this.renderBottomRow ? this.renderBottomRow() : h());\n        } // Note: these events will only emit if a listener is registered\n\n\n        var handlers = {\n          auxclick: this.onTbodyRowMiddleMouseRowClicked,\n          // TODO:\n          //   Perhaps we do want to automatically prevent the\n          //   default context menu from showing if there is a\n          //   `row-contextmenu` listener registered\n          contextmenu: this.onTbodyRowContextmenu,\n          // The following event(s) is not considered A11Y friendly\n          dblclick: this.onTbodyRowDblClicked // Hover events (`mouseenter`/`mouseleave`) are handled by `tbody-row` mixin\n\n        }; // Add in click/keydown listeners if needed\n\n        if (hasRowClickHandler) {\n          handlers.click = this.onTBodyRowClicked;\n          handlers.keydown = this.onTbodyRowKeydown;\n        } // Assemble rows into the tbody\n\n\n        var $tbody = h(BTbody, {\n          ref: 'tbody',\n          class: this.tbodyClass || null,\n          props: {\n            tbodyTransitionProps: this.tbodyTransitionProps,\n            tbodyTransitionHandlers: this.tbodyTransitionHandlers\n          },\n          // BTbody transfers all native event listeners to the root element\n          // TODO: Only set the handlers if the table is not busy\n          on: handlers\n        }, $rows); // Return the assembled tbody\n\n        return $tbody;\n      }\n    }\n  };\n\n  var emptyMixin = {\n    props: {\n      showEmpty: {\n        type: Boolean,\n        default: false\n      },\n      emptyText: {\n        type: String,\n        default: 'There are no records to show'\n      },\n      emptyHtml: {\n        type: String\n      },\n      emptyFilteredText: {\n        type: String,\n        default: 'There are no records matching your request'\n      },\n      emptyFilteredHtml: {\n        type: String\n      }\n    },\n    methods: {\n      renderEmpty: function renderEmpty() {\n        var h = this.$createElement;\n        var items = this.computedItems;\n        var $empty;\n\n        if (this.showEmpty && (!items || items.length === 0) && !(this.computedBusy && this.hasNormalizedSlot('table-busy'))) {\n          $empty = this.normalizeSlot(this.isFiltered ? 'emptyfiltered' : 'empty', {\n            emptyFilteredHtml: this.emptyFilteredHtml,\n            emptyFilteredText: this.emptyFilteredText,\n            emptyHtml: this.emptyHtml,\n            emptyText: this.emptyText,\n            fields: this.computedFields,\n            // Not sure why this is included, as it will always be an empty array\n            items: this.computedItems\n          });\n\n          if (!$empty) {\n            $empty = h('div', {\n              class: ['text-center', 'my-2'],\n              domProps: this.isFiltered ? htmlOrText(this.emptyFilteredHtml, this.emptyFilteredText) : htmlOrText(this.emptyHtml, this.emptyText)\n            });\n          }\n\n          $empty = h(BTd, {\n            props: {\n              colspan: this.computedFields.length || null\n            }\n          }, [h('div', {\n            attrs: {\n              role: 'alert',\n              'aria-live': 'polite'\n            }\n          }, [$empty])]);\n          $empty = h(BTr, {\n            key: this.isFiltered ? 'b-empty-filtered-row' : 'b-empty-row',\n            staticClass: 'b-table-empty-row',\n            class: [isFunction(this.tbodyTrClass) ? this.tbodyTrClass(null, 'row-empty') : this.tbodyTrClass],\n            attrs: isFunction(this.tbodyTrAttr) ? this.tbodyTrAttr(null, 'row-empty') : this.tbodyTrAttr\n          }, [$empty]);\n        }\n\n        return $empty || h();\n      }\n    }\n  };\n\n  var slotName = 'top-row';\n  var topRowMixin = {\n    methods: {\n      renderTopRow: function renderTopRow() {\n        var h = this.$createElement; // Add static Top Row slot (hidden in visibly stacked mode as we can't control the data-label)\n        // If in *always* stacked mode, we don't bother rendering the row\n\n        if (!this.hasNormalizedSlot(slotName) || this.stacked === true || this.stacked === '') {\n          return h();\n        }\n\n        var fields = this.computedFields;\n        return h(BTr, {\n          key: 'b-top-row',\n          staticClass: 'b-table-top-row',\n          class: [isFunction(this.tbodyTrClass) ? this.tbodyTrClass(null, 'row-top') : this.tbodyTrClass],\n          attrs: isFunction(this.tbodyTrAttr) ? this.tbodyTrAttr(null, 'row-top') : this.tbodyTrAttr\n        }, [this.normalizeSlot(slotName, {\n          columns: fields.length,\n          fields: fields\n        })]);\n      }\n    }\n  };\n\n  var slotName$1 = 'bottom-row';\n  var bottomRowMixin = {\n    methods: {\n      renderBottomRow: function renderBottomRow() {\n        var h = this.$createElement; // Static bottom row slot (hidden in visibly stacked mode as we can't control the data-label)\n        // If in *always* stacked mode, we don't bother rendering the row\n\n        if (!this.hasNormalizedSlot(slotName$1) || this.stacked === true || this.stacked === '') {\n          return h();\n        }\n\n        var fields = this.computedFields;\n        return h(BTr, {\n          key: 'b-bottom-row',\n          staticClass: 'b-table-bottom-row',\n          class: [isFunction(this.tbodyTrClass) ? this.tbodyTrClass(null, 'row-bottom') : this.tbodyTrClass],\n          attrs: isFunction(this.tbodyTrAttr) ? this.tbodyTrAttr(null, 'row-bottom') : this.tbodyTrAttr\n        }, this.normalizeSlot(slotName$1, {\n          columns: fields.length,\n          fields: fields\n        }));\n      }\n    }\n  };\n\n  var busySlotName = 'table-busy';\n  var busyMixin = {\n    props: {\n      busy: {\n        type: Boolean,\n        default: false\n      }\n    },\n    data: function data() {\n      return {\n        localBusy: false\n      };\n    },\n    computed: {\n      computedBusy: function computedBusy() {\n        return this.busy || this.localBusy;\n      }\n    },\n    watch: {\n      localBusy: function localBusy(newVal, oldVal) {\n        if (newVal !== oldVal) {\n          this.$emit('update:busy', newVal);\n        }\n      }\n    },\n    methods: {\n      // Event handler helper\n      stopIfBusy: function stopIfBusy(evt) {\n        if (this.computedBusy) {\n          // If table is busy (via provider) then don't propagate\n          evt.preventDefault();\n          evt.stopPropagation();\n          return true;\n        }\n\n        return false;\n      },\n      // Render the busy indicator or return `null` if not busy\n      renderBusy: function renderBusy() {\n        var h = this.$createElement; // Return a busy indicator row, or `null` if not busy\n\n        if (this.computedBusy && this.hasNormalizedSlot(busySlotName)) {\n          // Show the busy slot\n          return h(BTr, {\n            key: 'table-busy-slot',\n            staticClass: 'b-table-busy-slot',\n            class: [isFunction(this.tbodyTrClass) ? this.tbodyTrClass(null, busySlotName) : this.tbodyTrClass],\n            attrs: isFunction(this.tbodyTrAttr) ? this.tbodyTrAttr(null, busySlotName) : this.tbodyTrAttr\n          }, [h(BTd, {\n            props: {\n              colspan: this.computedFields.length || null\n            }\n          }, [this.normalizeSlot(busySlotName)])]);\n        } else {\n          // We return `null` here so that we can determine if we need to\n          // render the table items rows or not\n          return null;\n        }\n      }\n    }\n  };\n\n  var selectableMixin = {\n    props: {\n      selectable: {\n        type: Boolean,\n        default: false\n      },\n      selectMode: {\n        type: String,\n        default: 'multi',\n        validator: function validator(val) {\n          return arrayIncludes(['range', 'multi', 'single'], val);\n        }\n      },\n      selectedVariant: {\n        type: String,\n        default: function _default() {\n          return getComponentConfig('BTable', 'selectedVariant');\n        }\n      },\n      noSelectOnClick: {\n        // Disable use of click handlers for row selection\n        type: Boolean,\n        default: false\n      }\n    },\n    data: function data() {\n      return {\n        selectedRows: [],\n        selectedLastRow: -1\n      };\n    },\n    computed: {\n      isSelectable: function isSelectable() {\n        return this.selectable && this.selectMode;\n      },\n      hasSelectableRowClick: function hasSelectableRowClick() {\n        return this.isSelectable && !this.noSelectOnClick;\n      },\n      supportsSelectableRows: function supportsSelectableRows() {\n        return true;\n      },\n      selectableHasSelection: function selectableHasSelection() {\n        return this.isSelectable && this.selectedRows && this.selectedRows.length > 0 && this.selectedRows.some(identity);\n      },\n      selectableIsMultiSelect: function selectableIsMultiSelect() {\n        return this.isSelectable && arrayIncludes(['range', 'multi'], this.selectMode);\n      },\n      selectableTableClasses: function selectableTableClasses() {\n        var _ref;\n\n        return _ref = {\n          'b-table-selectable': this.isSelectable\n        }, _defineProperty(_ref, \"b-table-select-\".concat(this.selectMode), this.isSelectable), _defineProperty(_ref, 'b-table-selecting', this.selectableHasSelection), _defineProperty(_ref, 'b-table-selectable-no-click', this.isSelectable && !this.hasSelectableRowClick), _ref;\n      },\n      selectableTableAttrs: function selectableTableAttrs() {\n        return {\n          // TODO:\n          //   Should this attribute not be included when no-select-on-click is set\n          //   since this attribute implies keyboard navigation?\n          'aria-multiselectable': !this.isSelectable ? null : this.selectableIsMultiSelect ? 'true' : 'false'\n        };\n      }\n    },\n    watch: {\n      computedItems: function computedItems(newVal, oldVal) {\n        // Reset for selectable\n        var equal = false;\n\n        if (this.isSelectable && this.selectedRows.length > 0) {\n          // Quick check against array length\n          equal = isArray(newVal) && isArray(oldVal) && newVal.length === oldVal.length;\n\n          for (var i = 0; equal && i < newVal.length; i++) {\n            // Look for the first non-loosely equal row, after ignoring reserved fields\n            equal = looseEqual(sanitizeRow(newVal[i]), sanitizeRow(oldVal[i]));\n          }\n        }\n\n        if (!equal) {\n          this.clearSelected();\n        }\n      },\n      selectable: function selectable(newVal) {\n        this.clearSelected();\n        this.setSelectionHandlers(newVal);\n      },\n      selectMode: function selectMode() {\n        this.clearSelected();\n      },\n      hasSelectableRowClick: function hasSelectableRowClick(newVal) {\n        this.clearSelected();\n        this.setSelectionHandlers(!newVal);\n      },\n      selectedRows: function selectedRows(_selectedRows, oldVal) {\n        var _this = this;\n\n        if (this.isSelectable && !looseEqual(_selectedRows, oldVal)) {\n          var items = []; // `.forEach()` skips over non-existent indices (on sparse arrays)\n\n          _selectedRows.forEach(function (v, idx) {\n            if (v) {\n              items.push(_this.computedItems[idx]);\n            }\n          });\n\n          this.$emit('row-selected', items);\n        }\n      }\n    },\n    beforeMount: function beforeMount() {\n      // Set up handlers if needed\n      if (this.isSelectable) {\n        this.setSelectionHandlers(true);\n      }\n    },\n    methods: {\n      // Public methods\n      selectRow: function selectRow(index) {\n        // Select a particular row (indexed based on computedItems)\n        if (this.isSelectable && isNumber(index) && index >= 0 && index < this.computedItems.length && !this.isRowSelected(index)) {\n          var selectedRows = this.selectableIsMultiSelect ? this.selectedRows.slice() : [];\n          selectedRows[index] = true;\n          this.selectedLastClicked = -1;\n          this.selectedRows = selectedRows;\n        }\n      },\n      unselectRow: function unselectRow(index) {\n        // Un-select a particular row (indexed based on `computedItems`)\n        if (this.isSelectable && isNumber(index) && this.isRowSelected(index)) {\n          var selectedRows = this.selectedRows.slice();\n          selectedRows[index] = false;\n          this.selectedLastClicked = -1;\n          this.selectedRows = selectedRows;\n        }\n      },\n      selectAllRows: function selectAllRows() {\n        var length = this.computedItems.length;\n\n        if (this.isSelectable && length > 0) {\n          this.selectedLastClicked = -1;\n          this.selectedRows = this.selectableIsMultiSelect ? range(length).map(function () {\n            return true;\n          }) : [true];\n        }\n      },\n      isRowSelected: function isRowSelected(index) {\n        // Determine if a row is selected (indexed based on `computedItems`)\n        return !!(isNumber(index) && this.selectedRows[index]);\n      },\n      clearSelected: function clearSelected() {\n        // Clear any active selected row(s)\n        this.selectedLastClicked = -1;\n        this.selectedRows = [];\n      },\n      // Internal private methods\n      selectableRowClasses: function selectableRowClasses(index) {\n        if (this.isSelectable && this.isRowSelected(index)) {\n          var variant = this.selectedVariant;\n          return _defineProperty({\n            'b-table-row-selected': true\n          }, \"\".concat(this.dark ? 'bg' : 'table', \"-\").concat(variant), variant);\n        } else {\n          return {};\n        }\n      },\n      selectableRowAttrs: function selectableRowAttrs(index) {\n        return {\n          'aria-selected': !this.isSelectable ? null : this.isRowSelected(index) ? 'true' : 'false'\n        };\n      },\n      setSelectionHandlers: function setSelectionHandlers(on) {\n        var method = on && !this.noSelectOnClick ? '$on' : '$off'; // Handle row-clicked event\n\n        this[method]('row-clicked', this.selectionHandler); // Clear selection on filter, pagination, and sort changes\n\n        this[method]('filtered', this.clearSelected);\n        this[method]('context-changed', this.clearSelected);\n      },\n      selectionHandler: function selectionHandler(item, index, evt) {\n        /* istanbul ignore if: should never happen */\n        if (!this.isSelectable || this.noSelectOnClick) {\n          // Don't do anything if table is not in selectable mode\n          this.clearSelected();\n          return;\n        }\n\n        var selectMode = this.selectMode;\n        var selectedRows = this.selectedRows.slice();\n        var selected = !selectedRows[index]; // Note 'multi' mode needs no special event handling\n\n        if (selectMode === 'single') {\n          selectedRows = [];\n        } else if (selectMode === 'range') {\n          if (this.selectedLastRow > -1 && evt.shiftKey) {\n            // range\n            for (var idx = Math.min(this.selectedLastRow, index); idx <= Math.max(this.selectedLastRow, index); idx++) {\n              selectedRows[idx] = true;\n            }\n\n            selected = true;\n          } else {\n            if (!(evt.ctrlKey || evt.metaKey)) {\n              // Clear range selection if any\n              selectedRows = [];\n              selected = true;\n            }\n\n            this.selectedLastRow = selected ? index : -1;\n          }\n        }\n\n        selectedRows[index] = selected;\n        this.selectedRows = selectedRows;\n      }\n    }\n  };\n\n  var providerMixin = {\n    mixins: [listenOnRootMixin],\n    props: {\n      // Prop override(s)\n      items: {\n        // Adds in 'Function' support\n        type: [Array, Function],\n        default: function _default()\n        /* istanbul ignore next */\n        {\n          return [];\n        }\n      },\n      // Additional props\n      noProviderPaging: {\n        type: Boolean,\n        default: false\n      },\n      noProviderSorting: {\n        type: Boolean,\n        default: false\n      },\n      noProviderFiltering: {\n        type: Boolean,\n        default: false\n      },\n      apiUrl: {\n        // Passthrough prop. Passed to the context object. Not used by b-table directly\n        type: String,\n        default: ''\n      }\n    },\n    computed: {\n      hasProvider: function hasProvider() {\n        return isFunction(this.items);\n      },\n      providerTriggerContext: function providerTriggerContext() {\n        // Used to trigger the provider function via a watcher. Only the fields that\n        // are needed for triggering a provider update are included. Note that the\n        // regular this.context is sent to the provider during fetches though, as they\n        // may need all the prop info.\n        var ctx = {\n          apiUrl: this.apiUrl,\n          filter: null,\n          sortBy: null,\n          sortDesc: null,\n          perPage: null,\n          currentPage: null\n        };\n\n        if (!this.noProviderFiltering) {\n          // Either a string, or could be an object or array.\n          ctx.filter = this.localFilter;\n        }\n\n        if (!this.noProviderSorting) {\n          ctx.sortBy = this.localSortBy;\n          ctx.sortDesc = this.localSortDesc;\n        }\n\n        if (!this.noProviderPaging) {\n          ctx.perPage = this.perPage;\n          ctx.currentPage = this.currentPage;\n        }\n\n        return clone(ctx);\n      }\n    },\n    watch: {\n      // Provider update triggering\n      items: function items(newVal) {\n        // If a new provider has been specified, trigger an update\n        if (this.hasProvider || isFunction(newVal)) {\n          this.$nextTick(this._providerUpdate);\n        }\n      },\n      providerTriggerContext: function providerTriggerContext(newVal, oldVal) {\n        // Trigger the provider to update as the relevant context values have changed.\n        if (!looseEqual(newVal, oldVal)) {\n          this.$nextTick(this._providerUpdate);\n        }\n      }\n    },\n    mounted: function mounted() {\n      var _this = this;\n\n      // Call the items provider if necessary\n      if (this.hasProvider && (!this.localItems || this.localItems.length === 0)) {\n        // Fetch on mount if localItems is empty\n        this._providerUpdate();\n      } // Listen for global messages to tell us to force refresh the table\n\n\n      this.listenOnRoot('bv::refresh::table', function (id) {\n        if (id === _this.id || id === _this) {\n          _this.refresh();\n        }\n      });\n    },\n    methods: {\n      refresh: function refresh() {\n        // Public Method: Force a refresh of the provider function\n        this.$off('refreshed', this.refresh);\n\n        if (this.computedBusy) {\n          // Can't force an update when forced busy by user (busy prop === true)\n          if (this.localBusy && this.hasProvider) {\n            // But if provider running (localBusy), re-schedule refresh once `refreshed` emitted\n            this.$on('refreshed', this.refresh);\n          }\n        } else {\n          this.clearSelected();\n\n          if (this.hasProvider) {\n            this.$nextTick(this._providerUpdate);\n          } else {\n            /* istanbul ignore next */\n            this.localItems = isArray(this.items) ? this.items.slice() : [];\n          }\n        }\n      },\n      // Provider related methods\n      _providerSetLocal: function _providerSetLocal(items) {\n        this.localItems = isArray(items) ? items.slice() : [];\n        this.localBusy = false;\n        this.$emit('refreshed'); // New root emit\n\n        if (this.id) {\n          this.emitOnRoot('bv::table::refreshed', this.id);\n        }\n      },\n      _providerUpdate: function _providerUpdate() {\n        var _this2 = this;\n\n        // Refresh the provider function items.\n        if (!this.hasProvider) {\n          // Do nothing if no provider\n          return;\n        } // If table is busy, wait until refreshed before calling again\n\n\n        if (this.computedBusy) {\n          // Schedule a new refresh once `refreshed` is emitted\n          this.$nextTick(this.refresh);\n          return;\n        } // Set internal busy state\n\n\n        this.localBusy = true; // Call provider function with context and optional callback after DOM is fully updated\n\n        this.$nextTick(function () {\n          try {\n            // Call provider function passing it the context and optional callback\n            var data = _this2.items(_this2.context, _this2._providerSetLocal);\n\n            if (isPromise(data)) {\n              // Provider returned Promise\n              data.then(function (items) {\n                // Provider resolved with items\n                _this2._providerSetLocal(items);\n              });\n            } else if (isArray(data)) {\n              // Provider returned Array data\n              _this2._providerSetLocal(data);\n            } else {\n              /* istanbul ignore if */\n              if (_this2.items.length !== 2) {\n                // Check number of arguments provider function requested\n                // Provider not using callback (didn't request second argument), so we clear\n                // busy state as most likely there was an error in the provider function\n\n                /* istanbul ignore next */\n                warn(\"Provider function didn't request callback and did not return a promise or data.\", 'BTable');\n                _this2.localBusy = false;\n              }\n            }\n          } catch (e)\n          /* istanbul ignore next */\n          {\n            // Provider function borked on us, so we spew out a warning\n            // and clear the busy state\n            warn(\"Provider function error [\".concat(e.name, \"] \").concat(e.message, \".\"), 'BTable');\n            _this2.localBusy = false;\n\n            _this2.$off('refreshed', _this2.refresh);\n          }\n        });\n      }\n    }\n  };\n\n  // Includes all main table styling options\n\n  var tableRendererMixin = {\n    // Don't place attributes on root element automatically,\n    // as table could be wrapped in responsive `<div>`\n    inheritAttrs: false,\n    provide: function provide() {\n      return {\n        bvTable: this\n      };\n    },\n    props: {\n      striped: {\n        type: Boolean,\n        default: false\n      },\n      bordered: {\n        type: Boolean,\n        default: false\n      },\n      borderless: {\n        type: Boolean,\n        default: false\n      },\n      outlined: {\n        type: Boolean,\n        default: false\n      },\n      dark: {\n        type: Boolean,\n        default: false\n      },\n      hover: {\n        type: Boolean,\n        default: false\n      },\n      small: {\n        type: Boolean,\n        default: false\n      },\n      fixed: {\n        type: Boolean,\n        default: false\n      },\n      responsive: {\n        type: [Boolean, String],\n        default: false\n      },\n      stickyHeader: {\n        // If a string, it is assumed to be the table `max-height` value\n        type: [Boolean, String],\n        default: false\n      },\n      noBorderCollapse: {\n        type: Boolean,\n        default: false\n      },\n      captionTop: {\n        type: Boolean,\n        default: false\n      },\n      tableVariant: {\n        type: String,\n        default: null\n      },\n      tableClass: {\n        type: [String, Array, Object],\n        default: null\n      }\n    },\n    computed: {\n      // Layout related computed props\n      isResponsive: function isResponsive() {\n        var responsive = this.responsive === '' ? true : this.responsive;\n        return this.isStacked ? false : responsive;\n      },\n      isStickyHeader: function isStickyHeader() {\n        var stickyHeader = this.stickyHeader === '' ? true : this.stickyHeader;\n        return this.isStacked ? false : stickyHeader;\n      },\n      wrapperClasses: function wrapperClasses() {\n        return [this.isStickyHeader ? 'b-table-sticky-header' : '', this.isResponsive === true ? 'table-responsive' : this.isResponsive ? \"table-responsive-\".concat(this.responsive) : ''].filter(identity);\n      },\n      wrapperStyles: function wrapperStyles() {\n        return this.isStickyHeader && !isBoolean(this.isStickyHeader) ? {\n          maxHeight: this.isStickyHeader\n        } : {};\n      },\n      tableClasses: function tableClasses() {\n        var hover = this.isTableSimple ? this.hover : this.hover && this.computedItems.length > 0 && !this.computedBusy;\n        return [// User supplied classes\n        this.tableClass, // Styling classes\n        {\n          'table-striped': this.striped,\n          'table-hover': hover,\n          'table-dark': this.dark,\n          'table-bordered': this.bordered,\n          'table-borderless': this.borderless,\n          'table-sm': this.small,\n          // The following are b-table custom styles\n          border: this.outlined,\n          'b-table-fixed': this.fixed,\n          'b-table-caption-top': this.captionTop,\n          'b-table-no-border-collapse': this.noBorderCollapse\n        }, this.tableVariant ? \"\".concat(this.dark ? 'bg' : 'table', \"-\").concat(this.tableVariant) : '', // Stacked table classes\n        this.stackedTableClasses, // Selectable classes\n        this.selectableTableClasses];\n      },\n      tableAttrs: function tableAttrs() {\n        // Preserve user supplied aria-describedby, if provided in `$attrs`\n        var adb = [(this.$attrs || {})['aria-describedby'], this.captionId].filter(identity).join(' ') || null;\n        var items = this.computedItems;\n        var filteredItems = this.filteredItems;\n        var fields = this.computedFields;\n        var selectableAttrs = this.selectableTableAttrs || {};\n        var ariaAttrs = this.isTableSimple ? {} : {\n          'aria-busy': this.computedBusy ? 'true' : 'false',\n          'aria-colcount': toString$1(fields.length),\n          'aria-describedby': adb\n        };\n        var rowCount = items && filteredItems && filteredItems.length > items.length ? toString$1(filteredItems.length) : null;\n        return _objectSpread2({\n          // We set `aria-rowcount` before merging in `$attrs`,\n          // in case user has supplied their own\n          'aria-rowcount': rowCount\n        }, this.$attrs, {\n          // Now we can override any `$attrs` here\n          id: this.safeId(),\n          role: 'table'\n        }, ariaAttrs, {}, selectableAttrs);\n      }\n    },\n    render: function render(h) {\n      var $content = [];\n\n      if (this.isTableSimple) {\n        $content.push(this.normalizeSlot('default'));\n      } else {\n        // Build the `<caption>` (from caption mixin)\n        $content.push(this.renderCaption ? this.renderCaption() : null); // Build the `<colgroup>`\n\n        $content.push(this.renderColgroup ? this.renderColgroup() : null); // Build the `<thead>`\n\n        $content.push(this.renderThead ? this.renderThead() : null); // Build the `<tbody>`\n\n        $content.push(this.renderTbody ? this.renderTbody() : null); // Build the `<tfoot>`\n\n        $content.push(this.renderTfoot ? this.renderTfoot() : null);\n      } // Assemble `<table>`\n\n\n      var $table = h('table', {\n        key: 'b-table',\n        staticClass: 'table b-table',\n        class: this.tableClasses,\n        attrs: this.tableAttrs\n      }, $content.filter(identity)); // Add responsive/sticky wrapper if needed and return table\n\n      return this.wrapperClasses.length > 0 ? h('div', {\n        key: 'wrap',\n        class: this.wrapperClasses,\n        style: this.wrapperStyles\n      }, [$table]) : $table;\n    }\n  };\n\n  // @vue/component\n\n  var BTable =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BTable',\n    // Order of mixins is important!\n    // They are merged from first to last, followed by this component.\n    mixins: [// Required Mixins\n    hasListenerMixin, idMixin, normalizeSlotMixin, itemsMixin, tableRendererMixin, stackedMixin, theadMixin, tfootMixin, tbodyMixin, // Features Mixins\n    stackedMixin, filteringMixin, sortingMixin, paginationMixin$1, captionMixin, colgroupMixin, selectableMixin, emptyMixin, topRowMixin, bottomRowMixin, busyMixin, providerMixin] // render function provided by table-renderer mixin\n\n  });\n\n  // @vue/component\n\n  var BTableLite =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BTableLite',\n    // Order of mixins is important!\n    // They are merged from first to last, followed by this component.\n    mixins: [// Required mixins\n    hasListenerMixin, idMixin, normalizeSlotMixin, itemsMixin, tableRendererMixin, stackedMixin, theadMixin, tfootMixin, tbodyMixin, // Features Mixins\n    // These are pretty lightweight, and are useful for lightweight tables\n    captionMixin, colgroupMixin] // render function provided by table-renderer mixin\n\n  });\n\n  // @vue/component\n\n  var BTableSimple =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BTableSimple',\n    // Order of mixins is important!\n    // They are merged from first to last, followed by this component.\n    mixins: [// Required mixins\n    idMixin, normalizeSlotMixin, tableRendererMixin, // feature mixin\n    // Stacked requires extra handling by users via\n    // the table cell `stacked-heading` prop\n    stackedMixin],\n    computed: {\n      isTableSimple: function isTableSimple() {\n        return true;\n      }\n    } // render function provided by table-renderer mixin\n\n  });\n\n  var TableLitePlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BTableLite: BTableLite\n    }\n  });\n  var TableSimplePlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BTableSimple: BTableSimple,\n      BTbody: BTbody,\n      BThead: BThead,\n      BTfoot: BTfoot,\n      BTr: BTr,\n      BTd: BTd,\n      BTh: BTh\n    }\n  });\n  var TablePlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BTable: BTable\n    },\n    plugins: {\n      TableLitePlugin: TableLitePlugin,\n      TableSimplePlugin: TableSimplePlugin\n    }\n  });\n\n  var navProps = omit(props$I, ['tabs', 'isNavBar', 'cardHeader']); // -- Utils --\n  // Filter function to filter out disabled tabs\n\n  var notDisabled = function notDisabled(tab) {\n    return !tab.disabled;\n  }; // --- Helper components ---\n  // @vue/component\n\n\n  var BTabButtonHelper =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BTabButtonHelper',\n    inject: {\n      bvTabs: {\n        default: function _default()\n        /* istanbul ignore next */\n        {\n          return {};\n        }\n      }\n    },\n    props: {\n      // Reference to the child <b-tab> instance\n      tab: {\n        default: null\n      },\n      tabs: {\n        type: Array,\n        default: function _default()\n        /* istanbul ignore next */\n        {\n          return [];\n        }\n      },\n      id: {\n        type: String,\n        default: null\n      },\n      controls: {\n        type: String,\n        default: null\n      },\n      tabIndex: {\n        type: Number,\n        default: null\n      },\n      posInSet: {\n        type: Number,\n        default: null\n      },\n      setSize: {\n        type: Number,\n        default: null\n      },\n      noKeyNav: {\n        type: Boolean,\n        default: false\n      }\n    },\n    methods: {\n      focus: function focus() {\n        if (this.$refs && this.$refs.link && this.$refs.link.focus) {\n          this.$refs.link.focus();\n        }\n      },\n      handleEvt: function handleEvt(evt) {\n        var stop = function stop() {\n          evt.preventDefault();\n          evt.stopPropagation();\n        };\n\n        if (this.tab.disabled) {\n          /* istanbul ignore next */\n          return;\n        }\n\n        var type = evt.type;\n        var key = evt.keyCode;\n        var shift = evt.shiftKey;\n\n        if (type === 'click') {\n          stop();\n          this.$emit('click', evt);\n        } else if (type === 'keydown' && key === KEY_CODES.SPACE) {\n          // For ARIA tabs the SPACE key will also trigger a click/select\n          // Even with keyboard navigation disabled, SPACE should \"click\" the button\n          // See: https://github.com/bootstrap-vue/bootstrap-vue/issues/4323\n          stop();\n          this.$emit('click', evt);\n        } else if (type === 'keydown' && !this.noKeyNav) {\n          // For keyboard navigation\n          if (key === KEY_CODES.UP || key === KEY_CODES.LEFT || key === KEY_CODES.HOME) {\n            stop();\n\n            if (shift || key === KEY_CODES.HOME) {\n              this.$emit('first', evt);\n            } else {\n              this.$emit('prev', evt);\n            }\n          } else if (key === KEY_CODES.DOWN || key === KEY_CODES.RIGHT || key === KEY_CODES.END) {\n            stop();\n\n            if (shift || key === KEY_CODES.END) {\n              this.$emit('last', evt);\n            } else {\n              this.$emit('next', evt);\n            }\n          }\n        }\n      }\n    },\n    render: function render(h) {\n      var link = h(BLink, {\n        ref: 'link',\n        staticClass: 'nav-link',\n        class: [{\n          active: this.tab.localActive && !this.tab.disabled,\n          disabled: this.tab.disabled\n        }, this.tab.titleLinkClass, // Apply <b-tabs> `activeNavItemClass` styles when the tab is active\n        this.tab.localActive ? this.bvTabs.activeNavItemClass : null],\n        props: {\n          disabled: this.tab.disabled\n        },\n        attrs: {\n          role: 'tab',\n          id: this.id,\n          // Roving tab index when keynav enabled\n          tabindex: this.tabIndex,\n          'aria-selected': this.tab.localActive && !this.tab.disabled ? 'true' : 'false',\n          'aria-setsize': this.setSize,\n          'aria-posinset': this.posInSet,\n          'aria-controls': this.controls\n        },\n        on: {\n          click: this.handleEvt,\n          keydown: this.handleEvt\n        }\n      }, [this.tab.normalizeSlot('title') || this.tab.title]);\n      return h('li', {\n        staticClass: 'nav-item',\n        class: [this.tab.titleItemClass],\n        attrs: {\n          role: 'presentation'\n        }\n      }, [link]);\n    }\n  }); // @vue/component\n\n  var BTabs =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BTabs',\n    mixins: [idMixin, normalizeSlotMixin],\n    provide: function provide() {\n      return {\n        bvTabs: this\n      };\n    },\n    model: {\n      prop: 'value',\n      event: 'input'\n    },\n    props: _objectSpread2({}, navProps, {\n      tag: {\n        type: String,\n        default: 'div'\n      },\n      card: {\n        type: Boolean,\n        default: false\n      },\n      end: {\n        // Synonym for 'bottom'\n        type: Boolean,\n        default: false\n      },\n      noFade: {\n        type: Boolean,\n        default: false\n      },\n      noNavStyle: {\n        type: Boolean,\n        default: false\n      },\n      noKeyNav: {\n        type: Boolean,\n        default: false\n      },\n      lazy: {\n        // This prop is sniffed by the <b-tab> child\n        type: Boolean,\n        default: false\n      },\n      contentClass: {\n        type: [String, Array, Object],\n        default: null\n      },\n      navClass: {\n        type: [String, Array, Object],\n        default: null\n      },\n      navWrapperClass: {\n        type: [String, Array, Object],\n        default: null\n      },\n      activeNavItemClass: {\n        // Only applied to the currently active <b-nav-item>\n        type: [String, Array, Object],\n        default: null\n      },\n      activeTabClass: {\n        // Only applied to the currently active <b-tab>\n        // This prop is sniffed by the <b-tab> child\n        type: [String, Array, Object],\n        default: null\n      },\n      value: {\n        // v-model\n        type: Number,\n        default: null\n      }\n    }),\n    data: function data() {\n      var tabIdx = parseInt(this.value, 10);\n      tabIdx = isNaN(tabIdx) ? -1 : tabIdx;\n      return {\n        // Index of current tab\n        currentTab: tabIdx,\n        // Array of direct child <b-tab> instances, in DOM order\n        tabs: [],\n        // Array of child instances registered (for triggering reactive updates)\n        registeredTabs: [],\n        // Flag to know if we are mounted or not\n        isMounted: false\n      };\n    },\n    computed: {\n      fade: function fade() {\n        // This computed prop is sniffed by the tab child\n        return !this.noFade;\n      },\n      localNavClass: function localNavClass() {\n        var classes = [];\n\n        if (this.card && this.vertical) {\n          classes.push('card-header', 'h-100', 'border-bottom-0', 'rounded-0');\n        }\n\n        return [].concat(classes, [this.navClass]);\n      }\n    },\n    watch: {\n      currentTab: function currentTab(newVal) {\n        var index = -1; // Ensure only one tab is active at most\n\n        this.tabs.forEach(function (tab, idx) {\n          if (newVal === idx && !tab.disabled) {\n            tab.localActive = true;\n            index = idx;\n          } else {\n            tab.localActive = false;\n          }\n        }); // Update the v-model\n\n        this.$emit('input', index);\n      },\n      value: function value(newVal, oldVal) {\n        if (newVal !== oldVal) {\n          newVal = parseInt(newVal, 10);\n          newVal = isNaN(newVal) ? -1 : newVal;\n          oldVal = parseInt(oldVal, 10) || 0;\n          var tabs = this.tabs;\n\n          if (tabs[newVal] && !tabs[newVal].disabled) {\n            this.activateTab(tabs[newVal]);\n          } else {\n            // Try next or prev tabs\n            if (newVal < oldVal) {\n              this.previousTab();\n            } else {\n              this.nextTab();\n            }\n          }\n        }\n      },\n      registeredTabs: function registeredTabs() {\n        var _this = this;\n\n        // Each b-tab will register/unregister itself.\n        // We use this to detect when tabs are added/removed\n        // to trigger the update of the tabs.\n        this.$nextTick(function () {\n          requestAF(function () {\n            _this.updateTabs();\n          });\n        });\n      },\n      tabs: function tabs(newVal, oldVal) {\n        var _this2 = this;\n\n        // If tabs added, removed, or re-ordered, we emit a `changed` event.\n        // We use `tab._uid` instead of `tab.safeId()`, as the later is changed\n        // in a nextTick if no explicit ID is provided, causing duplicate emits.\n        if (!looseEqual(newVal.map(function (t) {\n          return t._uid;\n        }), oldVal.map(function (t) {\n          return t._uid;\n        }))) {\n          // In a nextTick to ensure currentTab has been set first.\n          this.$nextTick(function () {\n            // We emit shallow copies of the new and old arrays of tabs, to\n            // prevent users from potentially mutating the internal arrays.\n            _this2.$emit('changed', newVal.slice(), oldVal.slice());\n          });\n        }\n      },\n      isMounted: function isMounted(newVal) {\n        var _this3 = this;\n\n        // Trigger an update after mounted.  Needed for tabs inside lazy modals.\n        if (newVal) {\n          requestAF(function () {\n            _this3.updateTabs();\n          });\n        } // Enable or disable the observer\n\n\n        this.setObserver(newVal);\n      }\n    },\n    created: function created() {\n      var _this4 = this;\n\n      var tabIdx = parseInt(this.value, 10);\n      this.currentTab = isNaN(tabIdx) ? -1 : tabIdx;\n      this._bvObserver = null; // For SSR and to make sure only a single tab is shown on mount\n      // We wrap this in a `$nextTick()` to ensure the child tabs have been created\n\n      this.$nextTick(function () {\n        _this4.updateTabs();\n      });\n    },\n    mounted: function mounted() {\n      var _this5 = this;\n\n      // Call `updateTabs()` just in case...\n      this.updateTabs();\n      this.$nextTick(function () {\n        // Flag we are now mounted and to switch to DOM for tab probing.\n        // As this.$slots.default appears to lie about component instances\n        // after b-tabs is destroyed and re-instantiated.\n        // And this.$children does not respect DOM order.\n        _this5.isMounted = true;\n      });\n    },\n    deactivated: function deactivated()\n    /* istanbul ignore next */\n    {\n      this.isMounted = false;\n    },\n    activated: function activated()\n    /* istanbul ignore next */\n    {\n      var _this6 = this;\n\n      var tabIdx = parseInt(this.value, 10);\n      this.currentTab = isNaN(tabIdx) ? -1 : tabIdx;\n      this.$nextTick(function () {\n        _this6.updateTabs();\n\n        _this6.isMounted = true;\n      });\n    },\n    beforeDestroy: function beforeDestroy() {\n      this.isMounted = false;\n    },\n    destroyed: function destroyed() {\n      // Ensure no references to child instances exist\n      this.tabs = [];\n    },\n    methods: {\n      registerTab: function registerTab(tab) {\n        var _this7 = this;\n\n        if (!arrayIncludes(this.registeredTabs, tab)) {\n          this.registeredTabs.push(tab);\n          tab.$once('hook:destroyed', function () {\n            _this7.unregisterTab(tab);\n          });\n        }\n      },\n      unregisterTab: function unregisterTab(tab) {\n        this.registeredTabs = this.registeredTabs.slice().filter(function (t) {\n          return t !== tab;\n        });\n      },\n      setObserver: function setObserver(on) {\n        // DOM observer is needed to detect changes in order of tabs\n        if (on) {\n          // Make sure no existing observer running\n          this.setObserver(false);\n          var self = this;\n          /* istanbul ignore next: difficult to test mutation observer in JSDOM */\n\n          var handler = function handler() {\n            // We delay the update to ensure that `tab.safeId()` has\n            // updated with the final ID value.\n            self.$nextTick(function () {\n              requestAF(function () {\n                self.updateTabs();\n              });\n            });\n          }; // Watch for changes to <b-tab> sub components\n\n\n          this._bvObserver = observeDom(this.$refs.tabsContainer, handler, {\n            childList: true,\n            subtree: false,\n            attributes: true,\n            attributeFilter: ['id']\n          });\n        } else {\n          if (this._bvObserver && this._bvObserver.disconnect) {\n            this._bvObserver.disconnect();\n          }\n\n          this._bvObserver = null;\n        }\n      },\n      getTabs: function getTabs() {\n        // We use registeredTabs as the source of truth for child tab components. And we\n        // filter out any BTab components that are extended BTab with a root child BTab.\n        // https://github.com/bootstrap-vue/bootstrap-vue/issues/3260\n        var tabs = this.registeredTabs.filter(function (tab) {\n          return tab.$children.filter(function (t) {\n            return t._isTab;\n          }).length === 0;\n        }); // DOM Order of Tabs\n\n        var order = [];\n\n        if (this.isMounted && tabs.length > 0) {\n          // We rely on the DOM when mounted to get the 'true' order of the b-tab children.\n          // querySelectorAll(...) always returns elements in document order, regardless of\n          // order specified in the selector.\n          var selector = tabs.map(function (tab) {\n            return \"#\".concat(tab.safeId());\n          }).join(', ');\n          order = selectAll(selector, this.$el).map(function (el) {\n            return el.id;\n          }).filter(identity);\n        } // Stable sort keeps the original order if not found in the\n        // `order` array, which will be an empty array before mount.\n\n\n        return stableSort(tabs, function (a, b) {\n          return order.indexOf(a.safeId()) - order.indexOf(b.safeId());\n        });\n      },\n      // Update list of <b-tab> children\n      updateTabs: function updateTabs() {\n        // Probe tabs\n        var tabs = this.getTabs(); // Find *last* active non-disabled tab in current tabs\n        // We trust tab state over currentTab, in case tabs were added/removed/re-ordered\n\n        var tabIndex = tabs.indexOf(tabs.slice().reverse().find(function (tab) {\n          return tab.localActive && !tab.disabled;\n        })); // Else try setting to currentTab\n\n        if (tabIndex < 0) {\n          var currentTab = this.currentTab;\n\n          if (currentTab >= tabs.length) {\n            // Handle last tab being removed, so find the last non-disabled tab\n            tabIndex = tabs.indexOf(tabs.slice().reverse().find(notDisabled));\n          } else if (tabs[currentTab] && !tabs[currentTab].disabled) {\n            // Current tab is not disabled\n            tabIndex = currentTab;\n          }\n        } // Else find *first* non-disabled tab in current tabs\n\n\n        if (tabIndex < 0) {\n          tabIndex = tabs.indexOf(tabs.find(notDisabled));\n        } // Set the current tab state to active\n\n\n        tabs.forEach(function (tab) {\n          // tab.localActive = idx === tabIndex && !tab.disabled\n          tab.localActive = false;\n        });\n\n        if (tabs[tabIndex]) {\n          tabs[tabIndex].localActive = true;\n        } // Update the array of tab children\n\n\n        this.tabs = tabs; // Set the currentTab index (can be -1 if no non-disabled tabs)\n\n        this.currentTab = tabIndex;\n      },\n      // Find a button that controls a tab, given the tab reference\n      // Returns the button vm instance\n      getButtonForTab: function getButtonForTab(tab) {\n        return (this.$refs.buttons || []).find(function (btn) {\n          return btn.tab === tab;\n        });\n      },\n      // Force a button to re-render its content, given a <b-tab> instance\n      // Called by <b-tab> on `update()`\n      updateButton: function updateButton(tab) {\n        var button = this.getButtonForTab(tab);\n\n        if (button && button.$forceUpdate) {\n          button.$forceUpdate();\n        }\n      },\n      // Activate a tab given a <b-tab> instance\n      // Also accessed by <b-tab>\n      activateTab: function activateTab(tab) {\n        var result = false;\n\n        if (tab) {\n          var index = this.tabs.indexOf(tab);\n\n          if (!tab.disabled && index > -1 && index !== this.currentTab) {\n            var tabEvt = new BvEvent('activate-tab', {\n              cancelable: true,\n              vueTarget: this,\n              componentId: this.safeId()\n            });\n            this.$emit(tabEvt.type, index, this.currentTab, tabEvt);\n\n            if (!tabEvt.defaultPrevented) {\n              result = true;\n              this.currentTab = index;\n            }\n          }\n        } // Couldn't set tab, so ensure v-model is set to `this.currentTab`\n\n        /* istanbul ignore next: should rarely happen */\n\n\n        if (!result && this.currentTab !== this.value) {\n          this.$emit('input', this.currentTab);\n        }\n\n        return result;\n      },\n      // Deactivate a tab given a <b-tab> instance\n      // Accessed by <b-tab>\n      deactivateTab: function deactivateTab(tab) {\n        if (tab) {\n          // Find first non-disabled tab that isn't the one being deactivated\n          // If no tabs are available, then don't deactivate current tab\n          return this.activateTab(this.tabs.filter(function (t) {\n            return t !== tab;\n          }).find(notDisabled));\n        }\n        /* istanbul ignore next: should never/rarely happen */\n\n\n        return false;\n      },\n      // Focus a tab button given its <b-tab> instance\n      focusButton: function focusButton(tab) {\n        var _this8 = this;\n\n        // Wrap in `$nextTick()` to ensure DOM has completed rendering/updating before focusing\n        this.$nextTick(function () {\n          var button = _this8.getButtonForTab(tab);\n\n          if (button && button.focus) {\n            button.focus();\n          }\n        });\n      },\n      // Emit a click event on a specified <b-tab> component instance\n      emitTabClick: function emitTabClick(tab, evt) {\n        if (isEvent(evt) && tab && tab.$emit && !tab.disabled) {\n          tab.$emit('click', evt);\n        }\n      },\n      // Click handler\n      clickTab: function clickTab(tab, evt) {\n        this.activateTab(tab);\n        this.emitTabClick(tab, evt);\n      },\n      // Move to first non-disabled tab\n      firstTab: function firstTab(focus) {\n        var tab = this.tabs.find(notDisabled);\n\n        if (this.activateTab(tab) && focus) {\n          this.focusButton(tab);\n          this.emitTabClick(tab, focus);\n        }\n      },\n      // Move to previous non-disabled tab\n      previousTab: function previousTab(focus) {\n        var currentIndex = Math.max(this.currentTab, 0);\n        var tab = this.tabs.slice(0, currentIndex).reverse().find(notDisabled);\n\n        if (this.activateTab(tab) && focus) {\n          this.focusButton(tab);\n          this.emitTabClick(tab, focus);\n        }\n      },\n      // Move to next non-disabled tab\n      nextTab: function nextTab(focus) {\n        var currentIndex = Math.max(this.currentTab, -1);\n        var tab = this.tabs.slice(currentIndex + 1).find(notDisabled);\n\n        if (this.activateTab(tab) && focus) {\n          this.focusButton(tab);\n          this.emitTabClick(tab, focus);\n        }\n      },\n      // Move to last non-disabled tab\n      lastTab: function lastTab(focus) {\n        var tab = this.tabs.slice().reverse().find(notDisabled);\n\n        if (this.activateTab(tab) && focus) {\n          this.focusButton(tab);\n          this.emitTabClick(tab, focus);\n        }\n      }\n    },\n    render: function render(h) {\n      var _this9 = this;\n\n      var tabs = this.tabs; // Currently active tab\n\n      var activeTab = tabs.find(function (tab) {\n        return tab.localActive && !tab.disabled;\n      }); // Tab button to allow focusing when no active tab found (keynav only)\n\n      var fallbackTab = tabs.find(function (tab) {\n        return !tab.disabled;\n      }); // For each <b-tab> found create the tab buttons\n\n      var buttons = tabs.map(function (tab, index) {\n        var tabIndex = null; // Ensure at least one tab button is focusable when keynav enabled (if possible)\n\n        if (!_this9.noKeyNav) {\n          // Buttons are not in tab index unless active, or a fallback tab\n          tabIndex = -1;\n\n          if (activeTab === tab || !activeTab && fallbackTab === tab) {\n            // Place tab button in tab sequence\n            tabIndex = null;\n          }\n        }\n\n        return h(BTabButtonHelper, {\n          key: tab._uid || index,\n          ref: 'buttons',\n          // Needed to make `this.$refs.buttons` an array\n          refInFor: true,\n          props: {\n            tab: tab,\n            tabs: tabs,\n            id: tab.controlledBy || (tab.safeId ? tab.safeId(\"_BV_tab_button_\") : null),\n            controls: tab.safeId ? tab.safeId() : null,\n            tabIndex: tabIndex,\n            setSize: tabs.length,\n            posInSet: index + 1,\n            noKeyNav: _this9.noKeyNav\n          },\n          on: {\n            click: function click(evt) {\n              _this9.clickTab(tab, evt);\n            },\n            first: _this9.firstTab,\n            prev: _this9.previousTab,\n            next: _this9.nextTab,\n            last: _this9.lastTab\n          }\n        });\n      }); // Nav\n\n      var nav = h(BNav, {\n        ref: 'nav',\n        class: this.localNavClass,\n        attrs: {\n          role: 'tablist',\n          id: this.safeId('_BV_tab_controls_')\n        },\n        props: {\n          fill: this.fill,\n          justified: this.justified,\n          align: this.align,\n          tabs: !this.noNavStyle && !this.pills,\n          pills: !this.noNavStyle && this.pills,\n          vertical: this.vertical,\n          small: this.small,\n          cardHeader: this.card && !this.vertical\n        }\n      }, [this.normalizeSlot('tabs-start') || h(), buttons, this.normalizeSlot('tabs-end') || h()]);\n      nav = h('div', {\n        key: 'bv-tabs-nav',\n        class: [{\n          'card-header': this.card && !this.vertical && !this.end,\n          'card-footer': this.card && !this.vertical && this.end,\n          'col-auto': this.vertical\n        }, this.navWrapperClass]\n      }, [nav]);\n      var empty = h();\n\n      if (!tabs || tabs.length === 0) {\n        empty = h('div', {\n          key: 'bv-empty-tab',\n          class: ['tab-pane', 'active', {\n            'card-body': this.card\n          }]\n        }, this.normalizeSlot('empty'));\n      } // Main content section\n\n\n      var content = h('div', {\n        ref: 'tabsContainer',\n        key: 'bv-tabs-container',\n        staticClass: 'tab-content',\n        class: [{\n          col: this.vertical\n        }, this.contentClass],\n        attrs: {\n          id: this.safeId('_BV_tab_container_')\n        }\n      }, concat(this.normalizeSlot('default'), empty)); // Render final output\n\n      return h(this.tag, {\n        staticClass: 'tabs',\n        class: {\n          row: this.vertical,\n          'no-gutters': this.vertical && this.card\n        },\n        attrs: {\n          id: this.safeId()\n        }\n      }, [this.end ? content : h(), [nav], this.end ? h() : content]);\n    }\n  });\n\n  var BTab =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BTab',\n    mixins: [idMixin, normalizeSlotMixin],\n    inject: {\n      bvTabs: {\n        default: function _default() {\n          return {};\n        }\n      }\n    },\n    props: {\n      active: {\n        type: Boolean,\n        default: false\n      },\n      tag: {\n        type: String,\n        default: 'div'\n      },\n      buttonId: {\n        type: String,\n        default: ''\n      },\n      title: {\n        type: String,\n        default: ''\n      },\n      titleItemClass: {\n        // Sniffed by tabs.js and added to nav 'li.nav-item'\n        type: [String, Array, Object],\n        default: null\n      },\n      titleLinkClass: {\n        // Sniffed by tabs.js and added to nav 'a.nav-link'\n        type: [String, Array, Object],\n        default: null\n      },\n      disabled: {\n        type: Boolean,\n        default: false\n      },\n      noBody: {\n        type: Boolean,\n        default: false\n      },\n      lazy: {\n        type: Boolean,\n        default: false\n      }\n    },\n    data: function data() {\n      return {\n        localActive: this.active && !this.disabled,\n        show: false\n      };\n    },\n    computed: {\n      tabClasses: function tabClasses() {\n        return [{\n          active: this.localActive,\n          disabled: this.disabled,\n          'card-body': this.bvTabs.card && !this.noBody\n        }, // Apply <b-tabs> `activeTabClass` styles when this tab is active\n        this.localActive ? this.bvTabs.activeTabClass : null];\n      },\n      controlledBy: function controlledBy() {\n        return this.buttonId || this.safeId('__BV_tab_button__');\n      },\n      computedNoFade: function computedNoFade() {\n        return !(this.bvTabs.fade || false);\n      },\n      computedLazy: function computedLazy() {\n        return this.bvTabs.lazy || this.lazy;\n      },\n      _isTab: function _isTab() {\n        // For parent sniffing of child\n        return true;\n      }\n    },\n    watch: {\n      localActive: function localActive(newVal) {\n        // Make 'active' prop work with `.sync` modifier\n        this.$emit('update:active', newVal);\n      },\n      active: function active(newVal, oldVal) {\n        if (newVal !== oldVal) {\n          if (newVal) {\n            // If activated post mount\n            this.activate();\n          } else {\n            /* istanbul ignore next */\n            if (!this.deactivate()) {\n              // Tab couldn't be deactivated, so we reset the synced active prop\n              // Deactivation will fail if no other tabs to activate\n              this.$emit('update:active', this.localActive);\n            }\n          }\n        }\n      },\n      disabled: function disabled(newVal, oldVal) {\n        if (newVal !== oldVal) {\n          if (newVal && this.localActive && this.bvTabs.firstTab) {\n            this.localActive = false;\n            this.bvTabs.firstTab();\n          }\n        }\n      }\n    },\n    mounted: function mounted() {\n      // Inform b-tabs of our presence\n      this.registerTab(); // Initially show on mount if active and not disabled\n\n      this.show = this.localActive;\n    },\n    updated: function updated() {\n      // Force the tab button content to update (since slots are not reactive)\n      // Only done if we have a title slot, as the title prop is reactive\n      if (this.hasNormalizedSlot('title') && this.bvTabs.updateButton) {\n        this.bvTabs.updateButton(this);\n      }\n    },\n    destroyed: function destroyed() {\n      // inform b-tabs of our departure\n      this.unregisterTab();\n    },\n    methods: {\n      // Private methods\n      registerTab: function registerTab() {\n        // Inform `b-tabs` of our presence\n        this.bvTabs.registerTab && this.bvTabs.registerTab(this);\n      },\n      unregisterTab: function unregisterTab() {\n        // Inform `b-tabs` of our departure\n        this.bvTabs.unregisterTab && this.bvTabs.unregisterTab(this);\n      },\n      // Public methods\n      activate: function activate() {\n        if (this.bvTabs.activateTab && !this.disabled) {\n          return this.bvTabs.activateTab(this);\n        } else {\n          // Not inside a <b-tabs> component or tab is disabled\n          return false;\n        }\n      },\n      deactivate: function deactivate() {\n        if (this.bvTabs.deactivateTab && this.localActive) {\n          return this.bvTabs.deactivateTab(this);\n        } else {\n          // Not inside a <b-tabs> component or not active to begin with\n          return false;\n        }\n      }\n    },\n    render: function render(h) {\n      var content = h(this.tag, {\n        ref: 'panel',\n        staticClass: 'tab-pane',\n        class: this.tabClasses,\n        directives: [{\n          name: 'show',\n          rawName: 'v-show',\n          value: this.localActive,\n          expression: 'localActive'\n        }],\n        attrs: {\n          role: 'tabpanel',\n          id: this.safeId(),\n          'aria-hidden': this.localActive ? 'false' : 'true',\n          'aria-labelledby': this.controlledBy || null\n        }\n      }, // Render content lazily if requested\n      [this.localActive || !this.computedLazy ? this.normalizeSlot('default') : h()]);\n      return h(BVTransition, {\n        props: {\n          mode: 'out-in',\n          noFade: this.computedNoFade\n        }\n      }, [content]);\n    }\n  });\n\n  var TabsPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BTabs: BTabs,\n      BTab: BTab\n    }\n  });\n\n  function _typeof$1(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof$1 = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof$1 = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof$1(obj);\n  }\n\n  function _toConsumableArray$1(arr) {\n    return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _nonIterableSpread$1();\n  }\n\n  function _arrayWithoutHoles$1(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _iterableToArray$1(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n  }\n\n  function _nonIterableSpread$1() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n  }\n\n  var inBrowser = typeof window !== 'undefined';\n  function freeze$1(item) {\n    if (Array.isArray(item) || _typeof$1(item) === 'object') {\n      return Object.freeze(item);\n    }\n\n    return item;\n  }\n  function combinePassengers(transports) {\n    var slotProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return transports.reduce(function (passengers, transport) {\n      var temp = transport.passengers[0];\n      var newPassengers = typeof temp === 'function' ? temp(slotProps) : transport.passengers;\n      return passengers.concat(newPassengers);\n    }, []);\n  }\n  function stableSort$1(array, compareFn) {\n    return array.map(function (v, idx) {\n      return [idx, v];\n    }).sort(function (a, b) {\n      return compareFn(a[1], b[1]) || a[0] - b[0];\n    }).map(function (c) {\n      return c[1];\n    });\n  }\n  function pick(obj, keys) {\n    return keys.reduce(function (acc, key) {\n      if (obj.hasOwnProperty(key)) {\n        acc[key] = obj[key];\n      }\n\n      return acc;\n    }, {});\n  }\n\n  var transports = {};\n  var targets = {};\n  var sources = {};\n  var Wormhole = Vue.extend({\n    data: function data() {\n      return {\n        transports: transports,\n        targets: targets,\n        sources: sources,\n        trackInstances: inBrowser\n      };\n    },\n    methods: {\n      open: function open(transport) {\n        if (!inBrowser) return;\n        var to = transport.to,\n            from = transport.from,\n            passengers = transport.passengers,\n            _transport$order = transport.order,\n            order = _transport$order === void 0 ? Infinity : _transport$order;\n        if (!to || !from || !passengers) return;\n        var newTransport = {\n          to: to,\n          from: from,\n          passengers: freeze$1(passengers),\n          order: order\n        };\n        var keys = Object.keys(this.transports);\n\n        if (keys.indexOf(to) === -1) {\n          Vue.set(this.transports, to, []);\n        }\n\n        var currentIndex = this.$_getTransportIndex(newTransport); // Copying the array here so that the PortalTarget change event will actually contain two distinct arrays\n\n        var newTransports = this.transports[to].slice(0);\n\n        if (currentIndex === -1) {\n          newTransports.push(newTransport);\n        } else {\n          newTransports[currentIndex] = newTransport;\n        }\n\n        this.transports[to] = stableSort$1(newTransports, function (a, b) {\n          return a.order - b.order;\n        });\n      },\n      close: function close(transport) {\n        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var to = transport.to,\n            from = transport.from;\n        if (!to || !from && force === false) return;\n\n        if (!this.transports[to]) {\n          return;\n        }\n\n        if (force) {\n          this.transports[to] = [];\n        } else {\n          var index = this.$_getTransportIndex(transport);\n\n          if (index >= 0) {\n            // Copying the array here so that the PortalTarget change event will actually contain two distinct arrays\n            var newTransports = this.transports[to].slice(0);\n            newTransports.splice(index, 1);\n            this.transports[to] = newTransports;\n          }\n        }\n      },\n      registerTarget: function registerTarget(target, vm, force) {\n        if (!inBrowser) return;\n\n        if (this.trackInstances && !force && this.targets[target]) {\n          console.warn(\"[portal-vue]: Target \".concat(target, \" already exists\"));\n        }\n\n        this.$set(this.targets, target, Object.freeze([vm]));\n      },\n      unregisterTarget: function unregisterTarget(target) {\n        this.$delete(this.targets, target);\n      },\n      registerSource: function registerSource(source, vm, force) {\n        if (!inBrowser) return;\n\n        if (this.trackInstances && !force && this.sources[source]) {\n          console.warn(\"[portal-vue]: source \".concat(source, \" already exists\"));\n        }\n\n        this.$set(this.sources, source, Object.freeze([vm]));\n      },\n      unregisterSource: function unregisterSource(source) {\n        this.$delete(this.sources, source);\n      },\n      hasTarget: function hasTarget(to) {\n        return !!(this.targets[to] && this.targets[to][0]);\n      },\n      hasSource: function hasSource(to) {\n        return !!(this.sources[to] && this.sources[to][0]);\n      },\n      hasContentFor: function hasContentFor(to) {\n        return !!this.transports[to] && !!this.transports[to].length;\n      },\n      // Internal\n      $_getTransportIndex: function $_getTransportIndex(_ref) {\n        var to = _ref.to,\n            from = _ref.from;\n\n        for (var i in this.transports[to]) {\n          if (this.transports[to][i].from === from) {\n            return +i;\n          }\n        }\n\n        return -1;\n      }\n    }\n  });\n  var wormhole = new Wormhole(transports);\n\n  var _id = 1;\n  var Portal = Vue.extend({\n    name: 'portal',\n    props: {\n      disabled: {\n        type: Boolean\n      },\n      name: {\n        type: String,\n        default: function _default() {\n          return String(_id++);\n        }\n      },\n      order: {\n        type: Number,\n        default: 0\n      },\n      slim: {\n        type: Boolean\n      },\n      slotProps: {\n        type: Object,\n        default: function _default() {\n          return {};\n        }\n      },\n      tag: {\n        type: String,\n        default: 'DIV'\n      },\n      to: {\n        type: String,\n        default: function _default() {\n          return String(Math.round(Math.random() * 10000000));\n        }\n      }\n    },\n    created: function created() {\n      var _this = this;\n\n      this.$nextTick(function () {\n        wormhole.registerSource(_this.name, _this);\n      });\n    },\n    mounted: function mounted() {\n      if (!this.disabled) {\n        this.sendUpdate();\n      }\n    },\n    updated: function updated() {\n      if (this.disabled) {\n        this.clear();\n      } else {\n        this.sendUpdate();\n      }\n    },\n    beforeDestroy: function beforeDestroy() {\n      wormhole.unregisterSource(this.name);\n      this.clear();\n    },\n    watch: {\n      to: function to(newValue, oldValue) {\n        oldValue && oldValue !== newValue && this.clear(oldValue);\n        this.sendUpdate();\n      }\n    },\n    methods: {\n      clear: function clear(target) {\n        var closer = {\n          from: this.name,\n          to: target || this.to\n        };\n        wormhole.close(closer);\n      },\n      normalizeSlots: function normalizeSlots() {\n        return this.$scopedSlots.default ? [this.$scopedSlots.default] : this.$slots.default;\n      },\n      normalizeOwnChildren: function normalizeOwnChildren(children) {\n        return typeof children === 'function' ? children(this.slotProps) : children;\n      },\n      sendUpdate: function sendUpdate() {\n        var slotContent = this.normalizeSlots();\n\n        if (slotContent) {\n          var transport = {\n            from: this.name,\n            to: this.to,\n            passengers: _toConsumableArray$1(slotContent),\n            order: this.order\n          };\n          wormhole.open(transport);\n        } else {\n          this.clear();\n        }\n      }\n    },\n    render: function render(h) {\n      var children = this.$slots.default || this.$scopedSlots.default || [];\n      var Tag = this.tag;\n\n      if (children && this.disabled) {\n        return children.length <= 1 && this.slim ? this.normalizeOwnChildren(children)[0] : h(Tag, [this.normalizeOwnChildren(children)]);\n      } else {\n        return this.slim ? h() : h(Tag, {\n          class: {\n            'v-portal': true\n          },\n          style: {\n            display: 'none'\n          },\n          key: 'v-portal-placeholder'\n        });\n      }\n    }\n  });\n\n  var PortalTarget = Vue.extend({\n    name: 'portalTarget',\n    props: {\n      multiple: {\n        type: Boolean,\n        default: false\n      },\n      name: {\n        type: String,\n        required: true\n      },\n      slim: {\n        type: Boolean,\n        default: false\n      },\n      slotProps: {\n        type: Object,\n        default: function _default() {\n          return {};\n        }\n      },\n      tag: {\n        type: String,\n        default: 'div'\n      },\n      transition: {\n        type: [String, Object, Function]\n      }\n    },\n    data: function data() {\n      return {\n        transports: wormhole.transports,\n        firstRender: true\n      };\n    },\n    created: function created() {\n      var _this = this;\n\n      this.$nextTick(function () {\n        wormhole.registerTarget(_this.name, _this);\n      });\n    },\n    watch: {\n      ownTransports: function ownTransports() {\n        this.$emit('change', this.children().length > 0);\n      },\n      name: function name(newVal, oldVal) {\n        /**\r\n         * TODO\r\n         * This should warn as well ...\r\n         */\n        wormhole.unregisterTarget(oldVal);\n        wormhole.registerTarget(newVal, this);\n      }\n    },\n    mounted: function mounted() {\n      var _this2 = this;\n\n      if (this.transition) {\n        this.$nextTick(function () {\n          // only when we have a transition, because it causes a re-render\n          _this2.firstRender = false;\n        });\n      }\n    },\n    beforeDestroy: function beforeDestroy() {\n      wormhole.unregisterTarget(this.name);\n    },\n    computed: {\n      ownTransports: function ownTransports() {\n        var transports = this.transports[this.name] || [];\n\n        if (this.multiple) {\n          return transports;\n        }\n\n        return transports.length === 0 ? [] : [transports[transports.length - 1]];\n      },\n      passengers: function passengers() {\n        return combinePassengers(this.ownTransports, this.slotProps);\n      }\n    },\n    methods: {\n      // can't be a computed prop because it has to \"react\" to $slot changes.\n      children: function children() {\n        return this.passengers.length !== 0 ? this.passengers : this.$scopedSlots.default ? this.$scopedSlots.default(this.slotProps) : this.$slots.default || [];\n      },\n      // can't be a computed prop because it has to \"react\" to this.children().\n      noWrapper: function noWrapper() {\n        var noWrapper = this.slim && !this.transition;\n\n        if (noWrapper && this.children().length > 1) {\n          console.warn('[portal-vue]: PortalTarget with `slim` option received more than one child element.');\n        }\n\n        return noWrapper;\n      }\n    },\n    render: function render(h) {\n      var noWrapper = this.noWrapper();\n      var children = this.children();\n      var Tag = this.transition || this.tag;\n      return noWrapper ? children[0] : this.slim && !Tag ? h() : h(Tag, {\n        props: {\n          // if we have a transition component, pass the tag if it exists\n          tag: this.transition && this.tag ? this.tag : undefined\n        },\n        class: {\n          'vue-portal-target': true\n        }\n      }, children);\n    }\n  });\n\n  var _id$1 = 0;\n  var portalProps = ['disabled', 'name', 'order', 'slim', 'slotProps', 'tag', 'to'];\n  var targetProps = ['multiple', 'transition'];\n  var MountingPortal = Vue.extend({\n    name: 'MountingPortal',\n    inheritAttrs: false,\n    props: {\n      append: {\n        type: [Boolean, String]\n      },\n      bail: {\n        type: Boolean\n      },\n      mountTo: {\n        type: String,\n        required: true\n      },\n      // Portal\n      disabled: {\n        type: Boolean\n      },\n      // name for the portal\n      name: {\n        type: String,\n        default: function _default() {\n          return 'mounted_' + String(_id$1++);\n        }\n      },\n      order: {\n        type: Number,\n        default: 0\n      },\n      slim: {\n        type: Boolean\n      },\n      slotProps: {\n        type: Object,\n        default: function _default() {\n          return {};\n        }\n      },\n      tag: {\n        type: String,\n        default: 'DIV'\n      },\n      // name for the target\n      to: {\n        type: String,\n        default: function _default() {\n          return String(Math.round(Math.random() * 10000000));\n        }\n      },\n      // Target\n      multiple: {\n        type: Boolean,\n        default: false\n      },\n      targetSlim: {\n        type: Boolean\n      },\n      targetSlotProps: {\n        type: Object,\n        default: function _default() {\n          return {};\n        }\n      },\n      targetTag: {\n        type: String,\n        default: 'div'\n      },\n      transition: {\n        type: [String, Object, Function]\n      }\n    },\n    created: function created() {\n      if (typeof document === 'undefined') return;\n      var el = document.querySelector(this.mountTo);\n\n      if (!el) {\n        console.error(\"[portal-vue]: Mount Point '\".concat(this.mountTo, \"' not found in document\"));\n        return;\n      }\n\n      var props = this.$props; // Target already exists\n\n      if (wormhole.targets[props.name]) {\n        if (props.bail) {\n          console.warn(\"[portal-vue]: Target \".concat(props.name, \" is already mounted.\\n        Aborting because 'bail: true' is set\"));\n        } else {\n          this.portalTarget = wormhole.targets[props.name];\n        }\n\n        return;\n      }\n\n      var append = props.append;\n\n      if (append) {\n        var type = typeof append === 'string' ? append : 'DIV';\n        var mountEl = document.createElement(type);\n        el.appendChild(mountEl);\n        el = mountEl;\n      } // get props for target from $props\n      // we have to rename a few of them\n\n\n      var _props = pick(this.$props, targetProps);\n\n      _props.slim = this.targetSlim;\n      _props.tag = this.targetTag;\n      _props.slotProps = this.targetSlotProps;\n      _props.name = this.to;\n      this.portalTarget = new PortalTarget({\n        el: el,\n        parent: this.$parent || this,\n        propsData: _props\n      });\n    },\n    beforeDestroy: function beforeDestroy() {\n      var target = this.portalTarget;\n\n      if (this.append) {\n        var el = target.$el;\n        el.parentNode.removeChild(el);\n      }\n\n      target.$destroy();\n    },\n    render: function render(h) {\n      if (!this.portalTarget) {\n        console.warn(\"[portal-vue] Target wasn't mounted\");\n        return h();\n      } // if there's no \"manual\" scoped slot, so we create a <Portal> ourselves\n\n\n      if (!this.$scopedSlots.manual) {\n        var props = pick(this.$props, portalProps);\n        return h(Portal, {\n          props: props,\n          attrs: this.$attrs,\n          on: this.$listeners,\n          scopedSlots: this.$scopedSlots\n        }, this.$slots.default);\n      } // else, we render the scoped slot\n\n\n      var content = this.$scopedSlots.manual({\n        to: this.to\n      }); // if user used <template> for the scoped slot\n      // content will be an array\n\n      if (Array.isArray(content)) {\n        content = content[0];\n      }\n\n      if (!content) return h();\n      return content;\n    }\n  });\n\n  var NAME$C = 'BToaster';\n  var props$Z = {\n    name: {\n      type: String,\n      required: true\n    },\n    ariaLive: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$C, 'ariaLive');\n      }\n    },\n    ariaAtomic: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$C, 'ariaAtomic');\n      } // Allowed: 'true' or 'false' or null\n\n    },\n    role: {\n      // Aria role\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$C, 'role');\n      }\n    }\n    /*\n    transition: {\n      type: [Boolean, String, Object],\n      default: false\n    }\n    */\n\n  }; // @vue/component\n\n  var DefaultTransition =\n  /*#__PURE__*/\n  Vue.extend({\n    data: function data() {\n      return {\n        // Transition classes base name\n        name: 'b-toaster'\n      };\n    },\n    methods: {\n      onAfterEnter: function onAfterEnter(el) {\n        var _this = this;\n\n        // Handle bug where enter-to class is not removed.\n        // Bug is related to portal-vue and transition-groups.\n        requestAF(function () {\n          removeClass(el, \"\".concat(_this.name, \"-enter-to\")); // The *-move class is also stuck on elements that moved,\n          // but there are no javascript hooks to handle after move.\n        });\n      }\n    },\n    render: function render(h) {\n      return h('transition-group', {\n        props: {\n          tag: 'div',\n          name: this.name\n        },\n        on: {\n          afterEnter: this.onAfterEnter\n        }\n      }, this.$slots.default);\n    }\n  }); // @vue/component\n\n  var BToaster =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$C,\n    props: props$Z,\n    data: function data() {\n      return {\n        // We don't render on SSR or if a an existing target found\n        doRender: false,\n        dead: false,\n        // Toaster names cannot change once created\n        staticName: this.name\n      };\n    },\n    beforeMount: function beforeMount() {\n      var _this2 = this;\n\n      this.staticName = this.name;\n      /* istanbul ignore if */\n\n      if (wormhole.hasTarget(this.staticName)) {\n        warn(\"A \\\"<portal-target>\\\" with name \\\"\".concat(this.name, \"\\\" already exists in the document.\"), 'BToaster');\n        this.dead = true;\n      } else {\n        this.doRender = true;\n        this.$once('hook:beforeDestroy', function () {\n          // Let toasts made with `this.$bvToast.toast()` know that this toaster\n          // is being destroyed and should should also destroy/hide themselves\n          _this2.$root.$emit('bv::toaster::destroyed', _this2.staticName);\n        });\n      }\n    },\n    destroyed: function destroyed() {\n      // Remove from DOM if needed\n\n      /* istanbul ignore next: difficult to test */\n      if (this.$el && this.$el.parentNode) {\n        this.$el.parentNode.removeChild(this.$el);\n      }\n    },\n    render: function render(h) {\n      var $toaster = h('div', {\n        class: ['d-none', {\n          'b-dead-toaster': this.dead\n        }]\n      });\n\n      if (this.doRender) {\n        var $target = h(PortalTarget, {\n          staticClass: 'b-toaster-slot',\n          props: {\n            name: this.staticName,\n            multiple: true,\n            tag: 'div',\n            slim: false,\n            // transition: this.transition || DefaultTransition\n            transition: DefaultTransition\n          }\n        });\n        $toaster = h('div', {\n          staticClass: 'b-toaster',\n          class: [this.staticName],\n          attrs: {\n            id: this.staticName,\n            role: this.role || null,\n            // Fallback to null to make sure attribute doesn't exist\n            'aria-live': this.ariaLive,\n            'aria-atomic': this.ariaAtomic\n          }\n        }, [$target]);\n      }\n\n      return $toaster;\n    }\n  });\n\n  var NAME$D = 'BToast';\n  var MIN_DURATION = 1000; // --- Props ---\n\n  var props$_ = {\n    id: {\n      // Even though the ID prop is provided by idMixin, we\n      // add it here for $bvToast props filtering\n      type: String,\n      default: null\n    },\n    title: {\n      type: String,\n      default: null\n    },\n    toaster: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$D, 'toaster');\n      }\n    },\n    visible: {\n      type: Boolean,\n      default: false\n    },\n    variant: {\n      type: String,\n      default: function _default() {\n        return getComponentConfig(NAME$D, 'variant');\n      }\n    },\n    isStatus: {\n      // Switches role to 'status' and aria-live to 'polite'\n      type: Boolean,\n      default: false\n    },\n    appendToast: {\n      type: Boolean,\n      default: false\n    },\n    noAutoHide: {\n      type: Boolean,\n      default: false\n    },\n    autoHideDelay: {\n      type: [Number, String],\n      default: function _default() {\n        return getComponentConfig(NAME$D, 'autoHideDelay');\n      }\n    },\n    noCloseButton: {\n      type: Boolean,\n      default: false\n    },\n    noFade: {\n      type: Boolean,\n      default: false\n    },\n    noHoverPause: {\n      type: Boolean,\n      default: false\n    },\n    solid: {\n      type: Boolean,\n      default: false\n    },\n    toastClass: {\n      type: [String, Object, Array],\n      default: function _default() {\n        return getComponentConfig(NAME$D, 'toastClass');\n      }\n    },\n    headerClass: {\n      type: [String, Object, Array],\n      default: function _default() {\n        return getComponentConfig(NAME$D, 'headerClass');\n      }\n    },\n    bodyClass: {\n      type: [String, Object, Array],\n      default: function _default() {\n        return getComponentConfig(NAME$D, 'bodyClass');\n      }\n    },\n    href: {\n      type: String,\n      default: null\n    },\n    to: {\n      type: [String, Object],\n      default: null\n    },\n    static: {\n      // Render the toast in place, rather than in a portal-target\n      type: Boolean,\n      default: false\n    }\n  }; // @vue/component\n\n  var BToast =\n  /*#__PURE__*/\n  Vue.extend({\n    name: NAME$D,\n    mixins: [idMixin, listenOnRootMixin, normalizeSlotMixin, scopedStyleAttrsMixin],\n    inheritAttrs: false,\n    model: {\n      prop: 'visible',\n      event: 'change'\n    },\n    props: props$_,\n    data: function data() {\n      return {\n        isMounted: false,\n        doRender: false,\n        localShow: false,\n        isTransitioning: false,\n        isHiding: false,\n        order: 0,\n        timer: null,\n        dismissStarted: 0,\n        resumeDismiss: 0\n      };\n    },\n    computed: {\n      bToastClasses: function bToastClasses() {\n        return _defineProperty({\n          'b-toast-solid': this.solid,\n          'b-toast-append': this.appendToast,\n          'b-toast-prepend': !this.appendToast\n        }, \"b-toast-\".concat(this.variant), this.variant);\n      },\n      slotScope: function slotScope() {\n        return {\n          hide: this.hide\n        };\n      },\n      computedDuration: function computedDuration() {\n        // Minimum supported duration is 1 second\n        return Math.max(toInteger(this.autoHideDelay) || 0, MIN_DURATION);\n      },\n      computedToaster: function computedToaster() {\n        return String(this.toaster);\n      },\n      transitionHandlers: function transitionHandlers() {\n        return {\n          beforeEnter: this.onBeforeEnter,\n          afterEnter: this.onAfterEnter,\n          beforeLeave: this.onBeforeLeave,\n          afterLeave: this.onAfterLeave\n        };\n      }\n    },\n    watch: {\n      visible: function visible(newVal) {\n        newVal ? this.show() : this.hide();\n      },\n      localShow: function localShow(newVal) {\n        if (newVal !== this.visible) {\n          this.$emit('change', newVal);\n        }\n      },\n      toaster: function toaster()\n      /* istanbul ignore next */\n      {\n        // If toaster target changed, make sure toaster exists\n        this.$nextTick(this.ensureToaster);\n      },\n      static: function _static(newVal)\n      /* istanbul ignore next */\n      {\n        // If static changes to true, and the toast is showing,\n        // ensure the toaster target exists\n        if (newVal && this.localShow) {\n          this.ensureToaster();\n        }\n      }\n    },\n    mounted: function mounted() {\n      var _this = this;\n\n      this.isMounted = true;\n      this.$nextTick(function () {\n        if (_this.visible) {\n          requestAF(function () {\n            _this.show();\n          });\n        }\n      }); // Listen for global $root show events\n\n      this.listenOnRoot('bv::show::toast', function (id) {\n        if (id === _this.safeId()) {\n          _this.show();\n        }\n      }); // Listen for global $root hide events\n\n      this.listenOnRoot('bv::hide::toast', function (id) {\n        if (!id || id === _this.safeId()) {\n          _this.hide();\n        }\n      }); // Make sure we hide when toaster is destroyed\n\n      /* istanbul ignore next: difficult to test */\n\n      this.listenOnRoot('bv::toaster::destroyed', function (toaster) {\n        /* istanbul ignore next */\n        if (toaster === _this.computedToaster) {\n          /* istanbul ignore next */\n          _this.hide();\n        }\n      });\n    },\n    beforeDestroy: function beforeDestroy() {\n      this.clearDismissTimer();\n    },\n    methods: {\n      show: function show() {\n        var _this2 = this;\n\n        if (!this.localShow) {\n          this.ensureToaster();\n          var showEvt = this.buildEvent('show');\n          this.emitEvent(showEvt);\n          this.dismissStarted = this.resumeDismiss = 0;\n          this.order = Date.now() * (this.appendToast ? 1 : -1);\n          this.isHiding = false;\n          this.doRender = true;\n          this.$nextTick(function () {\n            // We show the toast after we have rendered the portal and b-toast wrapper\n            // so that screen readers will properly announce the toast\n            requestAF(function () {\n              _this2.localShow = true;\n            });\n          });\n        }\n      },\n      hide: function hide() {\n        var _this3 = this;\n\n        if (this.localShow) {\n          var hideEvt = this.buildEvent('hide');\n          this.emitEvent(hideEvt);\n          this.setHoverHandler(false);\n          this.dismissStarted = this.resumeDismiss = 0;\n          this.clearDismissTimer();\n          this.isHiding = true;\n          requestAF(function () {\n            _this3.localShow = false;\n          });\n        }\n      },\n      buildEvent: function buildEvent(type) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return new BvEvent(type, _objectSpread2({\n          cancelable: false,\n          target: this.$el || null,\n          relatedTarget: null\n        }, options, {\n          vueTarget: this,\n          componentId: this.safeId()\n        }));\n      },\n      emitEvent: function emitEvent(bvEvt) {\n        var type = bvEvt.type;\n        this.$root.$emit(\"bv::toast:\".concat(type), bvEvt);\n        this.$emit(type, bvEvt);\n      },\n      ensureToaster: function ensureToaster() {\n        if (this.static) {\n          return;\n        }\n\n        if (!wormhole.hasTarget(this.computedToaster)) {\n          var div = document.createElement('div');\n          document.body.appendChild(div);\n          var toaster = new BToaster({\n            parent: this.$root,\n            propsData: {\n              name: this.computedToaster\n            }\n          });\n          toaster.$mount(div);\n        }\n      },\n      startDismissTimer: function startDismissTimer() {\n        this.clearDismissTimer();\n\n        if (!this.noAutoHide) {\n          this.timer = setTimeout(this.hide, this.resumeDismiss || this.computedDuration);\n          this.dismissStarted = Date.now();\n          this.resumeDismiss = 0;\n        }\n      },\n      clearDismissTimer: function clearDismissTimer() {\n        clearTimeout(this.timer);\n        this.timer = null;\n      },\n      setHoverHandler: function setHoverHandler(on) {\n        var el = this.$refs['b-toast'];\n        eventOnOff(on, el, 'mouseenter', this.onPause, EVENT_OPTIONS_NO_CAPTURE);\n        eventOnOff(on, el, 'mouseleave', this.onUnPause, EVENT_OPTIONS_NO_CAPTURE);\n      },\n      onPause: function onPause() {\n        // Determine time remaining, and then pause timer\n        if (this.noAutoHide || this.noHoverPause || !this.timer || this.resumeDismiss) {\n          return;\n        }\n\n        var passed = Date.now() - this.dismissStarted;\n\n        if (passed > 0) {\n          this.clearDismissTimer();\n          this.resumeDismiss = Math.max(this.computedDuration - passed, MIN_DURATION);\n        }\n      },\n      onUnPause: function onUnPause() {\n        // Restart timer with max of time remaining or 1 second\n        if (this.noAutoHide || this.noHoverPause || !this.resumeDismiss) {\n          this.resumeDismiss = this.dismissStarted = 0;\n          return;\n        }\n\n        this.startDismissTimer();\n      },\n      onLinkClick: function onLinkClick() {\n        var _this4 = this;\n\n        // We delay the close to allow time for the\n        // browser to process the link click\n        this.$nextTick(function () {\n          requestAF(function () {\n            _this4.hide();\n          });\n        });\n      },\n      onBeforeEnter: function onBeforeEnter() {\n        this.isTransitioning = true;\n      },\n      onAfterEnter: function onAfterEnter() {\n        this.isTransitioning = false;\n        var hiddenEvt = this.buildEvent('shown');\n        this.emitEvent(hiddenEvt);\n        this.startDismissTimer();\n        this.setHoverHandler(true);\n      },\n      onBeforeLeave: function onBeforeLeave() {\n        this.isTransitioning = true;\n      },\n      onAfterLeave: function onAfterLeave() {\n        this.isTransitioning = false;\n        this.order = 0;\n        this.resumeDismiss = this.dismissStarted = 0;\n        var hiddenEvt = this.buildEvent('hidden');\n        this.emitEvent(hiddenEvt);\n        this.doRender = false;\n      },\n      makeToast: function makeToast(h) {\n        var _this5 = this;\n\n        // Render helper for generating the toast\n        // Assemble the header content\n        var $headerContent = [];\n        var $title = this.normalizeSlot('toast-title', this.slotScope);\n\n        if ($title) {\n          $headerContent.push($title);\n        } else if (this.title) {\n          $headerContent.push(h('strong', {\n            staticClass: 'mr-2'\n          }, this.title));\n        }\n\n        if (!this.noCloseButton) {\n          $headerContent.push(h(BButtonClose, {\n            staticClass: 'ml-auto mb-1',\n            on: {\n              click: function click() {\n                _this5.hide();\n              }\n            }\n          }));\n        } // Assemble the header (if needed)\n\n\n        var $header = h();\n\n        if ($headerContent.length > 0) {\n          $header = h('header', {\n            staticClass: 'toast-header',\n            class: this.headerClass\n          }, $headerContent);\n        } // Toast body\n\n\n        var isLink = this.href || this.to;\n        var $body = h(isLink ? BLink : 'div', {\n          staticClass: 'toast-body',\n          class: this.bodyClass,\n          props: isLink ? {\n            to: this.to,\n            href: this.href\n          } : {},\n          on: isLink ? {\n            click: this.onLinkClick\n          } : {}\n        }, [this.normalizeSlot('default', this.slotScope) || h()]); // Build the toast\n\n        var $toast = h('div', {\n          key: \"toast-\".concat(this._uid),\n          ref: 'toast',\n          staticClass: 'toast',\n          class: this.toastClass,\n          attrs: _objectSpread2({}, this.$attrs, {\n            tabindex: '0',\n            id: this.safeId()\n          })\n        }, [$header, $body]);\n        return $toast;\n      }\n    },\n    render: function render(h) {\n      if (!this.doRender || !this.isMounted) {\n        return h();\n      }\n\n      var name = \"b-toast-\".concat(this._uid); // If scoped styles are applied and the toast is not static,\n      // make sure the scoped style data attribute is applied\n\n      var scopedStyleAttrs = !this.static ? this.scopedStyleAttrs : {};\n      return h(Portal, {\n        props: {\n          name: name,\n          to: this.computedToaster,\n          order: this.order,\n          slim: true,\n          disabled: this.static\n        }\n      }, [h('div', {\n        key: name,\n        ref: 'b-toast',\n        staticClass: 'b-toast',\n        class: this.bToastClasses,\n        attrs: _objectSpread2({}, scopedStyleAttrs, {\n          id: this.safeId('_toast_outer'),\n          role: this.isHiding ? null : this.isStatus ? 'status' : 'alert',\n          'aria-live': this.isHiding ? null : this.isStatus ? 'polite' : 'assertive',\n          'aria-atomic': this.isHiding ? null : 'true'\n        })\n      }, [h(BVTransition, {\n        props: {\n          noFade: this.noFade\n        },\n        on: this.transitionHandlers\n      }, [this.localShow ? this.makeToast(h) : h()])])]);\n    }\n  });\n\n  var PROP_NAME$3 = '$bvToast';\n  var PROP_NAME_PRIV$1 = '_bv__toast'; // Base toast props that are allowed\n  // Some may be ignored or overridden on some message boxes\n  // Prop ID is allowed, but really only should be used for testing\n  // We need to add it in explicitly as it comes from the `idMixin`\n\n  var BASE_PROPS$1 = ['id'].concat(_toConsumableArray(keys(omit(props$_, ['static', 'visible'])))); // Map prop names to toast slot names\n\n  var propsToSlots$1 = {\n    toastContent: 'default',\n    title: 'toast-title'\n  }; // --- Utility methods ---\n  // Method to filter only recognized props that are not undefined\n\n  var filterOptions$1 = function filterOptions(options) {\n    return BASE_PROPS$1.reduce(function (memo, key) {\n      if (!isUndefined(options[key])) {\n        memo[key] = options[key];\n      }\n\n      return memo;\n    }, {});\n  }; // Method to install `$bvToast` VM injection\n\n\n  var plugin$1 = function plugin(Vue) {\n    // Create a private sub-component constructor that\n    // extends BToast and self-destructs after hidden\n    // @vue/component\n    var BToastPop = Vue.extend({\n      name: 'BToastPop',\n      extends: BToast,\n      destroyed: function destroyed() {\n        // Make sure we not in document any more\n        if (this.$el && this.$el.parentNode) {\n          this.$el.parentNode.removeChild(this.$el);\n        }\n      },\n      mounted: function mounted() {\n        var self = this; // Self destruct handler\n\n        var handleDestroy = function handleDestroy() {\n          // Ensure the toast has been force hidden\n          self.localShow = false;\n          self.doRender = false;\n          self.$nextTick(function () {\n            self.$nextTick(function () {\n              // In a `requestAF()` to release control back to application\n              // and to allow the portal-target time to remove the content\n              requestAF(function () {\n                self.$destroy();\n              });\n            });\n          });\n        }; // Self destruct if parent destroyed\n\n\n        this.$parent.$once('hook:destroyed', handleDestroy); // Self destruct after hidden\n\n        this.$once('hidden', handleDestroy); // Self destruct when toaster is destroyed\n\n        this.listenOnRoot('bv::toaster::destroyed', function (toaster) {\n          /* istanbul ignore next: hard to test */\n          if (toaster === self.toaster) {\n            handleDestroy();\n          }\n        });\n      }\n    }); // Private method to generate the on-demand toast\n\n    var makeToast = function makeToast(props, $parent) {\n      if (warnNotClient(PROP_NAME$3)) {\n        /* istanbul ignore next */\n        return;\n      } // Create an instance of `BToastPop` component\n\n\n      var toast = new BToastPop({\n        // We set parent as the local VM so these toasts can emit events on the\n        // app `$root`, and it ensures `BToast` is destroyed when parent is destroyed\n        parent: $parent,\n        propsData: _objectSpread2({}, filterOptions$1(getComponentConfig('BToast') || {}), {}, omit(props, keys(propsToSlots$1)), {\n          // Props that can't be overridden\n          static: false,\n          visible: true\n        })\n      }); // Convert certain props to slots\n\n      keys(propsToSlots$1).forEach(function (prop) {\n        var value = props[prop];\n\n        if (!isUndefined(value)) {\n          // Can be a string, or array of VNodes\n          if (prop === 'title' && isString(value)) {\n            // Special case for title if it is a string, we wrap in a <strong>\n            value = [$parent.$createElement('strong', {\n              class: 'mr-2'\n            }, value)];\n          }\n\n          toast.$slots[propsToSlots$1[prop]] = concat(value);\n        }\n      }); // Create a mount point (a DIV) and mount it (which triggers the show)\n\n      var div = document.createElement('div');\n      document.body.appendChild(div);\n      toast.$mount(div);\n    }; // Declare BvToast instance property class\n\n\n    var BvToast =\n    /*#__PURE__*/\n    function () {\n      function BvToast(vm) {\n        _classCallCheck(this, BvToast);\n\n        // Assign the new properties to this instance\n        assign(this, {\n          _vm: vm,\n          _root: vm.$root\n        }); // Set these properties as read-only and non-enumerable\n\n        defineProperties(this, {\n          _vm: readonlyDescriptor(),\n          _root: readonlyDescriptor()\n        });\n      } // --- Public Instance methods ---\n      // Opens a user defined toast and returns immediately\n\n\n      _createClass(BvToast, [{\n        key: \"toast\",\n        value: function toast(content) {\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          if (!content || warnNotClient(PROP_NAME$3)) {\n            /* istanbul ignore next */\n            return;\n          }\n\n          makeToast(_objectSpread2({}, filterOptions$1(options), {\n            toastContent: content\n          }), this._vm);\n        } // shows a `<b-toast>` component with the specified ID\n\n      }, {\n        key: \"show\",\n        value: function show(id) {\n          if (id) {\n            this._root.$emit('bv::show::toast', id);\n          }\n        } // Hide a toast with specified ID, or if not ID all toasts\n\n      }, {\n        key: \"hide\",\n        value: function hide() {\n          var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n          this._root.$emit('bv::hide::toast', id);\n        }\n      }]);\n\n      return BvToast;\n    }(); // Add our instance mixin\n\n\n    Vue.mixin({\n      beforeCreate: function beforeCreate() {\n        // Because we need access to `$root` for `$emits`, and VM for parenting,\n        // we have to create a fresh instance of `BvToast` for each VM\n        this[PROP_NAME_PRIV$1] = new BvToast(this);\n      }\n    }); // Define our read-only `$bvToast` instance property\n    // Placed in an if just in case in HMR mode\n    // eslint-disable-next-line no-prototype-builtins\n\n    if (!Vue.prototype.hasOwnProperty(PROP_NAME$3)) {\n      defineProperty(Vue.prototype, PROP_NAME$3, {\n        get: function get() {\n          /* istanbul ignore next */\n          if (!this || !this[PROP_NAME_PRIV$1]) {\n            warn(\"\\\"\".concat(PROP_NAME$3, \"\\\" must be accessed from a Vue instance \\\"this\\\" context.\"), 'BToast');\n          }\n\n          return this[PROP_NAME_PRIV$1];\n        }\n      });\n    }\n  };\n\n  var BVToastPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    plugins: {\n      plugin: plugin$1\n    }\n  });\n\n  var ToastPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BToast: BToast,\n      BToaster: BToaster\n    },\n    // $bvToast injection\n    plugins: {\n      BVToastPlugin: BVToastPlugin\n    }\n  });\n\n  var BV_TOOLTIP = '__BV_Tooltip__'; // Default trigger\n\n  var DefaultTrigger$1 = 'hover focus'; // Valid event triggers\n\n  var validTriggers$1 = {\n    focus: true,\n    hover: true,\n    click: true,\n    blur: true,\n    manual: true\n  }; // Directive modifier test regular expressions. Pre-compile for performance\n\n  var htmlRE$1 = /^html$/i;\n  var noninteractiveRE = /^noninteractive$/i;\n  var noFadeRE$1 = /^nofade$/i;\n  var placementRE$1 = /^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/i;\n  var boundaryRE$1 = /^(window|viewport|scrollParent)$/i;\n  var delayRE$1 = /^d\\d+$/i;\n  var delayShowRE$1 = /^ds\\d+$/i;\n  var delayHideRE$1 = /^dh\\d+$/i;\n  var offsetRE$1 = /^o-?\\d+$/i;\n  var variantRE$1 = /^v-.+$/i;\n  var spacesRE$1 = /\\s+/; // Build a Tooltip config based on bindings (if any)\n  // Arguments and modifiers take precedence over passed value config object\n\n  var parseBindings$1 = function parseBindings(bindings, vnode)\n  /* istanbul ignore next: not easy to test */\n  {\n    // We start out with a basic config\n    var NAME = 'BTooltip'; // Default config\n\n    var config = {\n      title: undefined,\n      trigger: '',\n      // Default set below if needed\n      placement: 'top',\n      fallbackPlacement: 'flip',\n      container: false,\n      // Default of body\n      animation: true,\n      offset: 0,\n      id: null,\n      html: false,\n      interactive: true,\n      disabled: false,\n      delay: getComponentConfig(NAME, 'delay'),\n      boundary: String(getComponentConfig(NAME, 'boundary')),\n      boundaryPadding: parseInt(getComponentConfig(NAME, 'boundaryPadding'), 10) || 0,\n      variant: getComponentConfig(NAME, 'variant'),\n      customClass: getComponentConfig(NAME, 'customClass')\n    }; // Process `bindings.value`\n\n    if (isString(bindings.value) || isNumber(bindings.value)) {\n      // Value is tooltip content (HTML optionally supported)\n      config.title = bindings.value;\n    } else if (isFunction(bindings.value)) {\n      // Title generator function\n      config.title = bindings.value;\n    } else if (isPlainObject(bindings.value)) {\n      // Value is config object, so merge\n      config = _objectSpread2({}, config, {}, bindings.value);\n    } // If title is not provided, try title attribute\n\n\n    if (isUndefined(config.title)) {\n      // Try attribute\n      var data = vnode.data || {};\n      config.title = data.attrs && !isUndefinedOrNull(data.attrs.title) ? data.attrs.title : undefined;\n    } // Normalize delay\n\n\n    if (!isPlainObject(config.delay)) {\n      config.delay = {\n        show: parseInt(config.delay, 10) || 0,\n        hide: parseInt(config.delay, 10) || 0\n      };\n    } // If argument, assume element ID of container element\n\n\n    if (bindings.arg) {\n      // Element ID specified as arg\n      // We must prepend '#' to become a CSS selector\n      config.container = \"#\".concat(bindings.arg);\n    } // Process modifiers\n\n\n    keys(bindings.modifiers).forEach(function (mod) {\n      if (htmlRE$1.test(mod)) {\n        // Title allows HTML\n        config.html = true;\n      } else if (noninteractiveRE.test(mod)) {\n        // Noninteractive\n        config.interactive = false;\n      } else if (noFadeRE$1.test(mod)) {\n        // No animation\n        config.animation = false;\n      } else if (placementRE$1.test(mod)) {\n        // Placement of tooltip\n        config.placement = mod;\n      } else if (boundaryRE$1.test(mod)) {\n        // Boundary of tooltip\n        mod = mod === 'scrollparent' ? 'scrollParent' : mod;\n        config.boundary = mod;\n      } else if (delayRE$1.test(mod)) {\n        // Delay value\n        var delay = parseInt(mod.slice(1), 10) || 0;\n        config.delay.show = delay;\n        config.delay.hide = delay;\n      } else if (delayShowRE$1.test(mod)) {\n        // Delay show value\n        config.delay.show = parseInt(mod.slice(2), 10) || 0;\n      } else if (delayHideRE$1.test(mod)) {\n        // Delay hide value\n        config.delay.hide = parseInt(mod.slice(2), 10) || 0;\n      } else if (offsetRE$1.test(mod)) {\n        // Offset value, negative allowed\n        config.offset = parseInt(mod.slice(1), 10) || 0;\n      } else if (variantRE$1.test(mod)) {\n        // Variant\n        config.variant = mod.slice(2) || null;\n      }\n    }); // Special handling of event trigger modifiers trigger is\n    // a space separated list\n\n    var selectedTriggers = {}; // Parse current config object trigger\n\n    concat(config.trigger || '').filter(identity).join(' ').trim().toLowerCase().split(spacesRE$1).forEach(function (trigger) {\n      if (validTriggers$1[trigger]) {\n        selectedTriggers[trigger] = true;\n      }\n    }); // Parse modifiers for triggers\n\n    keys(bindings.modifiers).forEach(function (mod) {\n      mod = mod.toLowerCase();\n\n      if (validTriggers$1[mod]) {\n        // If modifier is a valid trigger\n        selectedTriggers[mod] = true;\n      }\n    }); // Sanitize triggers\n\n    config.trigger = keys(selectedTriggers).join(' ');\n\n    if (config.trigger === 'blur') {\n      // Blur by itself is useless, so convert it to 'focus'\n      config.trigger = 'focus';\n    }\n\n    if (!config.trigger) {\n      // Use default trigger\n      config.trigger = DefaultTrigger$1;\n    } // Return the config\n\n\n    return config;\n  }; // Add/update Tooltip on our element\n\n\n  var applyTooltip = function applyTooltip(el, bindings, vnode) {\n    if (!isBrowser) {\n      /* istanbul ignore next */\n      return;\n    }\n\n    var config = parseBindings$1(bindings, vnode);\n\n    if (!el[BV_TOOLTIP]) {\n      var $parent = vnode.context;\n      el[BV_TOOLTIP] = new BVTooltip({\n        parent: $parent,\n        // Add the parent's scoped style attribute data\n        _scopeId: getScopeId($parent, undefined)\n      });\n      el[BV_TOOLTIP].__bv_prev_data__ = {};\n      el[BV_TOOLTIP].$on('show', function ()\n      /* istanbul ignore next: for now */\n      {\n        // Before showing the tooltip, we update the title if it is a function\n        if (isFunction(config.title)) {\n          el[BV_TOOLTIP].updateData({\n            title: config.title(el)\n          });\n        }\n      });\n    }\n\n    var data = {\n      title: config.title,\n      triggers: config.trigger,\n      placement: config.placement,\n      fallbackPlacement: config.fallbackPlacement,\n      variant: config.variant,\n      customClass: config.customClass,\n      container: config.container,\n      boundary: config.boundary,\n      delay: config.delay,\n      offset: config.offset,\n      noFade: !config.animation,\n      id: config.id,\n      interactive: config.interactive,\n      disabled: config.disabled,\n      html: config.html\n    };\n    var oldData = el[BV_TOOLTIP].__bv_prev_data__;\n    el[BV_TOOLTIP].__bv_prev_data__ = data;\n\n    if (!looseEqual(data, oldData)) {\n      // We only update the instance if data has changed\n      var newData = {\n        target: el\n      };\n      keys(data).forEach(function (prop) {\n        // We only pass data properties that have changed\n        if (data[prop] !== oldData[prop]) {\n          // if title is a function, we execute it here\n          newData[prop] = prop === 'title' && isFunction(data[prop]) ? data[prop](el) : data[prop];\n        }\n      });\n      el[BV_TOOLTIP].updateData(newData);\n    }\n  }; // Remove Tooltip on our element\n\n\n  var removeTooltip = function removeTooltip(el) {\n    if (el[BV_TOOLTIP]) {\n      el[BV_TOOLTIP].$destroy();\n      el[BV_TOOLTIP] = null;\n    }\n\n    delete el[BV_TOOLTIP];\n  }; // Export our directive\n\n\n  var VBTooltip = {\n    bind: function bind(el, bindings, vnode) {\n      applyTooltip(el, bindings, vnode);\n    },\n    // We use `componentUpdated` here instead of `update`, as the former\n    // waits until the containing component and children have finished updating\n    componentUpdated: function componentUpdated(el, bindings, vnode) {\n      // Performed in a `$nextTick()` to prevent render update loops\n      vnode.context.$nextTick(function () {\n        applyTooltip(el, bindings, vnode);\n      });\n    },\n    unbind: function unbind(el) {\n      removeTooltip(el);\n    }\n  };\n\n  var VBTooltipPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    directives: {\n      VBTooltip: VBTooltip\n    }\n  });\n\n  var TooltipPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    components: {\n      BTooltip: BTooltip\n    },\n    plugins: {\n      VBTooltipPlugin: VBTooltipPlugin\n    }\n  });\n\n  var componentsPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    plugins: {\n      AlertPlugin: AlertPlugin,\n      BadgePlugin: BadgePlugin,\n      BreadcrumbPlugin: BreadcrumbPlugin,\n      ButtonPlugin: ButtonPlugin,\n      ButtonGroupPlugin: ButtonGroupPlugin,\n      ButtonToolbarPlugin: ButtonToolbarPlugin,\n      CalendarPlugin: CalendarPlugin,\n      CardPlugin: CardPlugin,\n      CarouselPlugin: CarouselPlugin,\n      CollapsePlugin: CollapsePlugin,\n      DropdownPlugin: DropdownPlugin,\n      EmbedPlugin: EmbedPlugin,\n      FormPlugin: FormPlugin,\n      FormCheckboxPlugin: FormCheckboxPlugin,\n      FormDatepickerPlugin: FormDatepickerPlugin,\n      FormFilePlugin: FormFilePlugin,\n      FormGroupPlugin: FormGroupPlugin,\n      FormInputPlugin: FormInputPlugin,\n      FormRadioPlugin: FormRadioPlugin,\n      FormSelectPlugin: FormSelectPlugin,\n      FormSpinbuttonPlugin: FormSpinbuttonPlugin,\n      FormTagsPlugin: FormTagsPlugin,\n      FormTextareaPlugin: FormTextareaPlugin,\n      ImagePlugin: ImagePlugin,\n      InputGroupPlugin: InputGroupPlugin,\n      JumbotronPlugin: JumbotronPlugin,\n      LayoutPlugin: LayoutPlugin,\n      LinkPlugin: LinkPlugin,\n      ListGroupPlugin: ListGroupPlugin,\n      MediaPlugin: MediaPlugin,\n      ModalPlugin: ModalPlugin,\n      NavPlugin: NavPlugin,\n      NavbarPlugin: NavbarPlugin,\n      PaginationPlugin: PaginationPlugin,\n      PaginationNavPlugin: PaginationNavPlugin,\n      PopoverPlugin: PopoverPlugin,\n      ProgressPlugin: ProgressPlugin,\n      SpinnerPlugin: SpinnerPlugin,\n      TablePlugin: TablePlugin,\n      TabsPlugin: TabsPlugin,\n      ToastPlugin: ToastPlugin,\n      TooltipPlugin: TooltipPlugin\n    }\n  });\n\n  var VBHoverPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    directives: {\n      VBHover: VBHover\n    }\n  });\n\n  var VBModalPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    directives: {\n      VBModal: VBModal\n    }\n  });\n\n  /*\n   * Constants / Defaults\n   */\n\n  var NAME$E = 'v-b-scrollspy';\n  var ACTIVATE_EVENT = 'bv::scrollspy::activate';\n  var Default = {\n    element: 'body',\n    offset: 10,\n    method: 'auto',\n    throttle: 75\n  };\n  var DefaultType = {\n    element: '(string|element|component)',\n    offset: 'number',\n    method: 'string',\n    throttle: 'number'\n  };\n  var ClassName = {\n    DROPDOWN_ITEM: 'dropdown-item',\n    ACTIVE: 'active'\n  };\n  var Selector$2 = {\n    ACTIVE: '.active',\n    NAV_LIST_GROUP: '.nav, .list-group',\n    NAV_LINKS: '.nav-link',\n    NAV_ITEMS: '.nav-item',\n    LIST_ITEMS: '.list-group-item',\n    DROPDOWN: '.dropdown, .dropup',\n    DROPDOWN_ITEMS: '.dropdown-item',\n    DROPDOWN_TOGGLE: '.dropdown-toggle'\n  };\n  var OffsetMethod = {\n    OFFSET: 'offset',\n    POSITION: 'position'\n  }; // HREFs must end with a hash followed by at least one non-hash character.\n  // HREFs in the links are assumed to point to non-external links.\n  // Comparison to the current page base URL is not performed!\n\n  var HREF_REGEX = /^.*(#[^#]+)$/; // Transition Events\n\n  var TransitionEndEvents$1 = ['webkitTransitionEnd', 'transitionend', 'otransitionend', 'oTransitionEnd'];\n  /*\n   * Utility Methods\n   */\n  // Better var type detection\n\n  var toType$1 = function toType(obj)\n  /* istanbul ignore next: not easy to test */\n  {\n    return toString(obj).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n  }; // Check config properties for expected types\n\n\n  var typeCheckConfig = function typeCheckConfig(componentName, config, configTypes)\n  /* istanbul ignore next: not easy to test */\n  {\n    for (var property in configTypes) {\n      if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\n        var expectedTypes = configTypes[property];\n        var value = config[property];\n        var valueType = value && isElement(value) ? 'element' : toType$1(value); // handle Vue instances\n\n        valueType = value && value._isVue ? 'component' : valueType;\n\n        if (!new RegExp(expectedTypes).test(valueType)) {\n          /* istanbul ignore next */\n          warn(\"\".concat(componentName, \": Option \\\"\").concat(property, \"\\\" provided type \\\"\").concat(valueType, \"\\\" but expected type \\\"\").concat(expectedTypes, \"\\\"\"));\n        }\n      }\n    }\n  };\n  /*\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  /* istanbul ignore next: not easy to test */\n\n\n  var ScrollSpy\n  /* istanbul ignore next: not easy to test */\n  =\n  /*#__PURE__*/\n  function () {\n    function ScrollSpy(element, config, $root) {\n      _classCallCheck(this, ScrollSpy);\n\n      // The element we activate links in\n      this.$el = element;\n      this.$scroller = null;\n      this.$selector = [Selector$2.NAV_LINKS, Selector$2.LIST_ITEMS, Selector$2.DROPDOWN_ITEMS].join(',');\n      this.$offsets = [];\n      this.$targets = [];\n      this.$activeTarget = null;\n      this.$scrollHeight = 0;\n      this.$resizeTimeout = null;\n      this.$obs_scroller = null;\n      this.$obs_targets = null;\n      this.$root = $root || null;\n      this.$config = null;\n      this.updateConfig(config);\n    }\n\n    _createClass(ScrollSpy, [{\n      key: \"updateConfig\",\n      value: function updateConfig(config, $root) {\n        if (this.$scroller) {\n          // Just in case out scroll element has changed\n          this.unlisten();\n          this.$scroller = null;\n        }\n\n        var cfg = _objectSpread2({}, this.constructor.Default, {}, config);\n\n        if ($root) {\n          this.$root = $root;\n        }\n\n        typeCheckConfig(this.constructor.Name, cfg, this.constructor.DefaultType);\n        this.$config = cfg;\n\n        if (this.$root) {\n          var self = this;\n          this.$root.$nextTick(function () {\n            self.listen();\n          });\n        } else {\n          this.listen();\n        }\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        this.unlisten();\n        clearTimeout(this.$resizeTimeout);\n        this.$resizeTimeout = null;\n        this.$el = null;\n        this.$config = null;\n        this.$scroller = null;\n        this.$selector = null;\n        this.$offsets = null;\n        this.$targets = null;\n        this.$activeTarget = null;\n        this.$scrollHeight = null;\n      }\n    }, {\n      key: \"listen\",\n      value: function listen() {\n        var _this = this;\n\n        var scroller = this.getScroller();\n\n        if (scroller && scroller.tagName !== 'BODY') {\n          eventOn(scroller, 'scroll', this, EVENT_OPTIONS_NO_CAPTURE);\n        }\n\n        eventOn(window, 'scroll', this, EVENT_OPTIONS_NO_CAPTURE);\n        eventOn(window, 'resize', this, EVENT_OPTIONS_NO_CAPTURE);\n        eventOn(window, 'orientationchange', this, EVENT_OPTIONS_NO_CAPTURE);\n        TransitionEndEvents$1.forEach(function (evtName) {\n          eventOn(window, evtName, _this, EVENT_OPTIONS_NO_CAPTURE);\n        });\n        this.setObservers(true); // Schedule a refresh\n\n        this.handleEvent('refresh');\n      }\n    }, {\n      key: \"unlisten\",\n      value: function unlisten() {\n        var _this2 = this;\n\n        var scroller = this.getScroller();\n        this.setObservers(false);\n\n        if (scroller && scroller.tagName !== 'BODY') {\n          eventOff(scroller, 'scroll', this, EVENT_OPTIONS_NO_CAPTURE);\n        }\n\n        eventOff(window, 'scroll', this, EVENT_OPTIONS_NO_CAPTURE);\n        eventOff(window, 'resize', this, EVENT_OPTIONS_NO_CAPTURE);\n        eventOff(window, 'orientationchange', this, EVENT_OPTIONS_NO_CAPTURE);\n        TransitionEndEvents$1.forEach(function (evtName) {\n          eventOff(window, evtName, _this2, EVENT_OPTIONS_NO_CAPTURE);\n        });\n      }\n    }, {\n      key: \"setObservers\",\n      value: function setObservers(on) {\n        var _this3 = this;\n\n        // We observe both the scroller for content changes, and the target links\n        if (this.$obs_scroller) {\n          this.$obs_scroller.disconnect();\n          this.$obs_scroller = null;\n        }\n\n        if (this.$obs_targets) {\n          this.$obs_targets.disconnect();\n          this.$obs_targets = null;\n        }\n\n        if (on) {\n          this.$obs_targets = observeDom(this.$el, function () {\n            _this3.handleEvent('mutation');\n          }, {\n            subtree: true,\n            childList: true,\n            attributes: true,\n            attributeFilter: ['href']\n          });\n          this.$obs_scroller = observeDom(this.getScroller(), function () {\n            _this3.handleEvent('mutation');\n          }, {\n            subtree: true,\n            childList: true,\n            characterData: true,\n            attributes: true,\n            attributeFilter: ['id', 'style', 'class']\n          });\n        }\n      } // General event handler\n\n    }, {\n      key: \"handleEvent\",\n      value: function handleEvent(evt) {\n        var type = isString(evt) ? evt : evt.type;\n        var self = this;\n\n        var resizeThrottle = function resizeThrottle() {\n          if (!self.$resizeTimeout) {\n            self.$resizeTimeout = setTimeout(function () {\n              self.refresh();\n              self.process();\n              self.$resizeTimeout = null;\n            }, self.$config.throttle);\n          }\n        };\n\n        if (type === 'scroll') {\n          if (!this.$obs_scroller) {\n            // Just in case we are added to the DOM before the scroll target is\n            // We re-instantiate our listeners, just in case\n            this.listen();\n          }\n\n          this.process();\n        } else if (/(resize|orientationchange|mutation|refresh)/.test(type)) {\n          // Postpone these events by throttle time\n          resizeThrottle();\n        }\n      } // Refresh the list of target links on the element we are applied to\n\n    }, {\n      key: \"refresh\",\n      value: function refresh() {\n        var _this4 = this;\n\n        var scroller = this.getScroller();\n\n        if (!scroller) {\n          return;\n        }\n\n        var autoMethod = scroller !== scroller.window ? OffsetMethod.POSITION : OffsetMethod.OFFSET;\n        var method = this.$config.method === 'auto' ? autoMethod : this.$config.method;\n        var methodFn = method === OffsetMethod.POSITION ? position : offset;\n        var offsetBase = method === OffsetMethod.POSITION ? this.getScrollTop() : 0;\n        this.$offsets = [];\n        this.$targets = [];\n        this.$scrollHeight = this.getScrollHeight(); // Find all the unique link HREFs that we will control\n\n        selectAll(this.$selector, this.$el) // Get HREF value\n        .map(function (link) {\n          return getAttr(link, 'href');\n        }) // Filter out HREFs that do not match our RegExp\n        .filter(function (href) {\n          return href && HREF_REGEX.test(href || '');\n        }) // Find all elements with ID that match HREF hash\n        .map(function (href) {\n          // Convert HREF into an ID (including # at beginning)\n          var id = href.replace(HREF_REGEX, '$1').trim();\n\n          if (!id) {\n            return null;\n          } // Find the element with the ID specified by id\n\n\n          var el = select(id, scroller);\n\n          if (el && isVisible(el)) {\n            return {\n              offset: parseInt(methodFn(el).top, 10) + offsetBase,\n              target: id\n            };\n          }\n\n          return null;\n        }).filter(Boolean) // Sort them by their offsets (smallest first)\n        .sort(function (a, b) {\n          return a.offset - b.offset;\n        }) // record only unique targets/offsets\n        .reduce(function (memo, item) {\n          if (!memo[item.target]) {\n            _this4.$offsets.push(item.offset);\n\n            _this4.$targets.push(item.target);\n\n            memo[item.target] = true;\n          }\n\n          return memo;\n        }, {}); // Return this for easy chaining\n\n        return this;\n      } // Handle activating/clearing\n\n    }, {\n      key: \"process\",\n      value: function process() {\n        var scrollTop = this.getScrollTop() + this.$config.offset;\n        var scrollHeight = this.getScrollHeight();\n        var maxScroll = this.$config.offset + scrollHeight - this.getOffsetHeight();\n\n        if (this.$scrollHeight !== scrollHeight) {\n          this.refresh();\n        }\n\n        if (scrollTop >= maxScroll) {\n          var target = this.$targets[this.$targets.length - 1];\n\n          if (this.$activeTarget !== target) {\n            this.activate(target);\n          }\n\n          return;\n        }\n\n        if (this.$activeTarget && scrollTop < this.$offsets[0] && this.$offsets[0] > 0) {\n          this.$activeTarget = null;\n          this.clear();\n          return;\n        }\n\n        for (var i = this.$offsets.length; i--;) {\n          var isActiveTarget = this.$activeTarget !== this.$targets[i] && scrollTop >= this.$offsets[i] && (isUndefined(this.$offsets[i + 1]) || scrollTop < this.$offsets[i + 1]);\n\n          if (isActiveTarget) {\n            this.activate(this.$targets[i]);\n          }\n        }\n      }\n    }, {\n      key: \"getScroller\",\n      value: function getScroller() {\n        if (this.$scroller) {\n          return this.$scroller;\n        }\n\n        var scroller = this.$config.element;\n\n        if (!scroller) {\n          return null;\n        } else if (isElement(scroller.$el)) {\n          scroller = scroller.$el;\n        } else if (isString(scroller)) {\n          scroller = select(scroller);\n        }\n\n        if (!scroller) {\n          return null;\n        }\n\n        this.$scroller = scroller.tagName === 'BODY' ? window : scroller;\n        return this.$scroller;\n      }\n    }, {\n      key: \"getScrollTop\",\n      value: function getScrollTop() {\n        var scroller = this.getScroller();\n        return scroller === window ? scroller.pageYOffset : scroller.scrollTop;\n      }\n    }, {\n      key: \"getScrollHeight\",\n      value: function getScrollHeight() {\n        return this.getScroller().scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n      }\n    }, {\n      key: \"getOffsetHeight\",\n      value: function getOffsetHeight() {\n        var scroller = this.getScroller();\n        return scroller === window ? window.innerHeight : getBCR(scroller).height;\n      }\n    }, {\n      key: \"activate\",\n      value: function activate(target) {\n        var _this5 = this;\n\n        this.$activeTarget = target;\n        this.clear(); // Grab the list of target links (<a href=\"{$target}\">)\n\n        var links = selectAll(this.$selector // Split out the base selectors\n        .split(',') // Map to a selector that matches links with HREF ending in the ID (including '#')\n        .map(function (selector) {\n          return \"\".concat(selector, \"[href$=\\\"\").concat(target, \"\\\"]\");\n        }) // Join back into a single selector string\n        .join(','), this.$el);\n        links.forEach(function (link) {\n          if (hasClass(link, ClassName.DROPDOWN_ITEM)) {\n            // This is a dropdown item, so find the .dropdown-toggle and set its state\n            var dropdown = closest(Selector$2.DROPDOWN, link);\n\n            if (dropdown) {\n              _this5.setActiveState(select(Selector$2.DROPDOWN_TOGGLE, dropdown), true);\n            } // Also set this link's state\n\n\n            _this5.setActiveState(link, true);\n          } else {\n            // Set triggered link as active\n            _this5.setActiveState(link, true);\n\n            if (matches(link.parentElement, Selector$2.NAV_ITEMS)) {\n              // Handle nav-link inside nav-item, and set nav-item active\n              _this5.setActiveState(link.parentElement, true);\n            } // Set triggered links parents as active\n            // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n\n\n            var el = link;\n\n            while (el) {\n              el = closest(Selector$2.NAV_LIST_GROUP, el);\n              var sibling = el ? el.previousElementSibling : null;\n\n              if (sibling && matches(sibling, \"\".concat(Selector$2.NAV_LINKS, \", \").concat(Selector$2.LIST_ITEMS))) {\n                _this5.setActiveState(sibling, true);\n              } // Handle special case where nav-link is inside a nav-item\n\n\n              if (sibling && matches(sibling, Selector$2.NAV_ITEMS)) {\n                _this5.setActiveState(select(Selector$2.NAV_LINKS, sibling), true); // Add active state to nav-item as well\n\n\n                _this5.setActiveState(sibling, true);\n              }\n            }\n          }\n        }); // Signal event to via $root, passing ID of activated target and reference to array of links\n\n        if (links && links.length > 0 && this.$root) {\n          this.$root.$emit(ACTIVATE_EVENT, target, links);\n        }\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        var _this6 = this;\n\n        selectAll(\"\".concat(this.$selector, \", \").concat(Selector$2.NAV_ITEMS), this.$el).filter(function (el) {\n          return hasClass(el, ClassName.ACTIVE);\n        }).forEach(function (el) {\n          return _this6.setActiveState(el, false);\n        });\n      }\n    }, {\n      key: \"setActiveState\",\n      value: function setActiveState(el, active) {\n        if (!el) {\n          return;\n        }\n\n        if (active) {\n          addClass(el, ClassName.ACTIVE);\n        } else {\n          removeClass(el, ClassName.ACTIVE);\n        }\n      }\n    }], [{\n      key: \"Name\",\n      get: function get() {\n        return NAME$E;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType;\n      }\n    }]);\n\n    return ScrollSpy;\n  }();\n\n  var BV_SCROLLSPY = '__BV_ScrollSpy__'; // Pre-compiled regular expressions\n\n  var onlyDigitsRE = /^\\d+$/;\n  var offsetRE$2 = /^(auto|position|offset)$/; // Build a ScrollSpy config based on bindings (if any)\n  // Arguments and modifiers take precedence over passed value config object\n\n  /* istanbul ignore next: not easy to test */\n\n  var parseBindings$2 = function parseBindings(bindings)\n  /* istanbul ignore next: not easy to test */\n  {\n    var config = {}; // If argument, assume element ID\n\n    if (bindings.arg) {\n      // Element ID specified as arg\n      // We must prepend '#' to become a CSS selector\n      config.element = \"#\".concat(bindings.arg);\n    } // Process modifiers\n\n\n    keys(bindings.modifiers).forEach(function (mod) {\n      if (onlyDigitsRE.test(mod)) {\n        // Offset value\n        config.offset = parseInt(mod, 10);\n      } else if (offsetRE$2.test(mod)) {\n        // Offset method\n        config.method = mod;\n      }\n    }); // Process value\n\n    if (isString(bindings.value)) {\n      // Value is a CSS ID or selector\n      config.element = bindings.value;\n    } else if (isNumber(bindings.value)) {\n      // Value is offset\n      config.offset = Math.round(bindings.value);\n    } else if (isObject(bindings.value)) {\n      // Value is config object\n      // Filter the object based on our supported config options\n      keys(bindings.value).filter(function (k) {\n        return !!ScrollSpy.DefaultType[k];\n      }).forEach(function (k) {\n        config[k] = bindings.value[k];\n      });\n    }\n\n    return config;\n  }; // Add or update ScrollSpy on our element\n\n\n  var applyScrollspy = function applyScrollspy(el, bindings, vnode)\n  /* istanbul ignore next: not easy to test */\n  {\n    if (!isBrowser) {\n      /* istanbul ignore next */\n      return;\n    }\n\n    var config = parseBindings$2(bindings);\n\n    if (el[BV_SCROLLSPY]) {\n      el[BV_SCROLLSPY].updateConfig(config, vnode.context.$root);\n    } else {\n      el[BV_SCROLLSPY] = new ScrollSpy(el, config, vnode.context.$root);\n    }\n  }; // Remove ScrollSpy on our element\n\n  /* istanbul ignore next: not easy to test */\n\n\n  var removeScrollspy = function removeScrollspy(el)\n  /* istanbul ignore next: not easy to test */\n  {\n    if (el[BV_SCROLLSPY]) {\n      el[BV_SCROLLSPY].dispose();\n      el[BV_SCROLLSPY] = null;\n      delete el[BV_SCROLLSPY];\n    }\n  };\n  /*\n   * Export our directive\n   */\n\n\n  var VBScrollspy = {\n    bind: function bind(el, bindings, vnode)\n    /* istanbul ignore next: not easy to test */\n    {\n      applyScrollspy(el, bindings, vnode);\n    },\n    inserted: function inserted(el, bindings, vnode)\n    /* istanbul ignore next: not easy to test */\n    {\n      applyScrollspy(el, bindings, vnode);\n    },\n    update: function update(el, bindings, vnode)\n    /* istanbul ignore next: not easy to test */\n    {\n      if (bindings.value !== bindings.oldValue) {\n        applyScrollspy(el, bindings, vnode);\n      }\n    },\n    componentUpdated: function componentUpdated(el, bindings, vnode)\n    /* istanbul ignore next: not easy to test */\n    {\n      if (bindings.value !== bindings.oldValue) {\n        applyScrollspy(el, bindings, vnode);\n      }\n    },\n    unbind: function unbind(el)\n    /* istanbul ignore next: not easy to test */\n    {\n      removeScrollspy(el);\n    }\n  };\n\n  var VBScrollspyPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    directives: {\n      VBScrollspy: VBScrollspy\n    }\n  });\n\n  var VBTogglePlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    directives: {\n      VBToggle: VBToggle\n    }\n  });\n\n  var VBVisiblePlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    directives: {\n      VBVisible: VBVisible\n    }\n  });\n\n  var directivesPlugin =\n  /*#__PURE__*/\n  pluginFactory({\n    plugins: {\n      VBHoverPlugin: VBHoverPlugin,\n      VBModalPlugin: VBModalPlugin,\n      VBPopoverPlugin: VBPopoverPlugin,\n      VBScrollspyPlugin: VBScrollspyPlugin,\n      VBTogglePlugin: VBTogglePlugin,\n      VBTooltipPlugin: VBTooltipPlugin,\n      VBVisiblePlugin: VBVisiblePlugin\n    }\n  });\n\n  var RX_ICON_PREFIX = /^BIcon/; // Helper BIcon component\n  // Requires the requested icon component to be installed\n\n  var BIcon =\n  /*#__PURE__*/\n  Vue.extend({\n    name: 'BIcon',\n    functional: true,\n    props: _objectSpread2({\n      icon: {\n        type: String,\n        default: null\n      }\n    }, commonIconProps, {\n      stacked: {\n        type: Boolean,\n        default: false\n      }\n    }),\n    render: function render(h, _ref) {\n      var data = _ref.data,\n          props = _ref.props,\n          parent = _ref.parent;\n      var icon = pascalCase(trim(props.icon || '')).replace(RX_ICON_PREFIX, '');\n      var iconName = \"BIcon\".concat(icon); // If parent context exists, we check to see if the icon has been registered\n      // Either locally in the parent component, or globally at the `$root` level\n      // If not registered, we render a blank icon\n\n      var components = ((parent || {}).$options || {}).components;\n      var componentRefOrName = icon && components ? components[iconName] || BIconBlank : icon ? iconName : BIconBlank;\n      return h(componentRefOrName, a(data, {\n        props: _objectSpread2({}, props, {\n          icon: null\n        })\n      }));\n    }\n  });\n\n  var NAME$F = 'BootstrapVue'; // --- BootstrapVue installer ---\n\n  var install =\n  /*#__PURE__*/\n  installFactory({\n    plugins: {\n      componentsPlugin: componentsPlugin,\n      directivesPlugin: directivesPlugin\n    }\n  }); // --- BootstrapVue plugin ---\n\n  var BootstrapVue =\n  /*#__PURE__*/\n  {\n    install: install,\n    NAME: NAME$F\n  }; // --- Named exports for BvConfigPlugin ---\n\n  // Main entry point for the browser build\n\n  vueUse(BootstrapVue);\n\n  return BootstrapVue;\n\n})));\n//# sourceMappingURL=bootstrap-vue.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLXZ1ZS9kaXN0L2Jvb3RzdHJhcC12dWUuanM/ZTZlOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RCw0QkFBNEIsbUJBQU8sQ0FBQywrQ0FBSztBQUN2RyxFQUFFLENBQ29FO0FBQ3RFLENBQUMsd0JBQXdCOztBQUV6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7O0FBRW5FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLCtCQUErQjtBQUM5RTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsYUFBYTtBQUNwRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOEJBQThCLDRCQUE0QjtBQUMxRCxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGOztBQUVoRjtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTyxvQkFBb0IsT0FBTyxHQUFHLE9BQU8sVUFBVTs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQsT0FBTyxJQUFJO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsYUFBYTtBQUMxQixhQUFhLEVBQUU7QUFDZixjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVAsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUcsR0FBRzs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFJQUFxSTs7QUFFckk7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLE9BQU8sRUFBRTtBQUN0QixlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTyxFQUFFO0FBQ3RCLGVBQWUsT0FBTztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGFBQWE7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUcsRUFBRTtBQUNMOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTDtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFOztBQUVBOztBQUVBLGdHQUFnRzs7QUFFaEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQSxxRkFBcUY7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FB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QUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxvUUFBb1E7O0FBRXBRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQSx1RUFBdUUsYUFBYTtBQUNwRjtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd1JBQXdSOztBQUV4UjtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTyxZQUFZOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxLQUFLO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSCwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQSxTQUFTLDRCQUE0QjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQLGdCQUFnQjs7QUFFaEIsd0VBQXdFOztBQUV4RTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QixzQ0FBc0MsRUFBRSxZQUFZLEVBQUUsOERBQThELEVBQUUsR0FBRyxFQUFFLGlGQUFpRixHQUFHO0FBQy9NO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsMkRBQTJELEVBQUUsaUNBQWlDLEVBQUUsa0NBQWtDLEVBQUU7QUFDcEksK0JBQStCO0FBQy9CLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdULGdGQUFnRjs7QUFFaEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUU7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87OztBQUdQLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Es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O0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtB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TztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsdUNBQXVDOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsT0FBTztBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFB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QTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTs7QUFFVCxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUcsR0FBRzs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLHVFQUF1RTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsNEZBQTRGOztBQUU1Riw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVCxvREFBb0Q7O0FBRXBELG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBLDRCQUE0Qjs7O0FBRzVCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0Msa0JBQWtCLHVCQUF1QjtBQUN6RSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4Qyx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7OztBQUdBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUU7O0FBRUw7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLE9BQU87QUFDUCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7OztBQUdUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLGlEQUFpRDs7QUFFakQsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUMscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGFBQWE7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTyxpREFBaUQ7O0FBRXhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrSUFBa0k7O0FBRWxJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FB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QUEwRDtBQUMxRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7O0FBRUE7QUFDQSxTQUFTOzs7QUFHVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrSkFBK0o7O0FBRS9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEVBQUU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7O0FBR1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYztBQUNkO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QixpQ0FBaUM7O0FBRWpDLG9DQUFvQzs7QUFFcEMsb0NBQW9DOztBQUVwQyxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSCwyQkFBMkI7O0FBRTNCLDBEQUEwRDs7QUFFMUQscUNBQXFDOztBQUVyQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFNBQVMsRUFBRTs7QUFFWDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7OztBQUdUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNB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QUFXO0FBQ1gsU0FBUztBQUNULE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Qsc0NBQXNDOztBQUV0Qyw4REFBOEQ7O0FBRTlEO0FBQ0Es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QUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZUFBZTs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FB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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCLE9BQU87QUFDUDtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FB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QUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSCxvRkFBb0Y7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUgsK0JBQStCO0FBQy9COztBQUVBLDhDQUE4Qzs7QUFFOUMsNENBQTRDOztBQUU1Qyx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3Qix3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5ELDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSw2QkFBNkIsZUFBZTtBQUM1QztBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLGVBQWU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7O0FBRUEsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNi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QTtBQUNBLDhDQUE4Qzs7QUFFOUMscUNBQXFDOztBQUVyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7O0FBR1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDOzs7QUFHOUMsK0JBQStCOzs7QUFHL0IsdUVBQXVFOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRTs7QUFFWCxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdULDBDQUEwQzs7O0FBRzFDLDRDQUE0Qzs7O0FBRzVDLGdEQUFnRDs7O0FBR2hELDhDQUE4Qzs7O0FBRzlDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxpRUFBaUUsaUJBQWlCOztBQUVsRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHOztBQUVILG9DQUFvQzs7QUFFcEMsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUMsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTtBQUNQOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSCwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFT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QTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLElBQUk7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVcsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVJQUF1STs7QUFFdkk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7OztBQUdiO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVILHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQSxvRkFBb0Y7O0FBRXBGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0VBQStFLEtBQUs7QUFDakc7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVyxzQ0FBc0M7O0FBRWpEO0FBQ0EsVUFBVTs7O0FBR1YsMkRBQTJEOztBQUUzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkc7QUFDN0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUyxRQUFRLElBQUk7QUFD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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsNEJBQTRCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esa0VBQWtFOztBQUVsRSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUVBQWlFLDhDQUE4QztBQUMvRztBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdULDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVB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QUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRyxFQUFFOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVMsRUFBRTs7QUFFWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7OztBQUdUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2IsWUFBWTs7O0FBR1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUyxFQUFFOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7O0FBR0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7O0FBRVo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7OztBQUdULHlCQUF5Qjs7QUFFekI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7O0FBR0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0EsT0FBTyxFQUFFOztBQUVUO0FBQ0E7QUFDQSxPQUFPLEVBQUU7O0FBRVQ7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTyxFQUFFOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdEQUFnRDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7O0FBRW5FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLElBQUk7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrRUFBa0U7O0FBRWxFOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsT0FBTyxFQUFFO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHLEVBQUU7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU8sRUFBRTs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtB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RUFBRTtBQUNQOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjs7QUFFaEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsOEJBQThCOztBQUVqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7OztBQUdYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxJQUFJLEVBQUU7O0FBRWY7QUFDQSxPQUFPOztBQUVQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLEtBQUs7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsNkNBQTZDLFFBQVE7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7OztBQUdiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7OztBQUdmO0FBQ0EsbUZBQW1GOzs7QUFHbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEVBQUU7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVILHdDQUF3Qzs7QUFFeEM7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7O0FBRUo7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUEscUNBQXFDLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUgsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLXZ1ZS9kaXN0L2Jvb3RzdHJhcC12dWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEJvb3RzdHJhcFZ1ZSAyLjUuMFxuICpcbiAqIEBsaW5rIGh0dHBzOi8vYm9vdHN0cmFwLXZ1ZS5qcy5vcmdcbiAqIEBzb3VyY2UgaHR0cHM6Ly9naXRodWIuY29tL2Jvb3RzdHJhcC12dWUvYm9vdHN0cmFwLXZ1ZVxuICogQGNvcHlyaWdodCAoYykgMjAxNi0yMDIwIEJvb3RzdHJhcFZ1ZVxuICogQGxpY2Vuc2UgTUlUXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYm9vdHN0cmFwLXZ1ZS9ib290c3RyYXAtdnVlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgndnVlJykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsndnVlJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuYm9vdHN0cmFwVnVlID0gZmFjdG9yeShnbG9iYWwuVnVlKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoVnVlKSB7ICd1c2Ugc3RyaWN0JztcblxuICBWdWUgPSBWdWUgJiYgVnVlLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBWdWVbJ2RlZmF1bHQnXSA6IFZ1ZTtcblxuICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgfSk7XG4gICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICAgIGlmIChpICUgMikge1xuICAgICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH1cblxuICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgcmV0dXJuIG87XG4gICAgfTtcblxuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgIGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICAgIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICAgIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gICAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgICByZXR1cm4gYXJyMjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICAgIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gICAgaWYgKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gIH1cblxuICAvL1xuXG4gIC8vIC0tLSBTdGF0aWMgLS0tXG4gIHZhciBmcm9tID0gZnVuY3Rpb24gZnJvbSgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbS5hcHBseShBcnJheSwgYXJndW1lbnRzKTtcbiAgfTtcbiAgdmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCk7XG4gIH07IC8vIC0tLSBJbnN0YW5jZSAtLS1cblxuICB2YXIgYXJyYXlJbmNsdWRlcyA9IGZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5LmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgfTtcbiAgdmFyIGNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFyZ3MpO1xuICB9O1xuXG4gIHZhciBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBhcmd1bWVudHMpO1xuICB9O1xuICB2YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3RvLCBvcHRpb25hbFByb3BzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUocHJvdG8sIG9wdGlvbmFsUHJvcHMpO1xuICB9O1xuICB2YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMob2JqLCBwcm9wcykge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmosIHByb3BzKTtcbiAgfTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBkZXNjcikge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBkZXNjcik7XG4gIH07XG4gIHZhciBmcmVlemUgPSBmdW5jdGlvbiBmcmVlemUob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUob2JqKTtcbiAgfTtcbiAgdmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopO1xuICB9O1xuICB2YXIga2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gIH07IC8vIC0tLSBcIkluc3RhbmNlXCIgLS0tXG5cbiAgdmFyIGhhc093blByb3BlcnR5ID0gZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuICB9O1xuICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gIH07IC8vIC0tLSBVdGlsaXRpZXMgLS0tXG5cbiAgLyoqXG4gICAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICAgKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gICAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAgICogTm90ZSBvYmplY3QgY291bGQgYmUgYSBjb21wbGV4IHR5cGUgbGlrZSBhcnJheSwgZGF0ZSwgZXRjLlxuICAgKi9cblxuICB2YXIgaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gJ29iamVjdCc7XG4gIH07XG4gIC8qKlxuICAgKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gICAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gICAqL1xuXG4gIHZhciBpc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICB9O1xuICAvKipcbiAgICogU2hhbGxvdyBjb3B5IGFuIG9iamVjdC4gSWYgdGhlIHBhc3NlZCBpbiBvYmplY3RcbiAgICogaXMgbnVsbCBvciB1bmRlZmluZWQsIHJldHVybnMgYW4gZW1wdHkgb2JqZWN0XG4gICAqL1xuXG4gIHZhciBjbG9uZSA9IGZ1bmN0aW9uIGNsb25lKG9iaikge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMih7fSwgb2JqKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybiBhIHNoYWxsb3cgY29weSBvZiBvYmplY3Qgd2l0aFxuICAgKiB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMgb21pdHRlZFxuICAgKiBAbGluayBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9iaXN1YnVzLzJkYThhZjdlODAxZmZkODEzZmFiN2FjMjIxYWE3YWZjXG4gICAqL1xuXG4gIHZhciBvbWl0ID0gZnVuY3Rpb24gb21pdChvYmosIHByb3BzKSB7XG4gICAgcmV0dXJuIGtleXMob2JqKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHByb3BzLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG4gICAgfSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGtleSkge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHt9LCByZXN1bHQsIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBvYmpba2V5XSkpO1xuICAgIH0sIHt9KTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBjcmVhdGUgYSByZWFkLW9ubHkgZGVzY3JpcHRvclxuICAgKi9cblxuICB2YXIgcmVhZG9ubHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gcmVhZG9ubHlEZXNjcmlwdG9yKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH07XG4gIH07XG4gIC8qKlxuICAgKiBEZWVwLWZyZWV6ZXMgYW5kIG9iamVjdCwgbWFraW5nIGl0IGltbXV0YWJsZSAvIHJlYWQtb25seS5cbiAgICogUmV0dXJucyB0aGUgc2FtZSBvYmplY3QgcGFzc2VkLWluLCBidXQgZnJvemVuLlxuICAgKiBGcmVlemVzIGlubmVyIG9iamVjdC9hcnJheS92YWx1ZXMgZmlyc3QuXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9mcmVlemVcbiAgICogTm90ZTogdGhpcyBtZXRob2Qgd2lsbCBub3Qgd29yayBmb3IgcHJvcGVydHkgdmFsdWVzIHVzaW5nIFN5bWJvbCgpIGFzIGEga2V5XG4gICAqL1xuXG4gIHZhciBkZWVwRnJlZXplID0gZnVuY3Rpb24gZGVlcEZyZWV6ZShvYmopIHtcbiAgICAvLyBSZXRyaWV2ZSB0aGUgcHJvcGVydHkgbmFtZXMgZGVmaW5lZCBvbiBvYmplY3QvYXJyYXlcbiAgICAvLyBOb3RlOiBga2V5c2Agd2lsbCBpZ25vcmUgcHJvcGVydGllcyB0aGF0IGFyZSBrZXllZCBieSBhIGBTeW1ib2woKWBcbiAgICB2YXIgcHJvcHMgPSBrZXlzKG9iaik7IC8vIEl0ZXJhdGUgb3ZlciBlYWNoIHByb3AgYW5kIHJlY3Vyc2l2ZWx5IGZyZWV6ZSBpdFxuXG4gICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdOyAvLyBJZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCBvciBhcnJheSwgd2UgZGVlcEZyZWV6ZSBpdFxuXG4gICAgICBvYmpbcHJvcF0gPSB2YWx1ZSAmJiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSkpID8gZGVlcEZyZWV6ZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnJlZXplKG9iaik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFV0aWxpdGllcyB0byBnZXQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnRcbiAgICovXG4gIC8vIC0tLSBDb25zdGFudHMgLS0tXG4gIHZhciBoYXNXaW5kb3dTdXBwb3J0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBoYXNEb2N1bWVudFN1cHBvcnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgaGFzTmF2aWdhdG9yU3VwcG9ydCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgaGFzUHJvbWlzZVN1cHBvcnQgPSB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBoYXNNdXRhdGlvbk9ic2VydmVyU3VwcG9ydCA9IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgV2ViS2l0TXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIE1vek11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgaXNCcm93c2VyID0gaGFzV2luZG93U3VwcG9ydCAmJiBoYXNEb2N1bWVudFN1cHBvcnQgJiYgaGFzTmF2aWdhdG9yU3VwcG9ydDsgLy8gQnJvd3NlciB0eXBlIHNuaWZmaW5nXG5cbiAgdmFyIHVzZXJBZ2VudCA9IGlzQnJvd3NlciA/IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgdmFyIGlzSlNET00gPSB1c2VyQWdlbnQuaW5kZXhPZignanNkb20nKSA+IDA7XG4gIHZhciBpc0lFID0gL21zaWV8dHJpZGVudC8udGVzdCh1c2VyQWdlbnQpOyAvLyBEZXRlcm1pbmUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIG9wdGlvbiBwYXNzaXZlIGZvciBldmVudHNcblxuICB2YXIgaGFzUGFzc2l2ZUV2ZW50U3VwcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFzc2l2ZUV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5cbiAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgLy8gYXR0ZW1wdHMgdG8gYWNjZXNzIHRoZSBwYXNzaXZlIHByb3BlcnR5LlxuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogd2lsbCBuZXZlciBiZSBjYWxsZWQgaW4gSlNET00gKi9cbiAgICAgICAgICAgIHBhc3NpdmVFdmVudFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0Jywgb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0Jywgb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHdpbGwgbmV2ZXIgYmUgY2FsbGVkIGluIEpTRE9NICovXG4gICAgICAgIHBhc3NpdmVFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQ7XG4gIH0oKTtcbiAgdmFyIGhhc1RvdWNoU3VwcG9ydCA9IGlzQnJvd3NlciAmJiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDApO1xuICB2YXIgaGFzUG9pbnRlckV2ZW50U3VwcG9ydCA9IGlzQnJvd3NlciAmJiBCb29sZWFuKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgd2luZG93Lk1TUG9pbnRlckV2ZW50KTtcbiAgdmFyIGhhc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydCA9IGlzQnJvd3NlciAmJiAnSW50ZXJzZWN0aW9uT2JzZXJ2ZXInIGluIHdpbmRvdyAmJiAnSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeScgaW4gd2luZG93ICYmIC8vIEVkZ2UgMTUgYW5kIFVDIEJyb3dzZXIgbGFjayBzdXBwb3J0IGZvciBgaXNJbnRlcnNlY3RpbmdgXG4gIC8vIGJ1dCB3ZSBhbiB1c2UgaW50ZXJzZWN0aW9uUmF0aW8gPiAwIGluc3RlYWRcbiAgLy8gJ2lzSW50ZXJzZWN0aW5nJyBpbiB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeS5wcm90b3R5cGUgJiZcbiAgJ2ludGVyc2VjdGlvblJhdGlvJyBpbiB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeS5wcm90b3R5cGU7IC8vIC0tLSBHZXR0ZXJzIC0tLVxuXG4gIHZhciBnZXRFbnYgPSBmdW5jdGlvbiBnZXRFbnYoa2V5KSB7XG4gICAgdmFyIGZhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIHZhciBlbnYgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2VzcyA/IHByb2Nlc3MuZW52IHx8IHt9IDoge307XG5cbiAgICBpZiAoIWtleSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBlbnY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudltrZXldIHx8IGZhbGxiYWNrO1xuICB9O1xuICB2YXIgZ2V0Tm9XYXJuID0gZnVuY3Rpb24gZ2V0Tm9XYXJuKCkge1xuICAgIHJldHVybiBnZXRFbnYoJ0JPT1RTVFJBUF9WVUVfTk9fV0FSTicpO1xuICB9O1xuXG4gIHZhciB3ID0gaGFzV2luZG93U3VwcG9ydCA/IHdpbmRvdyA6IHt9O1xuICB2YXIgRWxlbWVudCQxID0gaGFzV2luZG93U3VwcG9ydCA/IHcuRWxlbWVudCA6XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9PYmplY3QpIHtcbiAgICBfaW5oZXJpdHMoRWxlbWVudCwgX09iamVjdCk7XG5cbiAgICBmdW5jdGlvbiBFbGVtZW50KCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVsZW1lbnQpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEVsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIHJldHVybiBFbGVtZW50O1xuICB9KF93cmFwTmF0aXZlU3VwZXIoT2JqZWN0KSk7XG4gIHZhciBIVE1MRWxlbWVudCA9IGhhc1dpbmRvd1N1cHBvcnQgPyB3LkhUTUxFbGVtZW50IDpcbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgICBfaW5oZXJpdHMoSFRNTEVsZW1lbnQsIF9FbGVtZW50KTtcblxuICAgIGZ1bmN0aW9uIEhUTUxFbGVtZW50KCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhUTUxFbGVtZW50KTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihIVE1MRWxlbWVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEhUTUxFbGVtZW50O1xuICB9KEVsZW1lbnQkMSk7XG4gIHZhciBTVkdFbGVtZW50ID0gaGFzV2luZG93U3VwcG9ydCA/IHcuU1ZHRWxlbWVudCA6XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9FbGVtZW50Mikge1xuICAgIF9pbmhlcml0cyhTVkdFbGVtZW50LCBfRWxlbWVudDIpO1xuXG4gICAgZnVuY3Rpb24gU1ZHRWxlbWVudCgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTVkdFbGVtZW50KTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihTVkdFbGVtZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU1ZHRWxlbWVudDtcbiAgfShFbGVtZW50JDEpO1xuICB2YXIgRmlsZSA9IGhhc1dpbmRvd1N1cHBvcnQgPyB3LkZpbGUgOlxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfT2JqZWN0Mikge1xuICAgIF9pbmhlcml0cyhGaWxlLCBfT2JqZWN0Mik7XG5cbiAgICBmdW5jdGlvbiBGaWxlKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbGUpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEZpbGUpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIHJldHVybiBGaWxlO1xuICB9KF93cmFwTmF0aXZlU3VwZXIoT2JqZWN0KSk7XG5cbiAgdmFyIHRvVHlwZSA9IGZ1bmN0aW9uIHRvVHlwZSh2YWwpIHtcbiAgICByZXR1cm4gX3R5cGVvZih2YWwpO1xuICB9O1xuICB2YXIgdG9SYXdUeXBlID0gZnVuY3Rpb24gdG9SYXdUeXBlKHZhbCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSk7XG4gIH07XG4gIHZhciBpc1VuZGVmaW5lZCA9IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZDtcbiAgfTtcbiAgdmFyIGlzTnVsbCA9IGZ1bmN0aW9uIGlzTnVsbCh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09PSBudWxsO1xuICB9O1xuICB2YXIgaXNVbmRlZmluZWRPck51bGwgPSBmdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWwpIHtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQodmFsKSB8fCBpc051bGwodmFsKTtcbiAgfTtcbiAgdmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiB0b1R5cGUodmFsKSA9PT0gJ2Z1bmN0aW9uJztcbiAgfTtcbiAgdmFyIGlzQm9vbGVhbiA9IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWwpIHtcbiAgICByZXR1cm4gdG9UeXBlKHZhbCkgPT09ICdib29sZWFuJztcbiAgfTtcbiAgdmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gICAgcmV0dXJuIHRvVHlwZSh2YWwpID09PSAnc3RyaW5nJztcbiAgfTtcbiAgdmFyIGlzTnVtYmVyID0gZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gICAgcmV0dXJuIHRvVHlwZSh2YWwpID09PSAnbnVtYmVyJztcbiAgfTtcbiAgdmFyIGlzRGF0ZSA9IGZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRGF0ZTtcbiAgfTtcbiAgdmFyIGlzRXZlbnQgPSBmdW5jdGlvbiBpc0V2ZW50KHZhbCkge1xuICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBFdmVudDtcbiAgfTtcbiAgdmFyIGlzRmlsZSA9IGZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRmlsZTtcbiAgfTtcbiAgdmFyIGlzUmVnRXhwID0gZnVuY3Rpb24gaXNSZWdFeHAodmFsKSB7XG4gICAgcmV0dXJuIHRvUmF3VHlwZSh2YWwpID09PSAnUmVnRXhwJztcbiAgfTtcbiAgdmFyIGlzUHJvbWlzZSA9IGZ1bmN0aW9uIGlzUHJvbWlzZSh2YWwpIHtcbiAgICByZXR1cm4gIWlzVW5kZWZpbmVkT3JOdWxsKHZhbCkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xuICB9OyAvLyBFeHRyYSBjb252ZW5pZW5jZSBuYW1lZCByZS1leHBvcnRzXG5cbiAgdmFyIGNsb25lRGVlcCA9IGZ1bmN0aW9uIGNsb25lRGVlcChvYmopIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBvYmo7XG5cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICByZXR1cm4gb2JqLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocmVzdWx0KSwgW2Nsb25lRGVlcCh2YWwsIHZhbCldKTtcbiAgICAgIH0sIFtdKTtcbiAgICB9XG5cbiAgICBpZiAoaXNQbGFpbk9iamVjdChvYmopKSB7XG4gICAgICByZXR1cm4ga2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHt9LCByZXN1bHQsIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBjbG9uZURlZXAob2JqW2tleV0sIG9ialtrZXldKSkpO1xuICAgICAgfSwge30pO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIH07XG5cbiAgdmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgIHJldHVybiB4O1xuICB9O1xuXG4gIHZhciBSWF9BUlJBWV9OT1RBVElPTiA9IC9cXFsoXFxkKyldL2c7XG4gIC8qKlxuICAgKiBHZXQgcHJvcGVydHkgZGVmaW5lZCBieSBkb3QvYXJyYXkgbm90YXRpb24gaW4gc3RyaW5nLlxuICAgKlxuICAgKiBAbGluayBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qZW5lZy85NzY3YWZkY2NhNDU2MDFlYTQ0OTMwZWEwM2UwZmViZiNnaXN0Y29tbWVudC0xOTM1OTAxXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHBhdGhcbiAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuICB2YXIgZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iaiwgcGF0aCkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgLy8gSGFuZGxlIGFycmF5IG9mIHBhdGggdmFsdWVzXG4gICAgcGF0aCA9IGlzQXJyYXkocGF0aCkgPyBwYXRoLmpvaW4oJy4nKSA6IHBhdGg7IC8vIElmIG5vIHBhdGggb3Igbm8gb2JqZWN0IHBhc3NlZFxuXG4gICAgaWYgKCFwYXRoIHx8ICFpc09iamVjdChvYmopKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH0gLy8gSGFuZGxlIGVkZ2UgY2FzZSB3aGVyZSB1c2VyIGhhcyBkb3QocykgaW4gdG9wLWxldmVsIGl0ZW0gZmllbGQga2V5XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ib290c3RyYXAtdnVlL2Jvb3RzdHJhcC12dWUvaXNzdWVzLzI3NjJcbiAgICAvLyBTd2l0Y2hlZCB0byBgaW5gIG9wZXJhdG9yIHZzIGBoYXNPd25Qcm9wZXJ0eWAgdG8gaGFuZGxlIG9iai5wcm90b3R5cGUgZ2V0dGVyc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ib290c3RyYXAtdnVlL2Jvb3RzdHJhcC12dWUvaXNzdWVzLzM0NjNcblxuXG4gICAgaWYgKHBhdGggaW4gb2JqKSB7XG4gICAgICByZXR1cm4gb2JqW3BhdGhdO1xuICAgIH0gLy8gSGFuZGxlIHN0cmluZyBhcnJheSBub3RhdGlvbiAobnVtZXJpYyBpbmRpY2VzIG9ubHkpXG5cblxuICAgIHBhdGggPSBTdHJpbmcocGF0aCkucmVwbGFjZShSWF9BUlJBWV9OT1RBVElPTiwgJy4kMScpO1xuICAgIHZhciBzdGVwcyA9IHBhdGguc3BsaXQoJy4nKS5maWx0ZXIoaWRlbnRpdHkpOyAvLyBIYW5kbGUgY2FzZSB3aGVyZSBzb21lb25lIHBhc3NlcyBhIHN0cmluZyBvZiBvbmx5IGRvdHNcblxuICAgIGlmIChzdGVwcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfSAvLyBUcmF2ZXJzZSBwYXRoIGluIG9iamVjdCB0byBmaW5kIHJlc3VsdFxuICAgIC8vIFdlIHVzZSBgIT1gIHZzIGAhPT1gIHRvIHRlc3QgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIC8vIFN3aXRjaGVkIHRvIGBpbmAgb3BlcmF0b3IgdnMgYGhhc093blByb3BlcnR5YCB0byBoYW5kbGUgb2JqLnByb3RvdHlwZSBnZXR0ZXJzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jvb3RzdHJhcC12dWUvYm9vdHN0cmFwLXZ1ZS9pc3N1ZXMvMzQ2M1xuXG5cbiAgICByZXR1cm4gc3RlcHMuZXZlcnkoZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgIHJldHVybiBpc09iamVjdChvYmopICYmIHN0ZXAgaW4gb2JqICYmIChvYmogPSBvYmpbc3RlcF0pICE9IG51bGw7XG4gICAgfSkgPyBvYmogOiBkZWZhdWx0VmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvZyBhIHdhcm5pbmcgbWVzc2FnZSB0byB0aGUgY29uc29sZSB3aXRoIEJvb3RzdHJhcFZ1ZSBmb3JtYXR0aW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAqL1xuXG4gIHZhciB3YXJuID0gZnVuY3Rpb24gd2FybihtZXNzYWdlKVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgIGlmICghZ2V0Tm9XYXJuKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltCb290c3RyYXBWdWUgd2Fybl06IFwiLmNvbmNhdChzb3VyY2UgPyBcIlwiLmNvbmNhdChzb3VyY2UsIFwiIC0gXCIpIDogJycpLmNvbmNhdChtZXNzYWdlKSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogV2FybiB3aGVuIG5vIFByb21pc2Ugc3VwcG9ydCBpcyBnaXZlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB3YXJuZWRcbiAgICovXG5cbiAgdmFyIHdhcm5Ob3RDbGllbnQgPSBmdW5jdGlvbiB3YXJuTm90Q2xpZW50KHNvdXJjZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFwiXCIuY29uY2F0KHNvdXJjZSwgXCI6IENhbiBub3QgYmUgY2FsbGVkIGR1cmluZyBTU1IuXCIpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFdhcm4gd2hlbiBubyBQcm9taXNlIHN1cHBvcnQgaXMgZ2l2ZW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2FybmVkXG4gICAqL1xuXG4gIHZhciB3YXJuTm9Qcm9taXNlU3VwcG9ydCA9IGZ1bmN0aW9uIHdhcm5Ob1Byb21pc2VTdXBwb3J0KHNvdXJjZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGhhc1Byb21pc2VTdXBwb3J0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXCJcIi5jb25jYXQoc291cmNlLCBcIjogUmVxdWlyZXMgUHJvbWlzZSBzdXBwb3J0LlwiKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBXYXJuIHdoZW4gbm8gTXV0YXRpb25PYnNlcnZlciBzdXBwb3J0IGlzIGdpdmVuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHdhcm5lZFxuICAgKi9cblxuICB2YXIgd2Fybk5vTXV0YXRpb25PYnNlcnZlclN1cHBvcnQgPSBmdW5jdGlvbiB3YXJuTm9NdXRhdGlvbk9ic2VydmVyU3VwcG9ydChzb3VyY2UpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChoYXNNdXRhdGlvbk9ic2VydmVyU3VwcG9ydCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFwiXCIuY29uY2F0KHNvdXJjZSwgXCI6IFJlcXVpcmVzIE11dGF0aW9uT2JzZXJ2ZXIgc3VwcG9ydC5cIikpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuXG4gIC8vIE5PVEVTXG4gIC8vXG4gIC8vIFRoZSBnbG9iYWwgY29uZmlnIFNIQUxMIE5PVCBiZSB1c2VkIHRvIHNldCBkZWZhdWx0cyBmb3IgQm9vbGVhbiBwcm9wcywgYXMgdGhlIHByb3BzXG4gIC8vIHdvdWxkIGxvb3NlIHRoZWlyIHNlbWFudGljIG1lYW5pbmcsIGFuZCBmb3JjZSBwZW9wbGUgd3JpdGluZyAzcmQgcGFydHkgY29tcG9uZW50cyB0b1xuICAvLyBleHBsaWNpdHkgc2V0IGEgdHJ1ZSBvciBmYWxzZSB2YWx1ZSB1c2luZyB0aGUgdi1iaW5kIHN5bnRheCBvbiBib29sZWFuIHByb3BzXG4gIC8vXG4gIC8vIFN1cHBvcnRlZCBjb25maWcgdmFsdWVzIChkZXBlbmRpbmcgb24gdGhlIHByb3AncyBzdXBwb3J0ZWQgdHlwZShzKSk6XG4gIC8vIGBTdHJpbmdgLCBgQXJyYXlgLCBgT2JqZWN0YCwgYG51bGxgIG9yIGB1bmRlZmluZWRgXG4gIC8vIEJSRUFLUE9JTlQgREVGSU5JVElPTlNcbiAgLy9cbiAgLy8gU29tZSBjb21wb25lbnRzIChgPGItY29sPmAgYW5kIGA8Yi1mb3JtLWdyb3VwPmApIGdlbmVyYXRlIHByb3BzIGJhc2VkIG9uIGJyZWFrcG9pbnRzLFxuICAvLyBhbmQgdGhpcyBvY2N1cnMgd2hlbiB0aGUgY29tcG9uZW50IGlzIGZpcnN0IGxvYWRlZCAoZXZhbHVhdGVkKSwgd2hpY2ggbWF5IGhhcHBlblxuICAvLyBiZWZvcmUgdGhlIGNvbmZpZyBpcyBjcmVhdGVkL21vZGlmaWVkXG4gIC8vXG4gIC8vIFRvIGdldCBhcm91bmQgdGhpcyB3ZSBtYWtlIHRoZXNlIGNvbXBvbmVudHMnIHByb3BzIGFzeW5jIChsYXp5IGV2YWx1YXRpb24pXG4gIC8vIFRoZSBjb21wb25lbnQgZGVmaW5pdGlvbiBpcyBvbmx5IGNhbGxlZC9leGVjdXRlZCB3aGVuIHRoZSBmaXJzdCBhY2Nlc3MgdG8gdGhlXG4gIC8vIGNvbXBvbmVudCBpcyB1c2VkIChhbmQgY2FjaGVkIG9uIHN1YnNlcXVlbnQgdXNlcylcbiAgLy8gUFJPUCBERUZBVUxUU1xuICAvL1xuICAvLyBGb3IgZGVmYXVsdCB2YWx1ZXMgb24gcHJvcHMsIHdlIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmYWN0b3J5IGZ1bmN0aW9uIGFwcHJvYWNoIHNvXG4gIC8vIHRoYXQgdGhlIGRlZmF1bHQgdmFsdWVzIGFyZSBwdWxsZWQgaW4gYXQgZWFjaCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAvL1xuICAvLyAgcHJvcHM6IHtcbiAgLy8gICAgdmFyaWFudDoge1xuICAvLyAgICAgIHR5cGU6IFN0cmluZyxcbiAgLy8gICAgICBkZWZhdWx0OiAoKSA9PiBnZXRDb25maWdDb21wb25lbnQoJ0JBbGVydCcsICd2YXJpYW50JylcbiAgLy8gICAgfVxuICAvLyAgfVxuICAvL1xuICAvLyBXZSBhbHNvIHByb3ZpZGUgYSBjYWNoZWQgZ2V0dGVyIGZvciBicmVha3BvaW50cywgd2hpY2ggYXJlIFwiZnJvemVuXCIgb24gZmlyc3QgYWNjZXNzXG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuXG4gIHZhciBERUZBVUxUUyA9IGRlZXBGcmVlemUoe1xuICAgIC8vIEJyZWFrcG9pbnRzXG4gICAgYnJlYWtwb2ludHM6IFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSxcbiAgICAvLyBGb3JtIGNvbnRyb2xzXG4gICAgZm9ybUNvbnRyb2xzOiB7XG4gICAgICBzaXplOiBudWxsXG4gICAgfSxcbiAgICAvLyBDb21wb25lbnQgc3BlY2lmaWMgZGVmYXVsdHMgYXJlIGtleWVkIGJ5IHRoZSBjb21wb25lbnRcbiAgICAvLyBuYW1lIChQYXNjYWxDYXNlKSBhbmQgcHJvcCBuYW1lIChjYW1lbENhc2UpXG4gICAgQkFsZXJ0OiB7XG4gICAgICBkaXNtaXNzTGFiZWw6ICdDbG9zZScsXG4gICAgICB2YXJpYW50OiAnaW5mbydcbiAgICB9LFxuICAgIEJCYWRnZToge1xuICAgICAgdmFyaWFudDogJ3NlY29uZGFyeSdcbiAgICB9LFxuICAgIEJCdXR0b246IHtcbiAgICAgIHNpemU6IG51bGwsXG4gICAgICB2YXJpYW50OiAnc2Vjb25kYXJ5J1xuICAgIH0sXG4gICAgQkJ1dHRvbkNsb3NlOiB7XG4gICAgICBjb250ZW50OiAnJnRpbWVzOycsXG4gICAgICAvLyBgdGV4dFZhcmlhbnRgIGlzIGBudWxsYCB0byBpbmhlcml0IHRoZSBjdXJyZW50IHRleHQgY29sb3JcbiAgICAgIHRleHRWYXJpYW50OiBudWxsLFxuICAgICAgYXJpYUxhYmVsOiAnQ2xvc2UnXG4gICAgfSxcbiAgICBCQ2FsZW5kYXI6IHtcbiAgICAgIC8vIEJGb3JtRGF0ZSB3aWxsIGNob29zZSB0aGVzZSBmaXJzdCBpZiBub3QgcHJvdmlkZWQgaW4gQkZvcm1EYXRlIHNlY3Rpb25cbiAgICAgIGxhYmVsUHJldlllYXI6ICdQcmV2aW91cyB5ZWFyJyxcbiAgICAgIGxhYmVsUHJldk1vbnRoOiAnUHJldmlvdXMgbW9udGgnLFxuICAgICAgbGFiZWxDdXJyZW50TW9udGg6ICdDdXJyZW50IG1vbnRoJyxcbiAgICAgIGxhYmVsTmV4dE1vbnRoOiAnTmV4dCBtb250aCcsXG4gICAgICBsYWJlbE5leHRZZWFyOiAnTmV4dCB5ZWFyJyxcbiAgICAgIGxhYmVsVG9kYXk6ICdUb2RheScsXG4gICAgICBsYWJlbFNlbGVjdGVkOiAnU2VsZWN0ZWQgZGF0ZScsXG4gICAgICBsYWJlbE5vRGF0ZVNlbGVjdGVkOiAnTm8gZGF0ZSBzZWxlY3RlZCcsXG4gICAgICBsYWJlbENhbGVuZGFyOiAnQ2FsZW5kYXInLFxuICAgICAgbGFiZWxOYXY6ICdDYWxlbmRhciBuYXZpZ2F0aW9uJyxcbiAgICAgIGxhYmVsSGVscDogJ1VzZSBjdXJzb3Iga2V5cyB0byBuYXZpZ2F0ZSBjYWxlbmRhciBkYXRlcydcbiAgICB9LFxuICAgIEJDYXJkU3ViVGl0bGU6IHtcbiAgICAgIC8vIGA8Yi1jYXJkPmAgYW5kIGA8Yi1jYXJkLWJvZHk+YCBhbHNvIGluaGVyaXQgdGhpcyBwcm9wXG4gICAgICBzdWJUaXRsZVRleHRWYXJpYW50OiAnbXV0ZWQnXG4gICAgfSxcbiAgICBCQ2Fyb3VzZWw6IHtcbiAgICAgIGxhYmVsUHJldjogJ1ByZXZpb3VzIFNsaWRlJyxcbiAgICAgIGxhYmVsTmV4dDogJ05leHQgU2xpZGUnLFxuICAgICAgbGFiZWxHb3RvU2xpZGU6ICdHb3RvIFNsaWRlJyxcbiAgICAgIGxhYmVsSW5kaWNhdG9yczogJ1NlbGVjdCBhIHNsaWRlIHRvIGRpc3BsYXknXG4gICAgfSxcbiAgICBCRHJvcGRvd246IHtcbiAgICAgIHRvZ2dsZVRleHQ6ICdUb2dnbGUgRHJvcGRvd24nLFxuICAgICAgc2l6ZTogbnVsbCxcbiAgICAgIHZhcmlhbnQ6ICdzZWNvbmRhcnknLFxuICAgICAgc3BsaXRWYXJpYW50OiBudWxsXG4gICAgfSxcbiAgICBCRm9ybURhdGVwaWNrZXI6IHtcbiAgICAgIC8vIEJGb3JtRGF0ZXBpY2tlciB3aWxsIGNob29zZSBmcm9tIEJDYWxlbmRhciBmaXJzdCBpZiBub3QgcHJvdmlkZWQgaW4gQkZvcm1EYXRlcGlja2VyIHNlY3Rpb25cbiAgICAgIGxhYmVsUHJldlllYXI6IG51bGwsXG4gICAgICBsYWJlbFByZXZNb250aDogbnVsbCxcbiAgICAgIGxhYmVsQ3VycmVudE1vbnRoOiBudWxsLFxuICAgICAgbGFiZWxOZXh0TW9udGg6IG51bGwsXG4gICAgICBsYWJlbE5leHRZZWFyOiBudWxsLFxuICAgICAgbGFiZWxUb2RheTogbnVsbCxcbiAgICAgIGxhYmVsU2VsZWN0ZWQ6IG51bGwsXG4gICAgICBsYWJlbE5vRGF0ZVNlbGVjdGVkOiBudWxsLFxuICAgICAgbGFiZWxDYWxlbmRhcjogbnVsbCxcbiAgICAgIGxhYmVsTmF2OiBudWxsLFxuICAgICAgbGFiZWxIZWxwOiBudWxsLFxuICAgICAgLy8gVGhlc2UgcHJvcHMgYXJlIHNwZWNpZmljIHRvIEJGb3JtRGF0ZXBpY2tlclxuICAgICAgbGFiZWxUb2RheUJ1dHRvbjogJ1NlbGVjdCB0b2RheScsXG4gICAgICBsYWJlbFJlc2V0QnV0dG9uOiAnUmVzZXQnLFxuICAgICAgbGFiZWxDbG9zZUJ1dHRvbjogJ0Nsb3NlJ1xuICAgIH0sXG4gICAgQkZvcm1GaWxlOiB7XG4gICAgICBicm93c2VUZXh0OiAnQnJvd3NlJyxcbiAgICAgIC8vIENocm9tZSBkZWZhdWx0IGZpbGUgcHJvbXB0XG4gICAgICBwbGFjZWhvbGRlcjogJ05vIGZpbGUgY2hvc2VuJyxcbiAgICAgIGRyb3BQbGFjZWhvbGRlcjogJ0Ryb3AgZmlsZXMgaGVyZSdcbiAgICB9LFxuICAgIEJGb3JtU3BpbmJ1dHRvbjoge1xuICAgICAgbGFiZWxEZWNyZW1lbnQ6ICdEZWNyZW1lbnQnLFxuICAgICAgbGFiZWxJbmNyZW1lbnQ6ICdJbmNyZW1lbnQnXG4gICAgfSxcbiAgICBCRm9ybVRhZzoge1xuICAgICAgcmVtb3ZlTGFiZWw6ICdSZW1vdmUgdGFnJyxcbiAgICAgIHZhcmlhbnQ6ICdzZWNvbmRhcnknXG4gICAgfSxcbiAgICBCRm9ybVRhZ3M6IHtcbiAgICAgIGFkZEJ1dHRvblRleHQ6ICdBZGQnLFxuICAgICAgYWRkQnV0dG9uVmFyaWFudDogJ291dGxpbmUtc2Vjb25kYXJ5JyxcbiAgICAgIGR1cGxpY2F0ZVRhZ1RleHQ6ICdEdXBsaWNhdGUgdGFnKHMpJyxcbiAgICAgIGludmFsaWRUYWdUZXh0OiAnSW52YWxpZCB0YWcocyknLFxuICAgICAgcGxhY2Vob2xkZXI6ICdBZGQgdGFnLi4uJyxcbiAgICAgIHRhZ1JlbW92ZUxhYmVsOiAnUmVtb3ZlIHRhZycsXG4gICAgICB0YWdSZW1vdmVkTGFiZWw6ICdUYWcgcmVtb3ZlZCcsXG4gICAgICB0YWdWYXJpYW50OiAnc2Vjb25kYXJ5J1xuICAgIH0sXG4gICAgQkZvcm1UZXh0OiB7XG4gICAgICB0ZXh0VmFyaWFudDogJ211dGVkJ1xuICAgIH0sXG4gICAgQkltZzoge1xuICAgICAgYmxhbmtDb2xvcjogJ3RyYW5zcGFyZW50J1xuICAgIH0sXG4gICAgQkltZ0xhenk6IHtcbiAgICAgIGJsYW5rQ29sb3I6ICd0cmFuc3BhcmVudCdcbiAgICB9LFxuICAgIEJJbnB1dEdyb3VwOiB7XG4gICAgICBzaXplOiBudWxsXG4gICAgfSxcbiAgICBCSnVtYm90cm9uOiB7XG4gICAgICBiZ1ZhcmlhbnQ6IG51bGwsXG4gICAgICBib3JkZXJWYXJpYW50OiBudWxsLFxuICAgICAgdGV4dFZhcmlhbnQ6IG51bGxcbiAgICB9LFxuICAgIEJMaXN0R3JvdXBJdGVtOiB7XG4gICAgICB2YXJpYW50OiBudWxsXG4gICAgfSxcbiAgICBCTW9kYWw6IHtcbiAgICAgIHRpdGxlVGFnOiAnaDUnLFxuICAgICAgc2l6ZTogJ21kJyxcbiAgICAgIGhlYWRlckJnVmFyaWFudDogbnVsbCxcbiAgICAgIGhlYWRlckJvcmRlclZhcmlhbnQ6IG51bGwsXG4gICAgICBoZWFkZXJUZXh0VmFyaWFudDogbnVsbCxcbiAgICAgIGhlYWRlckNsb3NlVmFyaWFudDogbnVsbCxcbiAgICAgIGJvZHlCZ1ZhcmlhbnQ6IG51bGwsXG4gICAgICBib2R5VGV4dFZhcmlhbnQ6IG51bGwsXG4gICAgICBmb290ZXJCZ1ZhcmlhbnQ6IG51bGwsXG4gICAgICBmb290ZXJCb3JkZXJWYXJpYW50OiBudWxsLFxuICAgICAgZm9vdGVyVGV4dFZhcmlhbnQ6IG51bGwsXG4gICAgICBjYW5jZWxUaXRsZTogJ0NhbmNlbCcsXG4gICAgICBjYW5jZWxWYXJpYW50OiAnc2Vjb25kYXJ5JyxcbiAgICAgIG9rVGl0bGU6ICdPSycsXG4gICAgICBva1ZhcmlhbnQ6ICdwcmltYXJ5JyxcbiAgICAgIGhlYWRlckNsb3NlQ29udGVudDogJyZ0aW1lczsnLFxuICAgICAgaGVhZGVyQ2xvc2VMYWJlbDogJ0Nsb3NlJ1xuICAgIH0sXG4gICAgQk5hdmJhcjoge1xuICAgICAgdmFyaWFudDogbnVsbFxuICAgIH0sXG4gICAgQk5hdmJhclRvZ2dsZToge1xuICAgICAgbGFiZWw6ICdUb2dnbGUgbmF2aWdhdGlvbidcbiAgICB9LFxuICAgIEJQYWdpbmF0aW9uOiB7XG4gICAgICBzaXplOiBudWxsXG4gICAgfSxcbiAgICBCUGFnaW5hdGlvbk5hdjoge1xuICAgICAgc2l6ZTogbnVsbFxuICAgIH0sXG4gICAgQlBvcG92ZXI6IHtcbiAgICAgIGJvdW5kYXJ5OiAnc2Nyb2xsUGFyZW50JyxcbiAgICAgIGJvdW5kYXJ5UGFkZGluZzogNSxcbiAgICAgIGN1c3RvbUNsYXNzOiBudWxsLFxuICAgICAgZGVsYXk6IDUwLFxuICAgICAgdmFyaWFudDogbnVsbFxuICAgIH0sXG4gICAgQlByb2dyZXNzOiB7XG4gICAgICB2YXJpYW50OiBudWxsXG4gICAgfSxcbiAgICBCUHJvZ3Jlc3NCYXI6IHtcbiAgICAgIHZhcmlhbnQ6IG51bGxcbiAgICB9LFxuICAgIEJTcGlubmVyOiB7XG4gICAgICB2YXJpYW50OiBudWxsXG4gICAgfSxcbiAgICBCVGFibGU6IHtcbiAgICAgIHNlbGVjdGVkVmFyaWFudDogJ2FjdGl2ZScsXG4gICAgICBoZWFkVmFyaWFudDogbnVsbCxcbiAgICAgIGZvb3RWYXJpYW50OiBudWxsXG4gICAgfSxcbiAgICBCVG9hc3Q6IHtcbiAgICAgIHRvYXN0ZXI6ICdiLXRvYXN0ZXItdG9wLXJpZ2h0JyxcbiAgICAgIGF1dG9IaWRlRGVsYXk6IDUwMDAsXG4gICAgICB2YXJpYW50OiBudWxsLFxuICAgICAgdG9hc3RDbGFzczogbnVsbCxcbiAgICAgIGhlYWRlckNsYXNzOiBudWxsLFxuICAgICAgYm9keUNsYXNzOiBudWxsXG4gICAgfSxcbiAgICBCVG9hc3Rlcjoge1xuICAgICAgYXJpYUxpdmU6IG51bGwsXG4gICAgICBhcmlhQXRvbWljOiBudWxsLFxuICAgICAgcm9sZTogbnVsbFxuICAgIH0sXG4gICAgQlRvb2x0aXA6IHtcbiAgICAgIGJvdW5kYXJ5OiAnc2Nyb2xsUGFyZW50JyxcbiAgICAgIGJvdW5kYXJ5UGFkZGluZzogNSxcbiAgICAgIGN1c3RvbUNsYXNzOiBudWxsLFxuICAgICAgZGVsYXk6IDUwLFxuICAgICAgdmFyaWFudDogbnVsbFxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIE5BTUUgPSAnQnZDb25maWcnO1xuICB2YXIgUFJPUF9OQU1FID0gJyRidkNvbmZpZyc7IC8vIENvbmZpZyBtYW5hZ2VyIGNsYXNzXG5cbiAgdmFyIEJ2Q29uZmlnID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnZDb25maWcoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnZDb25maWcpO1xuXG4gICAgICAvLyBUT0RPOiBwcmUtcG9wdWxhdGUgd2l0aCBkZWZhdWx0IGNvbmZpZyB2YWx1ZXMgKG5lZWRzIHVwZGF0ZWQgdGVzdHMpXG4gICAgICAvLyB0aGlzLiRfY29uZmlnID0gY2xvbmVEZWVwKERFRkFVTFRTKVxuICAgICAgdGhpcy4kX2NvbmZpZyA9IHt9O1xuICAgICAgdGhpcy4kX2NhY2hlZEJyZWFrcG9pbnRzID0gbnVsbDtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQnZDb25maWcsIFt7XG4gICAgICBrZXk6IFwiZ2V0RGVmYXVsdHNcIixcbiAgICAgIC8vIFJldHVybnMgdGhlIGRlZmF1bHRzXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmYXVsdHMoKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdHM7XG4gICAgICB9IC8vIE1ldGhvZCB0byBtZXJnZSBpbiB1c2VyIGNvbmZpZyBwYXJhbWV0ZXJzXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0Q29uZmlnXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29uZmlnKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBjb25maWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgIGlmICghaXNQbGFpbk9iamVjdChjb25maWcpKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29uZmlnS2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoY29uZmlnKTtcbiAgICAgICAgY29uZmlnS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChjbXBOYW1lKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KERFRkFVTFRTLCBjbXBOYW1lKSkge1xuICAgICAgICAgICAgd2FybihcIlVua25vd24gY29uZmlnIHByb3BlcnR5IFxcXCJcIi5jb25jYXQoY21wTmFtZSwgXCJcXFwiXCIpLCBOQU1FKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY21wQ29uZmlnID0gY29uZmlnW2NtcE5hbWVdO1xuXG4gICAgICAgICAgaWYgKGNtcE5hbWUgPT09ICdicmVha3BvaW50cycpIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYnJlYWtwb2ludHNcbiAgICAgICAgICAgIHZhciBicmVha3BvaW50cyA9IGNvbmZpZy5icmVha3BvaW50cztcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkoYnJlYWtwb2ludHMpIHx8IGJyZWFrcG9pbnRzLmxlbmd0aCA8IDIgfHwgYnJlYWtwb2ludHMuc29tZShmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgICByZXR1cm4gIWlzU3RyaW5nKGIpIHx8IGIubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgd2FybignXCJicmVha3BvaW50c1wiIG11c3QgYmUgYW4gYXJyYXkgb2YgYXQgbGVhc3QgMiBicmVha3BvaW50IG5hbWVzJywgTkFNRSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpcy4kX2NvbmZpZy5icmVha3BvaW50cyA9IGNsb25lRGVlcChicmVha3BvaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGNtcENvbmZpZykpIHtcbiAgICAgICAgICAgIC8vIENvbXBvbmVudCBwcm9wIGRlZmF1bHRzXG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKGNtcENvbmZpZyk7XG4gICAgICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KERFRkFVTFRTW2NtcE5hbWVdLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIHdhcm4oXCJVbmtub3duIGNvbmZpZyBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGNtcE5hbWUsIFwiLlwiKS5jb25jYXQocHJvcCwgXCJcXFwiXCIpLCBOQU1FKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJZiB3ZSBwcmUtcG9wdWxhdGUgdGhlIGNvbmZpZyB3aXRoIGRlZmF1bHRzLCB3ZSBjYW4gc2tpcCB0aGlzIGxpbmVcbiAgICAgICAgICAgICAgICBfdGhpcy4kX2NvbmZpZ1tjbXBOYW1lXSA9IF90aGlzLiRfY29uZmlnW2NtcE5hbWVdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChjbXBDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy4kX2NvbmZpZ1tjbXBOYW1lXVtwcm9wXSA9IGNsb25lRGVlcChjbXBDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gQ2xlYXIgdGhlIGNvbmZpZy4gRm9yIHRlc3RpbmcgcHVycG9zZXMgb25seVxuXG4gICAgfSwge1xuICAgICAga2V5OiBcInJlc2V0Q29uZmlnXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRDb25maWcoKSB7XG4gICAgICAgIHRoaXMuJF9jb25maWcgPSB7fTtcbiAgICAgIH0gLy8gUmV0dXJucyBhIGRlZXAgY29weSBvZiB0aGUgdXNlciBjb25maWdcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRDb25maWdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25maWcoKSB7XG4gICAgICAgIHJldHVybiBjbG9uZURlZXAodGhpcy4kX2NvbmZpZyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldENvbmZpZ1ZhbHVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29uZmlnVmFsdWUoa2V5KSB7XG4gICAgICAgIC8vIEZpcnN0IHdlIHRyeSB0aGUgdXNlciBjb25maWcsIGFuZCBpZiBrZXkgbm90IGZvdW5kIHdlIGZhbGwgYmFjayB0byBkZWZhdWx0IHZhbHVlXG4gICAgICAgIC8vIE5PVEU6IElmIHdlIGRlZXAgY2xvbmUgREVGQVVMVFMgaW50byBjb25maWcsIHRoZW4gd2UgY2FuIHNraXAgdGhlIGZhbGxiYWNrIGZvciBnZXRcbiAgICAgICAgcmV0dXJuIGNsb25lRGVlcChnZXQodGhpcy4kX2NvbmZpZywga2V5LCBnZXQoREVGQVVMVFMsIGtleSkpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVmYXVsdHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB7XG4gICAgICAgIHJldHVybiBERUZBVUxUUztcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJEZWZhdWx0c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRTO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBCdkNvbmZpZztcbiAgfSgpOyAvLyBNZXRob2QgZm9yIGFwcGx5aW5nIGEgZ2xvYmFsIGNvbmZpZ1xuXG5cbiAgdmFyIHNldENvbmZpZyA9IGZ1bmN0aW9uIHNldENvbmZpZygpIHtcbiAgICB2YXIgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgVnVlJDEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFZ1ZTtcbiAgICAvLyBFbnN1cmUgd2UgaGF2ZSBhICRidkNvbmZpZyBPYmplY3Qgb24gdGhlIFZ1ZSBwcm90b3R5cGUuXG4gICAgLy8gV2Ugc2V0IG9uIFZ1ZSBhbmQgT3VyVnVlIGp1c3QgaW4gY2FzZSBjb25zdW1lciBoYXMgbm90IHNldCBhbiBhbGlhcyBvZiBgdnVlYC5cbiAgICBWdWUkMS5wcm90b3R5cGVbUFJPUF9OQU1FXSA9IFZ1ZS5wcm90b3R5cGVbUFJPUF9OQU1FXSA9IFZ1ZSQxLnByb3RvdHlwZVtQUk9QX05BTUVdIHx8IFZ1ZS5wcm90b3R5cGVbUFJPUF9OQU1FXSB8fCBuZXcgQnZDb25maWcoKTsgLy8gQXBwbHkgdGhlIGNvbmZpZyB2YWx1ZXNcblxuICAgIFZ1ZSQxLnByb3RvdHlwZVtQUk9QX05BTUVdLnNldENvbmZpZyhjb25maWcpO1xuICB9OyAvLyBNZXRob2QgZm9yIHJlc2V0dGluZyB0aGUgdXNlciBjb25maWcuIEV4cG9ydGVkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIFZ1ZSwgYW5kIHdhcm5zIChvbmNlKSBhYm91dCBwb3NzaWJsZSBpc3N1ZXMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBWdWVcbiAgICovXG5cbiAgdmFyIGNoZWNrTXVsdGlwbGVWdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoZWNrTXVsdGlwbGVWdWVXYXJuZWQgPSBmYWxzZTtcbiAgICB2YXIgTVVMVElQTEVfVlVFX1dBUk5JTkcgPSBbJ011bHRpcGxlIGluc3RhbmNlcyBvZiBWdWUgZGV0ZWN0ZWQhJywgJ1lvdSBtYXkgbmVlZCB0byBzZXQgdXAgYW4gYWxpYXMgZm9yIFZ1ZSBpbiB5b3VyIGJ1bmRsZXIgY29uZmlnLicsICdTZWU6IGh0dHBzOi8vYm9vdHN0cmFwLXZ1ZS5qcy5vcmcvZG9jcyN1c2luZy1tb2R1bGUtYnVuZGxlcnMnXS5qb2luKCdcXG4nKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKFZ1ZSQxKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKCFjaGVja011bHRpcGxlVnVlV2FybmVkICYmIFZ1ZSAhPT0gVnVlJDEgJiYgIWlzSlNET00pIHtcbiAgICAgICAgd2FybihNVUxUSVBMRV9WVUVfV0FSTklORyk7XG4gICAgICB9XG5cbiAgICAgIGNoZWNrTXVsdGlwbGVWdWVXYXJuZWQgPSB0cnVlO1xuICAgIH07XG4gIH0oKTtcbiAgLyoqXG4gICAqIFBsdWdpbiBpbnN0YWxsIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB7IGNvbXBvbmVudHMsIGRpcmVjdGl2ZXMgfVxuICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259IHBsdWdpbiBpbnN0YWxsIGZ1bmN0aW9uXG4gICAqL1xuXG4gIHZhciBpbnN0YWxsRmFjdG9yeSA9IGZ1bmN0aW9uIGluc3RhbGxGYWN0b3J5KCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgY29tcG9uZW50cyA9IF9yZWYuY29tcG9uZW50cyxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYuZGlyZWN0aXZlcyxcbiAgICAgICAgcGx1Z2lucyA9IF9yZWYucGx1Z2lucztcblxuICAgIHZhciBpbnN0YWxsID0gZnVuY3Rpb24gaW5zdGFsbChWdWUpIHtcbiAgICAgIHZhciBjb25maWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBpZiAoaW5zdGFsbC5pbnN0YWxsZWQpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpbnN0YWxsLmluc3RhbGxlZCA9IHRydWU7XG4gICAgICBjaGVja011bHRpcGxlVnVlKFZ1ZSk7XG4gICAgICBzZXRDb25maWcoY29uZmlnLCBWdWUpO1xuICAgICAgcmVnaXN0ZXJDb21wb25lbnRzKFZ1ZSwgY29tcG9uZW50cyk7XG4gICAgICByZWdpc3RlckRpcmVjdGl2ZXMoVnVlLCBkaXJlY3RpdmVzKTtcbiAgICAgIHJlZ2lzdGVyUGx1Z2lucyhWdWUsIHBsdWdpbnMpO1xuICAgIH07XG5cbiAgICBpbnN0YWxsLmluc3RhbGxlZCA9IGZhbHNlO1xuICAgIHJldHVybiBpbnN0YWxsO1xuICB9O1xuICAvKipcbiAgICogUGx1Z2luIG9iamVjdCBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge29iamVjdH0geyBjb21wb25lbnRzLCBkaXJlY3RpdmVzLCBwbHVnaW5zIH1cbiAgICogQHJldHVybnMge29iamVjdH0gcGx1Z2luIGluc3RhbGwgb2JqZWN0XG4gICAqL1xuXG4gIHZhciBwbHVnaW5GYWN0b3J5ID0gZnVuY3Rpb24gcGx1Z2luRmFjdG9yeSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGV4dGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHt9LCBleHRlbmQsIHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGxGYWN0b3J5KG9wdGlvbnMpXG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBMb2FkIGEgZ3JvdXAgb2YgcGx1Z2lucy5cbiAgICogQHBhcmFtIHtvYmplY3R9IFZ1ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luIGRlZmluaXRpb25zXG4gICAqL1xuXG4gIHZhciByZWdpc3RlclBsdWdpbnMgPSBmdW5jdGlvbiByZWdpc3RlclBsdWdpbnMoVnVlKSB7XG4gICAgdmFyIHBsdWdpbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgZm9yICh2YXIgcGx1Z2luIGluIHBsdWdpbnMpIHtcbiAgICAgIGlmIChwbHVnaW4gJiYgcGx1Z2luc1twbHVnaW5dKSB7XG4gICAgICAgIFZ1ZS51c2UocGx1Z2luc1twbHVnaW5dKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBMb2FkIGEgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge29iamVjdH0gVnVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBDb21wb25lbnQgbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gQ29tcG9uZW50IGRlZmluaXRpb25cbiAgICovXG5cbiAgdmFyIHJlZ2lzdGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gcmVnaXN0ZXJDb21wb25lbnQoVnVlLCBuYW1lLCBkZWYpIHtcbiAgICBpZiAoVnVlICYmIG5hbWUgJiYgZGVmKSB7XG4gICAgICBWdWUuY29tcG9uZW50KG5hbWUsIGRlZik7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogTG9hZCBhIGdyb3VwIG9mIGNvbXBvbmVudHMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBWdWVcbiAgICogQHBhcmFtIHtvYmplY3R9IE9iamVjdCBvZiBjb21wb25lbnQgZGVmaW5pdGlvbnNcbiAgICovXG5cbiAgdmFyIHJlZ2lzdGVyQ29tcG9uZW50cyA9IGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50cyhWdWUpIHtcbiAgICB2YXIgY29tcG9uZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBmb3IgKHZhciBjb21wb25lbnQgaW4gY29tcG9uZW50cykge1xuICAgICAgcmVnaXN0ZXJDb21wb25lbnQoVnVlLCBjb21wb25lbnQsIGNvbXBvbmVudHNbY29tcG9uZW50XSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogTG9hZCBhIGRpcmVjdGl2ZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IFZ1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gRGlyZWN0aXZlIG5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IERpcmVjdGl2ZSBkZWZpbml0aW9uXG4gICAqL1xuXG4gIHZhciByZWdpc3RlckRpcmVjdGl2ZSA9IGZ1bmN0aW9uIHJlZ2lzdGVyRGlyZWN0aXZlKFZ1ZSwgbmFtZSwgZGVmKSB7XG4gICAgaWYgKFZ1ZSAmJiBuYW1lICYmIGRlZikge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgYW55IGxlYWRpbmcgViBpcyByZW1vdmVkIGZyb20gdGhlXG4gICAgICAvLyBuYW1lLCBhcyBWdWUgYWRkcyBpdCBhdXRvbWF0aWNhbGx5XG4gICAgICBWdWUuZGlyZWN0aXZlKG5hbWUucmVwbGFjZSgvXlZCLywgJ0InKSwgZGVmKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBMb2FkIGEgZ3JvdXAgb2YgZGlyZWN0aXZlcy5cbiAgICogQHBhcmFtIHtvYmplY3R9IFZ1ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gT2JqZWN0IG9mIGRpcmVjdGl2ZSBkZWZpbml0aW9uc1xuICAgKi9cblxuICB2YXIgcmVnaXN0ZXJEaXJlY3RpdmVzID0gZnVuY3Rpb24gcmVnaXN0ZXJEaXJlY3RpdmVzKFZ1ZSkge1xuICAgIHZhciBkaXJlY3RpdmVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIGZvciAodmFyIGRpcmVjdGl2ZSBpbiBkaXJlY3RpdmVzKSB7XG4gICAgICByZWdpc3RlckRpcmVjdGl2ZShWdWUsIGRpcmVjdGl2ZSwgZGlyZWN0aXZlc1tkaXJlY3RpdmVdKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBJbnN0YWxsIHBsdWdpbiBpZiB3aW5kb3cuVnVlIGF2YWlsYWJsZVxuICAgKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luIGRlZmluaXRpb25cbiAgICovXG5cbiAgdmFyIHZ1ZVVzZSA9IGZ1bmN0aW9uIHZ1ZVVzZShWdWVQbHVnaW4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmIChoYXNXaW5kb3dTdXBwb3J0ICYmIHdpbmRvdy5WdWUpIHtcbiAgICAgIHdpbmRvdy5WdWUudXNlKFZ1ZVBsdWdpbik7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICAgIGlmIChoYXNXaW5kb3dTdXBwb3J0ICYmIFZ1ZVBsdWdpbi5OQU1FKSB7XG4gICAgICB3aW5kb3dbVnVlUGx1Z2luLk5BTUVdID0gVnVlUGx1Z2luO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgICB2YXIgY2FjaGUgPSBjcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJnc0tleSA9IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FyZ3NLZXldID0gY2FjaGVbYXJnc0tleV0gfHwgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgUFJPUF9OQU1FJDEgPSAnJGJ2Q29uZmlnJztcbiAgdmFyIFZ1ZVByb3RvID0gVnVlLnByb3RvdHlwZTsgLy8gLS0tIEdldHRlciBtZXRob2RzIC0tLVxuXG4gIHZhciBnZXRDb25maWdWYWx1ZSA9IGZ1bmN0aW9uIGdldENvbmZpZ1ZhbHVlKGtleSkge1xuICAgIHJldHVybiBWdWVQcm90b1tQUk9QX05BTUUkMV0gPyBWdWVQcm90b1tQUk9QX05BTUUkMV0uZ2V0Q29uZmlnVmFsdWUoa2V5KSA6IGNsb25lRGVlcChnZXQoREVGQVVMVFMsIGtleSkpO1xuICB9OyAvLyBNZXRob2QgdG8gZ3JhYiBhIGNvbmZpZyB2YWx1ZSBmb3IgYSBwYXJ0aWN1bGFyIGNvbXBvbmVudFxuXG4gIHZhciBnZXRDb21wb25lbnRDb25maWcgPSBmdW5jdGlvbiBnZXRDb21wb25lbnRDb25maWcoY21wTmFtZSkge1xuICAgIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgLy8gUmV0dXJuIHRoZSBwYXJ0aWN1bGFyIGNvbmZpZyB2YWx1ZSBmb3Iga2V5IGZvciBpZiBzcGVjaWZpZWQsXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHJldHVybiB0aGUgZnVsbCBjb25maWcgKG9yIGFuIGVtcHR5IG9iamVjdCBpZiBub3QgZm91bmQpXG4gICAgcmV0dXJuIGtleSA/IGdldENvbmZpZ1ZhbHVlKFwiXCIuY29uY2F0KGNtcE5hbWUsIFwiLlwiKS5jb25jYXQoa2V5KSkgOiBnZXRDb25maWdWYWx1ZShjbXBOYW1lKSB8fCB7fTtcbiAgfTsgLy8gQ29udmVuaWVuY2UgbWV0aG9kIGZvciBnZXR0aW5nIGFsbCBicmVha3BvaW50IG5hbWVzXG5cbiAgdmFyIGdldEJyZWFrcG9pbnRzID0gZnVuY3Rpb24gZ2V0QnJlYWtwb2ludHMoKSB7XG4gICAgcmV0dXJuIGdldENvbmZpZ1ZhbHVlKCdicmVha3BvaW50cycpO1xuICB9OyAvLyBQcml2YXRlIGZ1bmN0aW9uIGZvciBjYWNoaW5nIC8gbG9ja2luZy1pbiBicmVha3BvaW50IG5hbWVzXG5cbiAgdmFyIF9nZXRCcmVha3BvaW50c0NhY2hlZCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRCcmVha3BvaW50cygpO1xuICB9KTsgLy8gQ29udmVuaWVuY2UgbWV0aG9kIGZvciBnZXR0aW5nIGFsbCBicmVha3BvaW50IG5hbWVzLlxuICAvLyBDYWNoZXMgdGhlIHJlc3VsdHMgYWZ0ZXIgZmlyc3QgYWNjZXNzLlxuXG5cbiAgdmFyIGdldEJyZWFrcG9pbnRzQ2FjaGVkID0gZnVuY3Rpb24gZ2V0QnJlYWtwb2ludHNDYWNoZWQoKSB7XG4gICAgcmV0dXJuIGNsb25lRGVlcChfZ2V0QnJlYWtwb2ludHNDYWNoZWQoKSk7XG4gIH07IC8vIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgZ2V0dGluZyBicmVha3BvaW50cyB3aXRoXG4gIC8vIHRoZSBzbWFsbGVzdCBicmVha3BvaW50IHNldCBhcyAnJy5cbiAgLy8gVXNlZnVsIGZvciBjb21wb25lbnRzIHRoYXQgY3JlYXRlIGJyZWFrcG9pbnQgc3BlY2lmaWMgcHJvcHMuXG4gIC8vIENhY2hlcyB0aGUgcmVzdWx0cyBhZnRlciBmaXJzdCBhY2Nlc3MuXG5cbiAgdmFyIGdldEJyZWFrcG9pbnRzVXBDYWNoZWQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYnJlYWtwb2ludHMgPSBnZXRCcmVha3BvaW50c0NhY2hlZCgpO1xuICAgIGJyZWFrcG9pbnRzWzBdID0gJyc7XG4gICAgcmV0dXJuIGJyZWFrcG9pbnRzO1xuICB9KTsgLy8gQ29udmVuaWVuY2UgbWV0aG9kIGZvciBnZXR0aW5nIGJyZWFrcG9pbnRzIHdpdGhcblxuICB2YXIgdyQxID0gaGFzV2luZG93U3VwcG9ydCA/IHdpbmRvdyA6IHt9O1xuICB2YXIgZCA9IGhhc0RvY3VtZW50U3VwcG9ydCA/IGRvY3VtZW50IDoge307XG4gIHZhciBlbFByb3RvID0gdHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnID8gRWxlbWVudC5wcm90b3R5cGUgOiB7fTsgLy8gLS0tIE5vcm1hbGl6YXRpb24gdXRpbHMgLS0tXG4gIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvbWF0Y2hlcyNQb2x5ZmlsbFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgdmFyIG1hdGNoZXNFbCA9IGVsUHJvdG8ubWF0Y2hlcyB8fCBlbFByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGVsUHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yOyAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3RcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gIHZhciBjbG9zZXN0RWwgPSBlbFByb3RvLmNsb3Nlc3QgfHwgZnVuY3Rpb24gKHNlbClcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAge1xuICAgIHZhciBlbCA9IHRoaXM7XG5cbiAgICBkbyB7XG4gICAgICAvLyBVc2Ugb3VyIFwicGF0Y2hlZFwiIG1hdGNoZXMgZnVuY3Rpb25cbiAgICAgIGlmIChtYXRjaGVzKGVsLCBzZWwpKSB7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cblxuICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGU7XG4gICAgfSB3aGlsZSAoIWlzTnVsbChlbCkgJiYgZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKTtcblxuICAgIHJldHVybiBudWxsO1xuICB9OyAvLyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKClgIGNvbnZlbmllbmNlIG1ldGhvZFxuXG4gIHZhciByZXF1ZXN0QUYgPSB3JDEucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHckMS53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgdyQxLm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3JDEubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgdyQxLm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgLy8gRmFsbGJhY2ssIGJ1dCBub3QgYSB0cnVlIHBvbHlmaWxsXG4gIC8vIE9ubHkgbmVlZGVkIGZvciBPcGVyYSBNaW5pXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZnVuY3Rpb24gKGNiKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoY2IsIDE2KTtcbiAgfTtcbiAgdmFyIE11dGF0aW9uT2JzID0gdyQxLk11dGF0aW9uT2JzZXJ2ZXIgfHwgdyQxLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIgfHwgdyQxLk1vek11dGF0aW9uT2JzZXJ2ZXIgfHwgbnVsbDsgLy8gLS0tIFV0aWxzIC0tLVxuICAvLyBSZW1vdmUgYSBub2RlIGZyb20gRE9NXG5cbiAgdmFyIHJlbW92ZU5vZGUgPSBmdW5jdGlvbiByZW1vdmVOb2RlKGVsKSB7XG4gICAgcmV0dXJuIGVsICYmIGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gIH07IC8vIERldGVybWluZSBpZiBhbiBlbGVtZW50IGlzIGFuIEhUTUwgZWxlbWVudFxuXG4gIHZhciBpc0VsZW1lbnQgPSBmdW5jdGlvbiBpc0VsZW1lbnQoZWwpIHtcbiAgICByZXR1cm4gISEoZWwgJiYgZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKTtcbiAgfTsgLy8gRGV0ZXJtaW5lIGlmIGFuIEhUTUwgZWxlbWVudCBpcyB2aXNpYmxlIC0gRmFzdGVyIHRoYW4gQ1NTIGNoZWNrXG5cbiAgdmFyIGlzVmlzaWJsZSA9IGZ1bmN0aW9uIGlzVmlzaWJsZShlbCkge1xuICAgIGlmICghaXNFbGVtZW50KGVsKSB8fCAhZWwucGFyZW50Tm9kZSB8fCAhY29udGFpbnMoZC5ib2R5LCBlbCkpIHtcbiAgICAgIC8vIE5vdGUgdGhpcyBjYW4gZmFpbCBmb3Igc2hhZG93IGRvbSBlbGVtZW50cyBzaW5jZSB0aGV5XG4gICAgICAvLyBhcmUgbm90IGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgZG9jdW1lbnQuYm9keVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgIC8vIFdlIGRvIHRoaXMgY2hlY2sgdG8gaGVscCB3aXRoIHZ1ZS10ZXN0LXV0aWxzIHdoZW4gdXNpbmcgdi1zaG93XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBBbGwgYnJvd3NlcnMgc3VwcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZXhjZXB0IEpTRE9NIGFzIGl0IHJldHVybnMgYWxsIDAncyBmb3IgdmFsdWVzIDooXG4gICAgLy8gU28gYW55IHRlc3RzIHRoYXQgbmVlZCBpc1Zpc2libGUgd2lsbCBmYWlsIGluIEpTRE9NXG4gICAgLy8gRXhjZXB0IHdoZW4gd2Ugb3ZlcnJpZGUgdGhlIGdldEJDUiBwcm90b3R5cGUgaW4gc29tZSB0ZXN0c1xuXG5cbiAgICB2YXIgYmNyID0gZ2V0QkNSKGVsKTtcbiAgICByZXR1cm4gISEoYmNyICYmIGJjci5oZWlnaHQgPiAwICYmIGJjci53aWR0aCA+IDApO1xuICB9OyAvLyBEZXRlcm1pbmUgaWYgYW4gZWxlbWVudCBpcyBkaXNhYmxlZFxuXG4gIHZhciBpc0Rpc2FibGVkID0gZnVuY3Rpb24gaXNEaXNhYmxlZChlbCkge1xuICAgIHJldHVybiAhaXNFbGVtZW50KGVsKSB8fCBlbC5kaXNhYmxlZCB8fCBoYXNBdHRyKGVsLCAnZGlzYWJsZWQnKSB8fCBoYXNDbGFzcyhlbCwgJ2Rpc2FibGVkJyk7XG4gIH07IC8vIENhdXNlL3dhaXQtZm9yIGFuIGVsZW1lbnQgdG8gcmVmbG93IGl0cyBjb250ZW50IChhZGp1c3RpbmcgaXRzIGhlaWdodC93aWR0aClcblxuICB2YXIgcmVmbG93ID0gZnVuY3Rpb24gcmVmbG93KGVsKSB7XG4gICAgLy8gUmVxdWVzdGluZyBhbiBlbGVtZW50cyBvZmZzZXRIaWdodCB3aWxsIHRyaWdnZXIgYSByZWZsb3cgb2YgdGhlIGVsZW1lbnQgY29udGVudFxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHJlZmxvdyBkb2Vzbid0IGhhcHBlbiBpbiBKU0RPTSAqL1xuICAgIHJldHVybiBpc0VsZW1lbnQoZWwpICYmIGVsLm9mZnNldEhlaWdodDtcbiAgfTsgLy8gU2VsZWN0IGFsbCBlbGVtZW50cyBtYXRjaGluZyBzZWxlY3Rvci4gUmV0dXJucyBgW11gIGlmIG5vbmUgZm91bmRcblxuICB2YXIgc2VsZWN0QWxsID0gZnVuY3Rpb24gc2VsZWN0QWxsKHNlbGVjdG9yLCByb290KSB7XG4gICAgcmV0dXJuIGZyb20oKGlzRWxlbWVudChyb290KSA/IHJvb3QgOiBkKS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gIH07IC8vIFNlbGVjdCBhIHNpbmdsZSBlbGVtZW50LCByZXR1cm5zIGBudWxsYCBpZiBub3QgZm91bmRcblxuICB2YXIgc2VsZWN0ID0gZnVuY3Rpb24gc2VsZWN0KHNlbGVjdG9yLCByb290KSB7XG4gICAgcmV0dXJuIChpc0VsZW1lbnQocm9vdCkgPyByb290IDogZCkucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgfHwgbnVsbDtcbiAgfTsgLy8gRGV0ZXJtaW5lIGlmIGFuIGVsZW1lbnQgbWF0Y2hlcyBhIHNlbGVjdG9yXG5cbiAgdmFyIG1hdGNoZXMgPSBmdW5jdGlvbiBtYXRjaGVzKGVsLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBpc0VsZW1lbnQoZWwpID8gbWF0Y2hlc0VsLmNhbGwoZWwsIHNlbGVjdG9yKSA6IGZhbHNlO1xuICB9OyAvLyBGaW5kcyBjbG9zZXN0IGVsZW1lbnQgbWF0Y2hpbmcgc2VsZWN0b3IuIFJldHVybnMgYG51bGxgIGlmIG5vdCBmb3VuZFxuXG4gIHZhciBjbG9zZXN0ID0gZnVuY3Rpb24gY2xvc2VzdChzZWxlY3Rvciwgcm9vdCkge1xuICAgIHZhciBpbmNsdWRlUm9vdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICBpZiAoIWlzRWxlbWVudChyb290KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGVsID0gY2xvc2VzdEVsLmNhbGwocm9vdCwgc2VsZWN0b3IpOyAvLyBOYXRpdmUgY2xvc2VzdCBiZWhhdmlvdXIgd2hlbiBgaW5jbHVkZVJvb3RgIGlzIHRydXRoeSxcbiAgICAvLyBlbHNlIGVtdWxhdGUgalF1ZXJ5IGNsb3Nlc3QgYW5kIHJldHVybiBgbnVsbGAgaWYgbWF0Y2ggaXNcbiAgICAvLyB0aGUgcGFzc2VkIGluIHJvb3QgZWxlbWVudCB3aGVuIGBpbmNsdWRlUm9vdGAgaXMgZmFsc2V5XG5cbiAgICByZXR1cm4gaW5jbHVkZVJvb3QgPyBlbCA6IGVsID09PSByb290ID8gbnVsbCA6IGVsO1xuICB9OyAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIHBhcmVudCBlbGVtZW50IGNvbnRhaW5zIHRoZSBjaGlsZCBlbGVtZW50XG5cbiAgdmFyIGNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICAgIHJldHVybiBwYXJlbnQgJiYgaXNGdW5jdGlvbihwYXJlbnQuY29udGFpbnMpID8gcGFyZW50LmNvbnRhaW5zKGNoaWxkKSA6IGZhbHNlO1xuICB9OyAvLyBHZXQgYW4gZWxlbWVudCBnaXZlbiBhbiBJRFxuXG4gIHZhciBnZXRCeUlkID0gZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiBkLmdldEVsZW1lbnRCeUlkKC9eIy8udGVzdChpZCkgPyBpZC5zbGljZSgxKSA6IGlkKSB8fCBudWxsO1xuICB9OyAvLyBBZGQgYSBjbGFzcyB0byBhbiBlbGVtZW50XG5cbiAgdmFyIGFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xuICAgIC8vIFdlIGFyZSBjaGVja2luZyBmb3IgYGVsLmNsYXNzTGlzdGAgZXhpc3RlbmNlIGhlcmUgc2luY2UgSUUgMTFcbiAgICAvLyByZXR1cm5zIGB1bmRlZmluZWRgIGZvciBzb21lIGVsZW1lbnRzIChlLmcuIFNWRyBlbGVtZW50cylcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jvb3RzdHJhcC12dWUvYm9vdHN0cmFwLXZ1ZS9pc3N1ZXMvMjcxM1xuICAgIGlmIChjbGFzc05hbWUgJiYgaXNFbGVtZW50KGVsKSAmJiBlbC5jbGFzc0xpc3QpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICB9XG4gIH07IC8vIFJlbW92ZSBhIGNsYXNzIGZyb20gYW4gZWxlbWVudFxuXG4gIHZhciByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpIHtcbiAgICAvLyBXZSBhcmUgY2hlY2tpbmcgZm9yIGBlbC5jbGFzc0xpc3RgIGV4aXN0ZW5jZSBoZXJlIHNpbmNlIElFIDExXG4gICAgLy8gcmV0dXJucyBgdW5kZWZpbmVkYCBmb3Igc29tZSBlbGVtZW50cyAoZS5nLiBTVkcgZWxlbWVudHMpXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ib290c3RyYXAtdnVlL2Jvb3RzdHJhcC12dWUvaXNzdWVzLzI3MTNcbiAgICBpZiAoY2xhc3NOYW1lICYmIGlzRWxlbWVudChlbCkgJiYgZWwuY2xhc3NMaXN0KSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgfVxuICB9OyAvLyBUZXN0IGlmIGFuIGVsZW1lbnQgaGFzIGEgY2xhc3NcblxuICB2YXIgaGFzQ2xhc3MgPSBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgLy8gV2UgYXJlIGNoZWNraW5nIGZvciBgZWwuY2xhc3NMaXN0YCBleGlzdGVuY2UgaGVyZSBzaW5jZSBJRSAxMVxuICAgIC8vIHJldHVybnMgYHVuZGVmaW5lZGAgZm9yIHNvbWUgZWxlbWVudHMgKGUuZy4gU1ZHIGVsZW1lbnRzKVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYm9vdHN0cmFwLXZ1ZS9ib290c3RyYXAtdnVlL2lzc3Vlcy8yNzEzXG4gICAgaWYgKGNsYXNzTmFtZSAmJiBpc0VsZW1lbnQoZWwpICYmIGVsLmNsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTsgLy8gU2V0IGFuIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50XG5cbiAgdmFyIHNldEF0dHIgPSBmdW5jdGlvbiBzZXRBdHRyKGVsLCBhdHRyLCB2YWwpIHtcbiAgICBpZiAoYXR0ciAmJiBpc0VsZW1lbnQoZWwpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsKTtcbiAgICB9XG4gIH07IC8vIFJlbW92ZSBhbiBhdHRyaWJ1dGUgZnJvbSBhbiBlbGVtZW50XG5cbiAgdmFyIHJlbW92ZUF0dHIgPSBmdW5jdGlvbiByZW1vdmVBdHRyKGVsLCBhdHRyKSB7XG4gICAgaWYgKGF0dHIgJiYgaXNFbGVtZW50KGVsKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgIH1cbiAgfTsgLy8gR2V0IGFuIGF0dHJpYnV0ZSB2YWx1ZSBmcm9tIGFuIGVsZW1lbnRcbiAgLy8gUmV0dXJucyBgbnVsbGAgaWYgbm90IGZvdW5kXG5cbiAgdmFyIGdldEF0dHIgPSBmdW5jdGlvbiBnZXRBdHRyKGVsLCBhdHRyKSB7XG4gICAgcmV0dXJuIGF0dHIgJiYgaXNFbGVtZW50KGVsKSA/IGVsLmdldEF0dHJpYnV0ZShhdHRyKSA6IG51bGw7XG4gIH07IC8vIERldGVybWluZSBpZiBhbiBhdHRyaWJ1dGUgZXhpc3RzIG9uIGFuIGVsZW1lbnRcbiAgLy8gUmV0dXJucyBgdHJ1ZWAgb3IgYGZhbHNlYCwgb3IgYG51bGxgIGlmIGVsZW1lbnQgbm90IGZvdW5kXG5cbiAgdmFyIGhhc0F0dHIgPSBmdW5jdGlvbiBoYXNBdHRyKGVsLCBhdHRyKSB7XG4gICAgcmV0dXJuIGF0dHIgJiYgaXNFbGVtZW50KGVsKSA/IGVsLmhhc0F0dHJpYnV0ZShhdHRyKSA6IG51bGw7XG4gIH07IC8vIFJldHVybiB0aGUgQm91bmRpbmcgQ2xpZW50IFJlY3Qgb2YgYW4gZWxlbWVudFxuICAvLyBSZXR1cm5zIGBudWxsYCBpZiBub3QgYW4gZWxlbWVudFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBkb2Vzbid0IHdvcmsgaW4gSlNET00gKi9cblxuICB2YXIgZ2V0QkNSID0gZnVuY3Rpb24gZ2V0QkNSKGVsKSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudChlbCkgPyBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IG51bGw7XG4gIH07IC8vIEdldCBjb21wdXRlZCBzdHlsZSBvYmplY3QgZm9yIGFuIGVsZW1lbnRcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZ2V0Q29tcHV0ZWRTdHlsZSgpIGRvZXNuJ3Qgd29yayBpbiBKU0RPTSAqL1xuXG4gIHZhciBnZXRDUyA9IGZ1bmN0aW9uIGdldENTKGVsKSB7XG4gICAgcmV0dXJuIGhhc1dpbmRvd1N1cHBvcnQgJiYgaXNFbGVtZW50KGVsKSA/IHckMS5nZXRDb21wdXRlZFN0eWxlKGVsKSA6IHt9O1xuICB9OyAvLyBSZXR1cm5zIGEgYFNlbGVjdGlvbmAgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmFuZ2Ugb2YgdGV4dCBzZWxlY3RlZFxuICAvLyBSZXR1cm5zIGBudWxsYCBpZiBubyB3aW5kb3cgc3VwcG9ydCBpcyBnaXZlblxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBnZXRTZWxlY3Rpb24oKSBkb2Vzbid0IHdvcmsgaW4gSlNET00gKi9cblxuICB2YXIgZ2V0U2VsID0gZnVuY3Rpb24gZ2V0U2VsKCkge1xuICAgIHJldHVybiBoYXNXaW5kb3dTdXBwb3J0ICYmIHckMS5nZXRTZWxlY3Rpb24gPyB3JDEuZ2V0U2VsZWN0aW9uKCkgOiBudWxsO1xuICB9OyAvLyBSZXR1cm4gYW4gZWxlbWVudCdzIG9mZnNldCB3aXRoIHJlc3BlY3QgdG8gZG9jdW1lbnQgZWxlbWVudFxuICAvLyBodHRwczovL2oxMXkuaW8vanF1ZXJ5LyN2PWdpdCZmbj1qUXVlcnkuZm4ub2Zmc2V0XG5cbiAgdmFyIG9mZnNldCA9IGZ1bmN0aW9uIG9mZnNldChlbClcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBnZXRDbGllbnRSZWN0cygpIGRvZXNuJ3Qgd29yayBpbiBKU0RPTSAqL1xuICB7XG4gICAgdmFyIF9vZmZzZXQgPSB7XG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfTtcblxuICAgIGlmICghaXNFbGVtZW50KGVsKSB8fCBlbC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIF9vZmZzZXQ7XG4gICAgfVxuXG4gICAgdmFyIGJjciA9IGdldEJDUihlbCk7XG5cbiAgICBpZiAoYmNyKSB7XG4gICAgICB2YXIgd2luID0gZWwub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgIF9vZmZzZXQudG9wID0gYmNyLnRvcCArIHdpbi5wYWdlWU9mZnNldDtcbiAgICAgIF9vZmZzZXQubGVmdCA9IGJjci5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0O1xuICAgIH1cblxuICAgIHJldHVybiBfb2Zmc2V0O1xuICB9OyAvLyBSZXR1cm4gYW4gZWxlbWVudCdzIG9mZnNldCB3aXRoIHJlc3BlY3QgdG8gdG8gaXRzIG9mZnNldFBhcmVudFxuICAvLyBodHRwczovL2oxMXkuaW8vanF1ZXJ5LyN2PWdpdCZmbj1qUXVlcnkuZm4ucG9zaXRpb25cblxuICB2YXIgcG9zaXRpb24gPSBmdW5jdGlvbiBwb3NpdGlvbihlbClcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGRvZXNuJ3Qgd29yayBpbiBKU0RPTSAqL1xuICB7XG4gICAgdmFyIF9vZmZzZXQgPSB7XG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfTtcblxuICAgIGlmICghaXNFbGVtZW50KGVsKSkge1xuICAgICAgcmV0dXJuIF9vZmZzZXQ7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudE9mZnNldCA9IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDBcbiAgICB9O1xuICAgIHZhciBlbFN0eWxlcyA9IGdldENTKGVsKTtcblxuICAgIGlmIChlbFN0eWxlcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgX29mZnNldCA9IGdldEJDUihlbCkgfHwgX29mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgX29mZnNldCA9IG9mZnNldChlbCk7XG4gICAgICB2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudDtcbiAgICAgIHZhciBvZmZzZXRQYXJlbnQgPSBlbC5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiAob2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQpICYmIGdldENTKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAob2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWwgJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICBwYXJlbnRPZmZzZXQgPSBvZmZzZXQob2Zmc2V0UGFyZW50KTtcbiAgICAgICAgdmFyIG9mZnNldFBhcmVudFN0eWxlcyA9IGdldENTKG9mZnNldFBhcmVudCk7XG4gICAgICAgIHBhcmVudE9mZnNldC50b3AgKz0gcGFyc2VGbG9hdChvZmZzZXRQYXJlbnRTdHlsZXMuYm9yZGVyVG9wV2lkdGgpO1xuICAgICAgICBwYXJlbnRPZmZzZXQubGVmdCArPSBwYXJzZUZsb2F0KG9mZnNldFBhcmVudFN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0b3A6IF9vZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIHBhcnNlRmxvYXQoZWxTdHlsZXMubWFyZ2luVG9wKSxcbiAgICAgIGxlZnQ6IF9vZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0gcGFyc2VGbG9hdChlbFN0eWxlcy5tYXJnaW5MZWZ0KVxuICAgIH07XG4gIH07XG5cbiAgLy8gTnVtYmVyIHV0aWxpdGllc1xuICAvLyBDb252ZXJ0cyBhIHZhbHVlIChzdHJpbmcsIG51bWJlciwgZXRjKSB0byBhbiBpbnRlZ2VyIG51bWJlclxuICAvLyBBc3N1bWVzIHJhZGl4IGJhc2UgMTBcbiAgLy8gUmV0dXJucyBOYU4gaWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBjb252ZXJ0ZWRcbiAgdmFyIHRvSW50ZWdlciA9IGZ1bmN0aW9uIHRvSW50ZWdlcih2YWwpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7XG4gIH07IC8vIENvbnZlcnRzIGEgdmFsdWUgKHN0cmluZywgbnVtYmVyLCBldGMpIHRvIGEgbnVtYmVyXG4gIC8vIFJldHVybnMgTmFOIGlmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgY29udmVydGVkXG5cbiAgdmFyIHRvRmxvYXQgPSBmdW5jdGlvbiB0b0Zsb2F0KHZhbCkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbCk7XG4gIH07IC8vIENvbnZlcnRzIGEgdmFsdWUgKHN0cmluZywgbnVtYmVyLCBldGMpIHRvIGEgc3RyaW5nXG4gIC8vIHJlcHJlc2VudGF0aW9uIHdpdGggJ3ByZWNpc2lvbicgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsXG4gIC8vIFJldHVybnMgdGhlIHN0cmluZyAnTmFOJyBpZiB0aGUgdmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZFxuXG4gIHZhciB0b0ZpeGVkID0gZnVuY3Rpb24gdG9GaXhlZCh2YWwsIHByZWNpc2lvbikge1xuICAgIHJldHVybiB0b0Zsb2F0KHZhbCkudG9GaXhlZCh0b0ludGVnZXIocHJlY2lzaW9uKSB8fCAwKTtcbiAgfTtcblxuICB2YXIgZT1mdW5jdGlvbigpe3JldHVybiAoZT1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHQscj0xLHM9YXJndW1lbnRzLmxlbmd0aDtyPHM7cisrKWZvcih2YXIgYSBpbiB0PWFyZ3VtZW50c1tyXSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxhKSYmKGVbYV09dFthXSk7cmV0dXJuIGV9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LHQ9e2tlYmFiOi8tKFxcdykvZyxzdHlsZVByb3A6LzooLiopLyxzdHlsZUxpc3Q6LzsoPyFbXihdKlxcKSkvZ307ZnVuY3Rpb24gcihlLHQpe3JldHVybiB0P3QudG9VcHBlckNhc2UoKTpcIlwifWZ1bmN0aW9uIHMoZSl7Zm9yKHZhciBzLGE9e30sYz0wLG89ZS5zcGxpdCh0LnN0eWxlTGlzdCk7YzxvLmxlbmd0aDtjKyspe3ZhciBuPW9bY10uc3BsaXQodC5zdHlsZVByb3ApLGk9blswXSxsPW5bMV07KGk9aS50cmltKCkpJiYoXCJzdHJpbmdcIj09dHlwZW9mIGwmJihsPWwudHJpbSgpKSxhWyhzPWkscy5yZXBsYWNlKHQua2ViYWIscikpXT1sKTt9cmV0dXJuIGF9ZnVuY3Rpb24gYSgpe2Zvcih2YXIgdCxyLGE9e30sYz1hcmd1bWVudHMubGVuZ3RoO2MtLTspZm9yKHZhciBvPTAsbj1PYmplY3Qua2V5cyhhcmd1bWVudHNbY10pO288bi5sZW5ndGg7bysrKXN3aXRjaCh0PW5bb10pe2Nhc2VcImNsYXNzXCI6Y2FzZVwic3R5bGVcIjpjYXNlXCJkaXJlY3RpdmVzXCI6aWYoQXJyYXkuaXNBcnJheShhW3RdKXx8KGFbdF09W10pLFwic3R5bGVcIj09PXQpe3ZhciBpPXZvaWQgMDtpPUFycmF5LmlzQXJyYXkoYXJndW1lbnRzW2NdLnN0eWxlKT9hcmd1bWVudHNbY10uc3R5bGU6W2FyZ3VtZW50c1tjXS5zdHlsZV07Zm9yKHZhciBsPTA7bDxpLmxlbmd0aDtsKyspe3ZhciB5PWlbbF07XCJzdHJpbmdcIj09dHlwZW9mIHkmJihpW2xdPXMoeSkpO31hcmd1bWVudHNbY10uc3R5bGU9aTt9YVt0XT1hW3RdLmNvbmNhdChhcmd1bWVudHNbY11bdF0pO2JyZWFrO2Nhc2VcInN0YXRpY0NsYXNzXCI6aWYoIWFyZ3VtZW50c1tjXVt0XSlicmVhazt2b2lkIDA9PT1hW3RdJiYoYVt0XT1cIlwiKSxhW3RdJiYoYVt0XSs9XCIgXCIpLGFbdF0rPWFyZ3VtZW50c1tjXVt0XS50cmltKCk7YnJlYWs7Y2FzZVwib25cIjpjYXNlXCJuYXRpdmVPblwiOmFbdF18fChhW3RdPXt9KTtmb3IodmFyIHA9MCxmPU9iamVjdC5rZXlzKGFyZ3VtZW50c1tjXVt0XXx8e30pO3A8Zi5sZW5ndGg7cCsrKXI9ZltwXSxhW3RdW3JdP2FbdF1bcl09W10uY29uY2F0KGFbdF1bcl0sYXJndW1lbnRzW2NdW3RdW3JdKTphW3RdW3JdPWFyZ3VtZW50c1tjXVt0XVtyXTticmVhaztjYXNlXCJhdHRyc1wiOmNhc2VcInByb3BzXCI6Y2FzZVwiZG9tUHJvcHNcIjpjYXNlXCJzY29wZWRTbG90c1wiOmNhc2VcInN0YXRpY1N0eWxlXCI6Y2FzZVwiaG9va1wiOmNhc2VcInRyYW5zaXRpb25cIjphW3RdfHwoYVt0XT17fSksYVt0XT1lKHt9LGFyZ3VtZW50c1tjXVt0XSxhW3RdKTticmVhaztjYXNlXCJzbG90XCI6Y2FzZVwia2V5XCI6Y2FzZVwicmVmXCI6Y2FzZVwidGFnXCI6Y2FzZVwic2hvd1wiOmNhc2VcImtlZXBBbGl2ZVwiOmRlZmF1bHQ6YVt0XXx8KGFbdF09YXJndW1lbnRzW2NdW3RdKTt9cmV0dXJuIGF9XG5cbiAgdmFyIE5PX0ZBREVfUFJPUFMgPSB7XG4gICAgbmFtZTogJycsXG4gICAgZW50ZXJDbGFzczogJycsXG4gICAgZW50ZXJBY3RpdmVDbGFzczogJycsXG4gICAgZW50ZXJUb0NsYXNzOiAnc2hvdycsXG4gICAgbGVhdmVDbGFzczogJ3Nob3cnLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6ICcnLFxuICAgIGxlYXZlVG9DbGFzczogJydcbiAgfTtcblxuICB2YXIgRkFERV9QUk9QUyA9IF9vYmplY3RTcHJlYWQyKHt9LCBOT19GQURFX1BST1BTLCB7XG4gICAgZW50ZXJBY3RpdmVDbGFzczogJ2ZhZGUnLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6ICdmYWRlJ1xuICB9KTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuXG4gIHZhciBCVlRyYW5zaXRpb24gPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCVlRyYW5zaXRpb24nLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IHtcbiAgICAgIG5vRmFkZToge1xuICAgICAgICAvLyBPbmx5IGFwcGxpY2FibGUgdG8gdGhlIGJ1aWx0IGluIHRyYW5zaXRpb25cbiAgICAgICAgLy8gSGFzIG5vIGVmZmVjdCBpZiBgdHJhbnMtcHJvcHNgIHByb3ZpZGVkXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgYXBwZWFyOiB7XG4gICAgICAgIC8vIEhhcyBubyBlZmZlY3QgaWYgYHRyYW5zLXByb3BzYCBwcm92aWRlZFxuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIG1vZGU6IHtcbiAgICAgICAgLy8gQ2FuIGJlIG92ZXJyaWRkZW4gYnkgdXNlciBzdXBwbGllZCB0cmFucy1wcm9wc1xuICAgICAgICB0eXBlOiBTdHJpbmcgLy8gZGVmYXVsdDogdW5kZWZpbmVkXG5cbiAgICAgIH0sXG4gICAgICAvLyBGb3IgdXNlciBzdXBwbGllZCB0cmFuc2l0aW9ucyAoaWYgbmVlZGVkKVxuICAgICAgdHJhbnNQcm9wczoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgICB2YXIgdHJhbnNQcm9wcyA9IHByb3BzLnRyYW5zUHJvcHM7XG5cbiAgICAgIGlmICghaXNQbGFpbk9iamVjdCh0cmFuc1Byb3BzKSkge1xuICAgICAgICB0cmFuc1Byb3BzID0gcHJvcHMubm9GYWRlID8gTk9fRkFERV9QUk9QUyA6IEZBREVfUFJPUFM7XG5cbiAgICAgICAgaWYgKHByb3BzLmFwcGVhcikge1xuICAgICAgICAgIC8vIERlZmF1bHQgdGhlIGFwcGVhciBjbGFzc2VzIHRvIGVxdWFsIHRoZSBlbnRlciBjbGFzc2VzXG4gICAgICAgICAgdHJhbnNQcm9wcyA9IF9vYmplY3RTcHJlYWQyKHt9LCB0cmFuc1Byb3BzLCB7XG4gICAgICAgICAgICBhcHBlYXI6IHRydWUsXG4gICAgICAgICAgICBhcHBlYXJDbGFzczogdHJhbnNQcm9wcy5lbnRlckNsYXNzLFxuICAgICAgICAgICAgYXBwZWFyQWN0aXZlQ2xhc3M6IHRyYW5zUHJvcHMuZW50ZXJBY3RpdmVDbGFzcyxcbiAgICAgICAgICAgIGFwcGVhclRvQ2xhc3M6IHRyYW5zUHJvcHMuZW50ZXJUb0NsYXNzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJhbnNQcm9wcyA9IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgbW9kZTogcHJvcHMubW9kZVxuICAgICAgfSwgdHJhbnNQcm9wcywge1xuICAgICAgICAvLyBXZSBhbHdheXMgbmVlZCBgY3NzYCB0cnVlXG4gICAgICAgIGNzczogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaCgndHJhbnNpdGlvbicsIC8vIEFueSB0cmFuc2l0aW9uIGV2ZW50IGxpc3RlbmVycyB3aWxsIGdldCBtZXJnZWQgaGVyZVxuICAgICAgYShkYXRhLCB7XG4gICAgICAgIHByb3BzOiB0cmFuc1Byb3BzXG4gICAgICB9KSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSW4gZnVuY3Rpb25hbCBjb21wb25lbnRzLCBgc2xvdHNgIGlzIGEgZnVuY3Rpb24gc28gaXQgbXVzdCBiZSBjYWxsZWRcbiAgLy8gZmlyc3QgYmVmb3JlIHBhc3NpbmcgdG8gdGhlIGJlbG93IG1ldGhvZHMuIGBzY29wZWRTbG90c2AgaXMgYWx3YXlzIGFuXG4gIC8vIG9iamVjdCBhbmQgbWF5IGJlIHVuZGVmaW5lZCAoZm9yIFZ1ZSA8IDIuNi54KVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgZWl0aGVyIHNjb3BlZCBvciB1bnNjb3BlZCBuYW1lZCBzbG90IGV4aXN0c1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZywgQXJyYXl9IG5hbWUgb3IgbmFtZVtdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZWRTbG90c1xuICAgKiBAcGFyYW0ge09iamVjdH0gc2xvdHNcbiAgICogQHJldHVybnMge0FycmF5fHVuZGVmaW5lZH0gVk5vZGVzXG4gICAqL1xuXG4gIHZhciBoYXNOb3JtYWxpemVkU2xvdCA9IGZ1bmN0aW9uIGhhc05vcm1hbGl6ZWRTbG90KG5hbWVzKSB7XG4gICAgdmFyICRzY29wZWRTbG90cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyICRzbG90cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgLy8gRW5zdXJlIG5hbWVzIGlzIGFuIGFycmF5XG4gICAgbmFtZXMgPSBjb25jYXQobmFtZXMpLmZpbHRlcihpZGVudGl0eSk7IC8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgZWl0aGVyIGEgJHNjb3BlZFNsb3Qgb3IgJHNsb3QgZXhpc3RzIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lXG5cbiAgICByZXR1cm4gbmFtZXMuc29tZShmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuICRzY29wZWRTbG90c1tuYW1lXSB8fCAkc2xvdHNbbmFtZV07XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIFZOb2RlcyBmb3IgbmFtZWQgc2xvdCBlaXRoZXIgc2NvcGVkIG9yIHVuc2NvcGVkXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nLCBBcnJheX0gbmFtZSBvciBuYW1lW11cbiAgICogQHBhcmFtIHtTdHJpbmd9IHNjb3BlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZWRTbG90c1xuICAgKiBAcGFyYW0ge09iamVjdH0gc2xvdHNcbiAgICogQHJldHVybnMge0FycmF5fHVuZGVmaW5lZH0gVk5vZGVzXG4gICAqL1xuXG5cbiAgdmFyIG5vcm1hbGl6ZVNsb3QgPSBmdW5jdGlvbiBub3JtYWxpemVTbG90KG5hbWVzKSB7XG4gICAgdmFyIHNjb3BlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgJHNjb3BlZFNsb3RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgJHNsb3RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICAvLyBFbnN1cmUgbmFtZXMgaXMgYW4gYXJyYXlcbiAgICBuYW1lcyA9IGNvbmNhdChuYW1lcykuZmlsdGVyKGlkZW50aXR5KTtcbiAgICB2YXIgc2xvdDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoICYmICFzbG90OyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICBzbG90ID0gJHNjb3BlZFNsb3RzW25hbWVdIHx8ICRzbG90c1tuYW1lXTtcbiAgICB9IC8vIE5vdGU6IGluIFZ1ZSAyLjYueCwgYWxsIG5hbWVkIHNsb3RzIGFyZSBhbHNvIHNjb3BlZCBzbG90c1xuXG5cbiAgICByZXR1cm4gaXNGdW5jdGlvbihzbG90KSA/IHNsb3Qoc2NvcGUpIDogc2xvdDtcbiAgfTsgLy8gTmFtZWQgZXhwb3J0c1xuXG4gIHZhciBub3JtYWxpemVTbG90TWl4aW4gPSB7XG4gICAgbWV0aG9kczoge1xuICAgICAgaGFzTm9ybWFsaXplZFNsb3Q6IGZ1bmN0aW9uIGhhc05vcm1hbGl6ZWRTbG90JDEobmFtZXMpIHtcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBlaXRoZXIgYSAkc2NvcGVkU2xvdCBvciAkc2xvdCBleGlzdHMgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVcbiAgICAgICAgLy8gYG5hbWVzYCBjYW4gYmUgYSBzdHJpbmcgbmFtZSBvciBhbiBhcnJheSBvZiBuYW1lc1xuICAgICAgICByZXR1cm4gaGFzTm9ybWFsaXplZFNsb3QobmFtZXMsIHRoaXMuJHNjb3BlZFNsb3RzLCB0aGlzLiRzbG90cyk7XG4gICAgICB9LFxuICAgICAgbm9ybWFsaXplU2xvdDogZnVuY3Rpb24gbm9ybWFsaXplU2xvdCQxKG5hbWVzKSB7XG4gICAgICAgIHZhciBzY29wZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiByZW5kZXJlZCBWTm9kZXMgaWYgc2xvdCBmb3VuZC5cbiAgICAgICAgLy8gUmV0dXJucyB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICAgICAgICAvLyBgbmFtZXNgIGNhbiBiZSBhIHN0cmluZyBuYW1lIG9yIGFuIGFycmF5IG9mIG5hbWVzXG4gICAgICAgIHZhciB2Tm9kZXMgPSBub3JtYWxpemVTbG90KG5hbWVzLCBzY29wZSwgdGhpcy4kc2NvcGVkU2xvdHMsIHRoaXMuJHNsb3RzKTtcblxuICAgICAgICByZXR1cm4gdk5vZGVzID8gY29uY2F0KHZOb2RlcykgOiB2Tm9kZXM7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBOQU1FJDEgPSAnQkJ1dHRvbkNsb3NlJztcbiAgdmFyIHByb3BzID0ge1xuICAgIGNvbnRlbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkMSwgJ2NvbnRlbnQnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpc2FibGVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGFyaWFMYWJlbDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSQxLCAnYXJpYUxhYmVsJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0ZXh0VmFyaWFudDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSQxLCAndGV4dFZhcmlhbnQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJCdXR0b25DbG9zZSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogTkFNRSQxLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBzbG90cyA9IF9yZWYuc2xvdHMsXG4gICAgICAgICAgc2NvcGVkU2xvdHMgPSBfcmVmLnNjb3BlZFNsb3RzO1xuICAgICAgdmFyICRzbG90cyA9IHNsb3RzKCk7XG4gICAgICB2YXIgJHNjb3BlZFNsb3RzID0gc2NvcGVkU2xvdHMgfHwge307XG4gICAgICB2YXIgY29tcG9uZW50RGF0YSA9IHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdjbG9zZScsXG4gICAgICAgIGNsYXNzOiBfZGVmaW5lUHJvcGVydHkoe30sIFwidGV4dC1cIi5jb25jYXQocHJvcHMudGV4dFZhcmlhbnQpLCBwcm9wcy50ZXh0VmFyaWFudCksXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgdHlwZTogJ2J1dHRvbicsXG4gICAgICAgICAgZGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkLFxuICAgICAgICAgICdhcmlhLWxhYmVsJzogcHJvcHMuYXJpYUxhYmVsID8gU3RyaW5nKHByb3BzLmFyaWFMYWJlbCkgOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKGV2dCkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIGNsaWNrIG9uIGJ1dHRvbiBIVE1MIGNvbnRlbnQgaXMgYWxzbyBkaXNhYmxlZFxuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IGJ1ZyBpbiBKU0RPTSBzdGlsbCBlbWl0cyBjbGljayBvbiBpbm5lciBlbGVtZW50ICovXG4gICAgICAgICAgICBpZiAocHJvcHMuZGlzYWJsZWQgJiYgaXNFdmVudChldnQpKSB7XG4gICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9OyAvLyBDYXJlZnVsIG5vdCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBzbG90IHdpdGggaW5uZXJIVE1MXG5cbiAgICAgIGlmICghaGFzTm9ybWFsaXplZFNsb3QoJ2RlZmF1bHQnLCAkc2NvcGVkU2xvdHMsICRzbG90cykpIHtcbiAgICAgICAgY29tcG9uZW50RGF0YS5kb21Qcm9wcyA9IHtcbiAgICAgICAgICBpbm5lckhUTUw6IHByb3BzLmNvbnRlbnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGgoJ2J1dHRvbicsIGEoZGF0YSwgY29tcG9uZW50RGF0YSksIG5vcm1hbGl6ZVNsb3QoJ2RlZmF1bHQnLCB7fSwgJHNjb3BlZFNsb3RzLCAkc2xvdHMpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBOQU1FJDIgPSAnQkFsZXJ0JzsgLy8gQ29udmVydCBgc2hvd2AgdmFsdWUgdG8gYSBudW1iZXJcblxuICB2YXIgcGFyc2VDb3VudERvd24gPSBmdW5jdGlvbiBwYXJzZUNvdW50RG93bihzaG93KSB7XG4gICAgaWYgKHNob3cgPT09ICcnIHx8IGlzQm9vbGVhbihzaG93KSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgc2hvdyA9IHRvSW50ZWdlcihzaG93KTtcbiAgICByZXR1cm4gc2hvdyA+IDAgPyBzaG93IDogMDtcbiAgfTsgLy8gQ29udmVydCBgc2hvd2AgdmFsdWUgdG8gYSBib29sZWFuXG5cblxuICB2YXIgcGFyc2VTaG93ID0gZnVuY3Rpb24gcGFyc2VTaG93KHNob3cpIHtcbiAgICBpZiAoc2hvdyA9PT0gJycgfHwgc2hvdyA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRvSW50ZWdlcihzaG93KSA8IDEpIHtcbiAgICAgIC8vIEJvb2xlYW4gd2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlIGZvciB0aGUgYWJvdmUgY29tcGFyaXNvblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhIXNob3c7XG4gIH07IC8vIElzIGEgdmFsdWUgbnVtYmVyIGxpa2UgKGkuZS4gYSBudW1iZXIgb3IgYSBudW1iZXIgYXMgc3RyaW5nKVxuXG5cbiAgdmFyIGlzTnVtZXJpY0xpa2UgPSBmdW5jdGlvbiBpc051bWVyaWNMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuICFpc05hTih0b0ludGVnZXIodmFsdWUpKTtcbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuXG4gIHZhciBCQWxlcnQgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6IE5BTUUkMixcbiAgICBtaXhpbnM6IFtub3JtYWxpemVTbG90TWl4aW5dLFxuICAgIG1vZGVsOiB7XG4gICAgICBwcm9wOiAnc2hvdycsXG4gICAgICBldmVudDogJ2lucHV0J1xuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIHZhcmlhbnQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkMiwgJ3ZhcmlhbnQnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc21pc3NpYmxlOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZGlzbWlzc0xhYmVsOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJDIsICdkaXNtaXNzTGFiZWwnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNob3c6IHtcbiAgICAgICAgdHlwZTogW0Jvb2xlYW4sIE51bWJlciwgU3RyaW5nXSxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBmYWRlOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY291bnREb3duVGltZXJJZDogbnVsbCxcbiAgICAgICAgY291bnREb3duOiAwLFxuICAgICAgICAvLyBJZiBpbml0aWFsbHkgc2hvd24sIHdlIG5lZWQgdG8gc2V0IHRoZXNlIGZvciBTU1JcbiAgICAgICAgbG9jYWxTaG93OiBwYXJzZVNob3codGhpcy5zaG93KVxuICAgICAgfTtcbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICBzaG93OiBmdW5jdGlvbiBzaG93KG5ld1ZhbCkge1xuICAgICAgICB0aGlzLmNvdW50RG93biA9IHBhcnNlQ291bnREb3duKG5ld1ZhbCk7XG4gICAgICAgIHRoaXMubG9jYWxTaG93ID0gcGFyc2VTaG93KG5ld1ZhbCk7XG4gICAgICB9LFxuICAgICAgY291bnREb3duOiBmdW5jdGlvbiBjb3VudERvd24obmV3VmFsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG5cbiAgICAgICAgaWYgKGlzTnVtZXJpY0xpa2UodGhpcy5zaG93KSkge1xuICAgICAgICAgIC8vIElnbm9yZSBpZiB0aGlzLnNob3cgdHJhbnNpdGlvbnMgdG8gYSBib29sZWFuIHZhbHVlLlxuICAgICAgICAgIHRoaXMuJGVtaXQoJ2Rpc21pc3MtY291bnQtZG93bicsIG5ld1ZhbCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5zaG93ICE9PSBuZXdWYWwpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdi1tb2RlbCBpZiBuZWVkZWRcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgbmV3VmFsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV3VmFsID4gMCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFNob3cgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb3VudERvd25UaW1lcklkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLmNvdW50RG93bi0tO1xuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNsaWdodGx5IGRlbGF5IHRoZSBoaWRlIHRvIGFsbG93IGFueSBVSSB1cGRhdGVzXG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3RBRihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9jYWxTaG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbG9jYWxTaG93OiBmdW5jdGlvbiBsb2NhbFNob3cobmV3VmFsKSB7XG4gICAgICAgIGlmICghbmV3VmFsICYmICh0aGlzLmRpc21pc3NpYmxlIHx8IGlzTnVtZXJpY0xpa2UodGhpcy5zaG93KSkpIHtcbiAgICAgICAgICAvLyBPbmx5IGVtaXQgZGlzbWlzc2VkIGV2ZW50cyBmb3IgZGlzbWlzc2libGUgb3IgYXV0byBkaXNtaXNzaW5nIGFsZXJ0c1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ2Rpc21pc3NlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bWVyaWNMaWtlKHRoaXMuc2hvdykgJiYgdGhpcy5zaG93ICE9PSBuZXdWYWwpIHtcbiAgICAgICAgICAvLyBPbmx5IGVtaXQgYm9vbGVhbnMgaWYgd2Ugd2VyZW4ndCBwYXNzZWQgYSBudW1iZXIgdmlhIGB0aGlzLnNob3dgXG4gICAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBuZXdWYWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgdGhpcy5jb3VudERvd24gPSBwYXJzZUNvdW50RG93bih0aGlzLnNob3cpO1xuICAgICAgdGhpcy5sb2NhbFNob3cgPSBwYXJzZVNob3codGhpcy5zaG93KTtcbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLmNvdW50RG93biA9IHBhcnNlQ291bnREb3duKHRoaXMuc2hvdyk7XG4gICAgICB0aGlzLmxvY2FsU2hvdyA9IHBhcnNlU2hvdyh0aGlzLnNob3cpO1xuICAgIH0sXG4gICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgZGlzbWlzczogZnVuY3Rpb24gZGlzbWlzcygpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgIHRoaXMuY291bnREb3duID0gMDtcbiAgICAgICAgdGhpcy5sb2NhbFNob3cgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBjbGVhclRpbWVyOiBmdW5jdGlvbiBjbGVhclRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5jb3VudERvd25UaW1lcklkKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNvdW50RG93blRpbWVySWQpO1xuICAgICAgICAgIHRoaXMuY291bnREb3duVGltZXJJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHZhciAkYWxlcnQ7IC8vIHVuZGVmaW5lZFxuXG4gICAgICBpZiAodGhpcy5sb2NhbFNob3cpIHtcbiAgICAgICAgdmFyICRkaXNtaXNzQnRuID0gaCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmRpc21pc3NpYmxlKSB7XG4gICAgICAgICAgLy8gQWRkIGRpc21pc3MgYnV0dG9uXG4gICAgICAgICAgJGRpc21pc3NCdG4gPSBoKEJCdXR0b25DbG9zZSwge1xuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiB0aGlzLmRpc21pc3NMYWJlbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGNsaWNrOiB0aGlzLmRpc21pc3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBbdGhpcy5ub3JtYWxpemVTbG90KCdkaXNtaXNzJyldKTtcbiAgICAgICAgfVxuXG4gICAgICAgICRhbGVydCA9IGgoJ2RpdicsIHtcbiAgICAgICAgICBrZXk6IHRoaXMuX3VpZCxcbiAgICAgICAgICBzdGF0aWNDbGFzczogJ2FsZXJ0JyxcbiAgICAgICAgICBjbGFzczogX2RlZmluZVByb3BlcnR5KHtcbiAgICAgICAgICAgICdhbGVydC1kaXNtaXNzaWJsZSc6IHRoaXMuZGlzbWlzc2libGVcbiAgICAgICAgICB9LCBcImFsZXJ0LVwiLmNvbmNhdCh0aGlzLnZhcmlhbnQpLCB0aGlzLnZhcmlhbnQpLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICByb2xlOiAnYWxlcnQnLFxuICAgICAgICAgICAgJ2FyaWEtbGl2ZSc6ICdwb2xpdGUnLFxuICAgICAgICAgICAgJ2FyaWEtYXRvbWljJzogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgWyRkaXNtaXNzQnRuLCB0aGlzLm5vcm1hbGl6ZVNsb3QoJ2RlZmF1bHQnKV0pO1xuICAgICAgICAkYWxlcnQgPSBbJGFsZXJ0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGgoQlZUcmFuc2l0aW9uLCB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbm9GYWRlOiAhdGhpcy5mYWRlXG4gICAgICAgIH1cbiAgICAgIH0sICRhbGVydCk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgQWxlcnRQbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJBbGVydDogQkFsZXJ0XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogR2l2ZW4gYW4gYXJyYXkgb2YgcHJvcGVydGllcyBvciBhbiBvYmplY3Qgb2YgcHJvcGVydHkga2V5cyxcbiAgICogcGx1Y2tzIGFsbCB0aGUgdmFsdWVzIG9mZiB0aGUgdGFyZ2V0IG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IG9iamVjdFxuICAgKiB0aGF0IGhhcyBwcm9wcyB0aGF0IHJlZmVyZW5jZSB0aGUgb3JpZ2luYWwgcHJvcCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHt7fXxzdHJpbmdbXX0ga2V5c1RvUGx1Y2tcbiAgICogQHBhcmFtIHt7fX0gb2JqVG9QbHVja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm1GblxuICAgKiBAcmV0dXJuIHt7fX1cbiAgICovXG5cbiAgdmFyIHBsdWNrUHJvcHMgPSBmdW5jdGlvbiBwbHVja1Byb3BzKGtleXNUb1BsdWNrLCBvYmpUb1BsdWNrKSB7XG4gICAgdmFyIHRyYW5zZm9ybUZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBpZGVudGl0eTtcbiAgICByZXR1cm4gKGlzQXJyYXkoa2V5c1RvUGx1Y2spID8ga2V5c1RvUGx1Y2suc2xpY2UoKSA6IGtleXMoa2V5c1RvUGx1Y2spKS5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIHByb3ApIHtcbiAgICAgIG1lbW9bdHJhbnNmb3JtRm4ocHJvcCldID0gb2JqVG9QbHVja1twcm9wXTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIHt9KTtcbiAgfTtcblxuICAvLyBTdHJpbmcgdXRpbGl0aWVzXG5cbiAgdmFyIFJYX1RSSU1fTEVGVCA9IC9eXFxzKy87XG4gIHZhciBSWF9SRUdFWFBfUkVQTEFDRSA9IC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nO1xuICB2YXIgUlhfVU5fS0VCQUIgPSAvLShcXHcpL2c7XG4gIHZhciBSWF9IWVBIRU5BVEUgPSAvXFxCKFtBLVpdKS9nOyAvLyAtLS0gVXRpbGl0aWVzIC0tLVxuICAvLyBDb252ZXJ0cyBQYXNjYWxDYXNlIG9yIGNhbWVsQ2FzZSB0byBrZWJhYi1jYXNlXG5cbiAgdmFyIGtlYmFiQ2FzZSA9IGZ1bmN0aW9uIGtlYmFiQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoUlhfSFlQSEVOQVRFLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbiAgfTsgLy8gQ29udmVydHMgYSBrZWJhYi1jYXNlIG9yIGNhbWVsQ2FzZSBzdHJpbmcgdG8gUGFzY2FsQ2FzZVxuXG4gIHZhciBwYXNjYWxDYXNlID0gZnVuY3Rpb24gcGFzY2FsQ2FzZShzdHIpIHtcbiAgICBzdHIgPSBrZWJhYkNhc2Uoc3RyKS5yZXBsYWNlKFJYX1VOX0tFQkFCLCBmdW5jdGlvbiAoXywgYykge1xuICAgICAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgICB9KTtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuICB9OyAvLyBMb3dlcmNhc2VzIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmcgYW5kIHJldHVybnMgYSBuZXcgc3RyaW5nXG5cbiAgdmFyIGxvd2VyRmlyc3QgPSBmdW5jdGlvbiBsb3dlckZpcnN0KHN0cikge1xuICAgIHN0ciA9IGlzU3RyaW5nKHN0cikgPyBzdHIudHJpbSgpIDogU3RyaW5nKHN0cik7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgfTsgLy8gVXBwZXJjYXNlcyB0aGUgZmlyc3QgbGV0dGVyIG9mIGEgc3RyaW5nIGFuZCByZXR1cm5zIGEgbmV3IHN0cmluZ1xuXG4gIHZhciB1cHBlckZpcnN0ID0gZnVuY3Rpb24gdXBwZXJGaXJzdChzdHIpIHtcbiAgICBzdHIgPSBpc1N0cmluZyhzdHIpID8gc3RyLnRyaW0oKSA6IFN0cmluZyhzdHIpO1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG4gIH07IC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRvIGJlIHVzZWQgaW4gYnVpbGRpbmcgYSByZWd1bGFyIGV4cHJlc3Npb25cblxuICB2YXIgZXNjYXBlUmVnRXhwID0gZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShSWF9SRUdFWFBfUkVQTEFDRSwgJ1xcXFwkJicpO1xuICB9OyAvLyBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBjYW4gYmUgcmVuZGVyZWRcbiAgLy8gYHVuZGVmaW5lZGAvYG51bGxgIHdpbGwgYmUgY29udmVydGVkIHRvIGAnJ2BcbiAgLy8gUGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIHdpbGwgYmUgSlNPTiBzdHJpbmdpZmllZFxuXG4gIHZhciB0b1N0cmluZyQxID0gZnVuY3Rpb24gdG9TdHJpbmcodmFsKSB7XG4gICAgdmFyIHNwYWNlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMjtcbiAgICByZXR1cm4gaXNVbmRlZmluZWRPck51bGwodmFsKSA/ICcnIDogaXNBcnJheSh2YWwpIHx8IGlzUGxhaW5PYmplY3QodmFsKSAmJiB2YWwudG9TdHJpbmcgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIHNwYWNlcykgOiBTdHJpbmcodmFsKTtcbiAgfTsgLy8gUmVtb3ZlIGxlYWRpbmcgd2hpdGUgc3BhY2UgZnJvbSBhIHN0cmluZ1xuXG4gIHZhciB0cmltTGVmdCA9IGZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICAgIHJldHVybiB0b1N0cmluZyQxKHN0cikucmVwbGFjZShSWF9UUklNX0xFRlQsICcnKTtcbiAgfTsgLy8gUmVtb3ZlIFRyYWlsaW5nIHdoaXRlIHNwYWNlIGZyb20gYSBzdHJpbmdcblxuICB2YXIgdHJpbSA9IGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nJDEoc3RyKS50cmltKCk7XG4gIH07IC8vIExvd2VyIGNhc2UgYSBzdHJpbmdcblxuICB2YXIgbG93ZXJDYXNlID0gZnVuY3Rpb24gbG93ZXJDYXNlKHN0cikge1xuICAgIHJldHVybiB0b1N0cmluZyQxKHN0cikudG9Mb3dlckNhc2UoKTtcbiAgfTsgLy8gVXBwZXIgY2FzZSBhIHN0cmluZ1xuXG4gIHZhciBBTkNIT1JfVEFHID0gJ2EnOyAvLyBQcmVjb21waWxlIFJlZ0V4cFxuXG4gIHZhciBjb21tYVJFID0gLyUyQy9nO1xuICB2YXIgZW5jb2RlUmVzZXJ2ZVJFID0gL1shJygpKl0vZztcbiAgdmFyIHBsdXNSRSA9IC9cXCsvZztcbiAgdmFyIHF1ZXJ5U3RhcnRSRSA9IC9eKFxcP3wjfCYpLzsgLy8gTWV0aG9kIHRvIHJlcGxhY2UgcmVzZXJ2ZWQgY2hhcnNcblxuICB2YXIgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyID0gZnVuY3Rpb24gZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtcbiAgfTsgLy8gRml4ZWQgZW5jb2RlVVJJQ29tcG9uZW50IHdoaWNoIGlzIG1vcmUgY29uZm9ybWFudCB0byBSRkMzOTg2OlxuICAvLyAtIGVzY2FwZXMgWyEnKCkqXVxuICAvLyAtIHByZXNlcnZlIGNvbW1hc1xuXG5cbiAgdmFyIGVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShzdHIpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHRvU3RyaW5nJDEoc3RyKSkucmVwbGFjZShlbmNvZGVSZXNlcnZlUkUsIGVuY29kZVJlc2VydmVSZXBsYWNlcikucmVwbGFjZShjb21tYVJFLCAnLCcpO1xuICB9O1xuXG4gIHZhciBkZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7IC8vIFN0cmluZ2lmaWVzIGFuIG9iamVjdCBvZiBxdWVyeSBwYXJhbWV0ZXJzXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1yb3V0ZXIvYmxvYi9kZXYvc3JjL3V0aWwvcXVlcnkuanNcblxuICB2YXIgc3RyaW5naWZ5UXVlcnlPYmogPSBmdW5jdGlvbiBzdHJpbmdpZnlRdWVyeU9iaihvYmopIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3Qob2JqKSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHZhciBxdWVyeSA9IGtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHZhbCA9IG9ialtrZXldO1xuXG4gICAgICBpZiAoaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9IGVsc2UgaWYgKGlzTnVsbCh2YWwpKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGUoa2V5KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHJldHVybiB2YWwucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHRzLCB2YWwyKSB7XG4gICAgICAgICAgaWYgKGlzTnVsbCh2YWwyKSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVuY29kZShrZXkpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFpc1VuZGVmaW5lZCh2YWwyKSkge1xuICAgICAgICAgICAgLy8gRmFzdGVyIHRoYW4gc3RyaW5nIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwyKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0sIFtdKS5qb2luKCcmJyk7XG4gICAgICB9IC8vIEZhc3RlciB0aGFuIHN0cmluZyBpbnRlcnBvbGF0aW9uXG5cblxuICAgICAgcmV0dXJuIGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHZhbCk7XG4gICAgfSlcbiAgICAvKiBtdXN0IGNoZWNrIGZvciBsZW5ndGgsIGFzIHdlIG9ubHkgd2FudCB0byBmaWx0ZXIgZW1wdHkgc3RyaW5ncywgbm90IHRoaW5ncyB0aGF0IGxvb2sgZmFsc2V5ISAqL1xuICAgIC5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4Lmxlbmd0aCA+IDA7XG4gICAgfSkuam9pbignJicpO1xuICAgIHJldHVybiBxdWVyeSA/IFwiP1wiLmNvbmNhdChxdWVyeSkgOiAnJztcbiAgfTtcbiAgdmFyIHBhcnNlUXVlcnkgPSBmdW5jdGlvbiBwYXJzZVF1ZXJ5KHF1ZXJ5KSB7XG4gICAgdmFyIHBhcnNlZCA9IHt9O1xuICAgIHF1ZXJ5ID0gdG9TdHJpbmckMShxdWVyeSkudHJpbSgpLnJlcGxhY2UocXVlcnlTdGFydFJFLCAnJyk7XG5cbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cblxuICAgIHF1ZXJ5LnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UocGx1c1JFLCAnICcpLnNwbGl0KCc9Jyk7XG4gICAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRzLnNoaWZ0KCkpO1xuICAgICAgdmFyIHZhbCA9IHBhcnRzLmxlbmd0aCA+IDAgPyBkZWNvZGUocGFydHMuam9pbignPScpKSA6IG51bGw7XG5cbiAgICAgIGlmIChpc1VuZGVmaW5lZChwYXJzZWRba2V5XSkpIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSB2YWw7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkocGFyc2VkW2tleV0pKSB7XG4gICAgICAgIHBhcnNlZFtrZXldLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gW3BhcnNlZFtrZXldLCB2YWxdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH07XG4gIHZhciBpc1JvdXRlckxpbmsgPSBmdW5jdGlvbiBpc1JvdXRlckxpbmsodGFnKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nJDEodGFnKS50b0xvd2VyQ2FzZSgpICE9PSBBTkNIT1JfVEFHO1xuICB9O1xuICB2YXIgY29tcHV0ZVRhZyA9IGZ1bmN0aW9uIGNvbXB1dGVUYWcoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICB0byA9IF9yZWYudG8sXG4gICAgICAgIGRpc2FibGVkID0gX3JlZi5kaXNhYmxlZDtcblxuICAgIHZhciB0aGlzT3JQYXJlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpc09yUGFyZW50LiRyb3V0ZXIgJiYgdG8gJiYgIWRpc2FibGVkID8gdGhpc09yUGFyZW50LiRudXh0ID8gJ251eHQtbGluaycgOiAncm91dGVyLWxpbmsnIDogQU5DSE9SX1RBRztcbiAgfTtcbiAgdmFyIGNvbXB1dGVSZWwgPSBmdW5jdGlvbiBjb21wdXRlUmVsKCkge1xuICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgICAgcmVsID0gX3JlZjIucmVsO1xuXG4gICAgaWYgKHRhcmdldCA9PT0gJ19ibGFuaycgJiYgaXNOdWxsKHJlbCkpIHtcbiAgICAgIHJldHVybiAnbm9vcGVuZXInO1xuICAgIH1cblxuICAgIHJldHVybiByZWwgfHwgbnVsbDtcbiAgfTtcbiAgdmFyIGNvbXB1dGVIcmVmID0gZnVuY3Rpb24gY29tcHV0ZUhyZWYoKSB7XG4gICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgaHJlZiA9IF9yZWYzLmhyZWYsXG4gICAgICAgIHRvID0gX3JlZjMudG87XG5cbiAgICB2YXIgdGFnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBBTkNIT1JfVEFHO1xuICAgIHZhciBmYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJyMnO1xuICAgIHZhciB0b0ZhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnLyc7XG5cbiAgICAvLyBXZSd2ZSBhbHJlYWR5IGNoZWNrZWQgdGhlICRyb3V0ZXIgaW4gY29tcHV0ZVRhZygpLCBzbyBpc1JvdXRlckxpbmsoKSBpbmRpY2F0ZXMgYSBsaXZlIHJvdXRlci5cbiAgICAvLyBXaGVuIGRlZmVycmluZyB0byBWdWUgUm91dGVyJ3Mgcm91dGVyLWxpbmssIGRvbid0IHVzZSB0aGUgaHJlZiBhdHRyaWJ1dGUgYXQgYWxsLlxuICAgIC8vIFdlIHJldHVybiBudWxsLCBhbmQgdGhlbiByZW1vdmUgaHJlZiBmcm9tIHRoZSBhdHRyaWJ1dGVzIHBhc3NlZCB0byByb3V0ZXItbGlua1xuICAgIGlmIChpc1JvdXRlckxpbmsodGFnKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBSZXR1cm4gYGhyZWZgIHdoZW4gZXhwbGljaXRseSBwcm92aWRlZFxuXG5cbiAgICBpZiAoaHJlZikge1xuICAgICAgcmV0dXJuIGhyZWY7XG4gICAgfSAvLyBSZWNvbnN0cnVjdCBgaHJlZmAgd2hlbiBgdG9gIHVzZWQsIGJ1dCBubyByb3V0ZXJcblxuXG4gICAgaWYgKHRvKSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBgdG9gIHByb3AgKGlmIGB0b2AgaXMgYSBzdHJpbmcpXG4gICAgICBpZiAoaXNTdHJpbmcodG8pKSB7XG4gICAgICAgIHJldHVybiB0byB8fCB0b0ZhbGxiYWNrO1xuICAgICAgfSAvLyBGYWxsYmFjayB0byBgdG8ucGF0aCArIHRvLnF1ZXJ5ICsgdG8uaGFzaGAgcHJvcCAoaWYgYHRvYCBpcyBhbiBvYmplY3QpXG5cblxuICAgICAgaWYgKGlzUGxhaW5PYmplY3QodG8pICYmICh0by5wYXRoIHx8IHRvLnF1ZXJ5IHx8IHRvLmhhc2gpKSB7XG4gICAgICAgIHZhciBwYXRoID0gdG9TdHJpbmckMSh0by5wYXRoKTtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gc3RyaW5naWZ5UXVlcnlPYmoodG8ucXVlcnkpO1xuICAgICAgICB2YXIgaGFzaCA9IHRvU3RyaW5nJDEodG8uaGFzaCk7XG4gICAgICAgIGhhc2ggPSAhaGFzaCB8fCBoYXNoLmNoYXJBdCgwKSA9PT0gJyMnID8gaGFzaCA6IFwiI1wiLmNvbmNhdChoYXNoKTtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHBhdGgpLmNvbmNhdChxdWVyeSkuY29uY2F0KGhhc2gpIHx8IHRvRmFsbGJhY2s7XG4gICAgICB9XG4gICAgfSAvLyBJZiBub3RoaW5nIGlzIHByb3ZpZGVkIHJldHVybiB0aGUgZmFsbGJhY2tcblxuXG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgTGluayBjb21wb25lbnQgaXMgdXNlZCBpbiBtYW55IG90aGVyIEJWIGNvbXBvbmVudHMuXG4gICAqIEFzIHN1Y2gsIHNoYXJpbmcgaXRzIHByb3BzIG1ha2VzIHN1cHBvcnRpbmcgYWxsIGl0cyBmZWF0dXJlcyBlYXNpZXIuXG4gICAqIEhvd2V2ZXIsIHNvbWUgY29tcG9uZW50cyBuZWVkIHRvIG1vZGlmeSB0aGUgZGVmYXVsdHMgZm9yIHRoZWlyIG93biBwdXJwb3NlLlxuICAgKiBQcmVmZXIgc2hhcmluZyBhIGZyZXNoIGNvcHkgb2YgdGhlIHByb3BzIHRvIGVuc3VyZSBtdXRhdGlvbnNcbiAgICogZG8gbm90IGFmZmVjdCBvdGhlciBjb21wb25lbnQgcmVmZXJlbmNlcyB0byB0aGUgcHJvcHMuXG4gICAqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtcm91dGVyL2Jsb2IvZGV2L3NyYy9jb21wb25lbnRzL2xpbmsuanNcbiAgICogQHJldHVybiB7e319XG4gICAqL1xuXG4gIHZhciBwcm9wc0ZhY3RvcnkgPSBmdW5jdGlvbiBwcm9wc0ZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhyZWY6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgcmVsOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHRhcmdldDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICdfc2VsZidcbiAgICAgIH0sXG4gICAgICBhY3RpdmU6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBkaXNhYmxlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIC8vIHJvdXRlci1saW5rIHNwZWNpZmljIHByb3BzXG4gICAgICB0bzoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgYXBwZW5kOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgcmVwbGFjZToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGV2ZW50OiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5XSxcbiAgICAgICAgZGVmYXVsdDogJ2NsaWNrJ1xuICAgICAgfSxcbiAgICAgIGFjdGl2ZUNsYXNzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyAvLyBkZWZhdWx0OiB1bmRlZmluZWRcblxuICAgICAgfSxcbiAgICAgIGV4YWN0OiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZXhhY3RBY3RpdmVDbGFzczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcgLy8gZGVmYXVsdDogdW5kZWZpbmVkXG5cbiAgICAgIH0sXG4gICAgICByb3V0ZXJUYWc6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnYSdcbiAgICAgIH0sXG4gICAgICAvLyBudXh0LWxpbmsgc3BlY2lmaWMgcHJvcChzKVxuICAgICAgbm9QcmVmZXRjaDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIEJMaW5rID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQkxpbmsnLFxuICAgIG1peGluczogW25vcm1hbGl6ZVNsb3RNaXhpbl0sXG4gICAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgICBwcm9wczogcHJvcHNGYWN0b3J5KCksXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGNvbXB1dGVkVGFnOiBmdW5jdGlvbiBjb21wdXRlZFRhZygpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3QgcGFzcyBgdGhpc2AgYXMgdGhlIGZpcnN0IGFyZyBhcyB3ZSBuZWVkIHJlYWN0aXZpdHkgb2YgdGhlIHByb3BzXG4gICAgICAgIHJldHVybiBjb21wdXRlVGFnKHtcbiAgICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgICBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZFxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICBpc1JvdXRlckxpbms6IGZ1bmN0aW9uIGlzUm91dGVyTGluayQxKCkge1xuICAgICAgICByZXR1cm4gaXNSb3V0ZXJMaW5rKHRoaXMuY29tcHV0ZWRUYWcpO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkUmVsOiBmdW5jdGlvbiBjb21wdXRlZFJlbCgpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3QgcGFzcyBgdGhpc2AgYXMgdGhlIGZpcnN0IGFyZyBhcyB3ZSBuZWVkIHJlYWN0aXZpdHkgb2YgdGhlIHByb3BzXG4gICAgICAgIHJldHVybiBjb21wdXRlUmVsKHtcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMudGFyZ2V0LFxuICAgICAgICAgIHJlbDogdGhpcy5yZWxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRIcmVmOiBmdW5jdGlvbiBjb21wdXRlZEhyZWYoKSB7XG4gICAgICAgIC8vIFdlIGRvbid0IHBhc3MgYHRoaXNgIGFzIHRoZSBmaXJzdCBhcmcgYXMgd2UgbmVlZCByZWFjdGl2aXR5IG9mIHRoZSBwcm9wc1xuICAgICAgICByZXR1cm4gY29tcHV0ZUhyZWYoe1xuICAgICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICAgIGhyZWY6IHRoaXMuaHJlZlxuICAgICAgICB9LCB0aGlzLmNvbXB1dGVkVGFnKTtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZFByb3BzOiBmdW5jdGlvbiBjb21wdXRlZFByb3BzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1JvdXRlckxpbmsgPyBfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy4kcHJvcHMsIHtcbiAgICAgICAgICB0YWc6IHRoaXMucm91dGVyVGFnXG4gICAgICAgIH0pIDoge307XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGV2dCkge1xuICAgICAgICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcbiAgICAgICAgdmFyIGV2dElzRXZlbnQgPSBpc0V2ZW50KGV2dCk7XG4gICAgICAgIHZhciBpc1JvdXRlckxpbmsgPSB0aGlzLmlzUm91dGVyTGluaztcbiAgICAgICAgdmFyIHN1cHBsaWVkSGFuZGxlciA9IHRoaXMuJGxpc3RlbmVycy5jbGljaztcblxuICAgICAgICBpZiAoZXZ0SXNFdmVudCAmJiB0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgLy8gU3RvcCBldmVudCBmcm9tIGJ1YmJsaW5nIHVwXG4gICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBLaWxsIHRoZSBldmVudCBsb29wIGF0dGFjaGVkIHRvIHRoaXMgc3BlY2lmaWMgYEV2ZW50VGFyZ2V0YFxuICAgICAgICAgIC8vIE5lZWRlZCB0byBwcmV2ZW50IGB2dWUtcm91dGVyYCBmb3IgZG9pbmcgaXRzIHRoaW5nXG5cbiAgICAgICAgICBldnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byB0ZXN0LCBidXQgd2Uga25vdyBpdCB3b3JrcyAqL1xuICAgICAgICAgIGlmIChpc1JvdXRlckxpbmsgJiYgZXZ0LmN1cnJlbnRUYXJnZXQuX192dWVfXykge1xuICAgICAgICAgICAgLy8gUm91dGVyIGxpbmtzIGRvIG5vdCBlbWl0IGluc3RhbmNlIGBjbGlja2AgZXZlbnRzLCBzbyB3ZVxuICAgICAgICAgICAgLy8gYWRkIGluIGFuIGAkZW1pdCgnY2xpY2snLCBldnQpYCBvbiBpdHMgVnVlIGluc3RhbmNlXG4gICAgICAgICAgICBldnQuY3VycmVudFRhcmdldC5fX3Z1ZV9fLiRlbWl0KCdjbGljaycsIGV2dCk7XG4gICAgICAgICAgfSAvLyBDYWxsIHRoZSBzdXBwbGllZEhhbmRsZXIocyksIGlmIGFueSBwcm92aWRlZFxuXG5cbiAgICAgICAgICBjb25jYXQoc3VwcGxpZWRIYW5kbGVyKS5maWx0ZXIoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGgpO1xuICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoX2FyZ3VtZW50cykpO1xuICAgICAgICAgIH0pOyAvLyBFbWl0IHRoZSBnbG9iYWwgYCRyb290YCBjbGljayBldmVudFxuXG4gICAgICAgICAgdGhpcy4kcm9vdC4kZW1pdCgnY2xpY2tlZDo6bGluaycsIGV2dCk7XG4gICAgICAgIH0gLy8gU3RvcCBzY3JvbGwtdG8tdG9wIGJlaGF2aW9yIG9yIG5hdmlnYXRpb24gb25cbiAgICAgICAgLy8gcmVndWxhciBsaW5rcyB3aGVuIGhyZWYgaXMganVzdCAnIydcblxuXG4gICAgICAgIGlmIChldnRJc0V2ZW50ICYmICh0aGlzLmRpc2FibGVkIHx8ICFpc1JvdXRlckxpbmsgJiYgdGhpcy5jb21wdXRlZEhyZWYgPT09ICcjJykpIHtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuJGVsICYmIHRoaXMuJGVsLmZvY3VzKSB7XG4gICAgICAgICAgdGhpcy4kZWwuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJsdXI6IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgICAgIGlmICh0aGlzLiRlbCAmJiB0aGlzLiRlbC5ibHVyKSB7XG4gICAgICAgICAgdGhpcy4kZWwuYmx1cigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICB2YXIgdGFnID0gdGhpcy5jb21wdXRlZFRhZztcbiAgICAgIHZhciByZWwgPSB0aGlzLmNvbXB1dGVkUmVsO1xuICAgICAgdmFyIGhyZWYgPSB0aGlzLmNvbXB1dGVkSHJlZjtcbiAgICAgIHZhciBpc1JvdXRlckxpbmsgPSB0aGlzLmlzUm91dGVyTGluaztcbiAgICAgIHZhciBjb21wb25lbnREYXRhID0ge1xuICAgICAgICBjbGFzczoge1xuICAgICAgICAgIGFjdGl2ZTogdGhpcy5hY3RpdmUsXG4gICAgICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWRcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cnM6IF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLiRhdHRycywge1xuICAgICAgICAgIHJlbDogcmVsLFxuICAgICAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXG4gICAgICAgICAgdGFiaW5kZXg6IHRoaXMuZGlzYWJsZWQgPyAnLTEnIDogaXNVbmRlZmluZWQodGhpcy4kYXR0cnMudGFiaW5kZXgpID8gbnVsbCA6IHRoaXMuJGF0dHJzLnRhYmluZGV4LFxuICAgICAgICAgICdhcmlhLWRpc2FibGVkJzogdGhpcy5kaXNhYmxlZCA/ICd0cnVlJyA6IG51bGxcbiAgICAgICAgfSksXG4gICAgICAgIHByb3BzOiB0aGlzLmNvbXB1dGVkUHJvcHNcbiAgICAgIH07IC8vIEFkZCB0aGUgZXZlbnQgaGFuZGxlcnMuIFdlIG11c3QgdXNlIGBuYXRpdmVPbmAgZm9yXG4gICAgICAvLyBgPHJvdXRlci1saW5rPmAvYDxudXh0LWxpbms+YCBpbnN0ZWFkIG9mIGBvbmBcblxuICAgICAgY29tcG9uZW50RGF0YVtpc1JvdXRlckxpbmsgPyAnbmF0aXZlT24nIDogJ29uJ10gPSBfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy4kbGlzdGVuZXJzLCB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gb3ZlcndyaXRlIGFueSBjbGljayBoYW5kbGVyIHNpbmNlIG91ciBjYWxsYmFja1xuICAgICAgICAvLyB3aWxsIGludm9rZSB0aGUgdXNlciBzdXBwbGllZCBoYW5kbGVyKHMpIGlmIGAhdGhpcy5kaXNhYmxlZGBcbiAgICAgICAgY2xpY2s6IHRoaXMub25DbGlja1xuICAgICAgfSk7IC8vIElmIGhyZWYgYXR0cmlidXRlIGV4aXN0cyBvbiA8cm91dGVyLWxpbms+IChldmVuIHVuZGVmaW5lZCBvciBudWxsKSBpdCBmYWlscyB3b3JraW5nIG9uXG4gICAgICAvLyBTU1IsIHNvIHdlIGV4cGxpY2l0bHkgYWRkIGl0IGhlcmUgaWYgbmVlZGVkIChpLmUuIGlmIGNvbXB1dGVkSHJlZigpIGlzIHRydXRoeSlcblxuICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgY29tcG9uZW50RGF0YS5hdHRycy5ocmVmID0gaHJlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgcHJvcCBIUkVGIGRvZXMgbm90IGV4aXN0IGZvciByb3V0ZXIgbGlua3NcbiAgICAgICAgZGVsZXRlIGNvbXBvbmVudERhdGEucHJvcHMuaHJlZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGgodGFnLCBjb21wb25lbnREYXRhLCB0aGlzLm5vcm1hbGl6ZVNsb3QoJ2RlZmF1bHQnKSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgTkFNRSQzID0gJ0JCYWRnZSc7XG4gIHZhciBsaW5rUHJvcHMgPSBwcm9wc0ZhY3RvcnkoKTtcbiAgZGVsZXRlIGxpbmtQcm9wcy5ocmVmLmRlZmF1bHQ7XG4gIGRlbGV0ZSBsaW5rUHJvcHMudG8uZGVmYXVsdDtcbiAgdmFyIHByb3BzJDEgPSBfb2JqZWN0U3ByZWFkMih7fSwgbGlua1Byb3BzLCB7XG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnc3BhbidcbiAgICB9LFxuICAgIHZhcmlhbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkMywgJ3ZhcmlhbnQnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBpbGw6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSk7IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJCYWRnZSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogTkFNRSQzLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IHByb3BzJDEsXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX3JlZikge1xuICAgICAgdmFyIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgICAgIHZhciBpc0JMaW5rID0gcHJvcHMuaHJlZiB8fCBwcm9wcy50bztcbiAgICAgIHZhciB0YWcgPSBpc0JMaW5rID8gQkxpbmsgOiBwcm9wcy50YWc7XG4gICAgICB2YXIgY29tcG9uZW50RGF0YSA9IHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdiYWRnZScsXG4gICAgICAgIGNsYXNzOiBbcHJvcHMudmFyaWFudCA/IFwiYmFkZ2UtXCIuY29uY2F0KHByb3BzLnZhcmlhbnQpIDogJ2JhZGdlLXNlY29uZGFyeScsIHtcbiAgICAgICAgICAnYmFkZ2UtcGlsbCc6IHByb3BzLnBpbGwsXG4gICAgICAgICAgYWN0aXZlOiBwcm9wcy5hY3RpdmUsXG4gICAgICAgICAgZGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkXG4gICAgICAgIH1dLFxuICAgICAgICBwcm9wczogaXNCTGluayA/IHBsdWNrUHJvcHMobGlua1Byb3BzLCBwcm9wcykgOiB7fVxuICAgICAgfTtcbiAgICAgIHJldHVybiBoKHRhZywgYShkYXRhLCBjb21wb25lbnREYXRhKSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIEJhZGdlUGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBCQmFkZ2U6IEJCYWRnZVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHN0cmlwVGFnc1JlZ2V4ID0gLyg8KFtePl0rKT4pL2dpOyAvLyBSZW1vdmVzIGFueSB0aGluZyB0aGF0IGxvb2tzIGxpa2UgYW4gSFRNTCB0YWcgZnJvbSB0aGUgc3VwcGxpZWQgc3RyaW5nXG5cbiAgdmFyIHN0cmlwVGFncyA9IGZ1bmN0aW9uIHN0cmlwVGFncygpIHtcbiAgICB2YXIgdGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gICAgcmV0dXJuIFN0cmluZyh0ZXh0KS5yZXBsYWNlKHN0cmlwVGFnc1JlZ2V4LCAnJyk7XG4gIH07IC8vIEdlbmVyYXRlIGEgZG9tUHJvcHMgb2JqZWN0IGZvciBlaXRoZXIgaW5uZXJIVE1MLCB0ZXh0Q29udGVudCBvciBub3RoaW5nXG5cbiAgdmFyIGh0bWxPclRleHQgPSBmdW5jdGlvbiBodG1sT3JUZXh0KGlubmVySFRNTCwgdGV4dENvbnRlbnQpIHtcbiAgICByZXR1cm4gaW5uZXJIVE1MID8ge1xuICAgICAgaW5uZXJIVE1MOiBpbm5lckhUTUxcbiAgICB9IDogdGV4dENvbnRlbnQgPyB7XG4gICAgICB0ZXh0Q29udGVudDogdGV4dENvbnRlbnRcbiAgICB9IDoge307XG4gIH07XG5cbiAgdmFyIHByb3BzJDIgPSBfb2JqZWN0U3ByZWFkMih7fSwgcHJvcHNGYWN0b3J5KCksIHtcbiAgICB0ZXh0OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBodG1sOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBhcmlhQ3VycmVudDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2xvY2F0aW9uJ1xuICAgIH1cbiAgfSk7IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJCcmVhZGNydW1iTGluayA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JCcmVhZGNydW1iTGluaycsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczogcHJvcHMkMixcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgc3VwcGxpZWRQcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gICAgICB2YXIgdGFnID0gc3VwcGxpZWRQcm9wcy5hY3RpdmUgPyAnc3BhbicgOiBCTGluaztcbiAgICAgIHZhciBjb21wb25lbnREYXRhID0ge1xuICAgICAgICBwcm9wczogcGx1Y2tQcm9wcyhwcm9wcyQyLCBzdXBwbGllZFByb3BzKVxuICAgICAgfTtcblxuICAgICAgaWYgKHN1cHBsaWVkUHJvcHMuYWN0aXZlKSB7XG4gICAgICAgIGNvbXBvbmVudERhdGEuYXR0cnMgPSB7XG4gICAgICAgICAgJ2FyaWEtY3VycmVudCc6IHN1cHBsaWVkUHJvcHMuYXJpYUN1cnJlbnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICBjb21wb25lbnREYXRhLmRvbVByb3BzID0gaHRtbE9yVGV4dChzdXBwbGllZFByb3BzLmh0bWwsIHN1cHBsaWVkUHJvcHMudGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoKHRhZywgYShkYXRhLCBjb21wb25lbnREYXRhKSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIEJCcmVhZGNydW1iSXRlbSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JCcmVhZGNydW1iSXRlbScsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczogcHJvcHMkMixcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICAgICAgcmV0dXJuIGgoJ2xpJywgYShkYXRhLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnYnJlYWRjcnVtYi1pdGVtJyxcbiAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICBhY3RpdmU6IHByb3BzLmFjdGl2ZVxuICAgICAgICB9XG4gICAgICB9KSwgW2goQkJyZWFkY3J1bWJMaW5rLCB7XG4gICAgICAgIHByb3BzOiBwcm9wc1xuICAgICAgfSwgY2hpbGRyZW4pXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcHJvcHMkMyA9IHtcbiAgICBpdGVtczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfVxuICB9OyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCQnJlYWRjcnVtYiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JCcmVhZGNydW1iJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBwcm9wcyQzLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gICAgICB2YXIgY2hpbGROb2RlcyA9IGNoaWxkcmVuOyAvLyBCdWlsZCBjaGlsZCBub2RlcyBmcm9tIGl0ZW1zIGlmIGdpdmVuLlxuXG4gICAgICBpZiAoaXNBcnJheShwcm9wcy5pdGVtcykpIHtcbiAgICAgICAgdmFyIGFjdGl2ZURlZmluZWQgPSBmYWxzZTtcbiAgICAgICAgY2hpbGROb2RlcyA9IHByb3BzLml0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSwgaWR4KSB7XG4gICAgICAgICAgaWYgKCFpc09iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgaXRlbSA9IHtcbiAgICAgICAgICAgICAgdGV4dDogdG9TdHJpbmckMShpdGVtKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IC8vIENvcHkgdGhlIHZhbHVlIGhlcmUgc28gd2UgY2FuIG5vcm1hbGl6ZSBpdC5cblxuXG4gICAgICAgICAgdmFyIGFjdGl2ZSA9IGl0ZW0uYWN0aXZlO1xuXG4gICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgYWN0aXZlRGVmaW5lZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFhY3RpdmUgJiYgIWFjdGl2ZURlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEF1dG8tZGV0ZWN0IGFjdGl2ZSBieSBwb3NpdGlvbiBpbiBsaXN0LlxuICAgICAgICAgICAgYWN0aXZlID0gaWR4ICsgMSA9PT0gcHJvcHMuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBoKEJCcmVhZGNydW1iSXRlbSwge1xuICAgICAgICAgICAgcHJvcHM6IF9vYmplY3RTcHJlYWQyKHt9LCBpdGVtLCB7XG4gICAgICAgICAgICAgIGFjdGl2ZTogYWN0aXZlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGgoJ29sJywgYShkYXRhLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnYnJlYWRjcnVtYidcbiAgICAgIH0pLCBjaGlsZE5vZGVzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBCcmVhZGNydW1iUGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBCQnJlYWRjcnVtYjogQkJyZWFkY3J1bWIsXG4gICAgICBCQnJlYWRjcnVtYkl0ZW06IEJCcmVhZGNydW1iSXRlbSxcbiAgICAgIEJCcmVhZGNydW1iTGluazogQkJyZWFkY3J1bWJMaW5rXG4gICAgfVxuICB9KTtcblxuICAvKlxuICAgKiBLZXkgQ29kZXMgKGV2ZW50cylcbiAgICovXG4gIHZhciBLRVlfQ09ERVMgPSBmcmVlemUoe1xuICAgIFNQQUNFOiAzMixcbiAgICBFTlRFUjogMTMsXG4gICAgRVNDOiAyNyxcbiAgICBMRUZUOiAzNyxcbiAgICBVUDogMzgsXG4gICAgUklHSFQ6IDM5LFxuICAgIERPV046IDQwLFxuICAgIFBBR0VVUDogMzMsXG4gICAgUEFHRURPV046IDM0LFxuICAgIEhPTUU6IDM2LFxuICAgIEVORDogMzUsXG4gICAgVEFCOiA5LFxuICAgIFNISUZUOiAxNixcbiAgICBDVFJMOiAxNyxcbiAgICBCQUNLU1BBQ0U6IDgsXG4gICAgQUxUOiAxOCxcbiAgICBQQVVTRTogMTksXG4gICAgQlJFQUs6IDE5LFxuICAgIElOU0VSVDogNDUsXG4gICAgSU5TOiA0NSxcbiAgICBERUxFVEU6IDQ2XG4gIH0pO1xuXG4gIHZhciBOQU1FJDQgPSAnQkJ1dHRvbic7XG4gIHZhciBidG5Qcm9wcyA9IHtcbiAgICBibG9jazoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBkaXNhYmxlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBzaXplOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJDQsICdzaXplJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YXJpYW50OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJDQsICd2YXJpYW50Jyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnYnV0dG9uJ1xuICAgIH0sXG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnYnV0dG9uJ1xuICAgIH0sXG4gICAgcGlsbDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBzcXVhcmVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHByZXNzZWQ6IHtcbiAgICAgIC8vIFRyaS1zdGF0ZTogYHRydWVgLCBgZmFsc2VgIG9yIGBudWxsYFxuICAgICAgLy8gPT4gT24sIG9mZiwgbm90IGEgdG9nZ2xlXG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH1cbiAgfTtcbiAgdmFyIGxpbmtQcm9wcyQxID0gcHJvcHNGYWN0b3J5KCk7XG4gIGRlbGV0ZSBsaW5rUHJvcHMkMS5ocmVmLmRlZmF1bHQ7XG4gIGRlbGV0ZSBsaW5rUHJvcHMkMS50by5kZWZhdWx0O1xuICB2YXIgbGlua1Byb3BLZXlzID0ga2V5cyhsaW5rUHJvcHMkMSk7XG4gIHZhciBwcm9wcyQ0ID0gX29iamVjdFNwcmVhZDIoe30sIGxpbmtQcm9wcyQxLCB7fSwgYnRuUHJvcHMpOyAvLyAtLS0gSGVscGVyIG1ldGhvZHMgLS0tXG4gIC8vIFJldHVybnMgYHRydWVgIGlmIGEgdGFnJ3MgbmFtZSBlcXVhbHMgYG5hbWVgXG5cbiAgdmFyIHRhZ0lzID0gZnVuY3Rpb24gdGFnSXModGFnLCBuYW1lKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nJDEodGFnKS50b0xvd2VyQ2FzZSgpID09PSB0b1N0cmluZyQxKG5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gIH07IC8vIEZvY3VzIGhhbmRsZXIgZm9yIHRvZ2dsZSBidXR0b25zXG4gIC8vIE5lZWRzIGNsYXNzIG9mICdmb2N1cycgd2hlbiBmb2N1c2VkXG5cblxuICB2YXIgaGFuZGxlRm9jdXMgPSBmdW5jdGlvbiBoYW5kbGVGb2N1cyhldnQpIHtcbiAgICBpZiAoZXZ0LnR5cGUgPT09ICdmb2N1c2luJykge1xuICAgICAgYWRkQ2xhc3MoZXZ0LnRhcmdldCwgJ2ZvY3VzJyk7XG4gICAgfSBlbHNlIGlmIChldnQudHlwZSA9PT0gJ2ZvY3Vzb3V0Jykge1xuICAgICAgcmVtb3ZlQ2xhc3MoZXZ0LnRhcmdldCwgJ2ZvY3VzJyk7XG4gICAgfVxuICB9OyAvLyBJcyB0aGUgcmVxdWVzdGVkIGJ1dHRvbiBhIGxpbms/XG4gIC8vIElmIHRhZyBwcm9wIGlzIHNldCB0byBgYWAsIHdlIHVzZSBhIDxiLWxpbms+IHRvIGdldCBwcm9wZXIgZGlzYWJsZWQgaGFuZGxpbmdcblxuXG4gIHZhciBpc0xpbmsgPSBmdW5jdGlvbiBpc0xpbmsocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMuaHJlZiB8fCBwcm9wcy50byB8fCB0YWdJcyhwcm9wcy50YWcsICdhJyk7XG4gIH07IC8vIElzIHRoZSBidXR0b24gdG8gYmUgYSB0b2dnbGUgYnV0dG9uP1xuXG5cbiAgdmFyIGlzVG9nZ2xlID0gZnVuY3Rpb24gaXNUb2dnbGUocHJvcHMpIHtcbiAgICByZXR1cm4gaXNCb29sZWFuKHByb3BzLnByZXNzZWQpO1xuICB9OyAvLyBJcyB0aGUgYnV0dG9uIFwicmVhbGx5XCIgYSBidXR0b24/XG5cblxuICB2YXIgaXNCdXR0b24gPSBmdW5jdGlvbiBpc0J1dHRvbihwcm9wcykge1xuICAgIHJldHVybiAhKGlzTGluayhwcm9wcykgfHwgcHJvcHMudGFnICYmICF0YWdJcyhwcm9wcy50YWcsICdidXR0b24nKSk7XG4gIH07IC8vIElzIHRoZSByZXF1ZXN0ZWQgdGFnIG5vdCBhIGJ1dHRvbiBvciBsaW5rP1xuXG5cbiAgdmFyIGlzTm9uU3RhbmRhcmRUYWcgPSBmdW5jdGlvbiBpc05vblN0YW5kYXJkVGFnKHByb3BzKSB7XG4gICAgcmV0dXJuICFpc0xpbmsocHJvcHMpICYmICFpc0J1dHRvbihwcm9wcyk7XG4gIH07IC8vIENvbXB1dGUgcmVxdWlyZWQgY2xhc3NlcyAobm9uIHN0YXRpYyBjbGFzc2VzKVxuXG5cbiAgdmFyIGNvbXB1dGVDbGFzcyA9IGZ1bmN0aW9uIGNvbXB1dGVDbGFzcyhwcm9wcykge1xuICAgIHZhciBfcmVmO1xuXG4gICAgcmV0dXJuIFtcImJ0bi1cIi5jb25jYXQocHJvcHMudmFyaWFudCB8fCBnZXRDb21wb25lbnRDb25maWcoTkFNRSQ0LCAndmFyaWFudCcpKSwgKF9yZWYgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9yZWYsIFwiYnRuLVwiLmNvbmNhdChwcm9wcy5zaXplKSwgcHJvcHMuc2l6ZSksIF9kZWZpbmVQcm9wZXJ0eShfcmVmLCAnYnRuLWJsb2NrJywgcHJvcHMuYmxvY2spLCBfZGVmaW5lUHJvcGVydHkoX3JlZiwgJ3JvdW5kZWQtcGlsbCcsIHByb3BzLnBpbGwpLCBfZGVmaW5lUHJvcGVydHkoX3JlZiwgJ3JvdW5kZWQtMCcsIHByb3BzLnNxdWFyZWQgJiYgIXByb3BzLnBpbGwpLCBfZGVmaW5lUHJvcGVydHkoX3JlZiwgXCJkaXNhYmxlZFwiLCBwcm9wcy5kaXNhYmxlZCksIF9kZWZpbmVQcm9wZXJ0eShfcmVmLCBcImFjdGl2ZVwiLCBwcm9wcy5wcmVzc2VkKSwgX3JlZildO1xuICB9OyAvLyBDb21wdXRlIHRoZSBsaW5rIHByb3BzIHRvIHBhc3MgdG8gYi1saW5rIChpZiByZXF1aXJlZClcblxuXG4gIHZhciBjb21wdXRlTGlua1Byb3BzID0gZnVuY3Rpb24gY29tcHV0ZUxpbmtQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBpc0xpbmsocHJvcHMpID8gcGx1Y2tQcm9wcyhsaW5rUHJvcEtleXMsIHByb3BzKSA6IG51bGw7XG4gIH07IC8vIENvbXB1dGUgdGhlIGF0dHJpYnV0ZXMgZm9yIGEgYnV0dG9uXG5cblxuICB2YXIgY29tcHV0ZUF0dHJzID0gZnVuY3Rpb24gY29tcHV0ZUF0dHJzKHByb3BzLCBkYXRhKSB7XG4gICAgdmFyIGJ1dHRvbiA9IGlzQnV0dG9uKHByb3BzKTtcbiAgICB2YXIgbGluayA9IGlzTGluayhwcm9wcyk7XG4gICAgdmFyIHRvZ2dsZSA9IGlzVG9nZ2xlKHByb3BzKTtcbiAgICB2YXIgbm9uU3RhbmRhcmRUYWcgPSBpc05vblN0YW5kYXJkVGFnKHByb3BzKTtcbiAgICB2YXIgaGFzaExpbmsgPSBsaW5rICYmIHByb3BzLmhyZWYgPT09ICcjJztcbiAgICB2YXIgcm9sZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5yb2xlID8gZGF0YS5hdHRycy5yb2xlIDogbnVsbDtcbiAgICB2YXIgdGFiaW5kZXggPSBkYXRhLmF0dHJzID8gZGF0YS5hdHRycy50YWJpbmRleCA6IG51bGw7XG5cbiAgICBpZiAobm9uU3RhbmRhcmRUYWcgfHwgaGFzaExpbmspIHtcbiAgICAgIHRhYmluZGV4ID0gJzAnO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAvLyBUeXBlIG9ubHkgdXNlZCBmb3IgXCJyZWFsXCIgYnV0dG9uc1xuICAgICAgdHlwZTogYnV0dG9uICYmICFsaW5rID8gcHJvcHMudHlwZSA6IG51bGwsXG4gICAgICAvLyBEaXNhYmxlZCBvbmx5IHNldCBvbiBcInJlYWxcIiBidXR0b25zXG4gICAgICBkaXNhYmxlZDogYnV0dG9uID8gcHJvcHMuZGlzYWJsZWQgOiBudWxsLFxuICAgICAgLy8gV2UgYWRkIGEgcm9sZSBvZiBidXR0b24gd2hlbiB0aGUgdGFnIGlzIG5vdCBhIGxpbmsgb3IgYnV0dG9uIGZvciBBUklBXG4gICAgICAvLyBEb24ndCBib3JrIGFueSByb2xlIHByb3ZpZGVkIGluIGBkYXRhLmF0dHJzYCB3aGVuIGBpc0xpbmtgIG9yIGBpc0J1dHRvbmBcbiAgICAgIC8vIEV4Y2VwdCB3aGVuIGxpbmsgaGFzIGBocmVmYCBvZiBgI2BcbiAgICAgIHJvbGU6IG5vblN0YW5kYXJkVGFnIHx8IGhhc2hMaW5rID8gJ2J1dHRvbicgOiByb2xlLFxuICAgICAgLy8gV2Ugc2V0IHRoZSBgYXJpYS1kaXNhYmxlZGAgc3RhdGUgZm9yIG5vbi1zdGFuZGFyZCB0YWdzXG4gICAgICAnYXJpYS1kaXNhYmxlZCc6IG5vblN0YW5kYXJkVGFnID8gU3RyaW5nKHByb3BzLmRpc2FibGVkKSA6IG51bGwsXG4gICAgICAvLyBGb3IgdG9nZ2xlcywgd2UgbmVlZCB0byBzZXQgdGhlIHByZXNzZWQgc3RhdGUgZm9yIEFSSUFcbiAgICAgICdhcmlhLXByZXNzZWQnOiB0b2dnbGUgPyBTdHJpbmcocHJvcHMucHJlc3NlZCkgOiBudWxsLFxuICAgICAgLy8gYGF1dG9jb21wbGV0ZT1cIm9mZlwiYCBpcyBuZWVkZWQgaW4gdG9nZ2xlIG1vZGUgdG8gcHJldmVudCBzb21lIGJyb3dzZXJzXG4gICAgICAvLyBmcm9tIHJlbWVtYmVyaW5nIHRoZSBwcmV2aW91cyBzZXR0aW5nIHdoZW4gdXNpbmcgdGhlIGJhY2sgYnV0dG9uXG4gICAgICBhdXRvY29tcGxldGU6IHRvZ2dsZSA/ICdvZmYnIDogbnVsbCxcbiAgICAgIC8vIGB0YWJpbmRleGAgaXMgdXNlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbm90IGEgYnV0dG9uXG4gICAgICAvLyBMaW5rcyBhcmUgdGFiYmFibGUsIGJ1dCBkb24ndCBhbGxvdyBkaXNhYmxlZCwgd2hpbGUgbm9uIGJ1dHRvbnMgb3IgbGlua3NcbiAgICAgIC8vIGFyZSBub3QgdGFiYmFibGUsIHNvIHdlIG1pbWljIHRoYXQgZnVuY3Rpb25hbGl0eSBieSBkaXNhYmxpbmcgdGFiYmluZ1xuICAgICAgLy8gd2hlbiBkaXNhYmxlZCwgYW5kIGFkZGluZyBhIGB0YWJpbmRleD1cIjBcImAgdG8gbm9uIGJ1dHRvbnMgb3Igbm9uIGxpbmtzXG4gICAgICB0YWJpbmRleDogcHJvcHMuZGlzYWJsZWQgJiYgIWJ1dHRvbiA/ICctMScgOiB0YWJpbmRleFxuICAgIH07XG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cblxuICB2YXIgQkJ1dHRvbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogTkFNRSQ0LFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IHByb3BzJDQsXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX3JlZjIpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYyLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgICAgIGxpc3RlbmVycyA9IF9yZWYyLmxpc3RlbmVycyxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYyLmNoaWxkcmVuO1xuICAgICAgdmFyIHRvZ2dsZSA9IGlzVG9nZ2xlKHByb3BzKTtcbiAgICAgIHZhciBsaW5rID0gaXNMaW5rKHByb3BzKTtcbiAgICAgIHZhciBub25TdGFuZGFyZFRhZyA9IGlzTm9uU3RhbmRhcmRUYWcocHJvcHMpO1xuICAgICAgdmFyIGhhc2hMaW5rID0gbGluayAmJiBwcm9wcy5ocmVmID09PSAnIyc7XG4gICAgICB2YXIgb24gPSB7XG4gICAgICAgIGtleWRvd246IGZ1bmN0aW9uIGtleWRvd24oZXZ0KSB7XG4gICAgICAgICAgLy8gV2hlbiB0aGUgbGluayBpcyBhIGBocmVmPVwiI1wiYCBvciBhIG5vbi1zdGFuZGFyZCB0YWcgKGhhcyBgcm9sZT1cImJ1dHRvblwiYCksXG4gICAgICAgICAgLy8gd2UgYWRkIGEga2V5ZG93biBoYW5kbGVycyBmb3IgU1BBQ0UvRU5URVJcblxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgaWYgKHByb3BzLmRpc2FibGVkIHx8ICEobm9uU3RhbmRhcmRUYWcgfHwgaGFzaExpbmspKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGtleUNvZGUgPSBldnQua2V5Q29kZTsgLy8gQWRkIFNQQUNFIGhhbmRsZXIgZm9yIGBocmVmPVwiI1wiYCBhbmQgRU5URVIgaGFuZGxlciBmb3Igbm9uLXN0YW5kYXJkIHRhZ3NcblxuICAgICAgICAgIGlmIChrZXlDb2RlID09PSBLRVlfQ09ERVMuU1BBQ0UgfHwga2V5Q29kZSA9PT0gS0VZX0NPREVTLkVOVEVSICYmIG5vblN0YW5kYXJkVGFnKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZ0LmN1cnJlbnRUYXJnZXQgfHwgZXZ0LnRhcmdldDtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGFyZ2V0LmNsaWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soZXZ0KSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiBibGluay9idXR0b24gZGlzYWJsZWQgc2hvdWxkIGhhbmRsZSB0aGlzICovXG4gICAgICAgICAgaWYgKHByb3BzLmRpc2FibGVkICYmIGlzRXZlbnQoZXZ0KSkge1xuICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0b2dnbGUgJiYgbGlzdGVuZXJzICYmIGxpc3RlbmVyc1sndXBkYXRlOnByZXNzZWQnXSkge1xuICAgICAgICAgICAgLy8gU2VuZCBgLnN5bmNgIHVwZGF0ZXMgdG8gYW55IFwicHJlc3NlZFwiIHByb3AgKGlmIGAuc3luY2AgbGlzdGVuZXJzKVxuICAgICAgICAgICAgLy8gYGNvbmNhdCgpYCB3aWxsIG5vcm1hbGl6ZSB0aGUgdmFsdWUgdG8gYW4gYXJyYXkgd2l0aG91dFxuICAgICAgICAgICAgLy8gZG91YmxlIHdyYXBwaW5nIGFuIGFycmF5IHZhbHVlIGluIGFuIGFycmF5XG4gICAgICAgICAgICBjb25jYXQobGlzdGVuZXJzWyd1cGRhdGU6cHJlc3NlZCddKS5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihmbikpIHtcbiAgICAgICAgICAgICAgICBmbighcHJvcHMucHJlc3NlZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHRvZ2dsZSkge1xuICAgICAgICBvbi5mb2N1c2luID0gaGFuZGxlRm9jdXM7XG4gICAgICAgIG9uLmZvY3Vzb3V0ID0gaGFuZGxlRm9jdXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wb25lbnREYXRhID0ge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2J0bicsXG4gICAgICAgIGNsYXNzOiBjb21wdXRlQ2xhc3MocHJvcHMpLFxuICAgICAgICBwcm9wczogY29tcHV0ZUxpbmtQcm9wcyhwcm9wcyksXG4gICAgICAgIGF0dHJzOiBjb21wdXRlQXR0cnMocHJvcHMsIGRhdGEpLFxuICAgICAgICBvbjogb25cbiAgICAgIH07XG4gICAgICByZXR1cm4gaChsaW5rID8gQkxpbmsgOiBwcm9wcy50YWcsIGEoZGF0YSwgY29tcG9uZW50RGF0YSksIGNoaWxkcmVuKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBCdXR0b25QbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJCdXR0b246IEJCdXR0b24sXG4gICAgICBCQnRuOiBCQnV0dG9uLFxuICAgICAgQkJ1dHRvbkNsb3NlOiBCQnV0dG9uQ2xvc2UsXG4gICAgICBCQnRuQ2xvc2U6IEJCdXR0b25DbG9zZVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIE5BTUUkNSA9ICdCQnV0dG9uR3JvdXAnO1xuICB2YXIgcHJvcHMkNSA9IHtcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBzaXplOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZygnQkJ1dHRvbicsICdzaXplJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdkaXYnXG4gICAgfSxcbiAgICBhcmlhUm9sZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2dyb3VwJ1xuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkJ1dHRvbkdyb3VwID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiBOQU1FJDUsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczogcHJvcHMkNSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICAgICAgcmV0dXJuIGgocHJvcHMudGFnLCBhKGRhdGEsIHtcbiAgICAgICAgY2xhc3M6IF9kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICAgICAgJ2J0bi1ncm91cCc6ICFwcm9wcy52ZXJ0aWNhbCxcbiAgICAgICAgICAnYnRuLWdyb3VwLXZlcnRpY2FsJzogcHJvcHMudmVydGljYWxcbiAgICAgICAgfSwgXCJidG4tZ3JvdXAtXCIuY29uY2F0KHByb3BzLnNpemUpLCBwcm9wcy5zaXplKSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICByb2xlOiBwcm9wcy5hcmlhUm9sZVxuICAgICAgICB9XG4gICAgICB9KSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIEJ1dHRvbkdyb3VwUGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBCQnV0dG9uR3JvdXA6IEJCdXR0b25Hcm91cCxcbiAgICAgIEJCdG5Hcm91cDogQkJ1dHRvbkdyb3VwXG4gICAgfVxuICB9KTtcblxuICB2YXIgSVRFTV9TRUxFQ1RPUiA9IFsnLmJ0bjpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSk6bm90KC5kcm9wZG93bi1pdGVtKScsICcuZm9ybS1jb250cm9sOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKScsICdzZWxlY3Q6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pJywgJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXTpub3QoLmRpc2FibGVkKScsICdpbnB1dFt0eXBlPVwicmFkaW9cIl06bm90KC5kaXNhYmxlZCknXS5qb2luKCcsJyk7IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJCdXR0b25Ub29sYmFyID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQkJ1dHRvblRvb2xiYXInLFxuICAgIG1peGluczogW25vcm1hbGl6ZVNsb3RNaXhpbl0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGp1c3RpZnk6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBrZXlOYXY6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICBpZiAodGhpcy5rZXlOYXYpIHtcbiAgICAgICAgLy8gUHJlLXNldCB0aGUgdGFiaW5kZXhlcyBpZiB0aGUgbWFya3VwIGRvZXMgbm90IGluY2x1ZGUgdGFiaW5kZXg9XCItMVwiIG9uIHRoZSB0b29sYmFyIGl0ZW1zXG4gICAgICAgIHRoaXMuZ2V0SXRlbXMoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIG9uRm9jdXNpbjogZnVuY3Rpb24gb25Gb2N1c2luKGV2dCkge1xuICAgICAgICBpZiAoZXZ0LnRhcmdldCA9PT0gdGhpcy4kZWwpIHtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgdGhpcy5mb2N1c0ZpcnN0KGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKGV2dCkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSxcbiAgICAgIG9uS2V5ZG93bjogZnVuY3Rpb24gb25LZXlkb3duKGV2dCkge1xuICAgICAgICBpZiAoIXRoaXMua2V5TmF2KSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNob3VsZCBuZXZlciBoYXBwZW4gKi9cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5ID0gZXZ0LmtleUNvZGU7XG4gICAgICAgIHZhciBzaGlmdCA9IGV2dC5zaGlmdEtleTtcblxuICAgICAgICBpZiAoa2V5ID09PSBLRVlfQ09ERVMuVVAgfHwga2V5ID09PSBLRVlfQ09ERVMuTEVGVCkge1xuICAgICAgICAgIHRoaXMuc3RvcChldnQpO1xuICAgICAgICAgIHNoaWZ0ID8gdGhpcy5mb2N1c0ZpcnN0KGV2dCkgOiB0aGlzLmZvY3VzUHJldihldnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gS0VZX0NPREVTLkRPV04gfHwga2V5ID09PSBLRVlfQ09ERVMuUklHSFQpIHtcbiAgICAgICAgICB0aGlzLnN0b3AoZXZ0KTtcbiAgICAgICAgICBzaGlmdCA/IHRoaXMuZm9jdXNMYXN0KGV2dCkgOiB0aGlzLmZvY3VzTmV4dChldnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0SXRlbUZvY3VzOiBmdW5jdGlvbiBzZXRJdGVtRm9jdXMoaXRlbSkge1xuICAgICAgICBpdGVtICYmIGl0ZW0uZm9jdXMgJiYgaXRlbS5mb2N1cygpO1xuICAgICAgfSxcbiAgICAgIGZvY3VzRmlyc3Q6IGZ1bmN0aW9uIGZvY3VzRmlyc3QoKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuZ2V0SXRlbXMoKTtcbiAgICAgICAgdGhpcy5zZXRJdGVtRm9jdXMoaXRlbXNbMF0pO1xuICAgICAgfSxcbiAgICAgIGZvY3VzUHJldjogZnVuY3Rpb24gZm9jdXNQcmV2KGV2dCkge1xuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmdldEl0ZW1zKCk7XG4gICAgICAgIHZhciBpbmRleCA9IGl0ZW1zLmluZGV4T2YoZXZ0LnRhcmdldCk7XG5cbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKDAsIGluZGV4KS5yZXZlcnNlKCk7XG4gICAgICAgICAgdGhpcy5zZXRJdGVtRm9jdXMoaXRlbXNbMF0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZm9jdXNOZXh0OiBmdW5jdGlvbiBmb2N1c05leHQoZXZ0KSB7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuZ2V0SXRlbXMoKTtcbiAgICAgICAgdmFyIGluZGV4ID0gaXRlbXMuaW5kZXhPZihldnQudGFyZ2V0KTtcblxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIGl0ZW1zID0gaXRlbXMuc2xpY2UoaW5kZXggKyAxKTtcbiAgICAgICAgICB0aGlzLnNldEl0ZW1Gb2N1cyhpdGVtc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmb2N1c0xhc3Q6IGZ1bmN0aW9uIGZvY3VzTGFzdCgpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5nZXRJdGVtcygpLnJldmVyc2UoKTtcbiAgICAgICAgdGhpcy5zZXRJdGVtRm9jdXMoaXRlbXNbMF0pO1xuICAgICAgfSxcbiAgICAgIGdldEl0ZW1zOiBmdW5jdGlvbiBnZXRJdGVtcygpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gc2VsZWN0QWxsKElURU1fU0VMRUNUT1IsIHRoaXMuJGVsKTtcbiAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIC8vIEVuc3VyZSB0YWJmb2N1cyBpcyAtMSBvbiBhbnkgbmV3IGVsZW1lbnRzXG4gICAgICAgICAgaXRlbS50YWJJbmRleCA9IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICByZXR1cm4gaXNWaXNpYmxlKGVsKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2J0bi10b29sYmFyJyxcbiAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAnanVzdGlmeS1jb250ZW50LWJldHdlZW4nOiB0aGlzLmp1c3RpZnlcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICByb2xlOiAndG9vbGJhcicsXG4gICAgICAgICAgdGFiaW5kZXg6IHRoaXMua2V5TmF2ID8gJzAnIDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBvbjogdGhpcy5rZXlOYXYgPyB7XG4gICAgICAgICAgZm9jdXNpbjogdGhpcy5vbkZvY3VzaW4sXG4gICAgICAgICAga2V5ZG93bjogdGhpcy5vbktleWRvd25cbiAgICAgICAgfSA6IHt9XG4gICAgICB9LCBbdGhpcy5ub3JtYWxpemVTbG90KCdkZWZhdWx0JyldKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBCdXR0b25Ub29sYmFyUGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBCQnV0dG9uVG9vbGJhcjogQkJ1dHRvblRvb2xiYXIsXG4gICAgICBCQnRuVG9vbGJhcjogQkJ1dHRvblRvb2xiYXJcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEhhbmRsZXMgd2hlbiBhcnJheXMgYXJlIFwic3BhcnNlXCIgKGFycmF5LmV2ZXJ5KC4uLikgZG9lc24ndCBoYW5kbGUgc3BhcnNlKVxuXG4gIHZhciBjb21wYXJlQXJyYXlzID0gZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBlcXVhbCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXF1YWw7XG4gIH07XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAgICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICAgKiBSZXR1cm5zIGJvb2xlYW4gdHJ1ZSBvciBmYWxzZVxuICAgKi9cblxuXG4gIHZhciBsb29zZUVxdWFsID0gZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xuICAgIHZhciBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xuXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xuICAgIH1cblxuICAgIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xuICAgIGJWYWxpZFR5cGUgPSBpc0FycmF5KGIpO1xuXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGNvbXBhcmVBcnJheXMoYSwgYikgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XG4gICAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xuXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB0aGlzIGlmIHdpbGwgcHJvYmFibHkgbmV2ZXIgYmUgY2FsbGVkICovXG4gICAgICBpZiAoIWFWYWxpZFR5cGUgfHwgIWJWYWxpZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYUtleXNDb3VudCA9IGtleXMoYSkubGVuZ3RoO1xuICAgICAgdmFyIGJLZXlzQ291bnQgPSBrZXlzKGIpLmxlbmd0aDtcblxuICAgICAgaWYgKGFLZXlzQ291bnQgIT09IGJLZXlzQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIHZhciBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5cbiAgICAgICAgdmFyIGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XG5cbiAgICAgICAgaWYgKGFIYXNLZXkgJiYgIWJIYXNLZXkgfHwgIWFIYXNLZXkgJiYgYkhhc0tleSB8fCAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG4gIH07XG5cbiAgdmFyIFJYX0RBVEUgPSAvXlxcZCstXFxkKy1cXGQrJC87IC8vIC0tLSBEYXRlIHV0aWxpdHkgbWV0aG9kcyAtLS1cbiAgLy8gQ3JlYXRlIG9yIGNsb25lIGEgZGF0ZSAoYG5ldyBEYXRlKC4uLilgIHNob3J0Y3V0KVxuXG4gIHZhciBjcmVhdGVEYXRlID0gZnVuY3Rpb24gY3JlYXRlRGF0ZSgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9jb25zdHJ1Y3QoRGF0ZSwgYXJncyk7XG4gIH07IC8vIFBhcnNlIGEgZGF0ZSBzdGluZywgb3IgRGF0ZSBvYmplY3QsIGludG8gYSBEYXRlIG9iamVjdCAod2l0aCBubyB0aW1lIGluZm9ybWF0aW9uKVxuXG4gIHZhciBwYXJzZVlNRCA9IGZ1bmN0aW9uIHBhcnNlWU1EKGRhdGUpIHtcbiAgICBpZiAoaXNTdHJpbmcoZGF0ZSkgJiYgUlhfREFURS50ZXN0KGRhdGUudHJpbSgpKSkge1xuICAgICAgdmFyIF9kYXRlJHNwbGl0JG1hcCA9IGRhdGUuc3BsaXQoJy0nKS5tYXAodG9JbnRlZ2VyKSxcbiAgICAgICAgICBfZGF0ZSRzcGxpdCRtYXAyID0gX3NsaWNlZFRvQXJyYXkoX2RhdGUkc3BsaXQkbWFwLCAzKSxcbiAgICAgICAgICB5ZWFyID0gX2RhdGUkc3BsaXQkbWFwMlswXSxcbiAgICAgICAgICBtb250aCA9IF9kYXRlJHNwbGl0JG1hcDJbMV0sXG4gICAgICAgICAgZGF5ID0gX2RhdGUkc3BsaXQkbWFwMlsyXTtcblxuICAgICAgcmV0dXJuIGNyZWF0ZURhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpO1xuICAgIH0gZWxzZSBpZiAoaXNEYXRlKGRhdGUpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9OyAvLyBGb3JtYXQgYSBkYXRlIG9iamVjdCBhcyBgWVlZWS1NTS1ERGAgZm9ybWF0XG5cbiAgdmFyIGZvcm1hdFlNRCA9IGZ1bmN0aW9uIGZvcm1hdFlNRChkYXRlKSB7XG4gICAgZGF0ZSA9IHBhcnNlWU1EKGRhdGUpO1xuXG4gICAgaWYgKCFkYXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICB2YXIgbW9udGggPSBcIjBcIi5jb25jYXQoZGF0ZS5nZXRNb250aCgpICsgMSkuc2xpY2UoLTIpO1xuICAgIHZhciBkYXkgPSBcIjBcIi5jb25jYXQoZGF0ZS5nZXREYXRlKCkpLnNsaWNlKC0yKTtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoeWVhciwgXCItXCIpLmNvbmNhdChtb250aCwgXCItXCIpLmNvbmNhdChkYXkpO1xuICB9OyAvLyBHaXZlbiBhIGxvY2FsZSAob3IgbG9jYWxlcyksIHJlc29sdmUgdGhlIGJyb3dzZXIgYXZhaWxhYmxlIGxvY2FsZVxuXG4gIHZhciByZXNvbHZlTG9jYWxlID0gZnVuY3Rpb24gcmVzb2x2ZUxvY2FsZShsb2NhbGVzKVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB7XG4gICAgdmFyIGNhbGVuZGFyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnZ3JlZ29yeSc7XG4gICAgbG9jYWxlcyA9IGNvbmNhdChsb2NhbGVzKS5maWx0ZXIoaWRlbnRpdHkpO1xuICAgIHZhciBmbXQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGVzLCB7XG4gICAgICBjYWxlbmRhcjogY2FsZW5kYXJcbiAgICB9KTtcbiAgICByZXR1cm4gZm10LnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZTtcbiAgfTsgLy8gQ3JlYXRlIGEgYEludGwuRGF0ZVRpbWVGb3JtYXRgIGZvcm1hdHRlciBmdW5jdGlvblxuXG4gIHZhciBjcmVhdGVEYXRlRm9ybWF0dGVyID0gZnVuY3Rpb24gY3JlYXRlRGF0ZUZvcm1hdHRlcihsb2NhbGUsIG9wdGlvbnMpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHtcbiAgICB2YXIgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gZHRmLmZvcm1hdDtcbiAgfTsgLy8gRGV0ZXJtaW5lIGlmIHR3byBkYXRlcyBhcmUgdGhlIHNhbWUgZGF0ZSAoaWdub3JpbmcgdGltZSBwb3J0aW9uKVxuXG4gIHZhciBkYXRlc0VxdWFsID0gZnVuY3Rpb24gZGF0ZXNFcXVhbChkYXRlMSwgZGF0ZTIpIHtcbiAgICAvLyBSZXR1cm5zIHRydWUgb2YgdGhlIGRhdGUgcG9ydGlvbiBvZiB0d28gZGF0ZSBvYmplY3RzIGFyZSBlcXVhbFxuICAgIC8vIFdlIGRvbid0IGNvbXBhcmUgdGhlIHRpbWUgcG9ydGlvblxuICAgIHJldHVybiBmb3JtYXRZTUQoZGF0ZTEpID09PSBmb3JtYXRZTUQoZGF0ZTIpO1xuICB9OyAvLyAtLS0gRGF0ZSBcIm1hdGhcIiB1dGlsaXR5IG1ldGhvZHMgKGZvciBCQ2FsZW5kYXIgY29tcG9uZW50IG1haW5seSkgLS0tXG5cbiAgdmFyIGZpcnN0RGF0ZU9mTW9udGggPSBmdW5jdGlvbiBmaXJzdERhdGVPZk1vbnRoKGRhdGUpIHtcbiAgICBkYXRlID0gY3JlYXRlRGF0ZShkYXRlKTtcbiAgICBkYXRlLnNldERhdGUoMSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH07XG4gIHZhciBsYXN0RGF0ZU9mTW9udGggPSBmdW5jdGlvbiBsYXN0RGF0ZU9mTW9udGgoZGF0ZSkge1xuICAgIGRhdGUgPSBjcmVhdGVEYXRlKGRhdGUpO1xuICAgIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgMSk7XG4gICAgZGF0ZS5zZXREYXRlKDApO1xuICAgIHJldHVybiBkYXRlO1xuICB9O1xuICB2YXIgb25lTW9udGhBZ28gPSBmdW5jdGlvbiBvbmVNb250aEFnbyhkYXRlKSB7XG4gICAgZGF0ZSA9IGNyZWF0ZURhdGUoZGF0ZSk7XG4gICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICAgIGRhdGUuc2V0TW9udGgobW9udGggLSAxKTtcblxuICAgIGlmIChkYXRlLmdldE1vbnRoKCkgPT09IG1vbnRoKSB7XG4gICAgICBkYXRlLnNldERhdGUoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGU7XG4gIH07XG4gIHZhciBvbmVNb250aEFoZWFkID0gZnVuY3Rpb24gb25lTW9udGhBaGVhZChkYXRlKSB7XG4gICAgZGF0ZSA9IGNyZWF0ZURhdGUoZGF0ZSk7XG4gICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICAgIGRhdGUuc2V0TW9udGgobW9udGggKyAxKTtcblxuICAgIGlmIChkYXRlLmdldE1vbnRoKCkgPT09IChtb250aCArIDIpICUgMTIpIHtcbiAgICAgIGRhdGUuc2V0RGF0ZSgwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZTtcbiAgfTtcbiAgdmFyIG9uZVllYXJBZ28gPSBmdW5jdGlvbiBvbmVZZWFyQWdvKGRhdGUpIHtcbiAgICBkYXRlID0gY3JlYXRlRGF0ZShkYXRlKTtcbiAgICB2YXIgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG4gICAgZGF0ZS5zZXRNb250aChtb250aCAtIDEyKTtcblxuICAgIGlmIChkYXRlLmdldE1vbnRoKCkgIT09IG1vbnRoKSB7XG4gICAgICBkYXRlLnNldERhdGUoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGU7XG4gIH07XG4gIHZhciBvbmVZZWFyQWhlYWQgPSBmdW5jdGlvbiBvbmVZZWFyQWhlYWQoZGF0ZSkge1xuICAgIGRhdGUgPSBjcmVhdGVEYXRlKGRhdGUpO1xuICAgIHZhciBtb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgICBkYXRlLnNldE1vbnRoKG1vbnRoICsgMTIpO1xuXG4gICAgaWYgKGRhdGUuZ2V0TW9udGgoKSAhPT0gbW9udGgpIHtcbiAgICAgIGRhdGUuc2V0RGF0ZSgwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZTtcbiAgfTtcblxuICAvKlxuICAgKiBTU1IgU2FmZSBDbGllbnQgU2lkZSBJRCBhdHRyaWJ1dGUgZ2VuZXJhdGlvblxuICAgKiBpZCdzIGNhbiBvbmx5IGJlIGdlbmVyYXRlZCBjbGllbnQgc2lkZSwgYWZ0ZXIgbW91bnQuXG4gICAqIHRoaXMuX3VpZCBpcyBub3Qgc3luY2hlZCBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50LlxuICAgKi9cbiAgLy8gQHZ1ZS9jb21wb25lbnRcbiAgdmFyIGlkTWl4aW4gPSB7XG4gICAgcHJvcHM6IHtcbiAgICAgIGlkOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvY2FsSWRfOiBudWxsXG4gICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIHNhZmVJZDogZnVuY3Rpb24gc2FmZUlkKCkge1xuICAgICAgICAvLyBDb21wdXRlZCBwcm9wZXJ0eSB0aGF0IHJldHVybnMgYSBkeW5hbWljIGZ1bmN0aW9uIGZvciBjcmVhdGluZyB0aGUgSUQuXG4gICAgICAgIC8vIFJlYWN0cyB0byBjaGFuZ2VzIGluIGJvdGggLmlkIGFuZCAubG9jYWxJZF8gQW5kIHJlZ2VucyBhIG5ldyBmdW5jdGlvblxuICAgICAgICB2YXIgaWQgPSB0aGlzLmlkIHx8IHRoaXMubG9jYWxJZF87IC8vIFdlIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhbiBvcHRpb25hbCBzdWZmaXggc3RyaW5nXG4gICAgICAgIC8vIFNvIHRoaXMgY29tcHV0ZWQgcHJvcCBsb29rcyBhbmQgd29ya3MgbGlrZSBhIG1ldGhvZCEhIVxuICAgICAgICAvLyBCdXQgYmVuZWZpdHMgZnJvbSBWdWUncyBDb21wdXRlZCBwcm9wIGNhY2hpbmdcblxuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiBmbihzdWZmaXgpIHtcbiAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdWZmaXggPSBTdHJpbmcoc3VmZml4IHx8ICcnKS5yZXBsYWNlKC9cXHMrL2csICdfJyk7XG4gICAgICAgICAgcmV0dXJuIHN1ZmZpeCA/IGlkICsgJ18nICsgc3VmZml4IDogaWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIG1vdW50ZWQgb25seSBvY2N1cnMgY2xpZW50IHNpZGVcbiAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVXBkYXRlIGRvbSB3aXRoIGF1dG8gSUQgYWZ0ZXIgZG9tIGxvYWRlZCB0byBwcmV2ZW50XG4gICAgICAgIC8vIFNTUiBoeWRyYXRpb24gZXJyb3JzLlxuICAgICAgICBfdGhpcy5sb2NhbElkXyA9IFwiX19CVklEX19cIi5jb25jYXQoX3RoaXMuX3VpZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNvbW1vbkljb25Qcm9wcyA9IHtcbiAgICB2YXJpYW50OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBmb250U2NhbGU6IHtcbiAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICBkZWZhdWx0OiAxXG4gICAgfSxcbiAgICBzY2FsZToge1xuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6IDFcbiAgICB9LFxuICAgIHJvdGF0ZToge1xuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9LFxuICAgIGZsaXBIOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGZsaXBWOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHNoaWZ0SDoge1xuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9LFxuICAgIHNoaWZ0Vjoge1xuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9XG4gIH07IC8vIEJhc2UgYXR0cmlidXRlcyBuZWVkZWQgb24gYWxsIGljb25zXG5cbiAgdmFyIGJhc2VBdHRycyA9IHtcbiAgICB3aWR0aDogJzFlbScsXG4gICAgaGVpZ2h0OiAnMWVtJyxcbiAgICB2aWV3Qm94OiAnMCAwIDIwIDIwJyxcbiAgICBmb2N1c2FibGU6ICdmYWxzZScsXG4gICAgcm9sZTogJ2ltZycsXG4gICAgYWx0OiAnaWNvbidcbiAgfTsgLy8gU2hhcmVkIHByaXZhdGUgYmFzZSBjb21wb25lbnQgdG8gcmVkdWNlIGJ1bmRsZS9ydW50aW1lIHNpemVcbiAgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQlZJY29uQmFzZSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JWSWNvbkJhc2UnLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICB9LFxuICAgICAgc3RhY2tlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfVxuICAgIH0sIGNvbW1vbkljb25Qcm9wcyksXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX3JlZikge1xuICAgICAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgICAgIHZhciBmb250U2NhbGUgPSBNYXRoLm1heCh0b0Zsb2F0KHByb3BzLmZvbnRTY2FsZSkgfHwgMSwgMCkgfHwgMTtcbiAgICAgIHZhciBzY2FsZSA9IE1hdGgubWF4KHRvRmxvYXQocHJvcHMuc2NhbGUpIHx8IDEsIDApIHx8IDE7XG4gICAgICB2YXIgcm90YXRlID0gdG9GbG9hdChwcm9wcy5yb3RhdGUpIHx8IDA7XG4gICAgICB2YXIgc2hpZnRIID0gdG9GbG9hdChwcm9wcy5zaGlmdEgpIHx8IDA7XG4gICAgICB2YXIgc2hpZnRWID0gdG9GbG9hdChwcm9wcy5zaGlmdFYpIHx8IDA7XG4gICAgICB2YXIgZmxpcEggPSBwcm9wcy5mbGlwSDtcbiAgICAgIHZhciBmbGlwViA9IHByb3BzLmZsaXBWOyAvLyBDb21wdXRlIHRoZSB0cmFuc2Zvcm1zXG4gICAgICAvLyBOb3RlIHRoYXQgb3JkZXIgaXMgaW1wb3J0YW50IGFzIFNWRyB0cmFuc2Zvcm1zIGFyZSBhcHBsaWVkIGluIG9yZGVyIGZyb21cbiAgICAgIC8vIGxlZnQgdG8gcmlnaHQgYW5kIHdlIHdhbnQgZmxpcHBpbmcvc2NhbGUgdG8gb2NjdXIgYmVmb3JlIHJvdGF0aW9uXG4gICAgICAvLyBOb3RlIHNoaWZ0aW5nIGlzIGFwcGxpZWQgc2VwYXJhdGVseVxuICAgICAgLy8gQXNzdW1lcyB0aGF0IHRoZSB2aWV3Ym94IGlzIGAwIDAgMjAgMjBgIChgMTAgMTBgIGlzIHRoZSBjZW50ZXIpXG5cbiAgICAgIHZhciBoYXNTY2FsZSA9IGZsaXBIIHx8IGZsaXBWIHx8IHNjYWxlICE9PSAxO1xuICAgICAgdmFyIGhhc1RyYW5zZm9ybXMgPSBoYXNTY2FsZSB8fCByb3RhdGU7XG4gICAgICB2YXIgaGFzU2hpZnQgPSBzaGlmdEggfHwgc2hpZnRWO1xuICAgICAgdmFyIHRyYW5zZm9ybXMgPSBbaGFzVHJhbnNmb3JtcyA/ICd0cmFuc2xhdGUoMTAgMTApJyA6IG51bGwsIGhhc1NjYWxlID8gXCJzY2FsZShcIi5jb25jYXQoKGZsaXBIID8gLTEgOiAxKSAqIHNjYWxlLCBcIiBcIikuY29uY2F0KChmbGlwViA/IC0xIDogMSkgKiBzY2FsZSwgXCIpXCIpIDogbnVsbCwgcm90YXRlID8gXCJyb3RhdGUoXCIuY29uY2F0KHJvdGF0ZSwgXCIpXCIpIDogbnVsbCwgaGFzVHJhbnNmb3JtcyA/ICd0cmFuc2xhdGUoLTEwIC0xMCknIDogbnVsbF0uZmlsdGVyKGlkZW50aXR5KTsgLy8gSGFuZGxpbmcgc3RhY2tlZCBpY29uc1xuXG4gICAgICB2YXIgaXNTdGFja2VkID0gcHJvcHMuc3RhY2tlZDtcbiAgICAgIHZhciBoYXNDb250ZW50ID0gIWlzVW5kZWZpbmVkT3JOdWxsKHByb3BzLmNvbnRlbnQpOyAvLyBXZSB3cmFwIHRoZSBjb250ZW50IGluIGEgYDxnPmAgZm9yIGhhbmRsaW5nIHRoZSB0cmFuc2Zvcm1zIChleGNlcHQgc2hpZnQpXG5cbiAgICAgIHZhciAkaW5uZXIgPSBoKCdnJywge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3Jtcy5qb2luKCcgJykgfHwgbnVsbFxuICAgICAgICB9LFxuICAgICAgICBkb21Qcm9wczogaGFzQ29udGVudCA/IHtcbiAgICAgICAgICBpbm5lckhUTUw6IHByb3BzLmNvbnRlbnQgfHwgJydcbiAgICAgICAgfSA6IHt9XG4gICAgICB9LCBjaGlsZHJlbik7IC8vIElmIG5lZWRlZCwgd2Ugd3JhcCBpbiBhbiBhZGRpdGlvbmFsIGA8Zz5gIGluIG9yZGVyIHRvIGhhbmRsZSB0aGUgc2hpZnRpbmdcblxuICAgICAgaWYgKGhhc1NoaWZ0KSB7XG4gICAgICAgICRpbm5lciA9IGgoJ2cnLCB7XG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KDIwICogc2hpZnRIIC8gMTYsIFwiIFwiKS5jb25jYXQoLTIwICogc2hpZnRWIC8gMTYsIFwiKVwiKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgWyRpbm5lcl0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaCgnc3ZnJywgYSh7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnYi1pY29uIGJpJyxcbiAgICAgICAgY2xhc3M6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJ0ZXh0LVwiLmNvbmNhdChwcm9wcy52YXJpYW50KSwgISFwcm9wcy52YXJpYW50KSxcbiAgICAgICAgYXR0cnM6IGJhc2VBdHRycyxcbiAgICAgICAgc3R5bGU6IGlzU3RhY2tlZCA/IHt9IDoge1xuICAgICAgICAgIGZvbnRTaXplOiBmb250U2NhbGUgPT09IDEgPyBudWxsIDogXCJcIi5jb25jYXQoZm9udFNjYWxlICogMTAwLCBcIiVcIilcbiAgICAgICAgfVxuICAgICAgfSwgLy8gTWVyZ2UgaW4gdXNlciBzdXBwbGllZCBkYXRhXG4gICAgICBkYXRhLCAvLyBJZiBpY29uIGlzIHN0YWNrZWQsIG51bGwgb3V0IHNvbWUgYXR0cnNcbiAgICAgIGlzU3RhY2tlZCA/IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICB3aWR0aDogbnVsbCxcbiAgICAgICAgICBoZWlnaHQ6IG51bGwsXG4gICAgICAgICAgcm9sZTogbnVsbCxcbiAgICAgICAgICBhbHQ6IG51bGxcbiAgICAgICAgfVxuICAgICAgfSA6IHt9LCAvLyBUaGVzZSBjYW5ub3QgYmUgb3ZlcnJpZGRlbiBieSB1c2Vyc1xuICAgICAge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHhtbG5zOiBpc1N0YWNrZWQgPyBudWxsIDogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICAgICAgICBmaWxsOiAnY3VycmVudENvbG9yJ1xuICAgICAgICB9XG4gICAgICB9KSwgWyRpbm5lcl0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEljb24gY29tcG9uZW50IGdlbmVyYXRvciBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWNvbiBuYW1lIChtaW51cyB0aGUgbGVhZGluZyBgQkljb25gKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmF3IGBpbm5lckhUTUxgIGZvciBTVkdcbiAgICogQHJldHVybiB7VnVlQ29tcG9uZW50fVxuICAgKi9cblxuICB2YXIgbWFrZUljb24gPSBmdW5jdGlvbiBtYWtlSWNvbihuYW1lLCBjb250ZW50KSB7XG4gICAgLy8gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbiB3ZSBwcmUtY29tcHV0ZSBzb21lIHZhbHVlcywgc28gdGhhdFxuICAgIC8vIHRoZXkgYXJlIG5vdCBjb21wdXRlZCBvbiBlYWNoIHJlbmRlciBvZiB0aGUgaWNvbiBjb21wb25lbnRcbiAgICB2YXIgaWNvbk5hbWUgPSBcIkJJY29uXCIuY29uY2F0KHBhc2NhbENhc2UobmFtZSkpO1xuICAgIHZhciBpY29uTmFtZUNsYXNzID0gXCJiaS1cIi5jb25jYXQoa2ViYWJDYXNlKG5hbWUpKTtcbiAgICB2YXIgc3ZnQ29udGVudCA9IHRyaW0oY29udGVudCB8fCAnJyk7IC8vIFJldHVybiB0aGUgaWNvbiBjb21wb25lbnQgZGVmaW5pdGlvblxuXG4gICAgcmV0dXJuIChcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIFZ1ZS5leHRlbmQoe1xuICAgICAgICBuYW1lOiBpY29uTmFtZSxcbiAgICAgICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICAgICAgcHJvcHM6IF9vYmplY3RTcHJlYWQyKHt9LCBjb21tb25JY29uUHJvcHMsIHtcbiAgICAgICAgICBzdGFja2VkOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICAgICAgICByZXR1cm4gaChCVkljb25CYXNlLCBhKGRhdGEsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBpY29uTmFtZUNsYXNzLFxuICAgICAgICAgICAgcHJvcHM6IF9vYmplY3RTcHJlYWQyKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICBjb250ZW50OiBzdmdDb250ZW50XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9O1xuXG4gIC8vIC0tLSBCRUdJTiBBVVRPLUdFTkVSQVRFRCBGSUxFIC0tLVxuXG4gIHZhciBCSWNvbkJsYW5rID1cbiAgLyojX19QVVJFX18qL1xuICBtYWtlSWNvbignQmxhbmsnLCAnJyk7IC8vIC0tLSBCb290c3RyYXAgSWNvbnMgLS0tXG4gIHZhciBCSWNvbkNhbGVuZGFyID1cbiAgLyojX19QVVJFX18qL1xuICBtYWtlSWNvbignQ2FsZW5kYXInLCAnPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNMTYgMkg0YTIgMiAwIDAwLTIgMnYxMmEyIDIgMCAwMDIgMmgxMmEyIDIgMCAwMDItMlY0YTIgMiAwIDAwLTItMnpNMyA1Ljg1N0MzIDUuMzg0IDMuNDQ4IDUgNCA1aDEyYy41NTIgMCAxIC4zODQgMSAuODU3djEwLjI4NmMwIC40NzMtLjQ0OC44NTctMSAuODU3SDRjLS41NTIgMC0xLS4zODQtMS0uODU3VjUuODU3elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIi8+PHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNOC41IDlhMSAxIDAgMTAwLTIgMSAxIDAgMDAwIDJ6bTMgMGExIDEgMCAxMDAtMiAxIDEgMCAwMDAgMnptMyAwYTEgMSAwIDEwMC0yIDEgMSAwIDAwMCAyem0tOSAzYTEgMSAwIDEwMC0yIDEgMSAwIDAwMCAyem0zIDBhMSAxIDAgMTAwLTIgMSAxIDAgMDAwIDJ6bTMgMGExIDEgMCAxMDAtMiAxIDEgMCAwMDAgMnptMyAwYTEgMSAwIDEwMC0yIDEgMSAwIDAwMCAyem0tOSAzYTEgMSAwIDEwMC0yIDEgMSAwIDAwMCAyem0zIDBhMSAxIDAgMTAwLTIgMSAxIDAgMDAwIDJ6bTMgMGExIDEgMCAxMDAtMiAxIDEgMCAwMDAgMnpcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIvPicpO1xuICB2YXIgQkljb25DYWxlbmRhckZpbGwgPVxuICAvKiNfX1BVUkVfXyovXG4gIG1ha2VJY29uKCdDYWxlbmRhckZpbGwnLCAnPHBhdGggZD1cIk0yIDRhMiAyIDAgMDEyLTJoMTJhMiAyIDAgMDEyIDJIMnpcIi8+PHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNMiA1aDE2djExYTIgMiAwIDAxLTIgMkg0YTIgMiAwIDAxLTItMlY1em02LjUgNGExIDEgMCAxMDAtMiAxIDEgMCAwMDAgMnptNC0xYTEgMSAwIDExLTIgMCAxIDEgMCAwMTIgMHptMiAxYTEgMSAwIDEwMC0yIDEgMSAwIDAwMCAyem0tOCAyYTEgMSAwIDExLTIgMCAxIDEgMCAwMTIgMHptMiAxYTEgMSAwIDEwMC0yIDEgMSAwIDAwMCAyem00LTFhMSAxIDAgMTEtMiAwIDEgMSAwIDAxMiAwem0yIDFhMSAxIDAgMTAwLTIgMSAxIDAgMDAwIDJ6bS04IDJhMSAxIDAgMTEtMiAwIDEgMSAwIDAxMiAwem0yIDFhMSAxIDAgMTAwLTIgMSAxIDAgMDAwIDJ6bTQtMWExIDEgMCAxMS0yIDAgMSAxIDAgMDEyIDB6XCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiLz4nKTtcbiAgdmFyIEJJY29uQ2hldnJvbkxlZnQgPVxuICAvKiNfX1BVUkVfXyovXG4gIG1ha2VJY29uKCdDaGV2cm9uTGVmdCcsICc8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk0xMy4zNTQgMy42NDZhLjUuNSAwIDAxMCAuNzA4TDcuNzA3IDEwbDUuNjQ3IDUuNjQ2YS41LjUgMCAwMS0uNzA4LjcwOGwtNi02YS41LjUgMCAwMTAtLjcwOGw2LTZhLjUuNSAwIDAxLjcwOCAwelwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIi8+Jyk7XG4gIHZhciBCSWNvbkNpcmNsZUZpbGwgPVxuICAvKiNfX1BVUkVfXyovXG4gIG1ha2VJY29uKCdDaXJjbGVGaWxsJywgJzxjaXJjbGUgY3g9XCIxMFwiIGN5PVwiMTBcIiByPVwiOFwiLz4nKTtcbiAgdmFyIEJJY29uRGFzaCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgbWFrZUljb24oJ0Rhc2gnLCAnPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNS41IDEwYS41LjUgMCAwMS41LS41aDhhLjUuNSAwIDAxMCAxSDZhLjUuNSAwIDAxLS41LS41elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIi8+Jyk7XG4gIHZhciBCSWNvblBsdXMgPVxuICAvKiNfX1BVUkVfXyovXG4gIG1ha2VJY29uKCdQbHVzJywgJzxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTEwIDUuNWEuNS41IDAgMDEuNS41djRhLjUuNSAwIDAxLS41LjVINmEuNS41IDAgMDEwLTFoMy41VjZhLjUuNSAwIDAxLjUtLjV6XCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiLz48cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk05LjUgMTBhLjUuNSAwIDAxLjUtLjVoNGEuNS41IDAgMDEwIDFoLTMuNVYxNGEuNS41IDAgMDEtMSAwdi00elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIi8+Jyk7XG4gICAvLyAtLS0gRU5EIEFVVE8tR0VORVJBVEVEIEZJTEUgLS0tXG5cbiAgdmFyIEJJY29uc3RhY2sgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCSWNvbnN0YWNrJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBfb2JqZWN0U3ByZWFkMih7fSwgY29tbW9uSWNvblByb3BzKSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICAgICAgcmV0dXJuIGgoQlZJY29uQmFzZSwgYShkYXRhLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnYi1pY29uc3RhY2snLFxuICAgICAgICBwcm9wczogX29iamVjdFNwcmVhZDIoe30sIHByb3BzLCB7XG4gICAgICAgICAgc3RhY2tlZDogZmFsc2VcbiAgICAgICAgfSlcbiAgICAgIH0pLCBjaGlsZHJlbik7XG4gICAgfVxuICB9KTtcblxuICB2YXIgTkFNRSQ2ID0gJ0JDYWxlbmRhcic7IC8vIEtleSBDb2Rlc1xuXG4gIHZhciBVUCA9IEtFWV9DT0RFUy5VUCxcbiAgICAgIERPV04gPSBLRVlfQ09ERVMuRE9XTixcbiAgICAgIExFRlQgPSBLRVlfQ09ERVMuTEVGVCxcbiAgICAgIFJJR0hUID0gS0VZX0NPREVTLlJJR0hULFxuICAgICAgUEFHRVVQID0gS0VZX0NPREVTLlBBR0VVUCxcbiAgICAgIFBBR0VET1dOID0gS0VZX0NPREVTLlBBR0VET1dOLFxuICAgICAgSE9NRSA9IEtFWV9DT0RFUy5IT01FLFxuICAgICAgRU5EID0gS0VZX0NPREVTLkVORCxcbiAgICAgIEVOVEVSID0gS0VZX0NPREVTLkVOVEVSLFxuICAgICAgU1BBQ0UgPSBLRVlfQ09ERVMuU1BBQ0U7IC8vIExhbmd1YWdlcyB0aGF0IGFyZSBSVExcblxuICB2YXIgUlRMX0xBTkdTID0gWydhcicsICdheicsICdja2InLCAnZmEnLCAnaGUnLCAna3MnLCAnbHJjJywgJ216bicsICdwcycsICdzZCcsICd0ZScsICd1ZycsICd1cicsICd5aSddLm1hcChmdW5jdGlvbiAobG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS50b0xvd2VyQ2FzZSgpO1xuICB9KTsgLy8gLS0tIEhlbHBlciB1dGlsaXRpZXMgLS0tXG5cbiAgdmFyIGlzTG9jYWxlUlRMID0gZnVuY3Rpb24gaXNMb2NhbGVSVEwobG9jYWxlKSB7XG4gICAgLy8gRGV0ZXJtaW5lcyBpZiB0aGUgbG9jYWxlIGlzIFJUTCAob25seSBzaW5nbGUgbG9jYWxlIHN1cHBvcnRlZClcbiAgICB2YXIgcGFydHMgPSB0b1N0cmluZyQxKGxvY2FsZSkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tdS0uKy8sICcnKS5zcGxpdCgnLScpO1xuICAgIHZhciBsb2NhbGUxID0gcGFydHMuc2xpY2UoMCwgMikuam9pbignLScpO1xuICAgIHZhciBsb2NhbGUyID0gcGFydHNbMF07XG4gICAgcmV0dXJuIGFycmF5SW5jbHVkZXMoUlRMX0xBTkdTLCBsb2NhbGUxKSB8fCBhcnJheUluY2x1ZGVzKFJUTF9MQU5HUywgbG9jYWxlMik7XG4gIH07IC8vIC0tLSBCQ2FsZW5kYXIgY29tcG9uZW50IC0tLVxuICAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCQ2FsZW5kYXIgPSBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiBOQU1FJDYsXG4gICAgbWl4aW5zOiBbaWRNaXhpbiwgbm9ybWFsaXplU2xvdE1peGluXSxcbiAgICBtb2RlbDoge1xuICAgICAgLy8gRXZlbiB0aG91Z2ggdGhpcyBpcyB0aGUgZGVmYXVsdCB0aGF0IFZ1ZSBhc3N1bWVzLCB3ZSBuZWVkXG4gICAgICAvLyB0byBhZGQgaXQgZm9yIHRoZSBkb2NzIHRvIHJlZmxlY3QgdGhhdCB0aGlzIGlzIHRoZSBtb2RlbFxuICAgICAgLy8gQW5kIGFsc28gZm9yIHNvbWUgdmFsaWRhdGlvbiBsaWJyYXJpZXMgdG8gd29ya1xuICAgICAgcHJvcDogJ3ZhbHVlJyxcbiAgICAgIGV2ZW50OiAnaW5wdXQnXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogW1N0cmluZywgRGF0ZV0gLy8gZGVmYXVsdDogbnVsbFxuXG4gICAgICB9LFxuICAgICAgdmFsdWVBc0RhdGU6IHtcbiAgICAgICAgLy8gQWx3YXlzIHJldHVybiB0aGUgYHYtbW9kZWxgIHZhbHVlIGFzIGEgZGF0ZSBvYmplY3RcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBkaXNhYmxlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHJlYWRvbmx5OiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgbWluOiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIERhdGVdIC8vIGRlZmF1bHQ6IG51bGxcblxuICAgICAgfSxcbiAgICAgIG1heDoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBEYXRlXSAvLyBkZWZhdWx0OiBudWxsXG5cbiAgICAgIH0sXG4gICAgICBkYXRlRGlzYWJsZWRGbjoge1xuICAgICAgICB0eXBlOiBGdW5jdGlvbiAvLyBkZWZhdWx0OiBudWxsXG5cbiAgICAgIH0sXG4gICAgICBzdGFydFdlZWtkYXk6IHtcbiAgICAgICAgLy8gYDBgIChTdW5kYXkpLCBgMWAgKE1vbmRheSksIC4uLiBgNmAgKFNhdHVyZGF5KVxuICAgICAgICAvLyBEYXkgb2Ygd2VlayB0byBzdGFydCBjYWxlbmRhciBvblxuICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICBkZWZhdWx0OiAwXG4gICAgICB9LFxuICAgICAgbG9jYWxlOiB7XG4gICAgICAgIC8vIExvY2FsZShzKSB0byB1c2VcbiAgICAgICAgLy8gRGVmYXVsdCBpcyB0byB1c2UgcGFnZS9icm93c2VyIGRlZmF1bHQgc2V0dGluZ1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0gLy8gZGVmYXVsdDogbnVsbFxuXG4gICAgICB9LFxuICAgICAgZGlyZWN0aW9uOiB7XG4gICAgICAgIC8vICdsdHInLCAncnRsJywgb3IgYG51bGxgIChmb3IgYXV0byBkZXRlY3QpXG4gICAgICAgIHR5cGU6IFN0cmluZyAvLyBkZWZhdWx0OiBudWxsXG5cbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZFZhcmlhbnQ6IHtcbiAgICAgICAgLy8gVmFyaWFudCBjb2xvciB0byB1c2UgZm9yIHRoZSBzZWxlY3RlZCBkYXRlXG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ3ByaW1hcnknXG4gICAgICB9LFxuICAgICAgdG9kYXlWYXJpYW50OiB7XG4gICAgICAgIC8vIFZhcmlhbnQgY29sb3IgdG8gdXNlIGZvciB0b2RheSdzIGRhdGUgKGRlZmF1bHRzIHRvIGB2YXJpYW50YClcbiAgICAgICAgdHlwZTogU3RyaW5nIC8vIGRlZmF1bHQ6IG51bGxcblxuICAgICAgfSxcbiAgICAgIG5vSGlnaGxpZ2h0VG9kYXk6IHtcbiAgICAgICAgLy8gRGlzYWJsZSBoaWdobGlnaHRpbmcgdG9kYXkncyBkYXRlXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZGF0ZUluZm9Gbjoge1xuICAgICAgICAvLyBGdW5jdGlvbiB0byBzZXQgYSBjbGFzcyBvZiAoY2xhc3Nlcykgb24gdGhlIGRhdGUgY2VsbFxuICAgICAgICAvLyBpZiBwYXNzZWQgYSBzdHJpbmcgb3IgYW4gYXJyYXlcbiAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgLy8gICBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhbiBvYmplY3QsIGxvb2sgZm9yIGNsYXNzIHByb3AgZm9yIGNsYXNzZXMsXG4gICAgICAgIC8vICAgYW5kIG90aGVyIHByb3BzIGZvciBoYW5kbGluZyBldmVudHMvZGV0YWlscy9kZXNjcmlwdGlvbnNcbiAgICAgICAgdHlwZTogRnVuY3Rpb24gLy8gZGVmYXVsdDogbnVsbFxuXG4gICAgICB9LFxuICAgICAgd2lkdGg6IHtcbiAgICAgICAgLy8gSGFzIG5vIGVmZmVjdCBpZiBwcm9wIGBibG9ja2AgaXMgc2V0XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJzI3MHB4J1xuICAgICAgfSxcbiAgICAgIGJsb2NrOiB7XG4gICAgICAgIC8vIE1ha2VzIGNhbGVuZGFyIHRoZSBmdWxsIHdpZHRoIG9mIGl0cyBwYXJlbnQgY29udGFpbmVyXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgaGlkZUhlYWRlcjoge1xuICAgICAgICAvLyBXaGVuIHRydWUgbWFrZXMgdGhlIHNlbGVjdGVkIGRhdGUgaGVhZGVyIGBzci1vbmx5YFxuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGhpZGRlbjoge1xuICAgICAgICAvLyBXaGVuIGB0cnVlYCwgcmVuZGVycyBhIGNvbW1lbnQgbm9kZSwgYnV0IGtlZXBzIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgYWN0aXZlXG4gICAgICAgIC8vIE1haW5seSBmb3IgPGItZm9ybS1kYXRlPiwgc28gdGhhdCB3ZSBjYW4gZ2V0IHRoZSBjb21wb25lbnQncyB2YWx1ZSBhbmQgbG9jYWxlXG4gICAgICAgIC8vIEJ1dCB3ZSBtaWdodCBqdXN0IHVzZSBzZXBhcmF0ZSBkYXRlIGZvcm1hdHRlcnMsIHVzaW5nIHRoZSByZXNvbHZlZCBsb2NhbGVcbiAgICAgICAgLy8gKGFkanVzdGVkIGZvciB0aGUgZ3JlZ29yaWFuIGNhbGVuZGFyKVxuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGFyaWFDb250cm9sczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcgLy8gZGVmYXVsdDogbnVsbFxuXG4gICAgICB9LFxuICAgICAgcm9sZURlc2NyaXB0aW9uOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyAvLyBkZWZhdWx0OiBudWxsXG5cbiAgICAgIH0sXG4gICAgICAvLyBMYWJlbHMgZm9yIGJ1dHRvbnMgYW5kIGtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAgbGFiZWxQcmV2WWVhcjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSQ2LCAnbGFiZWxQcmV2WWVhcicpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGFiZWxQcmV2TW9udGg6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkNiwgJ2xhYmVsUHJldk1vbnRoJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsYWJlbEN1cnJlbnRNb250aDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSQ2LCAnbGFiZWxDdXJyZW50TW9udGgnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxhYmVsTmV4dE1vbnRoOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJDYsICdsYWJlbE5leHRNb250aCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGFiZWxOZXh0WWVhcjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSQ2LCAnbGFiZWxOZXh0WWVhcicpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGFiZWxUb2RheToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSQ2LCAnbGFiZWxUb2RheScpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGFiZWxTZWxlY3RlZDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSQ2LCAnbGFiZWxTZWxlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGFiZWxOb0RhdGVTZWxlY3RlZDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSQ2LCAnbGFiZWxOb0RhdGVTZWxlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGFiZWxDYWxlbmRhcjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSQ2LCAnbGFiZWxDYWxlbmRhcicpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGFiZWxOYXY6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkNiwgJ2xhYmVsTmF2Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsYWJlbEhlbHA6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkNiwgJ2xhYmVsSGVscCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gZm9ybWF0WU1EKHRoaXMudmFsdWUpIHx8ICcnO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gU2VsZWN0ZWQgZGF0ZVxuICAgICAgICBzZWxlY3RlZFlNRDogc2VsZWN0ZWQsXG4gICAgICAgIC8vIERhdGUgaW4gY2FsZW5kYXIgZ3JpZCB0aGF0IGhhcyBgdGFiaW5kZXhgIG9mIGAwYFxuICAgICAgICBhY3RpdmVZTUQ6IHNlbGVjdGVkIHx8IGZvcm1hdFlNRCh0aGlzLmdldFRvZGF5KCkpLFxuICAgICAgICAvLyBXaWxsIGJlIHRydWUgaWYgdGhlIGNhbGVuZGFyIGdyaWQgaGFzL2NvbnRhaW5zIGZvY3VzXG4gICAgICAgIGdyaWRIYXNGb2N1czogZmFsc2UsXG4gICAgICAgIC8vIEZsYWcgdG8gZW5hYmxlIHRoZSBgYXJpYS1saXZlYCByZWdpb24ocykgYWZ0ZXIgbW91bnRcbiAgICAgICAgLy8gdG8gcHJldmVudCBzY3JlZW4gcmVhZGVyIFwib3V0YnVyc3RzXCIgd2hlbiBtb3VudGluZ1xuICAgICAgICBpc0xpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIC8vIFRPRE86IFVzZSBjb21wdXRlZCBwcm9wcyB0byBjb252ZXJ0IGBZWVlZLU1NLUREYCB0byBgRGF0ZWAgb2JqZWN0XG4gICAgICBzZWxlY3RlZERhdGU6IGZ1bmN0aW9uIHNlbGVjdGVkRGF0ZSgpIHtcbiAgICAgICAgLy8gU2VsZWN0ZWQgYXMgYSBgRGF0ZWAgb2JqZWN0XG4gICAgICAgIHJldHVybiBwYXJzZVlNRCh0aGlzLnNlbGVjdGVkWU1EKTtcbiAgICAgIH0sXG4gICAgICBhY3RpdmVEYXRlOiBmdW5jdGlvbiBhY3RpdmVEYXRlKCkge1xuICAgICAgICAvLyBBY3RpdmUgYXMgYSBgRGF0ZWAgb2JqZWN0XG4gICAgICAgIHJldHVybiBwYXJzZVlNRCh0aGlzLmFjdGl2ZVlNRCk7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRNaW46IGZ1bmN0aW9uIGNvbXB1dGVkTWluKCkge1xuICAgICAgICByZXR1cm4gcGFyc2VZTUQodGhpcy5taW4pO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkTWF4OiBmdW5jdGlvbiBjb21wdXRlZE1heCgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlWU1EKHRoaXMubWF4KTtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZFdlZWtTdGFydHM6IGZ1bmN0aW9uIGNvbXB1dGVkV2Vla1N0YXJ0cygpIHtcbiAgICAgICAgLy8gYHN0YXJ0V2Vla2RheWAgaXMgYSBwcm9wIChjb25zdHJhaW5lZCB0byBgMGAgdGhyb3VnaCBgNmApXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0b0ludGVnZXIodGhpcy5zdGFydFdlZWtkYXkpIHx8IDAsIDApICUgNztcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZExvY2FsZTogZnVuY3Rpb24gY29tcHV0ZWRMb2NhbGUoKSB7XG4gICAgICAgIC8vIFJldHVybnMgdGhlIHJlc29sdmVkIGxvY2FsZSB1c2VkIGJ5IHRoZSBjYWxlbmRhclxuICAgICAgICByZXR1cm4gcmVzb2x2ZUxvY2FsZShjb25jYXQodGhpcy5sb2NhbGUpLmZpbHRlcihpZGVudGl0eSksICdncmVnb3J5Jyk7XG4gICAgICB9LFxuICAgICAgY2FsZW5kYXJMb2NhbGU6IGZ1bmN0aW9uIGNhbGVuZGFyTG9jYWxlKCkge1xuICAgICAgICAvLyBUaGlzIGxvY2FsZSBlbmZvcmNlcyB0aGUgZ3JlZ29yaWFuIGNhbGVuZGFyIChmb3IgdXNlIGluIGZvcm1hdHRlciBmdW5jdGlvbnMpXG4gICAgICAgIC8vIE5lZWRlZCBiZWNhdXNlIElFIDExIHJlc29sdmVzIGBhci1JUmAgYXMgaXNsYW1pYy1jaXZpbCBjYWxlbmRhclxuICAgICAgICAvLyBhbmQgSUUgMTEgKGFuZCBzb21lIG90aGVyIGJyb3dzZXJzKSBkbyBub3Qgc3VwcG9ydCB0aGUgYGNhbGVuZGFyYCBvcHRpb25cbiAgICAgICAgLy8gQW5kIHdlIGN1cnJlbnRseSBvbmx5IHN1cHBvcnQgdGhlIGdyZWdvcmlhbiBjYWxlbmRhclxuICAgICAgICB2YXIgZm10ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5jb21wdXRlZExvY2FsZSwge1xuICAgICAgICAgIGNhbGVuZGFyOiAnZ3JlZ29yeSdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjYWxlbmRhciA9IGZtdC5yZXNvbHZlZE9wdGlvbnMoKS5jYWxlbmRhcjtcbiAgICAgICAgdmFyIGxvY2FsZSA9IGZtdC5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGU7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogbWFpbmx5IGZvciBJRSAxMSBhbmQgYSBmZXcgb3RoZXIgYnJvd3NlcnMsIGhhcmQgdG8gdGVzdCBpbiBKU0RPTSAqL1xuXG4gICAgICAgIGlmIChjYWxlbmRhciAhPT0gJ2dyZWdvcnknKSB7XG4gICAgICAgICAgLy8gRW5zdXJlIHRoZSBsb2NhbGUgcmVxdWVzdHMgdGhlIGdyZWdvcmlhbiBjYWxlbmRhclxuICAgICAgICAgIC8vIE1haW5seSBmb3IgSUUgMTEsIGFuZCBjdXJyZW50bHkgd2UgY2FuJ3QgaGFuZGxlIG5vbi1ncmVnb3JpYW4gY2FsZW5kYXJzXG4gICAgICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIGFsd2F5cyByZXR1cm4gdGhpcyB2YWx1ZT9cbiAgICAgICAgICBsb2NhbGUgPSBsb2NhbGUucmVwbGFjZSgvLXUtLiskL2ksICcnKS5jb25jYXQoJy11LWNhLWdyZWdvcnknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICB9LFxuICAgICAgY2FsZW5kYXJZZWFyOiBmdW5jdGlvbiBjYWxlbmRhclllYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgIH0sXG4gICAgICBjYWxlbmRhck1vbnRoOiBmdW5jdGlvbiBjYWxlbmRhck1vbnRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVEYXRlLmdldE1vbnRoKCk7XG4gICAgICB9LFxuICAgICAgY2FsZW5kYXJGaXJzdERheTogZnVuY3Rpb24gY2FsZW5kYXJGaXJzdERheSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURhdGUodGhpcy5jYWxlbmRhclllYXIsIHRoaXMuY2FsZW5kYXJNb250aCwgMSk7XG4gICAgICB9LFxuICAgICAgY2FsZW5kYXJEYXlzSW5Nb250aDogZnVuY3Rpb24gY2FsZW5kYXJEYXlzSW5Nb250aCgpIHtcbiAgICAgICAgLy8gV2UgY3JlYXRlIGEgbmV3IGRhdGUgYXMgdG8gbm90IG11dGF0ZSB0aGUgb3JpZ2luYWxcbiAgICAgICAgdmFyIGRhdGUgPSBjcmVhdGVEYXRlKHRoaXMuY2FsZW5kYXJGaXJzdERheSk7XG4gICAgICAgIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgMSwgMCk7XG4gICAgICAgIHJldHVybiBkYXRlLmdldERhdGUoKTtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZFZhcmlhbnQ6IGZ1bmN0aW9uIGNvbXB1dGVkVmFyaWFudCgpIHtcbiAgICAgICAgcmV0dXJuIFwiYnRuLVwiLmNvbmNhdCh0aGlzLnNlbGVjdGVkVmFyaWFudCB8fCAncHJpbWFyeScpO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkVG9kYXlWYXJpYW50OiBmdW5jdGlvbiBjb21wdXRlZFRvZGF5VmFyaWFudCgpIHtcbiAgICAgICAgcmV0dXJuIFwiYnRuLW91dGxpbmUtXCIuY29uY2F0KHRoaXMudG9kYXlWYXJpYW50IHx8IHRoaXMuc2VsZWN0ZWRWYXJpYW50IHx8ICdwcmltYXJ5Jyk7XG4gICAgICB9LFxuICAgICAgaXNSVEw6IGZ1bmN0aW9uIGlzUlRMKCkge1xuICAgICAgICAvLyBgdHJ1ZWAgaWYgdGhlIGxhbmd1YWdlIHJlcXVlc3RlZCBpcyBSVExcbiAgICAgICAgdmFyIGRpciA9IHRvU3RyaW5nJDEodGhpcy5kaXJlY3Rpb24pLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKGRpciA9PT0gJ3J0bCcpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRpciA9PT0gJ2x0cicpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0xvY2FsZVJUTCh0aGlzLmNvbXB1dGVkTG9jYWxlKTtcbiAgICAgIH0sXG4gICAgICBjb250ZXh0OiBmdW5jdGlvbiBjb250ZXh0KCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRZTUQgPSB0aGlzLnNlbGVjdGVkWU1EO1xuICAgICAgICB2YXIgc2VsZWN0ZWREYXRlID0gcGFyc2VZTUQoc2VsZWN0ZWRZTUQpO1xuICAgICAgICB2YXIgYWN0aXZlWU1EID0gdGhpcy5hY3RpdmVZTUQ7XG4gICAgICAgIHZhciBhY3RpdmVEYXRlID0gcGFyc2VZTUQoYWN0aXZlWU1EKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAvLyBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgYHYtbW9kZWxgXG4gICAgICAgICAgc2VsZWN0ZWRZTUQ6IHNlbGVjdGVkWU1ELFxuICAgICAgICAgIHNlbGVjdGVkRGF0ZTogc2VsZWN0ZWREYXRlLFxuICAgICAgICAgIHNlbGVjdGVkRm9ybWF0dGVkOiBzZWxlY3RlZERhdGUgPyB0aGlzLmZvcm1hdERhdGVTdHJpbmcoc2VsZWN0ZWREYXRlKSA6IHRoaXMubGFiZWxOb0RhdGVTZWxlY3RlZCxcbiAgICAgICAgICAvLyBXaGljaCBkYXRlIGNlbGwgaXMgY29uc2lkZXJlZCBhY3RpdmUgZHVlIHRvIG5hdmlnYXRpb25cbiAgICAgICAgICBhY3RpdmVZTUQ6IGFjdGl2ZVlNRCxcbiAgICAgICAgICBhY3RpdmVEYXRlOiBhY3RpdmVEYXRlLFxuICAgICAgICAgIGFjdGl2ZUZvcm1hdHRlZDogYWN0aXZlRGF0ZSA/IHRoaXMuZm9ybWF0RGF0ZVN0cmluZyhhY3RpdmVEYXRlKSA6ICcnLFxuICAgICAgICAgIC8vIGB0cnVlYCBpZiB0aGUgZGF0ZSBpcyBkaXNhYmxlZCAod2hlbiB1c2luZyBrZXlib2FyZCBuYXZpZ2F0aW9uKVxuICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmRhdGVEaXNhYmxlZChhY3RpdmVEYXRlKSxcbiAgICAgICAgICAvLyBMb2NhbGVzIHVzZWQgaW4gZm9ybWF0dGluZyBkYXRlc1xuICAgICAgICAgIGxvY2FsZTogdGhpcy5jb21wdXRlZExvY2FsZSxcbiAgICAgICAgICBjYWxlbmRhckxvY2FsZTogdGhpcy5jYWxlbmRhckxvY2FsZSxcbiAgICAgICAgICBydGw6IHRoaXMuaXNSVExcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICAvLyBDb21wdXRlZCBwcm9wcyB0aGF0IHJldHVybiBhIGZ1bmN0aW9uIHJlZmVyZW5jZVxuICAgICAgZGF0ZU91dE9mUmFuZ2U6IGZ1bmN0aW9uIGRhdGVPdXRPZlJhbmdlKCkge1xuICAgICAgICAvLyBDaGVjayB3ZXRoZXIgYSBkYXRlIGlzIHdpdGhpbiB0aGUgbWluL21heCByYW5nZVxuICAgICAgICAvLyByZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHJlZiBpZiB0aGUgcG9wcyBjaGFuZ2VcbiAgICAgICAgLy8gV2UgZG8gdGhpcyBhcyB3ZSBuZWVkIHRvIHRyaWdnZXIgdGhlIGNhbGVuZGFyIGNvbXB1dGVkIHByb3BcbiAgICAgICAgLy8gdG8gdXBkYXRlIHdoZW4gdGhlc2UgcHJvcHMgdXBkYXRlXG4gICAgICAgIHZhciBtaW4gPSB0aGlzLmNvbXB1dGVkTWluO1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5jb21wdXRlZE1heDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgLy8gSGFuZGxlIGJvdGggYFlZWVktTU0tRERgIGFuZCBgRGF0ZWAgb2JqZWN0c1xuICAgICAgICAgIGRhdGUgPSBwYXJzZVlNRChkYXRlKTtcbiAgICAgICAgICByZXR1cm4gbWluICYmIGRhdGUgPCBtaW4gfHwgbWF4ICYmIGRhdGUgPiBtYXg7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGF0ZURpc2FibGVkOiBmdW5jdGlvbiBkYXRlRGlzYWJsZWQoKSB7XG4gICAgICAgIC8vIFJldHVybnMgYSBmdW5jdGlvbiBmb3IgdmFsaWRhdGluZyBpZiBhIGRhdGUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgIC8vIFdlIGdyYWIgdGhpcyB2YXJpYWJsZXMgZmlyc3QgdG8gZW5zdXJlIGEgbmV3IGZ1bmN0aW9uIHJlZlxuICAgICAgICAvLyBpcyBnZW5lcmF0ZWQgd2hlbiB0aGUgcHJvcHMgdmFsdWUgY2hhbmdlc1xuICAgICAgICAvLyBXZSBkbyB0aGlzIGFzIHdlIG5lZWQgdG8gdHJpZ2dlciB0aGUgY2FsZW5kYXIgY29tcHV0ZWQgcHJvcFxuICAgICAgICAvLyB0byB1cGRhdGUgd2hlbiB0aGVzZSBwcm9wcyB1cGRhdGVcbiAgICAgICAgdmFyIHJhbmdlRm4gPSB0aGlzLmRhdGVPdXRPZlJhbmdlO1xuICAgICAgICB2YXIgZGlzYWJsZWRGbiA9IGlzRnVuY3Rpb24odGhpcy5kYXRlRGlzYWJsZWRGbikgPyB0aGlzLmRhdGVEaXNhYmxlZEZuIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTsgLy8gUmV0dXJuIHRoZSBmdW5jdGlvbiByZWZcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAvLyBIYW5kbGUgYm90aCBgWVlZWS1NTS1ERGAgYW5kIGBEYXRlYCBvYmplY3RzXG4gICAgICAgICAgZGF0ZSA9IHBhcnNlWU1EKGRhdGUpO1xuICAgICAgICAgIHZhciB5bWQgPSBmb3JtYXRZTUQoZGF0ZSk7XG4gICAgICAgICAgcmV0dXJuICEhKHJhbmdlRm4oZGF0ZSkgfHwgZGlzYWJsZWRGbih5bWQsIGRhdGUpKTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICAvLyBDb21wdXRlZCBwcm9wcyB0aGF0IHJldHVybiBkYXRlIGZvcm1hdHRlciBmdW5jdGlvbnNcbiAgICAgIGZvcm1hdERhdGVTdHJpbmc6IGZ1bmN0aW9uIGZvcm1hdERhdGVTdHJpbmcoKSB7XG4gICAgICAgIC8vIFJldHVybnMgYSBkYXRlIGZvcm1hdHRlciBmdW5jdGlvblxuICAgICAgICByZXR1cm4gY3JlYXRlRGF0ZUZvcm1hdHRlcih0aGlzLmNhbGVuZGFyTG9jYWxlLCB7XG4gICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICAgIG1vbnRoOiAnbG9uZycsXG4gICAgICAgICAgZGF5OiAnbnVtZXJpYycsXG4gICAgICAgICAgd2Vla2RheTogJ2xvbmcnLFxuICAgICAgICAgIGNhbGVuZGFyOiAnZ3JlZ29yeSdcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZm9ybWF0WWVhck1vbnRoOiBmdW5jdGlvbiBmb3JtYXRZZWFyTW9udGgoKSB7XG4gICAgICAgIC8vIFJldHVybnMgYSBkYXRlIGZvcm1hdHRlciBmdW5jdGlvblxuICAgICAgICByZXR1cm4gY3JlYXRlRGF0ZUZvcm1hdHRlcih0aGlzLmNhbGVuZGFyTG9jYWxlLCB7XG4gICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICAgIG1vbnRoOiAnbG9uZycsXG4gICAgICAgICAgY2FsZW5kYXI6ICdncmVnb3J5J1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmb3JtYXRXZWVrZGF5TmFtZTogZnVuY3Rpb24gZm9ybWF0V2Vla2RheU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEYXRlRm9ybWF0dGVyKHRoaXMuY2FsZW5kYXJMb2NhbGUsIHtcbiAgICAgICAgICB3ZWVrZGF5OiAnbG9uZycsXG4gICAgICAgICAgY2FsZW5kYXI6ICdncmVnb3J5J1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmb3JtYXRXZWVrZGF5TmFtZVNob3J0OiBmdW5jdGlvbiBmb3JtYXRXZWVrZGF5TmFtZVNob3J0KCkge1xuICAgICAgICAvLyBVc2VkIGFzIHRoZSBoZWFkZXIgY2VsbHNcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURhdGVGb3JtYXR0ZXIodGhpcy5jYWxlbmRhckxvY2FsZSwge1xuICAgICAgICAgIHdlZWtkYXk6ICdzaG9ydCcsXG4gICAgICAgICAgY2FsZW5kYXI6ICdncmVnb3J5J1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmb3JtYXREYXk6IGZ1bmN0aW9uIGZvcm1hdERheSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURhdGVGb3JtYXR0ZXIodGhpcy5jYWxlbmRhckxvY2FsZSwge1xuICAgICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICAgIGNhbGVuZGFyOiAnZ3JlZ29yeSdcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgLy8gRGlzYWJsZWQgc3RhdGVzIGZvciB0aGUgbmF2IGJ1dHRvbnNcbiAgICAgIHByZXZZZWFyRGlzYWJsZWQ6IGZ1bmN0aW9uIHByZXZZZWFyRGlzYWJsZWQoKSB7XG4gICAgICAgIHZhciBtaW4gPSB0aGlzLmNvbXB1dGVkTWluO1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCB8fCBtaW4gJiYgbGFzdERhdGVPZk1vbnRoKG9uZVllYXJBZ28odGhpcy5hY3RpdmVEYXRlKSkgPCBtaW47XG4gICAgICB9LFxuICAgICAgcHJldk1vbnRoRGlzYWJsZWQ6IGZ1bmN0aW9uIHByZXZNb250aERpc2FibGVkKCkge1xuICAgICAgICB2YXIgbWluID0gdGhpcy5jb21wdXRlZE1pbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgfHwgbWluICYmIGxhc3REYXRlT2ZNb250aChvbmVNb250aEFnbyh0aGlzLmFjdGl2ZURhdGUpKSA8IG1pbjtcbiAgICAgIH0sXG4gICAgICB0aGlzTW9udGhEaXNhYmxlZDogZnVuY3Rpb24gdGhpc01vbnRoRGlzYWJsZWQoKSB7XG4gICAgICAgIC8vIFRPRE86IFdlIGNvdWxkL3Nob3VsZCBjaGVjayBpZiB0b2RheSBpcyBvdXQgb2YgcmFuZ2VcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7XG4gICAgICB9LFxuICAgICAgbmV4dE1vbnRoRGlzYWJsZWQ6IGZ1bmN0aW9uIG5leHRNb250aERpc2FibGVkKCkge1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5jb21wdXRlZE1heDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgfHwgbWF4ICYmIGZpcnN0RGF0ZU9mTW9udGgob25lTW9udGhBaGVhZCh0aGlzLmFjdGl2ZURhdGUpKSA+IG1heDtcbiAgICAgIH0sXG4gICAgICBuZXh0WWVhckRpc2FibGVkOiBmdW5jdGlvbiBuZXh0WWVhckRpc2FibGVkKCkge1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5jb21wdXRlZE1heDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgfHwgbWF4ICYmIGZpcnN0RGF0ZU9mTW9udGgob25lWWVhckFoZWFkKHRoaXMuYWN0aXZlRGF0ZSkpID4gbWF4O1xuICAgICAgfSxcbiAgICAgIC8vIENhbGVuZGFyIGdlbmVyYXRpb25cbiAgICAgIGNhbGVuZGFyOiBmdW5jdGlvbiBjYWxlbmRhcigpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtdO1xuICAgICAgICB2YXIgZmlyc3REYXkgPSB0aGlzLmNhbGVuZGFyRmlyc3REYXk7XG4gICAgICAgIHZhciBjYWxlbmRhclllYXIgPSBmaXJzdERheS5nZXRGdWxsWWVhcigpO1xuICAgICAgICB2YXIgY2FsZW5kYXJNb250aCA9IGZpcnN0RGF5LmdldE1vbnRoKCk7XG4gICAgICAgIHZhciBkYXlzSW5Nb250aCA9IHRoaXMuY2FsZW5kYXJEYXlzSW5Nb250aDtcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBmaXJzdERheS5nZXREYXkoKTsgLy8gYDBgLi5gNmBcblxuICAgICAgICB2YXIgd2Vla09mZnNldCA9ICh0aGlzLmNvbXB1dGVkV2Vla1N0YXJ0cyA+IHN0YXJ0SW5kZXggPyA3IDogMCkgLSB0aGlzLmNvbXB1dGVkV2Vla1N0YXJ0czsgLy8gVE9ETzogQ2hhbmdlIGBkYXRlSW5mb0ZuYCB0byBoYW5kbGUgZXZlbnRzIGFuZCBub3RlcyBhcyB3ZWxsIGFzIGNsYXNzZXNcblxuICAgICAgICB2YXIgZGF0ZUluZm9GbiA9IGlzRnVuY3Rpb24odGhpcy5kYXRlSW5mb0ZuKSA/IHRoaXMuZGF0ZUluZm9GbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH07IC8vIEJ1aWxkIHRoZSBjYWxlbmRhciBtYXRyaXhcblxuICAgICAgICB2YXIgY3VycmVudERheSA9IDAgLSB3ZWVrT2Zmc2V0IC0gc3RhcnRJbmRleDtcblxuICAgICAgICBmb3IgKHZhciB3ZWVrID0gMDsgd2VlayA8IDYgJiYgY3VycmVudERheSA8IGRheXNJbk1vbnRoOyB3ZWVrKyspIHtcbiAgICAgICAgICAvLyBGb3IgZWFjaCB3ZWVrXG4gICAgICAgICAgbWF0cml4W3dlZWtdID0gW107IC8vIFRoZSBmb2xsb3dpbmcgY291bGQgYmUgYSBtYXAgZnVuY3Rpb25cblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgICAgICAvLyBGb3IgZWFjaCBkYXkgaW4gd2Vla1xuICAgICAgICAgICAgY3VycmVudERheSsrO1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBjcmVhdGVEYXRlKGNhbGVuZGFyWWVhciwgY2FsZW5kYXJNb250aCwgY3VycmVudERheSk7XG4gICAgICAgICAgICB2YXIgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICB2YXIgZGF5WU1EID0gZm9ybWF0WU1EKGRhdGUpO1xuICAgICAgICAgICAgdmFyIGRheURpc2FibGVkID0gdGhpcy5kYXRlRGlzYWJsZWQoZGF0ZSk7IC8vIFRPRE86IFRoaXMgY291bGQgYmUgYSBub3JtYWxpemVyIG1ldGhvZFxuXG4gICAgICAgICAgICB2YXIgZGF0ZUluZm8gPSBkYXRlSW5mb0ZuKGRheVlNRCwgcGFyc2VZTUQoZGF5WU1EKSk7XG4gICAgICAgICAgICBkYXRlSW5mbyA9IGlzU3RyaW5nKGRhdGVJbmZvKSB8fCBpc0FycmF5KGRhdGVJbmZvKSA/IHtcbiAgICAgICAgICAgICAgY2xhc3M6IGRhdGVJbmZvXG4gICAgICAgICAgICB9IDogaXNQbGFpbk9iamVjdChkYXRlSW5mbykgPyBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgIGNsYXNzOiAnJ1xuICAgICAgICAgICAgfSwgZGF0ZUluZm8pIDoge1xuICAgICAgICAgICAgICBjbGFzczogJydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtYXRyaXhbd2Vla10ucHVzaCh7XG4gICAgICAgICAgICAgIHltZDogZGF5WU1ELFxuICAgICAgICAgICAgICAvLyBDZWxsIGNvbnRlbnRcbiAgICAgICAgICAgICAgZGF5OiB0aGlzLmZvcm1hdERheShkYXRlKSxcbiAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZm9ybWF0RGF0ZVN0cmluZyhkYXRlKSxcbiAgICAgICAgICAgICAgLy8gRmxhZ3MgZm9yIHN0eWxpbmdcbiAgICAgICAgICAgICAgaXNUaGlzTW9udGg6IG1vbnRoID09PSBjYWxlbmRhck1vbnRoLFxuICAgICAgICAgICAgICBpc0Rpc2FibGVkOiBkYXlEaXNhYmxlZCxcbiAgICAgICAgICAgICAgLy8gVE9ETzogSGFuZGxlIG90aGVyIGRhdGVJbmZvIHByb3BlcnRpZXMgc3VjaCBhcyBub3Rlcy9ldmVudHNcbiAgICAgICAgICAgICAgaW5mbzogZGF0ZUluZm9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICB9LFxuICAgICAgY2FsZW5kYXJIZWFkaW5nczogZnVuY3Rpb24gY2FsZW5kYXJIZWFkaW5ncygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclswXS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogX3RoaXMuZm9ybWF0V2Vla2RheU5hbWVTaG9ydChwYXJzZVlNRChkLnltZCkpLFxuICAgICAgICAgICAgbGFiZWw6IF90aGlzLmZvcm1hdFdlZWtkYXlOYW1lKHBhcnNlWU1EKGQueW1kKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gZm9ybWF0WU1EKG5ld1ZhbCkgfHwgJyc7XG4gICAgICAgIHZhciBvbGQgPSBmb3JtYXRZTUQob2xkVmFsKSB8fCAnJztcblxuICAgICAgICBpZiAoIWRhdGVzRXF1YWwoc2VsZWN0ZWQsIG9sZCkpIHtcbiAgICAgICAgICB0aGlzLmFjdGl2ZVlNRCA9IHNlbGVjdGVkIHx8IHRoaXMuYWN0aXZlWU1EO1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRZTUQgPSBzZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkWU1EOiBmdW5jdGlvbiBzZWxlY3RlZFlNRChuZXdZTUQsIG9sZFlNRCkge1xuICAgICAgICAvLyBUT0RPOlxuICAgICAgICAvLyAgIFNob3VsZCB3ZSBjb21wYXJlIHRvIGBmb3JtYXRZTUQodGhpcy52YWx1ZSlgIGFuZCBlbWl0XG4gICAgICAgIC8vICAgb25seSBpZiB0aGV5IGFyZSBkaWZmZXJlbnQ/XG4gICAgICAgIGlmIChuZXdZTUQgIT09IG9sZFlNRCkge1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgdGhpcy52YWx1ZUFzRGF0ZSA/IHBhcnNlWU1EKG5ld1lNRCkgfHwgbnVsbCA6IG5ld1lNRCB8fCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb250ZXh0OiBmdW5jdGlvbiBjb250ZXh0KG5ld1ZhbCwgb2xkVmFsKSB7XG4gICAgICAgIGlmICghbG9vc2VFcXVhbChuZXdWYWwsIG9sZFZhbCkpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdjb250ZXh0JywgbmV3VmFsKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhpZGRlbjogZnVuY3Rpb24gaGlkZGVuKG5ld1ZhbCkge1xuICAgICAgICAvLyBSZXNldCB0aGUgYWN0aXZlIGZvY3VzZWQgZGF5IHdoZW4gaGlkZGVuXG4gICAgICAgIHRoaXMuYWN0aXZlWU1EID0gdGhpcy5zZWxlY3RlZFlNRCB8fCBmb3JtYXRZTUQodGhpcy52YWx1ZSkgfHwgZm9ybWF0WU1EKHRoaXMuZ2V0VG9kYXkoKSk7IC8vIEVuYWJsZS9kaXNhYmxlIHRoZSBsaXZlIHJlZ2lvbnNcblxuICAgICAgICB0aGlzLnNldExpdmUoIW5ld1ZhbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLiRlbWl0KCdjb250ZXh0JywgX3RoaXMyLmNvbnRleHQpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgdGhpcy5zZXRMaXZlKHRydWUpO1xuICAgIH0sXG4gICAgYWN0aXZhdGVkOiBmdW5jdGlvbiBhY3RpdmF0ZWQoKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAge1xuICAgICAgdGhpcy5zZXRMaXZlKHRydWUpO1xuICAgIH0sXG4gICAgZGVhY3RpdmF0ZWQ6IGZ1bmN0aW9uIGRlYWN0aXZhdGVkKClcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHtcbiAgICAgIHRoaXMuc2V0TGl2ZShmYWxzZSk7XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgdGhpcy5zZXRMaXZlKGZhbHNlKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIC8vIFB1YmxpYyBtZXRob2QocylcbiAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuJHJlZnMuZ3JpZC5mb2N1cygpO1xuICAgICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBibHVyOiBmdW5jdGlvbiBibHVyKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuJHJlZnMuZ3JpZC5ibHVyKCk7XG4gICAgICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7fVxuICAgICAgfSxcbiAgICAgIC8vIFByaXZhdGUgbWV0aG9kc1xuICAgICAgc2V0TGl2ZTogZnVuY3Rpb24gc2V0TGl2ZShvbikge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBpZiAob24pIHtcbiAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXF1ZXN0QUYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMuaXNMaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaXNMaXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXRUb2RheTogZnVuY3Rpb24gZ2V0VG9kYXkoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVlNRChjcmVhdGVEYXRlKCkpO1xuICAgICAgfSxcbiAgICAgIGNvbnN0cmFpbkRhdGU6IGZ1bmN0aW9uIGNvbnN0cmFpbkRhdGUoZGF0ZSkge1xuICAgICAgICAvLyBDb25zdHJhaW5zIGEgZGF0ZSBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gICAgICAgIC8vIHJldHVybnMgYSBuZXcgYERhdGVgIG9iamVjdCBpbnN0YW5jZVxuICAgICAgICBkYXRlID0gcGFyc2VZTUQoZGF0ZSk7XG4gICAgICAgIHZhciBtaW4gPSB0aGlzLmNvbXB1dGVkTWluIHx8IGRhdGU7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLmNvbXB1dGVkTWF4IHx8IGRhdGU7XG4gICAgICAgIHJldHVybiBjcmVhdGVEYXRlKGRhdGUgPCBtaW4gPyBtaW4gOiBkYXRlID4gbWF4ID8gbWF4IDogZGF0ZSk7XG4gICAgICB9LFxuICAgICAgZW1pdFNlbGVjdGVkOiBmdW5jdGlvbiBlbWl0U2VsZWN0ZWQoZGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICAvLyBQZXJmb3JtZWQgaW4gYSBgJG5leHRUaWNrKClgIHRvIChwcm9iYWJseSkgZW5zdXJlXG4gICAgICAgIC8vIHRoZSBpbnB1dCBldmVudCBoYXMgZW1pdHRlZCBmaXJzdFxuICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM0LiRlbWl0KCdzZWxlY3RlZCcsIGZvcm1hdFlNRChkYXRlKSB8fCAnJywgcGFyc2VZTUQoZGF0ZSkgfHwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIC8vIEV2ZW50IGhhbmRsZXJzXG4gICAgICBzZXRHcmlkRm9jdXNGbGFnOiBmdW5jdGlvbiBzZXRHcmlkRm9jdXNGbGFnKGV2dCkge1xuICAgICAgICAvLyBTZXRzIHRoZSBncmlkSGFzRm9jdXMgZmxhZyB0byBtYWtlIGRhdGUgXCJidXR0b25cIiBsb29rIGZvY3VzZWRcbiAgICAgICAgdGhpcy5ncmlkSGFzRm9jdXMgPSAhdGhpcy5kaXNhYmxlZCAmJiBldnQudHlwZSA9PT0gJ2ZvY3VzJztcbiAgICAgIH0sXG4gICAgICBvbktleWRvd25XcmFwcGVyOiBmdW5jdGlvbiBvbktleWRvd25XcmFwcGVyKGV2dCkge1xuICAgICAgICAvLyBDYWxlbmRhciBrZXlib2FyZCBuYXZpZ2F0aW9uXG4gICAgICAgIC8vIEhhbmRsZXMgUEFHRVVQL1BBR0VET1dOL0VORC9IT01FL0xFRlQvVVAvUklHSFQvRE9XTlxuICAgICAgICAvLyBGb2N1c2VzIGdyaWQgYWZ0ZXIgdXBkYXRpbmdcbiAgICAgICAgdmFyIGtleUNvZGUgPSBldnQua2V5Q29kZTtcbiAgICAgICAgdmFyIGFsdEtleSA9IGV2dC5hbHRLZXk7XG5cbiAgICAgICAgaWYgKCFhcnJheUluY2x1ZGVzKFtQQUdFVVAsIFBBR0VET1dOLCBFTkQsIEhPTUUsIExFRlQsIFVQLCBSSUdIVCwgRE9XTl0sIGtleUNvZGUpKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB2YXIgYWN0aXZlRGF0ZSA9IGNyZWF0ZURhdGUodGhpcy5hY3RpdmVEYXRlKTtcbiAgICAgICAgdmFyIGNoZWNrRGF0ZSA9IGNyZWF0ZURhdGUodGhpcy5hY3RpdmVEYXRlKTtcbiAgICAgICAgdmFyIGRheSA9IGFjdGl2ZURhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICB2YXIgaXNSVEwgPSB0aGlzLmlzUlRMO1xuXG4gICAgICAgIGlmIChrZXlDb2RlID09PSBQQUdFVVApIHtcbiAgICAgICAgICAvLyBQQUdFVVAgLSBQcmV2aW91cyBtb250aC95ZWFyXG4gICAgICAgICAgYWN0aXZlRGF0ZSA9IChhbHRLZXkgPyBvbmVZZWFyQWdvIDogb25lTW9udGhBZ28pKGFjdGl2ZURhdGUpOyAvLyBXZSBjaGVjayB0aGUgZmlyc3QgZGF5IG9mIG1vbnRoIHRvIGJlIGluIHJhZ2VcblxuICAgICAgICAgIGNoZWNrRGF0ZSA9IGNyZWF0ZURhdGUoYWN0aXZlRGF0ZSk7XG4gICAgICAgICAgY2hlY2tEYXRlLnNldERhdGUoMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gUEFHRURPV04pIHtcbiAgICAgICAgICAvLyBQQUdFRE9XTiAtIE5leHQgbW9udGgveWVhclxuICAgICAgICAgIGFjdGl2ZURhdGUgPSAoYWx0S2V5ID8gb25lWWVhckFoZWFkIDogb25lTW9udGhBaGVhZCkoYWN0aXZlRGF0ZSk7IC8vIFdlIGNoZWNrIHRoZSBsYXN0IGRheSBvZiBtb250aCB0byBiZSBpbiByYWdlXG5cbiAgICAgICAgICBjaGVja0RhdGUgPSBjcmVhdGVEYXRlKGFjdGl2ZURhdGUpO1xuICAgICAgICAgIGNoZWNrRGF0ZS5zZXRNb250aChjaGVja0RhdGUuZ2V0TW9udGgoKSArIDEpO1xuICAgICAgICAgIGNoZWNrRGF0ZS5zZXREYXRlKDApO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IExFRlQpIHtcbiAgICAgICAgICAvLyBMRUZUIC0gUHJldmlvdXMgZGF5IChvciBuZXh0IGRheSBmb3IgUlRMKVxuICAgICAgICAgIGFjdGl2ZURhdGUuc2V0RGF0ZShkYXkgKyAoaXNSVEwgPyAxIDogLTEpKTtcbiAgICAgICAgICBjaGVja0RhdGUgPSBhY3RpdmVEYXRlO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IFJJR0hUKSB7XG4gICAgICAgICAgLy8gUklHSFQgLSBOZXh0IGRheSAob3IgcHJldmlvdXMgZGF5IGZvciBSVEwpXG4gICAgICAgICAgYWN0aXZlRGF0ZS5zZXREYXRlKGRheSArIChpc1JUTCA/IC0xIDogMSkpO1xuICAgICAgICAgIGNoZWNrRGF0ZSA9IGFjdGl2ZURhdGU7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gVVApIHtcbiAgICAgICAgICAvLyBVUCAtIFByZXZpb3VzIHdlZWtcbiAgICAgICAgICBhY3RpdmVEYXRlLnNldERhdGUoZGF5IC0gNyk7XG4gICAgICAgICAgY2hlY2tEYXRlID0gYWN0aXZlRGF0ZTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBET1dOKSB7XG4gICAgICAgICAgLy8gRE9XTiAtIE5leHQgd2Vla1xuICAgICAgICAgIGFjdGl2ZURhdGUuc2V0RGF0ZShkYXkgKyA3KTtcbiAgICAgICAgICBjaGVja0RhdGUgPSBhY3RpdmVEYXRlO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEhPTUUpIHtcbiAgICAgICAgICAvLyBIT01FIC0gVG9kYXlcbiAgICAgICAgICBhY3RpdmVEYXRlID0gdGhpcy5nZXRUb2RheSgpO1xuICAgICAgICAgIGNoZWNrRGF0ZSA9IGFjdGl2ZURhdGU7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gRU5EKSB7XG4gICAgICAgICAgLy8gRU5EIC0gU2VsZWN0ZWQgZGF0ZSwgb3IgdG9kYXkgaWYgbm8gc2VsZWN0ZWQgZGF0ZVxuICAgICAgICAgIGFjdGl2ZURhdGUgPSBwYXJzZVlNRCh0aGlzLnNlbGVjdGVkRGF0ZSkgfHwgdGhpcy5nZXRUb2RheSgpO1xuICAgICAgICAgIGNoZWNrRGF0ZSA9IGFjdGl2ZURhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZGF0ZU91dE9mUmFuZ2UoY2hlY2tEYXRlKSAmJiAhZGF0ZXNFcXVhbChhY3RpdmVEYXRlLCB0aGlzLmFjdGl2ZURhdGUpKSB7XG4gICAgICAgICAgLy8gV2Ugb25seSBqdW1wIHRvIGRhdGUgaWYgd2l0aGluIG1pbi9tYXhcbiAgICAgICAgICAvLyBXZSBkb24ndCBjaGVjayBmb3IgaW5kaXZpZHVhbCBkaXNhYmxlZCBkYXRlcyB0aG91Z2ggKHZpYSB1c2VyIGZ1bmN0aW9uKVxuICAgICAgICAgIHRoaXMuYWN0aXZlWU1EID0gZm9ybWF0WU1EKGFjdGl2ZURhdGUpO1xuICAgICAgICB9IC8vIEVuc3VyZSBncmlkIGlzIGZvY3VzZWRcblxuXG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgIH0sXG4gICAgICBvbktleWRvd25HcmlkOiBmdW5jdGlvbiBvbktleWRvd25HcmlkKGV2dCkge1xuICAgICAgICAvLyBQcmVzc2luZyBlbnRlci9zcGFjZSBvbiBncmlkIHRvIHNlbGVjdCBhY3RpdmUgZGF0ZVxuICAgICAgICB2YXIga2V5Q29kZSA9IGV2dC5rZXlDb2RlO1xuICAgICAgICB2YXIgYWN0aXZlRGF0ZSA9IHRoaXMuYWN0aXZlRGF0ZTtcblxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gRU5URVIgfHwga2V5Q29kZSA9PT0gU1BBQ0UpIHtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgIXRoaXMucmVhZG9ubHkgJiYgIXRoaXMuZGF0ZURpc2FibGVkKGFjdGl2ZURhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkWU1EID0gZm9ybWF0WU1EKGFjdGl2ZURhdGUpO1xuICAgICAgICAgICAgdGhpcy5lbWl0U2VsZWN0ZWQoYWN0aXZlRGF0ZSk7XG4gICAgICAgICAgfSAvLyBFbnN1cmUgZ3JpZCBpcyBmb2N1c2VkXG5cblxuICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xpY2tEYXk6IGZ1bmN0aW9uIG9uQ2xpY2tEYXkoZGF5KSB7XG4gICAgICAgIC8vIENsaWNraW5nIG9uIGEgZGF0ZSBcImJ1dHRvblwiIHRvIHNlbGVjdCBpdFxuICAgICAgICAvLyBUT0RPOiBDaGFuZ2UgdG8gbG9va3VwIHRoZSBgZGF0YS1kYXRhYCBhdHRyaWJ1dGVcbiAgICAgICAgdmFyIHNlbGVjdGVkRGF0ZSA9IHRoaXMuc2VsZWN0ZWREYXRlO1xuICAgICAgICB2YXIgYWN0aXZlRGF0ZSA9IHRoaXMuYWN0aXZlRGF0ZTtcbiAgICAgICAgdmFyIGNsaWNrZWREYXRlID0gcGFyc2VZTUQoZGF5LnltZCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkICYmICFkYXkuaXNEaXNhYmxlZCAmJiAhdGhpcy5kYXRlRGlzYWJsZWQoY2xpY2tlZERhdGUpKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnJlYWRvbmx5KSB7XG4gICAgICAgICAgICAvLyBJZiByZWFkb25seSBtb2RlLCB3ZSBkb24ndCBzZXQgdGhlIHNlbGVjdGVkIGRhdGUsIGp1c3QgdGhlIGFjdGl2ZSBkYXRlXG4gICAgICAgICAgICAvLyBJZiB0aGUgY2xpY2tlZCBkYXRlIGlzIGVxdWFsIHRvIHRoZSBhbHJlYWR5IHNlbGVjdGVkIGRhdGUsIHdlIGRvbid0IHVwZGF0ZSB0aGUgbW9kZWxcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRZTUQgPSBmb3JtYXRZTUQoZGF0ZXNFcXVhbChjbGlja2VkRGF0ZSwgc2VsZWN0ZWREYXRlKSA/IHNlbGVjdGVkRGF0ZSA6IGNsaWNrZWREYXRlKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFNlbGVjdGVkKGNsaWNrZWREYXRlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmFjdGl2ZVlNRCA9IGZvcm1hdFlNRChkYXRlc0VxdWFsKGNsaWNrZWREYXRlLCBhY3RpdmVEYXRlKSA/IGFjdGl2ZURhdGUgOiBjcmVhdGVEYXRlKGNsaWNrZWREYXRlKSk7IC8vIEVuc3VyZSBncmlkIGlzIGZvY3VzZWRcblxuICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdvdG9QcmV2WWVhcjogZnVuY3Rpb24gZ290b1ByZXZZZWFyKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZVlNRCA9IGZvcm1hdFlNRCh0aGlzLmNvbnN0cmFpbkRhdGUob25lWWVhckFnbyh0aGlzLmFjdGl2ZURhdGUpKSk7XG4gICAgICB9LFxuICAgICAgZ290b1ByZXZNb250aDogZnVuY3Rpb24gZ290b1ByZXZNb250aCgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVZTUQgPSBmb3JtYXRZTUQodGhpcy5jb25zdHJhaW5EYXRlKG9uZU1vbnRoQWdvKHRoaXMuYWN0aXZlRGF0ZSkpKTtcbiAgICAgIH0sXG4gICAgICBnb3RvQ3VycmVudE1vbnRoOiBmdW5jdGlvbiBnb3RvQ3VycmVudE1vbnRoKCkge1xuICAgICAgICAvLyBUT0RPOiBNYXliZSB0aGlzIGdvdG8gZGF0ZSBzaG91bGQgYmUgY29uZmlndXJhYmxlP1xuICAgICAgICB0aGlzLmFjdGl2ZVlNRCA9IGZvcm1hdFlNRCh0aGlzLmdldFRvZGF5KCkpO1xuICAgICAgfSxcbiAgICAgIGdvdG9OZXh0TW9udGg6IGZ1bmN0aW9uIGdvdG9OZXh0TW9udGgoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlWU1EID0gZm9ybWF0WU1EKHRoaXMuY29uc3RyYWluRGF0ZShvbmVNb250aEFoZWFkKHRoaXMuYWN0aXZlRGF0ZSkpKTtcbiAgICAgIH0sXG4gICAgICBnb3RvTmV4dFllYXI6IGZ1bmN0aW9uIGdvdG9OZXh0WWVhcigpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVZTUQgPSBmb3JtYXRZTUQodGhpcy5jb25zdHJhaW5EYXRlKG9uZVllYXJBaGVhZCh0aGlzLmFjdGl2ZURhdGUpKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgLy8gSWYgaGlkZGVuIHByb3AgaXMgc2V0LCByZW5kZXIganVzdCBhIHBsYWNlaG9sZGVyIG5vZGVcbiAgICAgIGlmICh0aGlzLmhpZGRlbikge1xuICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNSVEwgPSB0aGlzLmlzUlRMO1xuICAgICAgdmFyIHRvZGF5WU1EID0gZm9ybWF0WU1EKHRoaXMuZ2V0VG9kYXkoKSk7XG4gICAgICB2YXIgc2VsZWN0ZWRZTUQgPSB0aGlzLnNlbGVjdGVkWU1EO1xuICAgICAgdmFyIGFjdGl2ZVlNRCA9IHRoaXMuYWN0aXZlWU1EO1xuICAgICAgdmFyIGhpZ2hsaWdodFRvZGF5ID0gIXRoaXMubm9IaWdobGlnaHRUb2RheTtcbiAgICAgIHZhciBzYWZlSWQgPSB0aGlzLnNhZmVJZDsgLy8gRmxhZyBmb3IgbWFraW5nIHRoZSBgYXJpYS1saXZlYCByZWdpb25zIGxpdmVcblxuICAgICAgdmFyIGlzTGl2ZSA9IHRoaXMuaXNMaXZlOyAvLyBQcmUtY29tcHV0ZSBzb21lIElEc1xuXG4gICAgICB2YXIgaWRXaWRnZXQgPSBzYWZlSWQoKTtcbiAgICAgIHZhciBpZFZhbHVlID0gc2FmZUlkKCdfY2FsZW5kYXItdmFsdWVfJyk7XG4gICAgICB2YXIgaWROYXYgPSBzYWZlSWQoJ19jYWxlbmRhci1uYXZfJyk7XG4gICAgICB2YXIgaWRHcmlkID0gc2FmZUlkKCdfY2FsZW5kYXItZ3JpZF8nKTtcbiAgICAgIHZhciBpZEdyaWRDYXB0aW9uID0gc2FmZUlkKCdfY2FsZW5kYXItZ3JpZC1jYXB0aW9uXycpO1xuICAgICAgdmFyIGlkR3JpZEhlbHAgPSBzYWZlSWQoJ19jYWxlbmRhci1ncmlkLWhlbHBfJyk7XG4gICAgICB2YXIgaWRBY3RpdmUgPSBhY3RpdmVZTUQgPyBzYWZlSWQoXCJfY2VsbC1cIi5jb25jYXQoYWN0aXZlWU1ELCBcIl9cIikpIDogbnVsbDsgLy8gSGVhZGVyIHNob3dpbmcgY3VycmVudCBzZWxlY3RlZCBkYXRlXG5cbiAgICAgIHZhciAkaGVhZGVyID0gaCgnb3V0cHV0Jywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2QtYmxvY2sgdGV4dC1jZW50ZXIgcm91bmRlZCBib3JkZXIgc21hbGwgcC0xIG1iLTEnLFxuICAgICAgICBjbGFzczoge1xuICAgICAgICAgICd0ZXh0LW11dGVkJzogdGhpcy5kaXNhYmxlZCxcbiAgICAgICAgICByZWFkb25seTogdGhpcy5yZWFkb25seSB8fCB0aGlzLmRpc2FibGVkXG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IGlkVmFsdWUsXG4gICAgICAgICAgZm9yOiBpZEdyaWQsXG4gICAgICAgICAgcm9sZTogJ3N0YXR1cycsXG4gICAgICAgICAgLy8gTWFpbmx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLCBhcyB3ZSBkbyBub3Qga25vd1xuICAgICAgICAgIC8vIHRoZSBleGFjdCBmb3JtYXQgYEludGxgIHdpbGwgZm9ybWF0IHRoZSBkYXRlIHN0cmluZ1xuICAgICAgICAgICdkYXRhLXNlbGVjdGVkJzogdG9TdHJpbmckMShzZWxlY3RlZFlNRCksXG4gICAgICAgICAgLy8gV2Ugd2FpdCB1bnRpbCBhZnRlciBtb3VudCB0byBlbmFibGUgYGFyaWEtbGl2ZWBcbiAgICAgICAgICAvLyB0byBwcmV2ZW50IGluaXRpYWwgYW5ub3VuY2VtZW50IG9uIHBhZ2UgcmVuZGVyXG4gICAgICAgICAgJ2FyaWEtbGl2ZSc6IGlzTGl2ZSA/ICdwb2xpdGUnIDogJ29mZicsXG4gICAgICAgICAgJ2FyaWEtYXRvbWljJzogaXNMaXZlID8gJ3RydWUnIDogbnVsbFxuICAgICAgICB9XG4gICAgICB9LCB0aGlzLnNlbGVjdGVkRGF0ZSA/IFsvLyBXZSB1c2UgYGJkaWAgZWxlbWVudHMgaGVyZSBpbiBjYXNlIHRoZSBsYWJlbCBkb2Vzbid0IG1hdGNoIHRoZSBsb2NhbGVcbiAgICAgIC8vIEFsdGhvdWdoIElFIDExIGRvZXMgbm90IGRlYWwgd2l0aCA8QkRJPiBhdCBhbGwgKGVxdWl2YWxlbnQgdG8gYSBzcGFuKVxuICAgICAgaCgnYmRpJywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ3NyLW9ubHknXG4gICAgICB9LCBcIiAoXCIuY29uY2F0KHRvU3RyaW5nJDEodGhpcy5sYWJlbFNlbGVjdGVkKSwgXCIpIFwiKSksIGgoJ2JkaScsIHt9LCB0aGlzLmZvcm1hdERhdGVTdHJpbmcodGhpcy5zZWxlY3RlZERhdGUpKV0gOiB0aGlzLmxhYmVsTm9EYXRlU2VsZWN0ZWQgfHwgXCJcXHhBMFwiIC8vICcmbmJzcDsnXG4gICAgICApO1xuICAgICAgJGhlYWRlciA9IGgoJ2hlYWRlcicsIHtcbiAgICAgICAgY2xhc3M6IHRoaXMuaGlkZUhlYWRlciA/ICdzci1vbmx5JyA6ICdtYi0xJyxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICB0aXRsZTogdGhpcy5zZWxlY3RlZERhdGUgPyB0aGlzLmxhYmVsU2VsZWN0ZWREYXRlIHx8IG51bGwgOiBudWxsXG4gICAgICAgIH1cbiAgICAgIH0sIFskaGVhZGVyXSk7IC8vIENvbnRlbnQgZm9yIHRoZSBkYXRlIG5hdmlnYXRpb24gYnV0dG9uc1xuXG4gICAgICB2YXIgJHByZXZZZWFySWNvbiA9IGgoQkljb25zdGFjaywge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHNoaWZ0VjogMC41LFxuICAgICAgICAgIGZsaXBIOiBpc1JUTFxuICAgICAgICB9XG4gICAgICB9LCBbaChCSWNvbkNoZXZyb25MZWZ0LCB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgc2hpZnRIOiAtMlxuICAgICAgICB9XG4gICAgICB9KSwgaChCSWNvbkNoZXZyb25MZWZ0LCB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgc2hpZnRIOiAyXG4gICAgICAgIH1cbiAgICAgIH0pXSk7XG4gICAgICB2YXIgJHByZXZNb250aEljb24gPSBoKEJJY29uQ2hldnJvbkxlZnQsIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBzaGlmdFY6IDAuNSxcbiAgICAgICAgICBmbGlwSDogaXNSVExcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgJHRoaXNNb250aEljb24gPSBoKEJJY29uQ2lyY2xlRmlsbCwge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHNoaWZ0VjogMC41XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyICRuZXh0TW9udGhJY29uID0gaChCSWNvbkNoZXZyb25MZWZ0LCB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgc2hpZnRWOiAwLjUsXG4gICAgICAgICAgZmxpcEg6ICFpc1JUTFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciAkbmV4dFllYXJJY29uID0gaChCSWNvbnN0YWNrLCB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgc2hpZnRWOiAwLjUsXG4gICAgICAgICAgZmxpcEg6ICFpc1JUTFxuICAgICAgICB9XG4gICAgICB9LCBbaChCSWNvbkNoZXZyb25MZWZ0LCB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgc2hpZnRIOiAtMlxuICAgICAgICB9XG4gICAgICB9KSwgaChCSWNvbkNoZXZyb25MZWZ0LCB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgc2hpZnRIOiAyXG4gICAgICAgIH1cbiAgICAgIH0pXSk7IC8vIFV0aWxpdHkgdG8gY3JlYXRlIHRoZSBkYXRlIG5hdmlnYXRpb24gYnV0dG9uc1xuXG4gICAgICB2YXIgbWFrZU5hdkJ0biA9IGZ1bmN0aW9uIG1ha2VOYXZCdG4oY29udGVudCwgbGFiZWwsIGhhbmRsZXIsIGJ0bkRpc2FibGVkLCBzaG9ydGN1dCkge1xuICAgICAgICByZXR1cm4gaCgnYnV0dG9uJywge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiAnYnRuIGJ0bi1zbSBidG4tb3V0bGluZS1zZWNvbmRhcnkgYm9yZGVyLTAgZmxleC1maWxsIHAtMSBteC0xJyxcbiAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgZGlzYWJsZWQ6IGJ0bkRpc2FibGVkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgdGl0bGU6IGxhYmVsIHx8IG51bGwsXG4gICAgICAgICAgICB0eXBlOiAnYnV0dG9uJyxcbiAgICAgICAgICAgICdhcmlhLWxhYmVsJzogbGFiZWwgfHwgbnVsbCxcbiAgICAgICAgICAgICdhcmlhLWRpc2FibGVkJzogYnRuRGlzYWJsZWQgPyAndHJ1ZScgOiBudWxsLFxuICAgICAgICAgICAgJ2FyaWEta2V5c2hvcnRjdXRzJzogc2hvcnRjdXQgfHwgbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IGJ0bkRpc2FibGVkID8ge30gOiB7XG4gICAgICAgICAgICBjbGljazogaGFuZGxlclxuICAgICAgICAgIH1cbiAgICAgICAgfSwgW2goJ2RpdicsIHtcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnXG4gICAgICAgICAgfVxuICAgICAgICB9LCBbY29udGVudF0pXSk7XG4gICAgICB9OyAvLyBHZW5lcmF0ZSB0aGUgZGF0ZSBuYXZpZ2F0aW9uIGJ1dHRvbnNcblxuXG4gICAgICB2YXIgJG5hdiA9IGgoJ2RpdicsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdiLWNhbGVuZGFyLW5hdiBkLWZsZXggbXgtbjEgbWItMScsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IGlkTmF2LFxuICAgICAgICAgIHJvbGU6ICdncm91cCcsXG4gICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdGhpcy5kaXNhYmxlZCA/ICd0cnVlJyA6IG51bGwsXG4gICAgICAgICAgJ2FyaWEtbGFiZWwnOiB0aGlzLmxhYmVsTmF2IHx8IG51bGwsXG4gICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBpZEdyaWRcbiAgICAgICAgfVxuICAgICAgfSwgW21ha2VOYXZCdG4oJHByZXZZZWFySWNvbiwgdGhpcy5sYWJlbFByZXZZZWFyLCB0aGlzLmdvdG9QcmV2WWVhciwgdGhpcy5wcmV2WWVhckRpc2FibGVkLCAnQWx0K1BhZ2VEb3duJyksIG1ha2VOYXZCdG4oJHByZXZNb250aEljb24sIHRoaXMubGFiZWxQcmV2TW9udGgsIHRoaXMuZ290b1ByZXZNb250aCwgdGhpcy5wcmV2TW9udGhEaXNhYmxlZCwgJ1BhZ2VEb3duJyksIG1ha2VOYXZCdG4oJHRoaXNNb250aEljb24sIHRoaXMubGFiZWxDdXJyZW50TW9udGgsIHRoaXMuZ290b0N1cnJlbnRNb250aCwgdGhpcy50aGlzTW9udGhEaXNhYmxlZCwgJ0hvbWUnKSwgbWFrZU5hdkJ0bigkbmV4dE1vbnRoSWNvbiwgdGhpcy5sYWJlbE5leHRNb250aCwgdGhpcy5nb3RvTmV4dE1vbnRoLCB0aGlzLm5leHRNb250aERpc2FibGVkLCAnUGFnZVVwJyksIG1ha2VOYXZCdG4oJG5leHRZZWFySWNvbiwgdGhpcy5sYWJlbE5leHRZZWFyLCB0aGlzLmdvdG9OZXh0WWVhciwgdGhpcy5uZXh0WWVhckRpc2FibGVkLCAnQWx0K1BhZ2VVcCcpXSk7IC8vIENhcHRpb24gZm9yIGNhbGVuZGFyIGdyaWRcblxuICAgICAgdmFyICRncmlkQ2FwdGlvbiA9IGgoJ2hlYWRlcicsIHtcbiAgICAgICAga2V5OiAnZ3JpZC1jYXB0aW9uJyxcbiAgICAgICAgc3RhdGljQ2xhc3M6ICd0ZXh0LWNlbnRlciBmb250LXdlaWdodC1ib2xkIHAtMSBtLTAnLFxuICAgICAgICBjbGFzczoge1xuICAgICAgICAgICd0ZXh0LW11dGVkJzogdGhpcy5kaXNhYmxlZFxuICAgICAgICB9LFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiBpZEdyaWRDYXB0aW9uLFxuICAgICAgICAgICdhcmlhLWxpdmUnOiBpc0xpdmUgPyAncG9saXRlJyA6IG51bGwsXG4gICAgICAgICAgJ2FyaWEtYXRvbWljJzogaXNMaXZlID8gJ3RydWUnIDogbnVsbFxuICAgICAgICB9XG4gICAgICB9LCB0aGlzLmZvcm1hdFllYXJNb250aCh0aGlzLmNhbGVuZGFyRmlyc3REYXkpKTsgLy8gQ2FsZW5kYXIgd2Vla2RheSBoZWFkaW5nc1xuXG4gICAgICB2YXIgJGdyaWRXZWVrRGF5cyA9IGgoJ2RpdicsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdyb3cgbm8tZ3V0dGVycyBib3JkZXItYm90dG9tJyxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAnYXJpYS1oaWRkZW4nOiAndHJ1ZSdcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5jYWxlbmRhckhlYWRpbmdzLm1hcChmdW5jdGlvbiAoZCwgaWR4KSB7XG4gICAgICAgIHJldHVybiBoKCdzbWFsbCcsIHtcbiAgICAgICAgICBrZXk6IGlkeCxcbiAgICAgICAgICBzdGF0aWNDbGFzczogJ2NvbCcsXG4gICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICd0ZXh0LW11dGVkJzogX3RoaXM1LmRpc2FibGVkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgdGl0bGU6IGQubGFiZWwgPT09IGQudGV4dCA/IG51bGwgOiBkLmxhYmVsLFxuICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiBkLmxhYmVsXG4gICAgICAgICAgfVxuICAgICAgICB9LCBkLnRleHQpO1xuICAgICAgfSkpOyAvLyBDYWxlbmRhciBkYXkgZ3JpZFxuXG4gICAgICB2YXIgJGdyaWRCb2R5ID0gdGhpcy5jYWxlbmRhci5tYXAoZnVuY3Rpb24gKHdlZWspIHtcbiAgICAgICAgdmFyICRjZWxscyA9IHdlZWsubWFwKGZ1bmN0aW9uIChkYXksIGRJbmRleCkge1xuICAgICAgICAgIHZhciBfY2xhc3M7XG5cbiAgICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IGRheS55bWQgPT09IHNlbGVjdGVkWU1EO1xuICAgICAgICAgIHZhciBpc0FjdGl2ZSA9IGRheS55bWQgPT09IGFjdGl2ZVlNRDtcbiAgICAgICAgICB2YXIgaXNUb2RheSA9IGRheS55bWQgPT09IHRvZGF5WU1EO1xuICAgICAgICAgIHZhciBpZENlbGwgPSBzYWZlSWQoXCJfY2VsbC1cIi5jb25jYXQoZGF5LnltZCwgXCJfXCIpKTsgLy8gXCJmYWtlXCIgYnV0dG9uXG5cbiAgICAgICAgICB2YXIgJGJ0biA9IGgoJ3NwYW4nLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ2J0biBib3JkZXItMCByb3VuZGVkLWNpcmNsZSB0ZXh0LW5vd3JhcCcsXG4gICAgICAgICAgICAvLyBTaG91bGQgd2UgYWRkIHNvbWUgY2xhc3NlcyB0byBzaWduaWZ5IGlmIHRvZGF5L3NlbGVjdGVkL2V0Yz9cbiAgICAgICAgICAgIGNsYXNzOiAoX2NsYXNzID0ge1xuICAgICAgICAgICAgICAvLyBHaXZlIHRoZSBmYWtlIGJ1dHRvbiBhIGZvY3VzIHJpbmdcbiAgICAgICAgICAgICAgZm9jdXM6IGlzQWN0aXZlICYmIF90aGlzNS5ncmlkSGFzRm9jdXMsXG4gICAgICAgICAgICAgIC8vIFN0eWxpbmdcbiAgICAgICAgICAgICAgZGlzYWJsZWQ6IGRheS5pc0Rpc2FibGVkIHx8IF90aGlzNS5kaXNhYmxlZCxcbiAgICAgICAgICAgICAgYWN0aXZlOiBpc1NlbGVjdGVkXG4gICAgICAgICAgICB9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzLCBfdGhpczUuY29tcHV0ZWRWYXJpYW50LCBpc1NlbGVjdGVkKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzcywgX3RoaXM1LmNvbXB1dGVkVG9kYXlWYXJpYW50LCBpc1RvZGF5ICYmIGhpZ2hsaWdodFRvZGF5ICYmICFpc1NlbGVjdGVkICYmIGRheS5pc1RoaXNNb250aCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsICdidG4tb3V0bGluZS1saWdodCcsICEoaXNUb2RheSAmJiBoaWdobGlnaHRUb2RheSkgJiYgIWlzU2VsZWN0ZWQgJiYgIWlzQWN0aXZlKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzcywgJ2J0bi1saWdodCcsICEoaXNUb2RheSAmJiBoaWdobGlnaHRUb2RheSkgJiYgIWlzU2VsZWN0ZWQgJiYgaXNBY3RpdmUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzLCAndGV4dC1tdXRlZCcsICFkYXkuaXNUaGlzTW9udGggJiYgIWlzU2VsZWN0ZWQpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzLCAndGV4dC1kYXJrJywgIShpc1RvZGF5ICYmIGhpZ2hsaWdodFRvZGF5KSAmJiAhaXNTZWxlY3RlZCAmJiAhaXNBY3RpdmUgJiYgZGF5LmlzVGhpc01vbnRoKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzcywgJ2ZvbnQtd2VpZ2h0LWJvbGQnLCAoaXNTZWxlY3RlZCB8fCBkYXkuaXNUaGlzTW9udGgpICYmICFkYXkuaXNEaXNhYmxlZCksIF9jbGFzcyksXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNS5vbkNsaWNrRGF5KGRheSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBkYXkuZGF5KTtcbiAgICAgICAgICByZXR1cm4gaCgnZGl2JywgLy8gQ2VsbCB3aXRoIGJ1dHRvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGtleTogZEluZGV4LFxuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICdjb2wgcC0wJyxcbiAgICAgICAgICAgIGNsYXNzOiBkYXkuaXNEaXNhYmxlZCA/ICdiZy1saWdodCcgOiBkYXkuaW5mby5jbGFzcyB8fCAnJyxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGlkOiBpZENlbGwsXG4gICAgICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgICAgICAnZGF0YS1kYXRlJzogZGF5LnltZCxcbiAgICAgICAgICAgICAgLy8gUHJpbWFyaWx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzXG4gICAgICAgICAgICAgIC8vIE9ubHkgZGF5cyBpbiB0aGUgbW9udGggYXJlIHByZXNlbnRlZCBhcyBidXR0b25zIHRvIHNjcmVlbiByZWFkZXJzXG4gICAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IGRheS5pc1RoaXNNb250aCA/IG51bGwgOiAndHJ1ZScsXG4gICAgICAgICAgICAgICdhcmlhLWRpc2FibGVkJzogZGF5LmlzRGlzYWJsZWQgfHwgX3RoaXM1LmRpc2FibGVkID8gJ3RydWUnIDogbnVsbCxcbiAgICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiBbZGF5LmxhYmVsLCBpc1NlbGVjdGVkID8gXCIoXCIuY29uY2F0KF90aGlzNS5sYWJlbFNlbGVjdGVkLCBcIilcIikgOiBudWxsLCBpc1RvZGF5ID8gXCIoXCIuY29uY2F0KF90aGlzNS5sYWJlbFRvZGF5LCBcIilcIikgOiBudWxsXS5maWx0ZXIoaWRlbnRpdHkpLmpvaW4oJyAnKSxcbiAgICAgICAgICAgICAgLy8gTlZEQSBkb2Vzbid0IGNvbnZleSBgYXJpYS1zZWxlY3RlZGAsIGJ1dCBkb2VzIGBhcmlhLWN1cnJlbnRgLFxuICAgICAgICAgICAgICAvLyBDaHJvbWVWb3ggZG9lc24ndCBjb252ZXkgYGFyaWEtY3VycmVudGAsIGJ1dCBkb2VzIGBhcmlhLXNlbGVjdGVkYCxcbiAgICAgICAgICAgICAgLy8gc28gd2Ugc2V0IGJvdGggYXR0cmlidXRlcyBmb3Igcm9idXN0bmVzc1xuICAgICAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IGlzU2VsZWN0ZWQgPyAndHJ1ZScgOiBudWxsLFxuICAgICAgICAgICAgICAnYXJpYS1jdXJyZW50JzogaXNTZWxlY3RlZCA/ICdkYXRlJyA6IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBbJGJ0bl0pO1xuICAgICAgICB9KTsgLy8gUmV0dXJuIHRoZSB3ZWVrIFwicm93XCJcbiAgICAgICAgLy8gV2UgdXNlIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWtzIFlNRCB2YWx1ZSBhcyBhXG4gICAgICAgIC8vIGtleSBmb3IgZWZmaWNpZW50IERPTSBwYXRjaGluZyAvIGVsZW1lbnQgcmUtdXNlXG5cbiAgICAgICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgICAgICBrZXk6IHdlZWtbMF0ueW1kLFxuICAgICAgICAgIHN0YXRpY0NsYXNzOiAncm93IG5vLWd1dHRlcnMnXG4gICAgICAgIH0sICRjZWxscyk7XG4gICAgICB9KTtcbiAgICAgICRncmlkQm9keSA9IGgoJ2RpdicsIHtcbiAgICAgICAgLy8gQSBrZXkgaXMgb25seSByZXF1aXJlZCBvbiB0aGUgYm9keSBpZiB3ZSBhZGQgaW4gdHJhbnNpdGlvbiBzdXBwb3J0XG4gICAgICAgIC8vIGtleTogdGhpcy5hY3RpdmVZTUQuc2xpY2UoMCwgLTMpLFxuICAgICAgICBzdGF0aWNDbGFzczogJ2ItY2FsZW5kYXItZ3JpZC1ib2R5JyxcbiAgICAgICAgc3R5bGU6IHRoaXMuZGlzYWJsZWQgPyB7XG4gICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICAgIH0gOiB7fVxuICAgICAgfSwgJGdyaWRCb2R5KTtcbiAgICAgIHZhciAkZ3JpZEhlbHAgPSBoKCdmb290ZXInLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnYm9yZGVyLXRvcCBzbWFsbCB0ZXh0LW11dGVkIHRleHQtY2VudGVyIGJnLWxpZ2h0JyxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBpZDogaWRHcmlkSGVscFxuICAgICAgICB9XG4gICAgICB9LCBbaCgnZGl2Jywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ3NtYWxsJ1xuICAgICAgfSwgdGhpcy5sYWJlbEhlbHApXSk7XG4gICAgICB2YXIgJGdyaWQgPSBoKCdkaXYnLCB7XG4gICAgICAgIHJlZjogJ2dyaWQnLFxuICAgICAgICBzdGF0aWNDbGFzczogJ2Zvcm0tY29udHJvbCBoLWF1dG8gdGV4dC1jZW50ZXIgcC0wIG1iLTAnLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiBpZEdyaWQsXG4gICAgICAgICAgcm9sZTogJ2FwcGxpY2F0aW9uJyxcbiAgICAgICAgICB0YWJpbmRleDogdGhpcy5kaXNhYmxlZCA/IG51bGwgOiAnMCcsXG4gICAgICAgICAgJ2RhdGEtbW9udGgnOiBhY3RpdmVZTUQuc2xpY2UoMCwgLTMpLFxuICAgICAgICAgIC8vIGBZWVlZLU1NYCwgbWFpbmx5IGZvciB0ZXN0aW5nXG4gICAgICAgICAgLy8gdGFiaW5kZXg6IHRoaXMuZGlzYWJsZWQgPyBudWxsIDogJzAnLFxuICAgICAgICAgICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IHRoaXMubGFiZWxDYWxlbmRhciB8fCBudWxsLFxuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBpZEdyaWRDYXB0aW9uLFxuICAgICAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogaWRHcmlkSGVscCxcbiAgICAgICAgICAvLyBgYXJpYS1yZWFkb25seWAgaXMgbm90IGNvbnNpZGVyZWQgdmFsaWQgb24gYHJvbGU9XCJhcHBsaWNhdGlvblwiYFxuICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS0xLjEvI2FyaWEtcmVhZG9ubHlcbiAgICAgICAgICAvLyAnYXJpYS1yZWFkb25seSc6IHRoaXMucmVhZG9ubHkgJiYgIXRoaXMuZGlzYWJsZWQgPyAndHJ1ZScgOiBudWxsLFxuICAgICAgICAgICdhcmlhLWRpc2FibGVkJzogdGhpcy5kaXNhYmxlZCA/ICd0cnVlJyA6IG51bGwsXG4gICAgICAgICAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IGlkQWN0aXZlXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAga2V5ZG93bjogdGhpcy5vbktleWRvd25HcmlkLFxuICAgICAgICAgIGZvY3VzOiB0aGlzLnNldEdyaWRGb2N1c0ZsYWcsXG4gICAgICAgICAgYmx1cjogdGhpcy5zZXRHcmlkRm9jdXNGbGFnXG4gICAgICAgIH1cbiAgICAgIH0sIFskZ3JpZENhcHRpb24sICRncmlkV2Vla0RheXMsICRncmlkQm9keSwgJGdyaWRIZWxwXSk7IC8vIE9wdGlvbmFsIGJvdHRvbSBzbG90XG5cbiAgICAgIHZhciAkc2xvdCA9IHRoaXMubm9ybWFsaXplU2xvdCgnZGVmYXVsdCcpO1xuICAgICAgJHNsb3QgPSAkc2xvdCA/IGgoJ2Zvb3RlcicsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdtdC0yJ1xuICAgICAgfSwgJHNsb3QpIDogaCgpO1xuICAgICAgdmFyICR3aWRnZXQgPSBoKCdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiB0aGlzLmJsb2NrID8gJ2QtYmxvY2snIDogJ2QtaW5saW5lLWJsb2NrJyxcbiAgICAgICAgc3R5bGU6IHRoaXMuYmxvY2sgPyB7fSA6IHtcbiAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aFxuICAgICAgICB9LFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiBpZFdpZGdldCxcbiAgICAgICAgICBkaXI6IGlzUlRMID8gJ3J0bCcgOiAnbHRyJyxcbiAgICAgICAgICBsYW5nOiB0aGlzLmNvbXB1dGVkTG9jYWxlIHx8IG51bGwsXG4gICAgICAgICAgcm9sZTogJ2dyb3VwJyxcbiAgICAgICAgICAnYXJpYS1kaXNhYmxlZCc6IHRoaXMuZGlzYWJsZWQgPyAndHJ1ZScgOiBudWxsLFxuICAgICAgICAgIC8vIElmIGRhdGVwaWNrZXIgY29udHJvbHMgYW4gaW5wdXQsIHRoaXMgd2lsbCBzcGVjaWZ5IHRoZSBJRCBvZiB0aGUgaW5wdXRcbiAgICAgICAgICAnYXJpYS1jb250cm9scyc6IHRoaXMuYXJpYUNvbnRyb2xzIHx8IG51bGwsXG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgYSBwcm9wIChzbyBpdCBjYW4gYmUgY2hhbmdlZCB0byBEYXRlIHBpY2tlciwgZXRjLCBsb2NhbGl6ZWRcbiAgICAgICAgICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiB0aGlzLnJvbGVEZXNjcmlwdGlvbiB8fCBudWxsLFxuICAgICAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogWy8vIFNob3VsZCB0aGUgYXR0ciAoaWYgcHJlc2VudCkgZ28gbGFzdD9cbiAgICAgICAgICAvLyBPciBzaG91bGQgdGhpcyBhdHRyIGJlIGEgcHJvcD9cbiAgICAgICAgICB0aGlzLiRhdHRyc1snYXJpYS1kZXNjcmliZWRieSddLCBpZFZhbHVlLCBpZEdyaWRIZWxwXS5maWx0ZXIoaWRlbnRpdHkpLmpvaW4oJyAnKVxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGtleWRvd246IHRoaXMub25LZXlkb3duV3JhcHBlclxuICAgICAgICB9XG4gICAgICB9LCBbJGhlYWRlciwgJG5hdiwgJGdyaWQsICRzbG90XSk7IC8vIFdyYXAgaW4gYW4gb3V0ZXIgZGl2IHRoYXQgY2FuIGJlIHN0eWxlZFxuXG4gICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2ItY2FsZW5kYXInLFxuICAgICAgICAvLyBXZSB1c2UgYSBzdHlsZSBoZXJlIHJhdGhlciB0aGFuIGNsYXNzIGBkLWlubGluZS1ibG9ja2Agc28gdGhhdCB1c2VycyBjYW5cbiAgICAgICAgLy8gb3ZlcnJpZGUgdGhlIGRpc3BsYXkgdmFsdWUgKGBkLSpgIGNsYXNzZXMgdXNlIHRoZSBgIWltcG9ydGFudGAgZmxhZylcbiAgICAgICAgc3R5bGU6IHRoaXMuYmxvY2sgPyB7fSA6IHtcbiAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJ1xuICAgICAgICB9XG4gICAgICB9LCBbJHdpZGdldF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIENhbGVuZGFyUGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBCQ2FsZW5kYXI6IEJDYWxlbmRhclxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuXG4gIHZhciBwcmVmaXhQcm9wTmFtZSA9IGZ1bmN0aW9uIHByZWZpeFByb3BOYW1lKHByZWZpeCwgdmFsdWUpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgdXBwZXJGaXJzdCh2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuXG4gIHZhciB1bnByZWZpeFByb3BOYW1lID0gZnVuY3Rpb24gdW5wcmVmaXhQcm9wTmFtZShwcmVmaXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGxvd2VyRmlyc3QodmFsdWUucmVwbGFjZShwcmVmaXgsICcnKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvcGllcyBwcm9wcyBmcm9tIG9uZSBhcnJheS9vYmplY3QgdG8gYSBuZXcgYXJyYXkvb2JqZWN0LiBQcm9wIHZhbHVlc1xuICAgKiBhcmUgYWxzbyBjbG9uZWQgYXMgbmV3IHJlZmVyZW5jZXMgdG8gcHJldmVudCBwb3NzaWJsZSBtdXRhdGlvbiBvZiBvcmlnaW5hbFxuICAgKiBwcm9wIG9iamVjdCB2YWx1ZXMuIE9wdGlvbmFsbHkgYWNjZXB0cyBhIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSB0aGUgcHJvcCBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge1tdfHt9fSBwcm9wc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm1GblxuICAgKi9cblxuICB2YXIgY29weVByb3BzID0gZnVuY3Rpb24gY29weVByb3BzKHByb3BzKSB7XG4gICAgdmFyIHRyYW5zZm9ybUZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBpZGVudGl0eTtcblxuICAgIGlmIChpc0FycmF5KHByb3BzKSkge1xuICAgICAgcmV0dXJuIHByb3BzLm1hcCh0cmFuc2Zvcm1Gbik7XG4gICAgfSAvLyBQcm9wcyBhcyBhbiBvYmplY3QuXG5cblxuICAgIHZhciBjb3BpZWQgPSB7fTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gcHJvcHMpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgLy8gSWYgdGhlIHByb3AgdmFsdWUgaXMgYW4gb2JqZWN0LCBkbyBhIHNoYWxsb3cgY2xvbmUgdG8gcHJldmVudFxuICAgICAgICAvLyBwb3RlbnRpYWwgbXV0YXRpb25zIHRvIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAgIGNvcGllZFt0cmFuc2Zvcm1Gbihwcm9wKV0gPSBpc09iamVjdChwcm9wc1twcm9wXSkgPyBjbG9uZShwcm9wc1twcm9wXSkgOiBwcm9wc1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29waWVkO1xuICB9O1xuXG4gIC8vIEB2dWUvY29tcG9uZW50XG4gIHZhciBjYXJkTWl4aW4gPSB7XG4gICAgcHJvcHM6IHtcbiAgICAgIHRhZzoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICdkaXYnXG4gICAgICB9LFxuICAgICAgYmdWYXJpYW50OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIGJvcmRlclZhcmlhbnQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgdGV4dFZhcmlhbnQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBwcm9wcyQ2ID0ge1xuICAgIHRpdGxlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnJ1xuICAgIH0sXG4gICAgdGl0bGVUYWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdoNCdcbiAgICB9XG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJDYXJkVGl0bGUgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCQ2FyZFRpdGxlJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBwcm9wcyQ2LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gICAgICByZXR1cm4gaChwcm9wcy50aXRsZVRhZywgYShkYXRhLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnY2FyZC10aXRsZSdcbiAgICAgIH0pLCBjaGlsZHJlbiB8fCBwcm9wcy50aXRsZSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgTkFNRSQ3ID0gJ0JDYXJkU3ViVGl0bGUnO1xuICB2YXIgcHJvcHMkNyA9IHtcbiAgICBzdWJUaXRsZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJydcbiAgICB9LFxuICAgIHN1YlRpdGxlVGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnaDYnXG4gICAgfSxcbiAgICBzdWJUaXRsZVRleHRWYXJpYW50OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJDcsICdzdWJUaXRsZVRleHRWYXJpYW50Jyk7XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCQ2FyZFN1YlRpdGxlID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiBOQU1FJDcsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczogcHJvcHMkNyxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICAgICAgcmV0dXJuIGgocHJvcHMuc3ViVGl0bGVUYWcsIGEoZGF0YSwge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2NhcmQtc3VidGl0bGUnLFxuICAgICAgICBjbGFzczogW3Byb3BzLnN1YlRpdGxlVGV4dFZhcmlhbnQgPyBcInRleHQtXCIuY29uY2F0KHByb3BzLnN1YlRpdGxlVGV4dFZhcmlhbnQpIDogbnVsbF1cbiAgICAgIH0pLCBjaGlsZHJlbiB8fCBwcm9wcy5zdWJUaXRsZSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcHJvcHMkOCA9IF9vYmplY3RTcHJlYWQyKHt9LCBjb3B5UHJvcHMoY2FyZE1peGluLnByb3BzLCBwcmVmaXhQcm9wTmFtZS5iaW5kKG51bGwsICdib2R5JykpLCB7XG4gICAgYm9keUNsYXNzOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3QsIEFycmF5XSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9XG4gIH0sIHByb3BzJDYsIHt9LCBwcm9wcyQ3LCB7XG4gICAgb3ZlcmxheToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9KTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkNhcmRCb2R5ID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQkNhcmRCb2R5JyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBwcm9wcyQ4LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBfcmVmMjtcblxuICAgICAgdmFyIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgICAgIHZhciBjYXJkVGl0bGUgPSBoKCk7XG4gICAgICB2YXIgY2FyZFN1YlRpdGxlID0gaCgpO1xuICAgICAgdmFyIGNhcmRDb250ZW50ID0gY2hpbGRyZW4gfHwgW2goKV07XG5cbiAgICAgIGlmIChwcm9wcy50aXRsZSkge1xuICAgICAgICBjYXJkVGl0bGUgPSBoKEJDYXJkVGl0bGUsIHtcbiAgICAgICAgICBwcm9wczogcGx1Y2tQcm9wcyhwcm9wcyQ2LCBwcm9wcylcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5zdWJUaXRsZSkge1xuICAgICAgICBjYXJkU3ViVGl0bGUgPSBoKEJDYXJkU3ViVGl0bGUsIHtcbiAgICAgICAgICBwcm9wczogcGx1Y2tQcm9wcyhwcm9wcyQ3LCBwcm9wcyksXG4gICAgICAgICAgY2xhc3M6IFsnbWItMiddXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaChwcm9wcy5ib2R5VGFnLCBhKGRhdGEsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdjYXJkLWJvZHknLFxuICAgICAgICBjbGFzczogWyhfcmVmMiA9IHtcbiAgICAgICAgICAnY2FyZC1pbWctb3ZlcmxheSc6IHByb3BzLm92ZXJsYXlcbiAgICAgICAgfSwgX2RlZmluZVByb3BlcnR5KF9yZWYyLCBcImJnLVwiLmNvbmNhdChwcm9wcy5ib2R5QmdWYXJpYW50KSwgcHJvcHMuYm9keUJnVmFyaWFudCksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMiwgXCJib3JkZXItXCIuY29uY2F0KHByb3BzLmJvZHlCb3JkZXJWYXJpYW50KSwgcHJvcHMuYm9keUJvcmRlclZhcmlhbnQpLCBfZGVmaW5lUHJvcGVydHkoX3JlZjIsIFwidGV4dC1cIi5jb25jYXQocHJvcHMuYm9keVRleHRWYXJpYW50KSwgcHJvcHMuYm9keVRleHRWYXJpYW50KSwgX3JlZjIpLCBwcm9wcy5ib2R5Q2xhc3MgfHwge31dXG4gICAgICB9KSwgW2NhcmRUaXRsZSwgY2FyZFN1YlRpdGxlXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGNhcmRDb250ZW50KSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHByb3BzJDkgPSBfb2JqZWN0U3ByZWFkMih7fSwgY29weVByb3BzKGNhcmRNaXhpbi5wcm9wcywgcHJlZml4UHJvcE5hbWUuYmluZChudWxsLCAnaGVhZGVyJykpLCB7XG4gICAgaGVhZGVyOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBoZWFkZXJIdG1sOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBoZWFkZXJDbGFzczoge1xuICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0LCBBcnJheV0sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfVxuICB9KTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkNhcmRIZWFkZXIgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCQ2FyZEhlYWRlcicsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczogcHJvcHMkOSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgX3JlZjI7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gICAgICByZXR1cm4gaChwcm9wcy5oZWFkZXJUYWcsIGEoZGF0YSwge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2NhcmQtaGVhZGVyJyxcbiAgICAgICAgY2xhc3M6IFtwcm9wcy5oZWFkZXJDbGFzcywgKF9yZWYyID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfcmVmMiwgXCJiZy1cIi5jb25jYXQocHJvcHMuaGVhZGVyQmdWYXJpYW50KSwgcHJvcHMuaGVhZGVyQmdWYXJpYW50KSwgX2RlZmluZVByb3BlcnR5KF9yZWYyLCBcImJvcmRlci1cIi5jb25jYXQocHJvcHMuaGVhZGVyQm9yZGVyVmFyaWFudCksIHByb3BzLmhlYWRlckJvcmRlclZhcmlhbnQpLCBfZGVmaW5lUHJvcGVydHkoX3JlZjIsIFwidGV4dC1cIi5jb25jYXQocHJvcHMuaGVhZGVyVGV4dFZhcmlhbnQpLCBwcm9wcy5oZWFkZXJUZXh0VmFyaWFudCksIF9yZWYyKV1cbiAgICAgIH0pLCBjaGlsZHJlbiB8fCBbaCgnZGl2Jywge1xuICAgICAgICBkb21Qcm9wczogaHRtbE9yVGV4dChwcm9wcy5oZWFkZXJIdG1sLCBwcm9wcy5oZWFkZXIpXG4gICAgICB9KV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHByb3BzJGEgPSBfb2JqZWN0U3ByZWFkMih7fSwgY29weVByb3BzKGNhcmRNaXhpbi5wcm9wcywgcHJlZml4UHJvcE5hbWUuYmluZChudWxsLCAnZm9vdGVyJykpLCB7XG4gICAgZm9vdGVyOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBmb290ZXJIdG1sOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBmb290ZXJDbGFzczoge1xuICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0LCBBcnJheV0sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfVxuICB9KTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkNhcmRGb290ZXIgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCQ2FyZEZvb3RlcicsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczogcHJvcHMkYSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgX3JlZjI7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gICAgICByZXR1cm4gaChwcm9wcy5mb290ZXJUYWcsIGEoZGF0YSwge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2NhcmQtZm9vdGVyJyxcbiAgICAgICAgY2xhc3M6IFtwcm9wcy5mb290ZXJDbGFzcywgKF9yZWYyID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfcmVmMiwgXCJiZy1cIi5jb25jYXQocHJvcHMuZm9vdGVyQmdWYXJpYW50KSwgcHJvcHMuZm9vdGVyQmdWYXJpYW50KSwgX2RlZmluZVByb3BlcnR5KF9yZWYyLCBcImJvcmRlci1cIi5jb25jYXQocHJvcHMuZm9vdGVyQm9yZGVyVmFyaWFudCksIHByb3BzLmZvb3RlckJvcmRlclZhcmlhbnQpLCBfZGVmaW5lUHJvcGVydHkoX3JlZjIsIFwidGV4dC1cIi5jb25jYXQocHJvcHMuZm9vdGVyVGV4dFZhcmlhbnQpLCBwcm9wcy5mb290ZXJUZXh0VmFyaWFudCksIF9yZWYyKV1cbiAgICAgIH0pLCBjaGlsZHJlbiB8fCBbaCgnZGl2Jywge1xuICAgICAgICBkb21Qcm9wczogaHRtbE9yVGV4dChwcm9wcy5mb290ZXJIdG1sLCBwcm9wcy5mb290ZXIpXG4gICAgICB9KV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHByb3BzJGIgPSB7XG4gICAgc3JjOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIGFsdDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgdG9wOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBzdGFydDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICAvLyBhbGlhcyBvZiAnc3RhcnQnXG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGVuZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgLy8gYWxpYXMgb2YgJ2VuZCdcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgaGVpZ2h0OiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgd2lkdGg6IHtcbiAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfVxuICB9OyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCQ2FyZEltZyA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JDYXJkSW1nJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBwcm9wcyRiLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YTtcbiAgICAgIHZhciBiYXNlQ2xhc3MgPSAnY2FyZC1pbWcnO1xuXG4gICAgICBpZiAocHJvcHMudG9wKSB7XG4gICAgICAgIGJhc2VDbGFzcyArPSAnLXRvcCc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BzLnJpZ2h0IHx8IHByb3BzLmVuZCkge1xuICAgICAgICBiYXNlQ2xhc3MgKz0gJy1yaWdodCc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BzLmJvdHRvbSkge1xuICAgICAgICBiYXNlQ2xhc3MgKz0gJy1ib3R0b20nO1xuICAgICAgfSBlbHNlIGlmIChwcm9wcy5sZWZ0IHx8IHByb3BzLnN0YXJ0KSB7XG4gICAgICAgIGJhc2VDbGFzcyArPSAnLWxlZnQnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaCgnaW1nJywgYShkYXRhLCB7XG4gICAgICAgIGNsYXNzOiBbYmFzZUNsYXNzXSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBzcmM6IHByb3BzLnNyYyxcbiAgICAgICAgICBhbHQ6IHByb3BzLmFsdCxcbiAgICAgICAgICBoZWlnaHQ6IHByb3BzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aDogcHJvcHMud2lkdGhcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGNhcmRJbWdQcm9wcyA9IGNvcHlQcm9wcyhwcm9wcyRiLCBwcmVmaXhQcm9wTmFtZS5iaW5kKG51bGwsICdpbWcnKSk7XG4gIGNhcmRJbWdQcm9wcy5pbWdTcmMucmVxdWlyZWQgPSBmYWxzZTtcbiAgdmFyIHByb3BzJGMgPSBfb2JqZWN0U3ByZWFkMih7fSwgcHJvcHMkOCwge30sIHByb3BzJDksIHt9LCBwcm9wcyRhLCB7fSwgY2FyZEltZ1Byb3BzLCB7fSwgY29weVByb3BzKGNhcmRNaXhpbi5wcm9wcyksIHtcbiAgICBhbGlnbjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgbm9Cb2R5OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH0pOyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCQ2FyZCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JDYXJkJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBwcm9wcyRjLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBfY2xhc3M7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBzbG90cyA9IF9yZWYuc2xvdHMsXG4gICAgICAgICAgc2NvcGVkU2xvdHMgPSBfcmVmLnNjb3BlZFNsb3RzO1xuICAgICAgdmFyICRzbG90cyA9IHNsb3RzKCk7IC8vIFZ1ZSA8IDIuNi54IG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciBzY29wZWRTbG90c1xuXG4gICAgICB2YXIgJHNjb3BlZFNsb3RzID0gc2NvcGVkU2xvdHMgfHwge307IC8vIENyZWF0ZSBwbGFjZWhvbGRlciBlbGVtZW50cyBmb3IgZWFjaCBzZWN0aW9uXG5cbiAgICAgIHZhciBpbWdGaXJzdCA9IGgoKTtcbiAgICAgIHZhciBoZWFkZXIgPSBoKCk7XG4gICAgICB2YXIgY29udGVudCA9IGgoKTtcbiAgICAgIHZhciBmb290ZXIgPSBoKCk7XG4gICAgICB2YXIgaW1nTGFzdCA9IGgoKTtcblxuICAgICAgaWYgKHByb3BzLmltZ1NyYykge1xuICAgICAgICB2YXIgaW1nID0gaChCQ2FyZEltZywge1xuICAgICAgICAgIHByb3BzOiBwbHVja1Byb3BzKGNhcmRJbWdQcm9wcywgcHJvcHMsIHVucHJlZml4UHJvcE5hbWUuYmluZChudWxsLCAnaW1nJykpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwcm9wcy5pbWdCb3R0b20pIHtcbiAgICAgICAgICBpbWdMYXN0ID0gaW1nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltZ0ZpcnN0ID0gaW1nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5oZWFkZXIgfHwgaGFzTm9ybWFsaXplZFNsb3QoJ2hlYWRlcicsICRzY29wZWRTbG90cywgJHNsb3RzKSkge1xuICAgICAgICBoZWFkZXIgPSBoKEJDYXJkSGVhZGVyLCB7XG4gICAgICAgICAgcHJvcHM6IHBsdWNrUHJvcHMocHJvcHMkOSwgcHJvcHMpXG4gICAgICAgIH0sIG5vcm1hbGl6ZVNsb3QoJ2hlYWRlcicsIHt9LCAkc2NvcGVkU2xvdHMsICRzbG90cykpO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50ID0gbm9ybWFsaXplU2xvdCgnZGVmYXVsdCcsIHt9LCAkc2NvcGVkU2xvdHMsICRzbG90cykgfHwgW107XG5cbiAgICAgIGlmICghcHJvcHMubm9Cb2R5KSB7XG4gICAgICAgIC8vIFdyYXAgY29udGVudCBpbiBjYXJkLWJvZHlcbiAgICAgICAgY29udGVudCA9IFtoKEJDYXJkQm9keSwge1xuICAgICAgICAgIHByb3BzOiBwbHVja1Byb3BzKHByb3BzJDgsIHByb3BzKVxuICAgICAgICB9LCBfdG9Db25zdW1hYmxlQXJyYXkoY29udGVudCkpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLmZvb3RlciB8fCBoYXNOb3JtYWxpemVkU2xvdCgnZm9vdGVyJywgJHNjb3BlZFNsb3RzLCAkc2xvdHMpKSB7XG4gICAgICAgIGZvb3RlciA9IGgoQkNhcmRGb290ZXIsIHtcbiAgICAgICAgICBwcm9wczogcGx1Y2tQcm9wcyhwcm9wcyRhLCBwcm9wcylcbiAgICAgICAgfSwgbm9ybWFsaXplU2xvdCgnZm9vdGVyJywge30sICRzY29wZWRTbG90cywgJHNsb3RzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoKHByb3BzLnRhZywgYShkYXRhLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnY2FyZCcsXG4gICAgICAgIGNsYXNzOiAoX2NsYXNzID0ge1xuICAgICAgICAgICdmbGV4LXJvdyc6IHByb3BzLmltZ0xlZnQgfHwgcHJvcHMuaW1nU3RhcnQsXG4gICAgICAgICAgJ2ZsZXgtcm93LXJldmVyc2UnOiAocHJvcHMuaW1nUmlnaHQgfHwgcHJvcHMuaW1nRW5kKSAmJiAhKHByb3BzLmltZ0xlZnQgfHwgcHJvcHMuaW1nU3RhcnQpXG4gICAgICAgIH0sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsIFwidGV4dC1cIi5jb25jYXQocHJvcHMuYWxpZ24pLCBwcm9wcy5hbGlnbiksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsIFwiYmctXCIuY29uY2F0KHByb3BzLmJnVmFyaWFudCksIHByb3BzLmJnVmFyaWFudCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsIFwiYm9yZGVyLVwiLmNvbmNhdChwcm9wcy5ib3JkZXJWYXJpYW50KSwgcHJvcHMuYm9yZGVyVmFyaWFudCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsIFwidGV4dC1cIi5jb25jYXQocHJvcHMudGV4dFZhcmlhbnQpLCBwcm9wcy50ZXh0VmFyaWFudCksIF9jbGFzcylcbiAgICAgIH0pLCBbaW1nRmlyc3QsIGhlYWRlcl0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjb250ZW50KSwgW2Zvb3RlciwgaW1nTGFzdF0pKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBPQlNFUlZFUl9QUk9QX05BTUUgPSAnX19idl9fdmlzaWJpbGl0eV9vYnNlcnZlcic7XG4gIHZhciBvbmx5RGdpdHNSRSA9IC9eXFxkKyQvO1xuXG4gIHZhciBWaXNpYmlsaXR5T2JzZXJ2ZXIgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaXNpYmlsaXR5T2JzZXJ2ZXIoZWwsIG9wdGlvbnMsIHZub2RlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlzaWJpbGl0eU9ic2VydmVyKTtcblxuICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgICB0aGlzLm1hcmdpbiA9IG9wdGlvbnMubWFyZ2luIHx8IDA7XG4gICAgICB0aGlzLm9uY2UgPSBvcHRpb25zLm9uY2UgfHwgZmFsc2U7XG4gICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgIHRoaXMudmlzaWJsZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZU9uY2UgPSBmYWxzZTsgLy8gQ3JlYXRlIHRoZSBvYnNlcnZlciBpbnN0YW5jZSAoaWYgcG9zc2libGUpXG5cbiAgICAgIHRoaXMuY3JlYXRlT2JzZXJ2ZXIodm5vZGUpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhWaXNpYmlsaXR5T2JzZXJ2ZXIsIFt7XG4gICAgICBrZXk6IFwiY3JlYXRlT2JzZXJ2ZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVPYnNlcnZlcih2bm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIC8vIFJlbW92ZSBhbnkgcHJldmlvdXMgb2JzZXJ2ZXJcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9IC8vIFNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlIGFuZCBgY2FsbGJhY2tgIHByb3Agc2hvdWxkIGJlIGEgZnVuY3Rpb25cblxuXG4gICAgICAgIGlmICh0aGlzLmRvbmVPbmNlIHx8ICFpc0Z1bmN0aW9uKHRoaXMuY2FsbGJhY2spKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ3JlYXRlIHRoZSBvYnNlcnZlciBpbnN0YW5jZVxuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBGdXR1cmU6IFBvc3NpYmx5IGFkZCBpbiBvdGhlciBtb2RpZmllcnMgZm9yIGxlZnQvcmlnaHQvdG9wL2JvdHRvbVxuICAgICAgICAgIC8vIG9mZnNldHMsIHJvb3QgZWxlbWVudCByZWZlcmVuY2UsIGFuZCB0aHJlc2hvbGRzXG4gICAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcih0aGlzLmhhbmRsZXIuYmluZCh0aGlzKSwge1xuICAgICAgICAgICAgLy8gYG51bGxgID0gJ3ZpZXdwb3J0J1xuICAgICAgICAgICAgcm9vdDogbnVsbCxcbiAgICAgICAgICAgIC8vIFBpeGVscyBhd2F5IGZyb20gdmlldyBwb3J0IHRvIGNvbnNpZGVyIFwidmlzaWJsZVwiXG4gICAgICAgICAgICByb290TWFyZ2luOiB0aGlzLm1hcmdpbixcbiAgICAgICAgICAgIC8vIEludGVyc2VjdGlvbiByYXRpbyBvZiBlbCBhbmQgcm9vdCAoYXMgYSB2YWx1ZSBmcm9tIDAgdG8gMSlcbiAgICAgICAgICAgIHRocmVzaG9sZDogMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgICAgLy8gTm8gSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgc3VwcG9ydCwgc28ganVzdCBzdG9wIHRyeWluZyB0byBvYnNlcnZlXG4gICAgICAgICAgdGhpcy5kb25lT25jZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5vYnNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdGFydCBvYnNlcnZpbmcgaW4gYSBgJG5leHRUaWNrKClgICh0byBhbGxvdyBET00gdG8gY29tcGxldGUgcmVuZGVyaW5nKVxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBJbnRlcnNlY3Rpb25PYnNlcnZlciBub3Qgc3VwcG9ydGVkIGluIEpTRE9NICovXG5cblxuICAgICAgICB2bm9kZS5jb250ZXh0LiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVxdWVzdEFGKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFBsYWNlZCBpbiBhbiBgaWZgIGp1c3QgaW4gY2FzZSB3ZSB3ZXJlIGRlc3Ryb3llZCBiZWZvcmVcbiAgICAgICAgICAgIC8vIHRoaXMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgcnVuc1xuICAgICAgICAgICAgaWYgKF90aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICAgIF90aGlzLm9ic2VydmVyLm9ic2VydmUoX3RoaXMuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZXIoZW50cmllcylcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBJbnRlcnNlY3Rpb25PYnNlcnZlciBub3Qgc3VwcG9ydGVkIGluIEpTRE9NICovXG4gICAgICB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXMgPyBlbnRyaWVzWzBdIDoge307XG4gICAgICAgIHZhciBpc0ludGVyc2VjdGluZyA9IEJvb2xlYW4oZW50cnkuaXNJbnRlcnNlY3RpbmcgfHwgZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwLjApO1xuXG4gICAgICAgIGlmIChpc0ludGVyc2VjdGluZyAhPT0gdGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgdGhpcy52aXNpYmxlID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgdGhpcy5jYWxsYmFjayhpc0ludGVyc2VjdGluZyk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vbmNlICYmIHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5kb25lT25jZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RvcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgICAgaWYgKG9ic2VydmVyICYmIG9ic2VydmVyLmRpc2Nvbm5lY3QpIHtcbiAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVmlzaWJpbGl0eU9ic2VydmVyO1xuICB9KCk7XG5cbiAgdmFyIGRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KGVsKSB7XG4gICAgdmFyIG9ic2VydmVyID0gZWxbT0JTRVJWRVJfUFJPUF9OQU1FXTtcblxuICAgIGlmIChvYnNlcnZlciAmJiBvYnNlcnZlci5zdG9wKSB7XG4gICAgICBvYnNlcnZlci5zdG9wKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIGVsW09CU0VSVkVSX1BST1BfTkFNRV07XG4gIH07XG5cbiAgdmFyIGJpbmQgPSBmdW5jdGlvbiBiaW5kKGVsLCBfcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICAgIG1vZGlmaWVycyA9IF9yZWYubW9kaWZpZXJzO1xuICAgIC8vIGB2YWx1ZWAgaXMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBtYXJnaW46ICcwcHgnLFxuICAgICAgb25jZTogZmFsc2UsXG4gICAgICBjYWxsYmFjazogdmFsdWVcbiAgICB9OyAvLyBQYXJzZSBtb2RpZmllcnNcblxuICAgIGtleXMobW9kaWZpZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBVbnRpbCA8Yi1pbWctbGF6eT4gaXMgc3dpdGNoZWQgdG8gdXNlIHRoaXMgZGlyZWN0aXZlICovXG4gICAgICBpZiAob25seURnaXRzUkUudGVzdChtb2QpKSB7XG4gICAgICAgIG9wdGlvbnMubWFyZ2luID0gXCJcIi5jb25jYXQobW9kLCBcInB4XCIpO1xuICAgICAgfSBlbHNlIGlmIChtb2QudG9Mb3dlckNhc2UoKSA9PT0gJ29uY2UnKSB7XG4gICAgICAgIG9wdGlvbnMub25jZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7IC8vIERlc3Ryb3kgYW55IHByZXZpb3VzIG9ic2VydmVyXG5cbiAgICBkZXN0cm95KGVsKTsgLy8gQ3JlYXRlIG5ldyBvYnNlcnZlclxuXG4gICAgZWxbT0JTRVJWRVJfUFJPUF9OQU1FXSA9IG5ldyBWaXNpYmlsaXR5T2JzZXJ2ZXIoZWwsIG9wdGlvbnMsIHZub2RlKTsgLy8gU3RvcmUgdGhlIGN1cnJlbnQgbW9kaWZpZXJzIG9uIHRoZSBvYmplY3QgKGNsb25lZClcblxuICAgIGVsW09CU0VSVkVSX1BST1BfTkFNRV0uX3ByZXZNb2RpZmllcnMgPSBjbG9uZShtb2RpZmllcnMpO1xuICB9OyAvLyBXaGVuIHRoZSBkaXJlY3RpdmUgb3B0aW9ucyBtYXkgaGF2ZSBiZWVuIHVwZGF0ZWQgKG9yIGVsZW1lbnQpXG5cblxuICB2YXIgY29tcG9uZW50VXBkYXRlZCA9IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQoZWwsIF9yZWYyLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlLFxuICAgICAgICBvbGRWYWx1ZSA9IF9yZWYyLm9sZFZhbHVlLFxuICAgICAgICBtb2RpZmllcnMgPSBfcmVmMi5tb2RpZmllcnM7XG4gICAgLy8gQ29tcGFyZSB2YWx1ZS9vbGRWYWx1ZSBhbmQgbW9kaWZpZXJzIHRvIHNlZSBpZiBhbnl0aGluZyBoYXMgY2hhbmdlZFxuICAgIC8vIGFuZCBpZiBzbywgZGVzdHJveSBvbGQgb2JzZXJ2ZXIgYW5kIGNyZWF0ZSBuZXcgb2JzZXJ2ZXJcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgbW9kaWZpZXJzID0gY2xvbmUobW9kaWZpZXJzKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgaWYgKGVsICYmICh2YWx1ZSAhPT0gb2xkVmFsdWUgfHwgIWVsW09CU0VSVkVSX1BST1BfTkFNRV0gfHwgIWxvb3NlRXF1YWwobW9kaWZpZXJzLCBlbFtPQlNFUlZFUl9QUk9QX05BTUVdLl9wcmV2TW9kaWZpZXJzKSkpIHtcbiAgICAgIC8vIFJlLWJpbmQgb24gZWxlbWVudFxuICAgICAgYmluZChlbCwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzXG4gICAgICB9LCB2bm9kZSk7XG4gICAgfVxuICB9OyAvLyBXaGVuIGRpcmVjdGl2ZSB1bi1iaW5kcyBmcm9tIGVsZW1lbnRcblxuXG4gIHZhciB1bmJpbmQgPSBmdW5jdGlvbiB1bmJpbmQoZWwpIHtcbiAgICAvLyBSZW1vdmUgdGhlIG9ic2VydmVyXG4gICAgZGVzdHJveShlbCk7XG4gIH07IC8vIEV4cG9ydCB0aGUgZGlyZWN0aXZlXG5cblxuICB2YXIgVkJWaXNpYmxlID0ge1xuICAgIGJpbmQ6IGJpbmQsXG4gICAgY29tcG9uZW50VXBkYXRlZDogY29tcG9uZW50VXBkYXRlZCxcbiAgICB1bmJpbmQ6IHVuYmluZFxuICB9O1xuXG4gIHZhciBOQU1FJDggPSAnQkltZyc7IC8vIEJsYW5rIGltYWdlIHdpdGggZmlsbCB0ZW1wbGF0ZVxuXG4gIHZhciBCTEFOS19URU1QTEFURSA9ICc8c3ZnIHdpZHRoPVwiJXt3fVwiIGhlaWdodD1cIiV7aH1cIiAnICsgJ3htbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnICsgJ3ZpZXdCb3g9XCIwIDAgJXt3fSAle2h9XCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cIm5vbmVcIj4nICsgJzxyZWN0IHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiBzdHlsZT1cImZpbGw6JXtmfTtcIj48L3JlY3Q+JyArICc8L3N2Zz4nO1xuICB2YXIgcHJvcHMkZCA9IHtcbiAgICBzcmM6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIHNyY3NldDoge1xuICAgICAgdHlwZTogW1N0cmluZywgQXJyYXldLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgc2l6ZXM6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5XSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGFsdDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgd2lkdGg6IHtcbiAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBoZWlnaHQ6IHtcbiAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBibG9jazoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBmbHVpZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBmbHVpZEdyb3c6IHtcbiAgICAgIC8vIEdpdmVzIGZsdWlkIGltYWdlcyBjbGFzcyBgdy0xMDBgIHRvIG1ha2UgdGhlbSBncm93IHRvIGZpdCBjb250YWluZXJcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgcm91bmRlZDoge1xuICAgICAgLy8gcm91bmRlZCBjYW4gYmU6XG4gICAgICAvLyAgIGZhbHNlOiBubyByb3VuZGluZyBvZiBjb3JuZXJzXG4gICAgICAvLyAgIHRydWU6IHNsaWdodGx5IHJvdW5kZWQgY29ybmVyc1xuICAgICAgLy8gICAndG9wJzogdG9wIGNvcm5lcnMgcm91bmRlZFxuICAgICAgLy8gICAncmlnaHQnOiByaWdodCBjb3JuZXJzIHJvdW5kZWRcbiAgICAgIC8vICAgJ2JvdHRvbSc6IGJvdHRvbSBjb3JuZXJzIHJvdW5kZWRcbiAgICAgIC8vICAgJ2xlZnQnOiBsZWZ0IGNvcm5lcnMgcm91bmRlZFxuICAgICAgLy8gICAnY2lyY2xlJzogY2lyY2xlL292YWxcbiAgICAgIC8vICAgJzAnOiBmb3JjZSByb3VuZGluZyBvZmZcbiAgICAgIHR5cGU6IFtCb29sZWFuLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHRodW1ibmFpbDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGNlbnRlcjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBibGFuazoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBibGFua0NvbG9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJDgsICdibGFua0NvbG9yJyk7XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyAtLS0gSGVscGVyIG1ldGhvZHMgLS0tXG5cbiAgdmFyIG1ha2VCbGFua0ltZ1NyYyA9IGZ1bmN0aW9uIG1ha2VCbGFua0ltZ1NyYyh3aWR0aCwgaGVpZ2h0LCBjb2xvcikge1xuICAgIHZhciBzcmMgPSBlbmNvZGVVUklDb21wb25lbnQoQkxBTktfVEVNUExBVEUucmVwbGFjZSgnJXt3fScsIHRvU3RyaW5nJDEod2lkdGgpKS5yZXBsYWNlKCcle2h9JywgdG9TdHJpbmckMShoZWlnaHQpKS5yZXBsYWNlKCcle2Z9JywgY29sb3IpKTtcbiAgICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD1VVEYtOCxcIi5jb25jYXQoc3JjKTtcbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuXG4gIHZhciBCSW1nID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiBOQU1FJDgsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczogcHJvcHMkZCxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgX2NsYXNzO1xuXG4gICAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGE7XG4gICAgICB2YXIgc3JjID0gcHJvcHMuc3JjO1xuICAgICAgdmFyIHdpZHRoID0gdG9JbnRlZ2VyKHByb3BzLndpZHRoKSB8fCBudWxsO1xuICAgICAgdmFyIGhlaWdodCA9IHRvSW50ZWdlcihwcm9wcy5oZWlnaHQpIHx8IG51bGw7XG4gICAgICB2YXIgYWxpZ24gPSBudWxsO1xuICAgICAgdmFyIGJsb2NrID0gcHJvcHMuYmxvY2s7XG4gICAgICB2YXIgc3Jjc2V0ID0gY29uY2F0KHByb3BzLnNyY3NldCkuZmlsdGVyKGlkZW50aXR5KS5qb2luKCcsJyk7XG4gICAgICB2YXIgc2l6ZXMgPSBjb25jYXQocHJvcHMuc2l6ZXMpLmZpbHRlcihpZGVudGl0eSkuam9pbignLCcpO1xuXG4gICAgICBpZiAocHJvcHMuYmxhbmspIHtcbiAgICAgICAgaWYgKCFoZWlnaHQgJiYgd2lkdGgpIHtcbiAgICAgICAgICBoZWlnaHQgPSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIGlmICghd2lkdGggJiYgaGVpZ2h0KSB7XG4gICAgICAgICAgd2lkdGggPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXdpZHRoICYmICFoZWlnaHQpIHtcbiAgICAgICAgICB3aWR0aCA9IDE7XG4gICAgICAgICAgaGVpZ2h0ID0gMTtcbiAgICAgICAgfSAvLyBNYWtlIGEgYmxhbmsgU1ZHIGltYWdlXG5cblxuICAgICAgICBzcmMgPSBtYWtlQmxhbmtJbWdTcmMod2lkdGgsIGhlaWdodCwgcHJvcHMuYmxhbmtDb2xvciB8fCAndHJhbnNwYXJlbnQnKTsgLy8gRGlzYWJsZSBzcmNzZXQgYW5kIHNpemVzXG5cbiAgICAgICAgc3Jjc2V0ID0gbnVsbDtcbiAgICAgICAgc2l6ZXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMubGVmdCkge1xuICAgICAgICBhbGlnbiA9ICdmbG9hdC1sZWZ0JztcbiAgICAgIH0gZWxzZSBpZiAocHJvcHMucmlnaHQpIHtcbiAgICAgICAgYWxpZ24gPSAnZmxvYXQtcmlnaHQnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wcy5jZW50ZXIpIHtcbiAgICAgICAgYWxpZ24gPSAnbXgtYXV0byc7XG4gICAgICAgIGJsb2NrID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGgoJ2ltZycsIGEoZGF0YSwge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHNyYzogc3JjLFxuICAgICAgICAgIGFsdDogcHJvcHMuYWx0LFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCA/IHRvU3RyaW5nJDEod2lkdGgpIDogbnVsbCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/IHRvU3RyaW5nJDEoaGVpZ2h0KSA6IG51bGwsXG4gICAgICAgICAgc3Jjc2V0OiBzcmNzZXQgfHwgbnVsbCxcbiAgICAgICAgICBzaXplczogc2l6ZXMgfHwgbnVsbFxuICAgICAgICB9LFxuICAgICAgICBjbGFzczogKF9jbGFzcyA9IHtcbiAgICAgICAgICAnaW1nLXRodW1ibmFpbCc6IHByb3BzLnRodW1ibmFpbCxcbiAgICAgICAgICAnaW1nLWZsdWlkJzogcHJvcHMuZmx1aWQgfHwgcHJvcHMuZmx1aWRHcm93LFxuICAgICAgICAgICd3LTEwMCc6IHByb3BzLmZsdWlkR3JvdyxcbiAgICAgICAgICByb3VuZGVkOiBwcm9wcy5yb3VuZGVkID09PSAnJyB8fCBwcm9wcy5yb3VuZGVkID09PSB0cnVlXG4gICAgICAgIH0sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsIFwicm91bmRlZC1cIi5jb25jYXQocHJvcHMucm91bmRlZCksIGlzU3RyaW5nKHByb3BzLnJvdW5kZWQpICYmIHByb3BzLnJvdW5kZWQgIT09ICcnKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzcywgYWxpZ24sIGFsaWduKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzcywgJ2QtYmxvY2snLCBibG9jayksIF9jbGFzcylcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBOQU1FJDkgPSAnQkltZ0xhenknO1xuICB2YXIgcHJvcHMkZSA9IHtcbiAgICBzcmM6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgc3Jjc2V0OiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBzaXplczoge1xuICAgICAgdHlwZTogW1N0cmluZywgQXJyYXldLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgYWx0OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICB3aWR0aDoge1xuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGhlaWdodDoge1xuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGJsYW5rU3JjOiB7XG4gICAgICAvLyBJZiBudWxsLCBhIGJsYW5rIGltYWdlIGlzIGdlbmVyYXRlZFxuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgYmxhbmtDb2xvcjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSQ5LCAnYmxhbmtDb2xvcicpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYmxhbmtXaWR0aDoge1xuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGJsYW5rSGVpZ2h0OiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgc2hvdzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBmbHVpZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBmbHVpZEdyb3c6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgYmxvY2s6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgdGh1bWJuYWlsOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHJvdW5kZWQ6IHtcbiAgICAgIHR5cGU6IFtCb29sZWFuLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgY2VudGVyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIG9mZnNldDoge1xuICAgICAgLy8gRGlzdGFuY2UgYXdheSBmcm9tIHZpZXdwb3J0IChpbiBwaXhlbHMpIGJlZm9yZSBiZWluZ1xuICAgICAgLy8gY29uc2lkZXJlZCBcInZpc2libGVcIlxuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6IDM2MFxuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkltZ0xhenkgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6IE5BTUUkOSxcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICBiVmlzaWJsZTogVkJWaXNpYmxlXG4gICAgfSxcbiAgICBwcm9wczogcHJvcHMkZSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNTaG93bjogdGhpcy5zaG93XG4gICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGNvbXB1dGVkU3JjOiBmdW5jdGlvbiBjb21wdXRlZFNyYygpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmJsYW5rU3JjIHx8IHRoaXMuaXNTaG93biA/IHRoaXMuc3JjIDogdGhpcy5ibGFua1NyYztcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZEJsYW5rOiBmdW5jdGlvbiBjb21wdXRlZEJsYW5rKCkge1xuICAgICAgICByZXR1cm4gISh0aGlzLmlzU2hvd24gfHwgdGhpcy5ibGFua1NyYyk7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRXaWR0aDogZnVuY3Rpb24gY29tcHV0ZWRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTaG93biA/IHRoaXMud2lkdGggOiB0aGlzLmJsYW5rV2lkdGggfHwgdGhpcy53aWR0aDtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZEhlaWdodDogZnVuY3Rpb24gY29tcHV0ZWRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2hvd24gPyB0aGlzLmhlaWdodCA6IHRoaXMuYmxhbmtIZWlnaHQgfHwgdGhpcy5oZWlnaHQ7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRTcmNzZXQ6IGZ1bmN0aW9uIGNvbXB1dGVkU3Jjc2V0KCkge1xuICAgICAgICB2YXIgc3Jjc2V0ID0gY29uY2F0KHRoaXMuc3Jjc2V0KS5maWx0ZXIoaWRlbnRpdHkpLmpvaW4oJywnKTtcbiAgICAgICAgcmV0dXJuICF0aGlzLmJsYW5rU3JjIHx8IHRoaXMuaXNTaG93biA/IHNyY3NldCA6IG51bGw7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRTaXplczogZnVuY3Rpb24gY29tcHV0ZWRTaXplcygpIHtcbiAgICAgICAgdmFyIHNpemVzID0gY29uY2F0KHRoaXMuc2l6ZXMpLmZpbHRlcihpZGVudGl0eSkuam9pbignLCcpO1xuICAgICAgICByZXR1cm4gIXRoaXMuYmxhbmtTcmMgfHwgdGhpcy5pc1Nob3duID8gc2l6ZXMgOiBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgIHNob3c6IGZ1bmN0aW9uIHNob3cobmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgaWYgKG5ld1ZhbCAhPT0gb2xkVmFsKSB7XG4gICAgICAgICAgLy8gSWYgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgc3VwcG9ydCBpcyBub3QgYXZhaWxhYmxlLCBpbWFnZSBpcyBhbHdheXMgc2hvd25cbiAgICAgICAgICB2YXIgdmlzaWJsZSA9IGhhc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydCA/IG5ld1ZhbCA6IHRydWU7XG4gICAgICAgICAgdGhpcy5pc1Nob3duID0gdmlzaWJsZTtcblxuICAgICAgICAgIGlmICh2aXNpYmxlICE9PSBuZXdWYWwpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgc2hvdyBwcm9wIGlzIHN5bmNlZCAod2hlbiBubyBJbnRlcnNlY3Rpb25PYnNlcnZlcilcbiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKHRoaXMudXBkYXRlU2hvd1Byb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlzU2hvd246IGZ1bmN0aW9uIGlzU2hvd24obmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgaWYgKG5ld1ZhbCAhPT0gb2xkVmFsKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHN5bmNoZWQgc2hvdyBwcm9wXG4gICAgICAgICAgdGhpcy51cGRhdGVTaG93UHJvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgLy8gSWYgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaXMgbm90IGF2YWlsYWJsZSwgaW1hZ2UgaXMgYWx3YXlzIHNob3duXG4gICAgICB0aGlzLmlzU2hvd24gPSBoYXNJbnRlcnNlY3Rpb25PYnNlcnZlclN1cHBvcnQgPyB0aGlzLnNob3cgOiB0cnVlO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgdXBkYXRlU2hvd1Byb3A6IGZ1bmN0aW9uIHVwZGF0ZVNob3dQcm9wKCkge1xuICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6c2hvdycsIHRoaXMuaXNTaG93bik7XG4gICAgICB9LFxuICAgICAgZG9TaG93OiBmdW5jdGlvbiBkb1Nob3codmlzaWJsZSkge1xuICAgICAgICAvLyBJZiBJbnRlcnNlY3Rpb25PYnNlcnZlciBpcyBub3Qgc3VwcG9ydGVkLCB0aGUgY2FsbGJhY2tcbiAgICAgICAgLy8gd2lsbCBiZSBjYWxsZWQgd2l0aCBgbnVsbGAgcmF0aGVyIHRoYW4gYHRydWVgIG9yIGBmYWxzZWBcbiAgICAgICAgaWYgKCh2aXNpYmxlIHx8IHZpc2libGUgPT09IG51bGwpICYmICF0aGlzLmlzU2hvd24pIHtcbiAgICAgICAgICB0aGlzLmlzU2hvd24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICB2YXIgZGlyZWN0aXZlcyA9IFtdO1xuXG4gICAgICBpZiAoIXRoaXMuaXNTaG93bikge1xuICAgICAgICB2YXIgX21vZGlmaWVycztcblxuICAgICAgICAvLyBXZSBvbmx5IGFkZCB0aGUgdmlzaWJsZSBkaXJlY3RpdmUgaWYgd2UgYXJlIG5vdCBzaG93blxuICAgICAgICBkaXJlY3RpdmVzLnB1c2goe1xuICAgICAgICAgIC8vIFZpc2libGUgZGlyZWN0aXZlIHdpbGwgc2lsZW50bHkgZG8gbm90aGluZyBpZlxuICAgICAgICAgIC8vIEludGVyc2VjdGlvbk9ic2VydmVyIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICBuYW1lOiAnYi12aXNpYmxlJyxcbiAgICAgICAgICAvLyBWYWx1ZSBleHBlY3RzIGEgY2FsbGJhY2sgKHBhc3NlZCBvbmUgYXJnIG9mIGB2aXNpYmxlYCA9IGB0cnVlYCBvciBgZmFsc2VgKVxuICAgICAgICAgIHZhbHVlOiB0aGlzLmRvU2hvdyxcbiAgICAgICAgICBtb2RpZmllcnM6IChfbW9kaWZpZXJzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfbW9kaWZpZXJzLCBcIlwiLmNvbmNhdCh0b0ludGVnZXIodGhpcy5vZmZzZXQpIHx8IDApLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9tb2RpZmllcnMsIFwib25jZVwiLCB0cnVlKSwgX21vZGlmaWVycylcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoKEJJbWcsIHtcbiAgICAgICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAvLyBDb21wdXRlZCB2YWx1ZSBwcm9wc1xuICAgICAgICAgIHNyYzogdGhpcy5jb21wdXRlZFNyYyxcbiAgICAgICAgICBibGFuazogdGhpcy5jb21wdXRlZEJsYW5rLFxuICAgICAgICAgIHdpZHRoOiB0aGlzLmNvbXB1dGVkV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLmNvbXB1dGVkSGVpZ2h0LFxuICAgICAgICAgIHNyY3NldDogdGhpcy5jb21wdXRlZFNyY3NldCB8fCBudWxsLFxuICAgICAgICAgIHNpemVzOiB0aGlzLmNvbXB1dGVkU2l6ZXMgfHwgbnVsbCxcbiAgICAgICAgICAvLyBQYXNzdGhyb3VnaCBwcm9wc1xuICAgICAgICAgIGFsdDogdGhpcy5hbHQsXG4gICAgICAgICAgYmxhbmtDb2xvcjogdGhpcy5ibGFua0NvbG9yLFxuICAgICAgICAgIGZsdWlkOiB0aGlzLmZsdWlkLFxuICAgICAgICAgIGZsdWlkR3JvdzogdGhpcy5mbHVpZEdyb3csXG4gICAgICAgICAgYmxvY2s6IHRoaXMuYmxvY2ssXG4gICAgICAgICAgdGh1bWJuYWlsOiB0aGlzLnRodW1ibmFpbCxcbiAgICAgICAgICByb3VuZGVkOiB0aGlzLnJvdW5kZWQsXG4gICAgICAgICAgbGVmdDogdGhpcy5sZWZ0LFxuICAgICAgICAgIHJpZ2h0OiB0aGlzLnJpZ2h0LFxuICAgICAgICAgIGNlbnRlcjogdGhpcy5jZW50ZXJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUaGUgYG9taXQoKWAgdXRpbCBjcmVhdGVzIGEgbmV3IG9iamVjdCwgc28gd2UgY2FuIGp1c3QgcGFzcyB0aGUgb3JpZ2luYWwgcHJvcHNcblxuICB2YXIgbGF6eVByb3BzID0gb21pdChwcm9wcyRlLCBbJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJywgJ2Jsb2NrJywgJ3JvdW5kZWQnLCAndGh1bWJuYWlsJywgJ2ZsdWlkJywgJ2ZsdWlkR3JvdyddKTtcbiAgdmFyIHByb3BzJGYgPSBfb2JqZWN0U3ByZWFkMih7fSwgbGF6eVByb3BzLCB7XG4gICAgdG9wOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBzdGFydDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICAvLyBhbGlhcyBvZiAnc3RhcnQnXG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGVuZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgLy8gYWxpYXMgb2YgJ2VuZCdcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSk7IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJDYXJkSW1nTGF6eSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JDYXJkSW1nTGF6eScsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczogcHJvcHMkZixcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGE7XG4gICAgICB2YXIgYmFzZUNsYXNzID0gJ2NhcmQtaW1nJztcblxuICAgICAgaWYgKHByb3BzLnRvcCkge1xuICAgICAgICBiYXNlQ2xhc3MgKz0gJy10b3AnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wcy5yaWdodCB8fCBwcm9wcy5lbmQpIHtcbiAgICAgICAgYmFzZUNsYXNzICs9ICctcmlnaHQnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wcy5ib3R0b20pIHtcbiAgICAgICAgYmFzZUNsYXNzICs9ICctYm90dG9tJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcHMubGVmdCB8fCBwcm9wcy5zdGFydCkge1xuICAgICAgICBiYXNlQ2xhc3MgKz0gJy1sZWZ0JztcbiAgICAgIH0gLy8gRmFsc2Ugb3V0IHRoZSBsZWZ0L2NlbnRlci9yaWdodCBwcm9wcyBiZWZvcmUgcGFzc2luZyB0byBiLWltZy1sYXp5XG5cblxuICAgICAgdmFyIGxhenlQcm9wcyA9IF9vYmplY3RTcHJlYWQyKHt9LCBwcm9wcywge1xuICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgcmlnaHQ6IGZhbHNlLFxuICAgICAgICBjZW50ZXI6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGgoQkltZ0xhenksIGEoZGF0YSwge1xuICAgICAgICBjbGFzczogW2Jhc2VDbGFzc10sXG4gICAgICAgIHByb3BzOiBsYXp5UHJvcHNcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwcm9wcyRnID0ge1xuICAgIHRleHRUYWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdwJ1xuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkNhcmRUZXh0ID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQkNhcmRUZXh0JyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBwcm9wcyRnLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gICAgICByZXR1cm4gaChwcm9wcy50ZXh0VGFnLCBhKGRhdGEsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdjYXJkLXRleHQnXG4gICAgICB9KSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHByb3BzJGggPSB7XG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGl2J1xuICAgIH0sXG4gICAgZGVjazoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBjb2x1bW5zOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJDYXJkR3JvdXAgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCQ2FyZEdyb3VwJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBwcm9wcyRoLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gICAgICByZXR1cm4gaChwcm9wcy50YWcsIGEoZGF0YSwge1xuICAgICAgICBjbGFzczogcHJvcHMuZGVjayA/ICdjYXJkLWRlY2snIDogcHJvcHMuY29sdW1ucyA/ICdjYXJkLWNvbHVtbnMnIDogJ2NhcmQtZ3JvdXAnXG4gICAgICB9KSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIENhcmRQbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJDYXJkOiBCQ2FyZCxcbiAgICAgIEJDYXJkSGVhZGVyOiBCQ2FyZEhlYWRlcixcbiAgICAgIEJDYXJkQm9keTogQkNhcmRCb2R5LFxuICAgICAgQkNhcmRUaXRsZTogQkNhcmRUaXRsZSxcbiAgICAgIEJDYXJkU3ViVGl0bGU6IEJDYXJkU3ViVGl0bGUsXG4gICAgICBCQ2FyZEZvb3RlcjogQkNhcmRGb290ZXIsXG4gICAgICBCQ2FyZEltZzogQkNhcmRJbWcsXG4gICAgICBCQ2FyZEltZ0xhenk6IEJDYXJkSW1nTGF6eSxcbiAgICAgIEJDYXJkVGV4dDogQkNhcmRUZXh0LFxuICAgICAgQkNhcmRHcm91cDogQkNhcmRHcm91cFxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbiAgLyoqXG4gICAqIE9ic2VydmUgYSBET00gZWxlbWVudCBjaGFuZ2VzLCBmYWxscyBiYWNrIHRvIGV2ZW50TGlzdGVuZXIgbW9kZVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIFRoZSBET00gZWxlbWVudCB0byBvYnNlcnZlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBjaGFuZ2VcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWV9XSBvYnNlcnZlIG9wdGlvbnNcbiAgICogQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMyMTk3NThcbiAgICovXG5cbiAgdmFyIG9ic2VydmVEb20gPSBmdW5jdGlvbiBvYnNlcnZlRG9tKGVsLCBjYWxsYmFjaywgb3B0aW9ucylcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byB0ZXN0IGluIEpTRE9NICovXG4gIHtcbiAgICAvLyBIYW5kbGUgY2FzZXMgd2hlcmUgd2UgbWlnaHQgYmUgcGFzc2VkIGEgVnVlIGluc3RhbmNlXG4gICAgZWwgPSBlbCA/IGVsLiRlbCB8fCBlbCA6IG51bGw7IC8vIEVhcmx5IGV4aXQgd2hlbiB3ZSBoYXZlIG5vIGVsZW1lbnRcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gdGVzdCBpbiBKU0RPTSAqL1xuXG4gICAgaWYgKCFpc0VsZW1lbnQoZWwpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIEV4aXQgYW5kIHRocm93IGEgd2FybmluZyB3aGVuIGBNdXRhdGlvbk9ic2VydmVyYCBpc24ndCBhdmFpbGFibGVcblxuXG4gICAgaWYgKHdhcm5Ob011dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0KCdvYnNlcnZlRG9tJykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gRGVmaW5lIGEgbmV3IG9ic2VydmVyXG5cblxuICAgIHZhciBvYnMgPSBuZXcgTXV0YXRpb25PYnMoZnVuY3Rpb24gKG11dGF0aW9ucykge1xuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTsgLy8gQSBtdXRhdGlvbiBjYW4gY29udGFpbiBzZXZlcmFsIGNoYW5nZSByZWNvcmRzLCBzbyB3ZSBsb29wXG4gICAgICAvLyB0aHJvdWdoIHRoZW0gdG8gc2VlIHdoYXQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIFdlIGJyZWFrIG91dCBvZiB0aGUgbG9vcCBlYXJseSBpZiBhbnkgXCJzaWduaWZpY2FudFwiIGNoYW5nZVxuICAgICAgLy8gaGFzIGJlZW4gZGV0ZWN0ZWRcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoICYmICFjaGFuZ2VkOyBpKyspIHtcbiAgICAgICAgLy8gVGhlIG11dGF0aW9uIHJlY29yZFxuICAgICAgICB2YXIgbXV0YXRpb24gPSBtdXRhdGlvbnNbaV07IC8vIE11dGF0aW9uIHR5cGVcblxuICAgICAgICB2YXIgdHlwZSA9IG11dGF0aW9uLnR5cGU7IC8vIERPTSBub2RlIChjb3VsZCBiZSBhbnkgRE9NIG5vZGUgdHlwZSAtIEhUTUxFbGVtZW50LCBUZXh0LCBjb21tZW50LCBldGMuKVxuXG4gICAgICAgIHZhciB0YXJnZXQgPSBtdXRhdGlvbi50YXJnZXQ7IC8vIERldGVjdCB3aGV0aGVyIGEgY2hhbmdlIGhhcHBlbmVkIGJhc2VkIG9uIHR5cGUgYW5kIHRhcmdldFxuXG4gICAgICAgIGlmICh0eXBlID09PSAnY2hhcmFjdGVyRGF0YScgJiYgdGFyZ2V0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgIC8vIFdlIGlnbm9yZSBub2RlcyB0aGF0IGFyZSBub3QgVEVYVCAoaS5lLiBjb21tZW50cywgZXRjKVxuICAgICAgICAgIC8vIGFzIHRoZXkgZG9uJ3QgY2hhbmdlIGxheW91dFxuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjaGlsZExpc3QnICYmIChtdXRhdGlvbi5hZGRlZE5vZGVzLmxlbmd0aCA+IDAgfHwgbXV0YXRpb24ucmVtb3ZlZE5vZGVzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgLy8gVGhpcyBpbmNsdWRlcyBIVE1MRWxlbWVudCBhbmQgdGV4dCBub2RlcyBiZWluZ1xuICAgICAgICAgIC8vIGFkZGVkL3JlbW92ZWQvcmUtYXJyYW5nZWRcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBXZSBvbmx5IGNhbGwgdGhlIGNhbGxiYWNrIGlmIGEgY2hhbmdlIHRoYXQgY291bGQgYWZmZWN0XG4gICAgICAvLyBsYXlvdXQvc2l6ZSB0cnVlbHkgaGFwcGVuZWRcblxuXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pOyAvLyBIYXZlIHRoZSBvYnNlcnZlciBvYnNlcnZlIGZvbyBmb3IgY2hhbmdlcyBpbiBjaGlsZHJlbiwgZXRjXG5cbiAgICBvYnMub2JzZXJ2ZShlbCwgX29iamVjdFNwcmVhZDIoe1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpKTsgLy8gV2UgcmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBvYnNlcnZlciBzbyB0aGF0IGBvYnMuZGlzY29ubmVjdCgpYFxuICAgIC8vIGNhbiBiZSBjYWxsZWQgaWYgbmVjZXNzYXJ5XG4gICAgLy8gVG8gcmVkdWNlIG92ZXJoZWFkIHdoZW4gdGhlIHJvb3QgZWxlbWVudCBpcyBoaWRkZW5cblxuICAgIHJldHVybiBvYnM7XG4gIH07XG5cbiAgdmFyIEVWRU5UX09QVElPTlNfUEFTU0lWRSA9IHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH07XG4gIHZhciBFVkVOVF9PUFRJT05TX05PX0NBUFRVUkUgPSB7XG4gICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICBjYXB0dXJlOiBmYWxzZVxuICB9OyAvLyAtLS0gVXRpbHMgLS0tXG4gIC8vIE5vcm1hbGl6ZSBldmVudCBvcHRpb25zIGJhc2VkIG9uIHN1cHBvcnQgb2YgcGFzc2l2ZSBvcHRpb25cbiAgLy8gRXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuXG4gIHZhciBwYXJzZUV2ZW50T3B0aW9ucyA9IGZ1bmN0aW9uIHBhcnNlRXZlbnRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogY2FuJ3QgdGVzdCBpbiBKU0RPTSwgYXMgaXQgc3VwcG9ydHMgcGFzc2l2ZSAqL1xuICAgIGlmIChoYXNQYXNzaXZlRXZlbnRTdXBwb3J0KSB7XG4gICAgICByZXR1cm4gaXNPYmplY3Qob3B0aW9ucykgPyBvcHRpb25zIDoge1xuICAgICAgICBjYXB0dXJlOiAhIW9wdGlvbnMgfHwgZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5lZWQgdG8gdHJhbnNsYXRlIHRvIGFjdHVhbCBCb29sZWFuIHZhbHVlXG4gICAgICByZXR1cm4gISEoaXNPYmplY3Qob3B0aW9ucykgPyBvcHRpb25zLmNhcHR1cmUgOiBvcHRpb25zKTtcbiAgICB9XG4gIH07IC8vIEF0dGFjaCBhbiBldmVudCBsaXN0ZW5lciB0byBhbiBlbGVtZW50XG5cbiAgdmFyIGV2ZW50T24gPSBmdW5jdGlvbiBldmVudE9uKGVsLCBldnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKGVsICYmIGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0TmFtZSwgaGFuZGxlciwgcGFyc2VFdmVudE9wdGlvbnMob3B0aW9ucykpO1xuICAgIH1cbiAgfTsgLy8gUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYW4gZWxlbWVudFxuXG4gIHZhciBldmVudE9mZiA9IGZ1bmN0aW9uIGV2ZW50T2ZmKGVsLCBldnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKGVsICYmIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0TmFtZSwgaGFuZGxlciwgcGFyc2VFdmVudE9wdGlvbnMob3B0aW9ucykpO1xuICAgIH1cbiAgfTsgLy8gVXRpbGl0eSBtZXRob2QgdG8gYWRkL3JlbW92ZSBhIGV2ZW50IGxpc3RlbmVyIGJhc2VkIG9uIGZpcnN0IGFyZ3VtZW50IChib29sZWFuKVxuICAvLyBJdCBwYXNzZXMgYWxsIG90aGVyIGFyZ3VtZW50cyB0byB0aGUgYGV2ZW50T24oKWAgb3IgYGV2ZW50T2ZmYCBtZXRob2RcblxuICB2YXIgZXZlbnRPbk9mZiA9IGZ1bmN0aW9uIGV2ZW50T25PZmYob24pIHtcbiAgICB2YXIgbWV0aG9kID0gb24gPyBldmVudE9uIDogZXZlbnRPZmY7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBtZXRob2QuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgfTtcblxuICB2YXIgTkFNRSRhID0gJ0JDYXJvdXNlbCc7IC8vIFNsaWRlIGRpcmVjdGlvbmFsIGNsYXNzZXNcblxuICB2YXIgRElSRUNUSU9OID0ge1xuICAgIG5leHQ6IHtcbiAgICAgIGRpckNsYXNzOiAnY2Fyb3VzZWwtaXRlbS1sZWZ0JyxcbiAgICAgIG92ZXJsYXlDbGFzczogJ2Nhcm91c2VsLWl0ZW0tbmV4dCdcbiAgICB9LFxuICAgIHByZXY6IHtcbiAgICAgIGRpckNsYXNzOiAnY2Fyb3VzZWwtaXRlbS1yaWdodCcsXG4gICAgICBvdmVybGF5Q2xhc3M6ICdjYXJvdXNlbC1pdGVtLXByZXYnXG4gICAgfVxuICB9OyAvLyBGYWxsYmFjayBUcmFuc2l0aW9uIGR1cmF0aW9uICh3aXRoIGEgbGl0dGxlIGJ1ZmZlcikgaW4gbXNcblxuICB2YXIgVFJBTlNfRFVSQVRJT04gPSA2MDAgKyA1MDsgLy8gVGltZSBmb3IgbW91c2UgY29tcGF0IGV2ZW50cyB0byBmaXJlIGFmdGVyIHRvdWNoXG5cbiAgdmFyIFRPVUNIX0VWRU5UX0NPTVBBVF9XQUlUID0gNTAwOyAvLyBOdW1iZXIgb2YgcGl4ZWxzIHRvIGNvbnNpZGVyIHRvdWNoIG1vdmUgYSBzd2lwZVxuXG4gIHZhciBTV0lQRV9USFJFU0hPTEQgPSA0MDsgLy8gUG9pbnRlckV2ZW50IHBvaW50ZXIgdHlwZXNcblxuICB2YXIgUG9pbnRlclR5cGUgPSB7XG4gICAgVE9VQ0g6ICd0b3VjaCcsXG4gICAgUEVOOiAncGVuJ1xuICB9OyAvLyBUcmFuc2l0aW9uIEV2ZW50IG5hbWVzXG5cbiAgdmFyIFRyYW5zaXRpb25FbmRFdmVudHMgPSB7XG4gICAgV2Via2l0VHJhbnNpdGlvbjogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgIE1velRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJyxcbiAgICBPVHJhbnNpdGlvbjogJ290cmFuc2l0aW9uZW5kIG9UcmFuc2l0aW9uRW5kJyxcbiAgICB0cmFuc2l0aW9uOiAndHJhbnNpdGlvbmVuZCdcbiAgfTsgLy8gUmV0dXJuIHRoZSBicm93c2VyIHNwZWNpZmljIHRyYW5zaXRpb25FbmQgZXZlbnQgbmFtZVxuXG4gIHZhciBnZXRUcmFuc2l0aW9uRW5kRXZlbnQgPSBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uRW5kRXZlbnQoZWwpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIFRyYW5zaXRpb25FbmRFdmVudHMpIHtcbiAgICAgIGlmICghaXNVbmRlZmluZWQoZWwuc3R5bGVbbmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2l0aW9uRW5kRXZlbnRzW25hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gRmFsbGJhY2tcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICAgIHJldHVybiBudWxsO1xuICB9OyAvLyBAdnVlL2NvbXBvbmVudFxuXG5cbiAgdmFyIEJDYXJvdXNlbCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogTkFNRSRhLFxuICAgIG1peGluczogW2lkTWl4aW4sIG5vcm1hbGl6ZVNsb3RNaXhpbl0sXG4gICAgcHJvdmlkZTogZnVuY3Rpb24gcHJvdmlkZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ2Q2Fyb3VzZWw6IHRoaXNcbiAgICAgIH07XG4gICAgfSxcbiAgICBtb2RlbDoge1xuICAgICAgcHJvcDogJ3ZhbHVlJyxcbiAgICAgIGV2ZW50OiAnaW5wdXQnXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgbGFiZWxQcmV2OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJGEsICdsYWJlbFByZXYnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxhYmVsTmV4dDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRhLCAnbGFiZWxOZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsYWJlbEdvdG9TbGlkZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRhLCAnbGFiZWxHb3RvU2xpZGUnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxhYmVsSW5kaWNhdG9yczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRhLCAnbGFiZWxJbmRpY2F0b3JzJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbnRlcnZhbDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIGRlZmF1bHQ6IDUwMDBcbiAgICAgIH0sXG4gICAgICBpbmRpY2F0b3JzOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgY29udHJvbHM6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBub0FuaW1hdGlvbjoge1xuICAgICAgICAvLyBEaXNhYmxlIHNsaWRlL2ZhZGUgYW5pbWF0aW9uXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZmFkZToge1xuICAgICAgICAvLyBFbmFibGUgY3Jvc3MtZmFkZSBhbmltYXRpb24gaW5zdGVhZCBvZiBzbGlkZSBhbmltYXRpb25cbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBub1dyYXA6IHtcbiAgICAgICAgLy8gRGlzYWJsZSB3cmFwcGluZy9sb29waW5nIHdoZW4gc3RhcnQvZW5kIGlzIHJlYWNoZWRcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBub1RvdWNoOiB7XG4gICAgICAgIC8vIFNuaWZmZWQgYnkgY2Fyb3VzZWwtc2xpZGVcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBub0hvdmVyUGF1c2U6IHtcbiAgICAgICAgLy8gRGlzYWJsZSBwYXVzZSBvbiBob3ZlclxuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGltZ1dpZHRoOiB7XG4gICAgICAgIC8vIFNuaWZmZWQgYnkgY2Fyb3VzZWwtc2xpZGVcbiAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSAvLyBkZWZhdWx0OiB1bmRlZmluZWRcblxuICAgICAgfSxcbiAgICAgIGltZ0hlaWdodDoge1xuICAgICAgICAvLyBTbmlmZmVkIGJ5IGNhcm91c2VsLXNsaWRlXG4gICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10gLy8gZGVmYXVsdDogdW5kZWZpbmVkXG5cbiAgICAgIH0sXG4gICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyAvLyBkZWZhdWx0OiB1bmRlZmluZWRcblxuICAgICAgfSxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgZGVmYXVsdDogMFxuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4OiB0aGlzLnZhbHVlIHx8IDAsXG4gICAgICAgIGlzU2xpZGluZzogZmFsc2UsXG4gICAgICAgIHRyYW5zaXRpb25FbmRFdmVudDogbnVsbCxcbiAgICAgICAgc2xpZGVzOiBbXSxcbiAgICAgICAgZGlyZWN0aW9uOiBudWxsLFxuICAgICAgICBpc1BhdXNlZDogISh0b0ludGVnZXIodGhpcy5pbnRlcnZhbCkgPiAwKSxcbiAgICAgICAgLy8gVG91Y2ggZXZlbnQgaGFuZGxpbmcgdmFsdWVzXG4gICAgICAgIHRvdWNoU3RhcnRYOiAwLFxuICAgICAgICB0b3VjaERlbHRhWDogMFxuICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBudW1TbGlkZXM6IGZ1bmN0aW9uIG51bVNsaWRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpZGVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgaWYgKG5ld1ZhbCAhPT0gb2xkVmFsKSB7XG4gICAgICAgICAgdGhpcy5zZXRTbGlkZSh0b0ludGVnZXIobmV3VmFsKSB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGludGVydmFsOiBmdW5jdGlvbiBpbnRlcnZhbChuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICBpZiAobmV3VmFsID09PSBvbGRWYWwpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmV3VmFsKSB7XG4gICAgICAgICAgLy8gUGF1c2luZyBzbGlkZSBzaG93XG4gICAgICAgICAgdGhpcy5wYXVzZShmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVzdGFydGluZyBvciBDaGFuZ2luZyBpbnRlcnZhbFxuICAgICAgICAgIHRoaXMucGF1c2UodHJ1ZSk7XG4gICAgICAgICAgdGhpcy5zdGFydChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpc1BhdXNlZDogZnVuY3Rpb24gaXNQYXVzZWQobmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgaWYgKG5ld1ZhbCAhPT0gb2xkVmFsKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdChuZXdWYWwgPyAncGF1c2VkJyA6ICd1bnBhdXNlZCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW5kZXg6IGZ1bmN0aW9uIGluZGV4KHRvLCBmcm9tKSB7XG4gICAgICAgIGlmICh0byA9PT0gZnJvbSB8fCB0aGlzLmlzU2xpZGluZykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kb1NsaWRlKHRvLCBmcm9tKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgICAvLyBDcmVhdGUgcHJpdmF0ZSBub24tcmVhY3RpdmUgcHJvcHNcbiAgICAgIHRoaXMuX2ludGVydmFsSWQgPSBudWxsO1xuICAgICAgdGhpcy5fYW5pbWF0aW9uVGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLl90b3VjaFRpbWVvdXQgPSBudWxsOyAvLyBTZXQgaW5pdGlhbCBwYXVzZWQgc3RhdGVcblxuICAgICAgdGhpcy5pc1BhdXNlZCA9ICEodG9JbnRlZ2VyKHRoaXMuaW50ZXJ2YWwpID4gMCk7XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgLy8gQ2FjaGUgY3VycmVudCBicm93c2VyIHRyYW5zaXRpb25lbmQgZXZlbnQgbmFtZVxuICAgICAgdGhpcy50cmFuc2l0aW9uRW5kRXZlbnQgPSBnZXRUcmFuc2l0aW9uRW5kRXZlbnQodGhpcy4kZWwpIHx8IG51bGw7IC8vIEdldCBhbGwgc2xpZGVzXG5cbiAgICAgIHRoaXMudXBkYXRlU2xpZGVzKCk7IC8vIE9ic2VydmUgY2hpbGQgY2hhbmdlcyBzbyB3ZSBjYW4gdXBkYXRlIHNsaWRlIGxpc3RcblxuICAgICAgb2JzZXJ2ZURvbSh0aGlzLiRyZWZzLmlubmVyLCB0aGlzLnVwZGF0ZVNsaWRlcy5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHN1YnRyZWU6IGZhbHNlLFxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogWydpZCddXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fYW5pbWF0aW9uVGltZW91dCk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdG91Y2hUaW1lb3V0KTtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJZCk7XG4gICAgICB0aGlzLl9pbnRlcnZhbElkID0gbnVsbDtcbiAgICAgIHRoaXMuX2FuaW1hdGlvblRpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5fdG91Y2hUaW1lb3V0ID0gbnVsbDtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIC8vIFNldCBzbGlkZVxuICAgICAgc2V0U2xpZGU6IGZ1bmN0aW9uIHNldFNsaWRlKHNsaWRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgICAgICAvLyBEb24ndCBhbmltYXRlIHdoZW4gcGFnZSBpcyBub3QgdmlzaWJsZVxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogZGlmZmljdWx0IHRvIHRlc3QgKi9cbiAgICAgICAgaWYgKGlzQnJvd3NlciAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgJiYgZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vV3JhcCA9IHRoaXMubm9XcmFwO1xuICAgICAgICB2YXIgbnVtU2xpZGVzID0gdGhpcy5udW1TbGlkZXM7IC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGFuIGludGVnZXIgKHlvdSBuZXZlciBrbm93ISlcblxuICAgICAgICBzbGlkZSA9IE1hdGguZmxvb3Ioc2xpZGUpOyAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBub3RoaW5nIHRvIHNsaWRlIHRvXG5cbiAgICAgICAgaWYgKG51bVNsaWRlcyA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBEb24ndCBjaGFuZ2Ugc2xpZGUgd2hpbGUgdHJhbnNpdGlvbmluZywgd2FpdCB1bnRpbCB0cmFuc2l0aW9uIGlzIGRvbmVcblxuXG4gICAgICAgIGlmICh0aGlzLmlzU2xpZGluZykge1xuICAgICAgICAgIC8vIFNjaGVkdWxlIHNsaWRlIGFmdGVyIHNsaWRpbmcgY29tcGxldGVcbiAgICAgICAgICB0aGlzLiRvbmNlKCdzbGlkaW5nLWVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRTbGlkZShzbGlkZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjsgLy8gU2V0IG5ldyBzbGlkZSBpbmRleFxuICAgICAgICAvLyBXcmFwIGFyb3VuZCBpZiBuZWNlc3NhcnkgKGlmIG5vLXdyYXAgbm90IGVuYWJsZWQpXG5cbiAgICAgICAgdGhpcy5pbmRleCA9IHNsaWRlID49IG51bVNsaWRlcyA/IG5vV3JhcCA/IG51bVNsaWRlcyAtIDEgOiAwIDogc2xpZGUgPCAwID8gbm9XcmFwID8gMCA6IG51bVNsaWRlcyAtIDEgOiBzbGlkZTsgLy8gRW5zdXJlIHRoZSB2LW1vZGVsIGlzIHN5bmNoZWQgdXAgaWYgbm8td3JhcCBpcyBlbmFibGVkXG4gICAgICAgIC8vIGFuZCB1c2VyIHRyaWVkIHRvIHNsaWRlIHBhc3MgZWl0aGVyIGVuZHNcblxuICAgICAgICBpZiAobm9XcmFwICYmIHRoaXMuaW5kZXggIT09IHNsaWRlICYmIHRoaXMuaW5kZXggIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIHRoaXMuaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gUHJldmlvdXMgc2xpZGVcbiAgICAgIHByZXY6IGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgIHRoaXMuc2V0U2xpZGUodGhpcy5pbmRleCAtIDEsICdwcmV2Jyk7XG4gICAgICB9LFxuICAgICAgLy8gTmV4dCBzbGlkZVxuICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdGhpcy5zZXRTbGlkZSh0aGlzLmluZGV4ICsgMSwgJ25leHQnKTtcbiAgICAgIH0sXG4gICAgICAvLyBQYXVzZSBhdXRvIHJvdGF0aW9uXG4gICAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoZXZ0KSB7XG4gICAgICAgIGlmICghZXZ0KSB7XG4gICAgICAgICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWxJZCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJZCk7XG4gICAgICAgICAgdGhpcy5faW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBTdGFydCBhdXRvIHJvdGF0ZSBzbGlkZXNcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChldnQpIHtcbiAgICAgICAgaWYgKCFldnQpIHtcbiAgICAgICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG1vc3QgbGlrZWx5IHdpbGwgbmV2ZXIgaGFwcGVuLCBidXQganVzdCBpbiBjYXNlICovXG5cblxuICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWxJZCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJZCk7XG4gICAgICAgICAgdGhpcy5faW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgICAgIH0gLy8gRG9uJ3Qgc3RhcnQgaWYgbm8gaW50ZXJ2YWwsIG9yIGxlc3MgdGhhbiAyIHNsaWRlc1xuXG5cbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwgJiYgdGhpcy5udW1TbGlkZXMgPiAxKSB7XG4gICAgICAgICAgdGhpcy5faW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHRoaXMubmV4dCwgTWF0aC5tYXgoMTAwMCwgdGhpcy5pbnRlcnZhbCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gUmVzdGFydCBhdXRvIHJvdGF0ZSBzbGlkZXMgd2hlbiBmb2N1cy9ob3ZlciBsZWF2ZXMgdGhlIGNhcm91c2VsXG4gICAgICByZXN0YXJ0OiBmdW5jdGlvbiByZXN0YXJ0KClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gdGVzdCAqL1xuICAgICAge1xuICAgICAgICBpZiAoIXRoaXMuJGVsLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZG9TbGlkZTogZnVuY3Rpb24gZG9TbGlkZSh0bywgZnJvbSkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgaXNDeWNsaW5nID0gQm9vbGVhbih0aGlzLmludGVydmFsKTsgLy8gRGV0ZXJtaW5lIHNsaWRpbmcgZGlyZWN0aW9uXG5cbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuY2FsY0RpcmVjdGlvbih0aGlzLmRpcmVjdGlvbiwgZnJvbSwgdG8pO1xuICAgICAgICB2YXIgb3ZlcmxheUNsYXNzID0gZGlyZWN0aW9uLm92ZXJsYXlDbGFzcztcbiAgICAgICAgdmFyIGRpckNsYXNzID0gZGlyZWN0aW9uLmRpckNsYXNzOyAvLyBEZXRlcm1pbmUgY3VycmVudCBhbmQgbmV4dCBzbGlkZXNcblxuICAgICAgICB2YXIgY3VycmVudFNsaWRlID0gdGhpcy5zbGlkZXNbZnJvbV07XG4gICAgICAgIHZhciBuZXh0U2xpZGUgPSB0aGlzLnNsaWRlc1t0b107IC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoZXJlIGFyZW4ndCBhbnkgc2xpZGVzIHRvIHNsaWRlIHRvXG5cbiAgICAgICAgaWYgKCFjdXJyZW50U2xpZGUgfHwgIW5leHRTbGlkZSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFN0YXJ0IGFuaW1hdGluZ1xuXG5cbiAgICAgICAgdGhpcy5pc1NsaWRpbmcgPSB0cnVlO1xuXG4gICAgICAgIGlmIChpc0N5Y2xpbmcpIHtcbiAgICAgICAgICB0aGlzLnBhdXNlKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGVtaXQoJ3NsaWRpbmctc3RhcnQnLCB0byk7IC8vIFVwZGF0ZSB2LW1vZGVsXG5cbiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB0aGlzLmluZGV4KTtcblxuICAgICAgICBpZiAodGhpcy5ub0FuaW1hdGlvbikge1xuICAgICAgICAgIGFkZENsYXNzKG5leHRTbGlkZSwgJ2FjdGl2ZScpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGN1cnJlbnRTbGlkZSwgJ2FjdGl2ZScpO1xuICAgICAgICAgIHRoaXMuaXNTbGlkaW5nID0gZmFsc2U7IC8vIE5vdGlmeSBvdXJzZWx2ZXMgdGhhdCB3ZSdyZSBkb25lIHNsaWRpbmcgKHNsaWQpXG5cbiAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLiRlbWl0KCdzbGlkaW5nLWVuZCcsIHRvKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDbGFzcyhuZXh0U2xpZGUsIG92ZXJsYXlDbGFzcyk7IC8vIFRyaWdnZXIgYSByZWZsb3cgb2YgbmV4dCBzbGlkZVxuXG4gICAgICAgICAgcmVmbG93KG5leHRTbGlkZSk7XG4gICAgICAgICAgYWRkQ2xhc3MoY3VycmVudFNsaWRlLCBkaXJDbGFzcyk7XG4gICAgICAgICAgYWRkQ2xhc3MobmV4dFNsaWRlLCBkaXJDbGFzcyk7IC8vIFRyYW5zaXRpb24gRW5kIGhhbmRsZXJcblxuICAgICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIHRlc3QgKi9cblxuICAgICAgICAgIHZhciBvbmNlVHJhbnNFbmQgPSBmdW5jdGlvbiBvbmNlVHJhbnNFbmQoKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdHJhbnNpdGlvbiBldmVudHMgY2FudCBiZSB0ZXN0ZWQgaW4gSlNET00gKi9cblxuICAgICAgICAgICAgaWYgKF90aGlzMi50cmFuc2l0aW9uRW5kRXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IF90aGlzMi50cmFuc2l0aW9uRW5kRXZlbnQuc3BsaXQoL1xccysvKTtcblxuICAgICAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50T2ZmKGN1cnJlbnRTbGlkZSwgZXZ0LCBvbmNlVHJhbnNFbmQsIEVWRU5UX09QVElPTlNfTk9fQ0FQVFVSRSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfdGhpczIuX2FuaW1hdGlvblRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MobmV4dFNsaWRlLCBkaXJDbGFzcyk7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhuZXh0U2xpZGUsIG92ZXJsYXlDbGFzcyk7XG4gICAgICAgICAgICBhZGRDbGFzcyhuZXh0U2xpZGUsICdhY3RpdmUnKTtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKGN1cnJlbnRTbGlkZSwgJ2FjdGl2ZScpO1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoY3VycmVudFNsaWRlLCBkaXJDbGFzcyk7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhjdXJyZW50U2xpZGUsIG92ZXJsYXlDbGFzcyk7XG4gICAgICAgICAgICBzZXRBdHRyKGN1cnJlbnRTbGlkZSwgJ2FyaWEtY3VycmVudCcsICdmYWxzZScpO1xuICAgICAgICAgICAgc2V0QXR0cihuZXh0U2xpZGUsICdhcmlhLWN1cnJlbnQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgc2V0QXR0cihjdXJyZW50U2xpZGUsICdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgICAgICBzZXRBdHRyKG5leHRTbGlkZSwgJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICBfdGhpczIuaXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBfdGhpczIuZGlyZWN0aW9uID0gbnVsbDsgLy8gTm90aWZ5IG91cnNlbHZlcyB0aGF0IHdlJ3JlIGRvbmUgc2xpZGluZyAoc2xpZClcblxuICAgICAgICAgICAgX3RoaXMyLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczIuJGVtaXQoJ3NsaWRpbmctZW5kJywgdG8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTsgLy8gU2V0IHVwIHRyYW5zaXRpb25lbmQgaGFuZGxlclxuXG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB0cmFuc2l0aW9uIGV2ZW50cyBjYW50IGJlIHRlc3RlZCBpbiBKU0RPTSAqL1xuXG5cbiAgICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uRW5kRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLnRyYW5zaXRpb25FbmRFdmVudC5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBldmVudE9uKGN1cnJlbnRTbGlkZSwgZXZlbnQsIG9uY2VUcmFuc0VuZCwgRVZFTlRfT1BUSU9OU19OT19DQVBUVVJFKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gRmFsbGJhY2sgdG8gc2V0VGltZW91dCgpXG5cblxuICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uY2VUcmFuc0VuZCwgVFJBTlNfRFVSQVRJT04pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ3ljbGluZykge1xuICAgICAgICAgIHRoaXMuc3RhcnQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gVXBkYXRlIHNsaWRlIGxpc3RcbiAgICAgIHVwZGF0ZVNsaWRlczogZnVuY3Rpb24gdXBkYXRlU2xpZGVzKCkge1xuICAgICAgICB0aGlzLnBhdXNlKHRydWUpOyAvLyBHZXQgYWxsIHNsaWRlcyBhcyBET00gZWxlbWVudHNcblxuICAgICAgICB0aGlzLnNsaWRlcyA9IHNlbGVjdEFsbCgnLmNhcm91c2VsLWl0ZW0nLCB0aGlzLiRyZWZzLmlubmVyKTtcbiAgICAgICAgdmFyIG51bVNsaWRlcyA9IHRoaXMuc2xpZGVzLmxlbmd0aDsgLy8gS2VlcCBzbGlkZSBudW1iZXIgaW4gcmFuZ2VcblxuICAgICAgICB2YXIgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihNYXRoLmZsb29yKHRoaXMuaW5kZXgpLCBudW1TbGlkZXMgLSAxKSk7XG4gICAgICAgIHRoaXMuc2xpZGVzLmZvckVhY2goZnVuY3Rpb24gKHNsaWRlLCBpZHgpIHtcbiAgICAgICAgICB2YXIgbiA9IGlkeCArIDE7XG5cbiAgICAgICAgICBpZiAoaWR4ID09PSBpbmRleCkge1xuICAgICAgICAgICAgYWRkQ2xhc3Moc2xpZGUsICdhY3RpdmUnKTtcbiAgICAgICAgICAgIHNldEF0dHIoc2xpZGUsICdhcmlhLWN1cnJlbnQnLCAndHJ1ZScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhzbGlkZSwgJ2FjdGl2ZScpO1xuICAgICAgICAgICAgc2V0QXR0cihzbGlkZSwgJ2FyaWEtY3VycmVudCcsICdmYWxzZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldEF0dHIoc2xpZGUsICdhcmlhLXBvc2luc2V0JywgU3RyaW5nKG4pKTtcbiAgICAgICAgICBzZXRBdHRyKHNsaWRlLCAnYXJpYS1zZXRzaXplJywgU3RyaW5nKG51bVNsaWRlcykpO1xuICAgICAgICB9KTsgLy8gU2V0IHNsaWRlIGFzIGFjdGl2ZVxuXG4gICAgICAgIHRoaXMuc2V0U2xpZGUoaW5kZXgpO1xuICAgICAgICB0aGlzLnN0YXJ0KHRoaXMuaXNQYXVzZWQpO1xuICAgICAgfSxcbiAgICAgIGNhbGNEaXJlY3Rpb246IGZ1bmN0aW9uIGNhbGNEaXJlY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICAgIHZhciBjdXJJbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgICAgdmFyIG5leHRJbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcblxuICAgICAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBuZXh0SW5kZXggPiBjdXJJbmRleCA/IERJUkVDVElPTi5uZXh0IDogRElSRUNUSU9OLnByZXY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRElSRUNUSU9OW2RpcmVjdGlvbl07XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2dCwgZm4pIHtcbiAgICAgICAgdmFyIGtleUNvZGUgPSBldnQua2V5Q29kZTtcblxuICAgICAgICBpZiAoZXZ0LnR5cGUgPT09ICdjbGljaycgfHwga2V5Q29kZSA9PT0gS0VZX0NPREVTLlNQQUNFIHx8IGtleUNvZGUgPT09IEtFWV9DT0RFUy5FTlRFUikge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBmbigpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFuZGxlU3dpcGU6IGZ1bmN0aW9uIGhhbmRsZVN3aXBlKClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBKU0RPTSBkb2Vzbid0IHN1cHBvcnQgdG91Y2ggZXZlbnRzICovXG4gICAgICB7XG4gICAgICAgIHZhciBhYnNEZWx0YVggPSBNYXRoLmFicyh0aGlzLnRvdWNoRGVsdGFYKTtcblxuICAgICAgICBpZiAoYWJzRGVsdGFYIDw9IFNXSVBFX1RIUkVTSE9MRCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBhYnNEZWx0YVggLyB0aGlzLnRvdWNoRGVsdGFYOyAvLyBSZXNldCB0b3VjaCBkZWx0YSBYXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9wdWxsLzI4NTU4XG5cbiAgICAgICAgdGhpcy50b3VjaERlbHRhWCA9IDA7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAvLyBTd2lwZSBsZWZ0XG4gICAgICAgICAgdGhpcy5wcmV2KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uIDwgMCkge1xuICAgICAgICAgIC8vIFN3aXBlIHJpZ2h0XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b3VjaFN0YXJ0OiBmdW5jdGlvbiB0b3VjaFN0YXJ0KGV2dClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBKU0RPTSBkb2Vzbid0IHN1cHBvcnQgdG91Y2ggZXZlbnRzICovXG4gICAgICB7XG4gICAgICAgIGlmIChoYXNQb2ludGVyRXZlbnRTdXBwb3J0ICYmIFBvaW50ZXJUeXBlW2V2dC5wb2ludGVyVHlwZS50b1VwcGVyQ2FzZSgpXSkge1xuICAgICAgICAgIHRoaXMudG91Y2hTdGFydFggPSBldnQuY2xpZW50WDtcbiAgICAgICAgfSBlbHNlIGlmICghaGFzUG9pbnRlckV2ZW50U3VwcG9ydCkge1xuICAgICAgICAgIHRoaXMudG91Y2hTdGFydFggPSBldnQudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG91Y2hNb3ZlOiBmdW5jdGlvbiB0b3VjaE1vdmUoZXZ0KVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IEpTRE9NIGRvZXNuJ3Qgc3VwcG9ydCB0b3VjaCBldmVudHMgKi9cbiAgICAgIHtcbiAgICAgICAgLy8gRW5zdXJlIHN3aXBpbmcgd2l0aCBvbmUgdG91Y2ggYW5kIG5vdCBwaW5jaGluZ1xuICAgICAgICBpZiAoZXZ0LnRvdWNoZXMgJiYgZXZ0LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMudG91Y2hEZWx0YVggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudG91Y2hEZWx0YVggPSBldnQudG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy50b3VjaFN0YXJ0WDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRvdWNoRW5kOiBmdW5jdGlvbiB0b3VjaEVuZChldnQpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogSlNET00gZG9lc24ndCBzdXBwb3J0IHRvdWNoIGV2ZW50cyAqL1xuICAgICAge1xuICAgICAgICBpZiAoaGFzUG9pbnRlckV2ZW50U3VwcG9ydCAmJiBQb2ludGVyVHlwZVtldnQucG9pbnRlclR5cGUudG9VcHBlckNhc2UoKV0pIHtcbiAgICAgICAgICB0aGlzLnRvdWNoRGVsdGFYID0gZXZ0LmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRYO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYW5kbGVTd2lwZSgpOyAvLyBJZiBpdCdzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2UsIG1vdXNlZW50ZXIvbGVhdmUgYXJlIGZpcmVkIGFzXG4gICAgICAgIC8vIHBhcnQgb2YgdGhlIG1vdXNlIGNvbXBhdGliaWxpdHkgZXZlbnRzIG9uIGZpcnN0IHRhcCAtIHRoZSBjYXJvdXNlbFxuICAgICAgICAvLyB3b3VsZCBzdG9wIGN5Y2xpbmcgdW50aWwgdXNlciB0YXBwZWQgb3V0IG9mIGl0O1xuICAgICAgICAvLyBoZXJlLCB3ZSBsaXN0ZW4gZm9yIHRvdWNoZW5kLCBleHBsaWNpdGx5IHBhdXNlIHRoZSBjYXJvdXNlbFxuICAgICAgICAvLyAoYXMgaWYgaXQncyB0aGUgc2Vjb25kIHRpbWUgd2UgdGFwIG9uIGl0LCBtb3VzZWVudGVyIGNvbXBhdCBldmVudFxuICAgICAgICAvLyBpcyBOT1QgZmlyZWQpIGFuZCBhZnRlciBhIHRpbWVvdXQgKHRvIGFsbG93IGZvciBtb3VzZSBjb21wYXRpYmlsaXR5XG4gICAgICAgIC8vIGV2ZW50cyB0byBmaXJlKSB3ZSBleHBsaWNpdGx5IHJlc3RhcnQgY3ljbGluZ1xuXG4gICAgICAgIHRoaXMucGF1c2UoZmFsc2UpO1xuXG4gICAgICAgIGlmICh0aGlzLl90b3VjaFRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdG91Y2hUaW1lb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RvdWNoVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5zdGFydCwgVE9VQ0hfRVZFTlRfQ09NUEFUX1dBSVQgKyBNYXRoLm1heCgxMDAwLCB0aGlzLmludGVydmFsKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgLy8gV3JhcHBlciBmb3Igc2xpZGVzXG4gICAgICB2YXIgaW5uZXIgPSBoKCdkaXYnLCB7XG4gICAgICAgIHJlZjogJ2lubmVyJyxcbiAgICAgICAgY2xhc3M6IFsnY2Fyb3VzZWwtaW5uZXInXSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBpZDogdGhpcy5zYWZlSWQoJ19fQlZfaW5uZXJfJyksXG4gICAgICAgICAgcm9sZTogJ2xpc3QnXG4gICAgICAgIH1cbiAgICAgIH0sIFt0aGlzLm5vcm1hbGl6ZVNsb3QoJ2RlZmF1bHQnKV0pOyAvLyBQcmV2IGFuZCBuZXh0IGNvbnRyb2xzXG5cbiAgICAgIHZhciBjb250cm9scyA9IGgoKTtcblxuICAgICAgaWYgKHRoaXMuY29udHJvbHMpIHtcbiAgICAgICAgdmFyIHByZXZIYW5kbGVyID0gZnVuY3Rpb24gcHJldkhhbmRsZXIoZXZ0KSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBpZiAoIV90aGlzMy5pc1NsaWRpbmcpIHtcbiAgICAgICAgICAgIF90aGlzMy5oYW5kbGVDbGljayhldnQsIF90aGlzMy5wcmV2KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBuZXh0SGFuZGxlciA9IGZ1bmN0aW9uIG5leHRIYW5kbGVyKGV2dCkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgaWYgKCFfdGhpczMuaXNTbGlkaW5nKSB7XG4gICAgICAgICAgICBfdGhpczMuaGFuZGxlQ2xpY2soZXZ0LCBfdGhpczMubmV4dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb250cm9scyA9IFtoKCdhJywge1xuICAgICAgICAgIGNsYXNzOiBbJ2Nhcm91c2VsLWNvbnRyb2wtcHJldiddLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBocmVmOiAnIycsXG4gICAgICAgICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogdGhpcy5zYWZlSWQoJ19fQlZfaW5uZXJfJyksXG4gICAgICAgICAgICAnYXJpYS1kaXNhYmxlZCc6IHRoaXMuaXNTbGlkaW5nID8gJ3RydWUnIDogbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNsaWNrOiBwcmV2SGFuZGxlcixcbiAgICAgICAgICAgIGtleWRvd246IHByZXZIYW5kbGVyXG4gICAgICAgICAgfVxuICAgICAgICB9LCBbaCgnc3BhbicsIHtcbiAgICAgICAgICBjbGFzczogWydjYXJvdXNlbC1jb250cm9sLXByZXYtaWNvbiddLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiAndHJ1ZSdcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBoKCdzcGFuJywge1xuICAgICAgICAgIGNsYXNzOiBbJ3NyLW9ubHknXVxuICAgICAgICB9LCBbdGhpcy5sYWJlbFByZXZdKV0pLCBoKCdhJywge1xuICAgICAgICAgIGNsYXNzOiBbJ2Nhcm91c2VsLWNvbnRyb2wtbmV4dCddLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBocmVmOiAnIycsXG4gICAgICAgICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogdGhpcy5zYWZlSWQoJ19fQlZfaW5uZXJfJyksXG4gICAgICAgICAgICAnYXJpYS1kaXNhYmxlZCc6IHRoaXMuaXNTbGlkaW5nID8gJ3RydWUnIDogbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNsaWNrOiBuZXh0SGFuZGxlcixcbiAgICAgICAgICAgIGtleWRvd246IG5leHRIYW5kbGVyXG4gICAgICAgICAgfVxuICAgICAgICB9LCBbaCgnc3BhbicsIHtcbiAgICAgICAgICBjbGFzczogWydjYXJvdXNlbC1jb250cm9sLW5leHQtaWNvbiddLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiAndHJ1ZSdcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBoKCdzcGFuJywge1xuICAgICAgICAgIGNsYXNzOiBbJ3NyLW9ubHknXVxuICAgICAgICB9LCBbdGhpcy5sYWJlbE5leHRdKV0pXTtcbiAgICAgIH0gLy8gSW5kaWNhdG9yc1xuXG5cbiAgICAgIHZhciBpbmRpY2F0b3JzID0gaCgnb2wnLCB7XG4gICAgICAgIGNsYXNzOiBbJ2Nhcm91c2VsLWluZGljYXRvcnMnXSxcbiAgICAgICAgZGlyZWN0aXZlczogW3tcbiAgICAgICAgICBuYW1lOiAnc2hvdycsXG4gICAgICAgICAgcmF3TmFtZTogJ3Ytc2hvdycsXG4gICAgICAgICAgdmFsdWU6IHRoaXMuaW5kaWNhdG9ycyxcbiAgICAgICAgICBleHByZXNzaW9uOiAnaW5kaWNhdG9ycydcbiAgICAgICAgfV0sXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHRoaXMuc2FmZUlkKCdfX0JWX2luZGljYXRvcnNfJyksXG4gICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdGhpcy5pbmRpY2F0b3JzID8gJ2ZhbHNlJyA6ICd0cnVlJyxcbiAgICAgICAgICAnYXJpYS1sYWJlbCc6IHRoaXMubGFiZWxJbmRpY2F0b3JzLFxuICAgICAgICAgICdhcmlhLW93bnMnOiB0aGlzLnNhZmVJZCgnX19CVl9pbm5lcl8nKVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzLnNsaWRlcy5tYXAoZnVuY3Rpb24gKHNsaWRlLCBuKSB7XG4gICAgICAgIHJldHVybiBoKCdsaScsIHtcbiAgICAgICAgICBrZXk6IFwic2xpZGVfXCIuY29uY2F0KG4pLFxuICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICBhY3RpdmU6IG4gPT09IF90aGlzMy5pbmRleFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgICAgaWQ6IF90aGlzMy5zYWZlSWQoXCJfX0JWX2luZGljYXRvcl9cIi5jb25jYXQobiArIDEsIFwiX1wiKSksXG4gICAgICAgICAgICB0YWJpbmRleDogX3RoaXMzLmluZGljYXRvcnMgPyAnMCcgOiAnLTEnLFxuICAgICAgICAgICAgJ2FyaWEtY3VycmVudCc6IG4gPT09IF90aGlzMy5pbmRleCA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgICAgICAgICAnYXJpYS1sYWJlbCc6IFwiXCIuY29uY2F0KF90aGlzMy5sYWJlbEdvdG9TbGlkZSwgXCIgXCIpLmNvbmNhdChuICsgMSksXG4gICAgICAgICAgICAnYXJpYS1kZXNjcmliZWRieSc6IF90aGlzMy5zbGlkZXNbbl0uaWQgfHwgbnVsbCxcbiAgICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogX3RoaXMzLnNhZmVJZCgnX19CVl9pbm5lcl8nKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljayhldnQpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmhhbmRsZUNsaWNrKGV2dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzMy5zZXRTbGlkZShuKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5ZG93bjogZnVuY3Rpb24ga2V5ZG93bihldnQpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmhhbmRsZUNsaWNrKGV2dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzMy5zZXRTbGlkZShuKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pKTtcbiAgICAgIHZhciBvbiA9IHtcbiAgICAgICAgbW91c2VlbnRlcjogdGhpcy5ub0hvdmVyUGF1c2UgPyBub29wIDogdGhpcy5wYXVzZSxcbiAgICAgICAgbW91c2VsZWF2ZTogdGhpcy5ub0hvdmVyUGF1c2UgPyBub29wIDogdGhpcy5yZXN0YXJ0LFxuICAgICAgICBmb2N1c2luOiB0aGlzLnBhdXNlLFxuICAgICAgICBmb2N1c291dDogdGhpcy5yZXN0YXJ0LFxuICAgICAgICBrZXlkb3duOiBmdW5jdGlvbiBrZXlkb3duKGV2dCkge1xuICAgICAgICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2dC50YXJnZXQudGFnTmFtZSkpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGtleUNvZGUgPSBldnQua2V5Q29kZTtcblxuICAgICAgICAgIGlmIChrZXlDb2RlID09PSBLRVlfQ09ERVMuTEVGVCB8fCBrZXlDb2RlID09PSBLRVlfQ09ERVMuUklHSFQpIHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICBfdGhpczNba2V5Q29kZSA9PT0gS0VZX0NPREVTLkxFRlQgPyAncHJldicgOiAnbmV4dCddKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9OyAvLyBUb3VjaCBzdXBwb3J0IGV2ZW50IGhhbmRsZXJzIGZvciBlbnZpcm9ubWVudFxuXG4gICAgICBpZiAoIXRoaXMubm9Ub3VjaCAmJiBoYXNUb3VjaFN1cHBvcnQpIHtcbiAgICAgICAgLy8gQXR0YWNoIGFwcHJvcHJpYXRlIGxpc3RlbmVycyAocHJlcGVuZCBldmVudCBuYW1lIHdpdGggJyYnIGZvciBwYXNzaXZlIG1vZGUpXG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IEpTRE9NIGRvZXNuJ3Qgc3VwcG9ydCB0b3VjaCBldmVudHMgKi9cbiAgICAgICAgaWYgKGhhc1BvaW50ZXJFdmVudFN1cHBvcnQpIHtcbiAgICAgICAgICBvblsnJnBvaW50ZXJkb3duJ10gPSB0aGlzLnRvdWNoU3RhcnQ7XG4gICAgICAgICAgb25bJyZwb2ludGVydXAnXSA9IHRoaXMudG91Y2hFbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25bJyZ0b3VjaHN0YXJ0J10gPSB0aGlzLnRvdWNoU3RhcnQ7XG4gICAgICAgICAgb25bJyZ0b3VjaG1vdmUnXSA9IHRoaXMudG91Y2hNb3ZlO1xuICAgICAgICAgIG9uWycmdG91Y2hlbmQnXSA9IHRoaXMudG91Y2hFbmQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmV0dXJuIHRoZSBjYXJvdXNlbFxuXG5cbiAgICAgIHJldHVybiBoKCdkaXYnLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnY2Fyb3VzZWwnLFxuICAgICAgICBjbGFzczoge1xuICAgICAgICAgIHNsaWRlOiAhdGhpcy5ub0FuaW1hdGlvbixcbiAgICAgICAgICAnY2Fyb3VzZWwtZmFkZSc6ICF0aGlzLm5vQW5pbWF0aW9uICYmIHRoaXMuZmFkZSxcbiAgICAgICAgICAncG9pbnRlci1ldmVudCc6ICF0aGlzLm5vVG91Y2ggJiYgaGFzVG91Y2hTdXBwb3J0ICYmIGhhc1BvaW50ZXJFdmVudFN1cHBvcnRcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiB0aGlzLmJhY2tncm91bmRcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICByb2xlOiAncmVnaW9uJyxcbiAgICAgICAgICBpZDogdGhpcy5zYWZlSWQoKSxcbiAgICAgICAgICAnYXJpYS1idXN5JzogdGhpcy5pc1NsaWRpbmcgPyAndHJ1ZScgOiAnZmFsc2UnXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiBvblxuICAgICAgfSwgW2lubmVyLCBjb250cm9scywgaW5kaWNhdG9yc10pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHByb3BzJGkgPSB7XG4gICAgaW1nU3JjOiB7XG4gICAgICB0eXBlOiBTdHJpbmcgLy8gZGVmYXVsdDogdW5kZWZpbmVkXG5cbiAgICB9LFxuICAgIGltZ0FsdDoge1xuICAgICAgdHlwZTogU3RyaW5nIC8vIGRlZmF1bHQ6IHVuZGVmaW5lZFxuXG4gICAgfSxcbiAgICBpbWdXaWR0aDoge1xuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSAvLyBkZWZhdWx0OiB1bmRlZmluZWRcblxuICAgIH0sXG4gICAgaW1nSGVpZ2h0OiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddIC8vIGRlZmF1bHQ6IHVuZGVmaW5lZFxuXG4gICAgfSxcbiAgICBpbWdCbGFuazoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBpbWdCbGFua0NvbG9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAndHJhbnNwYXJlbnQnXG4gICAgfSxcbiAgICBjb250ZW50VmlzaWJsZVVwOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuICAgIGNvbnRlbnRUYWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdkaXYnXG4gICAgfSxcbiAgICBjYXB0aW9uOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuICAgIGNhcHRpb25IdG1sOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuICAgIGNhcHRpb25UYWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdoMydcbiAgICB9LFxuICAgIHRleHQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG4gICAgdGV4dEh0bWw6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG4gICAgdGV4dFRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ3AnXG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9XG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJDYXJvdXNlbFNsaWRlID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQkNhcm91c2VsU2xpZGUnLFxuICAgIG1peGluczogW2lkTWl4aW4sIG5vcm1hbGl6ZVNsb3RNaXhpbl0sXG4gICAgaW5qZWN0OiB7XG4gICAgICBidkNhcm91c2VsOiB7XG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IGRpc2FibGUgdG91Y2ggaWYgbm90IGEgY2hpbGQgb2YgY2Fyb3VzZWxcbiAgICAgICAgICAgIG5vVG91Y2g6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wczogcHJvcHMkaSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgY29udGVudENsYXNzZXM6IGZ1bmN0aW9uIGNvbnRlbnRDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuY29udGVudFZpc2libGVVcCA/ICdkLW5vbmUnIDogJycsIHRoaXMuY29udGVudFZpc2libGVVcCA/IFwiZC1cIi5jb25jYXQodGhpcy5jb250ZW50VmlzaWJsZVVwLCBcIi1ibG9ja1wiKSA6ICcnXTtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZFdpZHRoOiBmdW5jdGlvbiBjb21wdXRlZFdpZHRoKCkge1xuICAgICAgICAvLyBVc2UgbG9jYWwgd2lkdGgsIG9yIHRyeSBwYXJlbnQgd2lkdGhcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1nV2lkdGggfHwgdGhpcy5idkNhcm91c2VsLmltZ1dpZHRoIHx8IG51bGw7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRIZWlnaHQ6IGZ1bmN0aW9uIGNvbXB1dGVkSGVpZ2h0KCkge1xuICAgICAgICAvLyBVc2UgbG9jYWwgaGVpZ2h0LCBvciB0cnkgcGFyZW50IGhlaWdodFxuICAgICAgICByZXR1cm4gdGhpcy5pbWdIZWlnaHQgfHwgdGhpcy5idkNhcm91c2VsLmltZ0hlaWdodCB8fCBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgdmFyIG5vRHJhZyA9ICF0aGlzLmJ2Q2Fyb3VzZWwubm9Ub3VjaCAmJiBoYXNUb3VjaFN1cHBvcnQ7XG4gICAgICB2YXIgaW1nID0gdGhpcy5ub3JtYWxpemVTbG90KCdpbWcnKTtcblxuICAgICAgaWYgKCFpbWcgJiYgKHRoaXMuaW1nU3JjIHx8IHRoaXMuaW1nQmxhbmspKSB7XG4gICAgICAgIGltZyA9IGgoQkltZywge1xuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBmbHVpZEdyb3c6IHRydWUsXG4gICAgICAgICAgICBibG9jazogdHJ1ZSxcbiAgICAgICAgICAgIHNyYzogdGhpcy5pbWdTcmMsXG4gICAgICAgICAgICBibGFuazogdGhpcy5pbWdCbGFuayxcbiAgICAgICAgICAgIGJsYW5rQ29sb3I6IHRoaXMuaW1nQmxhbmtDb2xvcixcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLmNvbXB1dGVkV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuY29tcHV0ZWRIZWlnaHQsXG4gICAgICAgICAgICBhbHQ6IHRoaXMuaW1nQWx0XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyBUb3VjaCBzdXBwb3J0IGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICBvbjogbm9EcmFnID8ge1xuICAgICAgICAgICAgZHJhZ3N0YXJ0OiBmdW5jdGlvbiBkcmFnc3RhcnQoZSkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIHRlc3QgaW4gSlNET00gKi9cbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gOiB7fVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpbWcpIHtcbiAgICAgICAgaW1nID0gaCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGVudCA9IGgoKTtcbiAgICAgIHZhciBjb250ZW50Q2hpbGRyZW4gPSBbdGhpcy5jYXB0aW9uIHx8IHRoaXMuY2FwdGlvbkh0bWwgPyBoKHRoaXMuY2FwdGlvblRhZywge1xuICAgICAgICBkb21Qcm9wczogaHRtbE9yVGV4dCh0aGlzLmNhcHRpb25IdG1sLCB0aGlzLmNhcHRpb24pXG4gICAgICB9KSA6IGZhbHNlLCB0aGlzLnRleHQgfHwgdGhpcy50ZXh0SHRtbCA/IGgodGhpcy50ZXh0VGFnLCB7XG4gICAgICAgIGRvbVByb3BzOiBodG1sT3JUZXh0KHRoaXMudGV4dEh0bWwsIHRoaXMudGV4dClcbiAgICAgIH0pIDogZmFsc2UsIHRoaXMubm9ybWFsaXplU2xvdCgnZGVmYXVsdCcpIHx8IGZhbHNlXTtcblxuICAgICAgaWYgKGNvbnRlbnRDaGlsZHJlbi5zb21lKEJvb2xlYW4pKSB7XG4gICAgICAgIGNvbnRlbnQgPSBoKHRoaXMuY29udGVudFRhZywge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiAnY2Fyb3VzZWwtY2FwdGlvbicsXG4gICAgICAgICAgY2xhc3M6IHRoaXMuY29udGVudENsYXNzZXNcbiAgICAgICAgfSwgY29udGVudENoaWxkcmVuLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiBpIHx8IGgoKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2Nhcm91c2VsLWl0ZW0nLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHRoaXMuYmFja2dyb3VuZCB8fCB0aGlzLmJ2Q2Fyb3VzZWwuYmFja2dyb3VuZCB8fCBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHRoaXMuc2FmZUlkKCksXG4gICAgICAgICAgcm9sZTogJ2xpc3RpdGVtJ1xuICAgICAgICB9XG4gICAgICB9LCBbaW1nLCBjb250ZW50XSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgQ2Fyb3VzZWxQbHVnaW4gPVxuICAvKiNfX1BVUkUqL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBCQ2Fyb3VzZWw6IEJDYXJvdXNlbCxcbiAgICAgIEJDYXJvdXNlbFNsaWRlOiBCQ2Fyb3VzZWxTbGlkZVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gR2VuZXJpYyBjb2xsYXBzZSB0cmFuc2lvbiBoZWxwZXIgY29tcG9uZW50XG5cbiAgdmFyIG9uRW50ZXIgPSBmdW5jdGlvbiBvbkVudGVyKGVsKSB7XG4gICAgZWwuc3R5bGUuaGVpZ2h0ID0gMDsgLy8gQW5pbWF0b24gZnJhbWUgZGVsYXkgbmVlZWRlZCBmb3IgYGFwcGVhcmAgdG8gd29ya1xuXG4gICAgcmVxdWVzdEFGKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlZmxvdyhlbCk7XG4gICAgICBlbC5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChlbC5zY3JvbGxIZWlnaHQsIFwicHhcIik7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIG9uQWZ0ZXJFbnRlciA9IGZ1bmN0aW9uIG9uQWZ0ZXJFbnRlcihlbCkge1xuICAgIGVsLnN0eWxlLmhlaWdodCA9IG51bGw7XG4gIH07XG5cbiAgdmFyIG9uTGVhdmUgPSBmdW5jdGlvbiBvbkxlYXZlKGVsKSB7XG4gICAgZWwuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGVsLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGdldEJDUihlbCkuaGVpZ2h0LCBcInB4XCIpO1xuICAgIHJlZmxvdyhlbCk7XG4gICAgZWwuc3R5bGUuaGVpZ2h0ID0gMDtcbiAgfTtcblxuICB2YXIgb25BZnRlckxlYXZlID0gZnVuY3Rpb24gb25BZnRlckxlYXZlKGVsKSB7XG4gICAgZWwuc3R5bGUuaGVpZ2h0ID0gbnVsbDtcbiAgfTsgLy8gRGVmYXVsdCB0cmFuc2l0aW9uIHByb3BzXG4gIC8vIGBhcHBlYXJgIHdpbGwgdXNlIHRoZSBlbnRlciBjbGFzc2VzXG5cblxuICB2YXIgVFJBTlNJVElPTl9QUk9QUyA9IHtcbiAgICBjc3M6IHRydWUsXG4gICAgZW50ZXJDbGFzczogJycsXG4gICAgZW50ZXJBY3RpdmVDbGFzczogJ2NvbGxhcHNpbmcnLFxuICAgIGVudGVyVG9DbGFzczogJ2NvbGxhcHNlIHNob3cnLFxuICAgIGxlYXZlQ2xhc3M6ICdjb2xsYXBzZSBzaG93JyxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAnY29sbGFwc2luZycsXG4gICAgbGVhdmVUb0NsYXNzOiAnY29sbGFwc2UnXG4gIH07IC8vIERlZmF1bHQgdHJhbnNpdGlvbiBoYW5kbGVyc1xuICAvLyBgYXBwZWFyYCB3aWxsIHVzZSB0aGUgZW50ZXIgaGFuZGxlcnNcblxuICB2YXIgVFJBTlNJVElPTl9IQU5ETEVSUyA9IHtcbiAgICBlbnRlcjogb25FbnRlcixcbiAgICBhZnRlckVudGVyOiBvbkFmdGVyRW50ZXIsXG4gICAgbGVhdmU6IG9uTGVhdmUsXG4gICAgYWZ0ZXJMZWF2ZTogb25BZnRlckxlYXZlXG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJWQ29sbGFwc2UgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCVkNvbGxhcHNlJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiB7XG4gICAgICBhcHBlYXI6IHtcbiAgICAgICAgLy8gSWYgYHRydWVgIChhbmQgYHZpc2libGVgIGlzIGB0cnVlYCBvbiBtb3VudCksIGFuaW1hdGUgaW5pdGlhbGx5IHZpc2libGVcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gICAgICByZXR1cm4gaCgndHJhbnNpdGlvbicsIC8vIFdlIG1lcmdlIGluIHRoZSBgYXBwZWFyYCBwcm9wIGxhc3RcbiAgICAgIGEoZGF0YSwge1xuICAgICAgICBwcm9wczogVFJBTlNJVElPTl9QUk9QUyxcbiAgICAgICAgb246IFRSQU5TSVRJT05fSEFORExFUlNcbiAgICAgIH0sIHtcbiAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICB9KSwgLy8gTm90ZTogYDx0cmFuaXRpb24+YCBzdXBwb3J0cyBhIHNpbmdsZSByb290IGVsZW1lbnQgb25seVxuICAgICAgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIElzc3VlICM1Njk6IGNvbGxhcHNlOjp0b2dnbGU6OnN0YXRlIHRyaWdnZXJlZCB0b28gbWFueSB0aW1lc1xuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vYm9vdHN0cmFwLXZ1ZS9ib290c3RyYXAtdnVlL2lzc3Vlcy81NjlcbiAgICovXG4gIC8vIEB2dWUvY29tcG9uZW50XG4gIHZhciBsaXN0ZW5PblJvb3RNaXhpbiA9IHtcbiAgICBtZXRob2RzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNhZmVseSByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgb24gdGhlIHJvb3QgVnVlIG5vZGUuXG4gICAgICAgKiBXaGlsZSBWdWUgYXV0b21hdGljYWxseSByZW1vdmVzIGxpc3RlbmVycyBmb3IgaW5kaXZpZHVhbCBjb21wb25lbnRzLFxuICAgICAgICogd2hlbiBhIGNvbXBvbmVudCByZWdpc3RlcnMgYSBsaXN0ZW5lciBvbiByb290IGFuZCBpcyBkZXN0cm95ZWQsXG4gICAgICAgKiB0aGlzIG9ycGhhbnMgYSBjYWxsYmFjayBiZWNhdXNlIHRoZSBub2RlIGlzIGdvbmUsXG4gICAgICAgKiBidXQgdGhlIHJvb3QgZG9lcyBub3QgY2xlYXIgdGhlIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIFdoZW4gcmVnaXN0ZXJpbmcgYSAkcm9vdCBsaXN0ZW5lciwgaXQgYWxzbyByZWdpc3RlcnMgYSBsaXN0ZW5lciBvblxuICAgICAgICogdGhlIGNvbXBvbmVudCdzIGBiZWZvcmVEZXN0cm95YCBob29rIHRvIGF1dG9tYXRpY2FsbHkgcmVtb3ZlIHRoZVxuICAgICAgICogZXZlbnQgbGlzdGVuZXIgZnJvbSB0aGUgJHJvb3QgaW5zdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICogQGNoYWluYWJsZVxuICAgICAgICovXG4gICAgICBsaXN0ZW5PblJvb3Q6IGZ1bmN0aW9uIGxpc3Rlbk9uUm9vdChldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLiRyb290LiRvbihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB0aGlzLiRvbignaG9vazpiZWZvcmVEZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLiRyb290LiRvZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7IC8vIFJldHVybiB0aGlzIGZvciBlYXN5IGNoYWluaW5nXG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNhZmVseSByZWdpc3RlciBhICRvbmNlIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSByb290IFZ1ZSBub2RlLlxuICAgICAgICogV2hpbGUgVnVlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlcyBsaXN0ZW5lcnMgZm9yIGluZGl2aWR1YWwgY29tcG9uZW50cyxcbiAgICAgICAqIHdoZW4gYSBjb21wb25lbnQgcmVnaXN0ZXJzIGEgbGlzdGVuZXIgb24gcm9vdCBhbmQgaXMgZGVzdHJveWVkLFxuICAgICAgICogdGhpcyBvcnBoYW5zIGEgY2FsbGJhY2sgYmVjYXVzZSB0aGUgbm9kZSBpcyBnb25lLFxuICAgICAgICogYnV0IHRoZSByb290IGRvZXMgbm90IGNsZWFyIHRoZSBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBXaGVuIHJlZ2lzdGVyaW5nIGEgJHJvb3QgbGlzdGVuZXIsIGl0IGFsc28gcmVnaXN0ZXJzIGEgbGlzdGVuZXIgb25cbiAgICAgICAqIHRoZSBjb21wb25lbnQncyBgYmVmb3JlRGVzdHJveWAgaG9vayB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGVcbiAgICAgICAqIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhlICRyb290IGluc3RhbmNlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAqIEBjaGFpbmFibGVcbiAgICAgICAqL1xuICAgICAgbGlzdGVuT25Sb290T25jZTogZnVuY3Rpb24gbGlzdGVuT25Sb290T25jZShldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy4kcm9vdC4kb25jZShldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB0aGlzLiRvbignaG9vazpiZWZvcmVEZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi4kcm9vdC4kb2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pOyAvLyBSZXR1cm4gdGhpcyBmb3IgZWFzeSBjaGFpbmluZ1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGNhbGxpbmcgdm0uJGVtaXQgb24gdm0uJHJvb3QuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7Kn0gYXJnc1xuICAgICAgICogQGNoYWluYWJsZVxuICAgICAgICovXG4gICAgICBlbWl0T25Sb290OiBmdW5jdGlvbiBlbWl0T25Sb290KGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyQkcm9vdDtcblxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICAoX3RoaXMkJHJvb3QgPSB0aGlzLiRyb290KS4kZW1pdC5hcHBseShfdGhpcyQkcm9vdCwgW2V2ZW50XS5jb25jYXQoYXJncykpOyAvLyBSZXR1cm4gdGhpcyBmb3IgZWFzeSBjaGFpbmluZ1xuXG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBFVkVOVF9TVEFURSA9ICdidjo6Y29sbGFwc2U6OnN0YXRlJztcbiAgdmFyIEVWRU5UX0FDQ09SRElPTiA9ICdidjo6Y29sbGFwc2U6OmFjY29yZGlvbic7IC8vIFByaXZhdGUgZXZlbnQgd2UgZW1pdCBvbiBgJHJvb3RgIHRvIGVuc3VyZSB0aGUgdG9nZ2xlIHN0YXRlIGlzXG4gIC8vIGFsd2F5cyBzeW5jZWQuIEl0IGdldHMgZW1pdHRlZCBldmVuIGlmIHRoZSBzdGF0ZSBoYXMgbm90IGNoYW5nZWQhXG4gIC8vIFRoaXMgZXZlbnQgaXMgTk9UIHRvIGJlIGRvY3VtZW50ZWQgYXMgcGVvcGxlIHNob3VsZCBub3QgYmUgdXNpbmcgaXRcblxuICB2YXIgRVZFTlRfU1RBVEVfU1lOQyA9ICdidjo6Y29sbGFwc2U6OnN5bmM6OnN0YXRlJzsgLy8gRXZlbnRzIHdlIGxpc3RlbiB0byBvbiBgJHJvb3RgXG5cbiAgdmFyIEVWRU5UX1RPR0dMRSA9ICdidjo6dG9nZ2xlOjpjb2xsYXBzZSc7XG4gIHZhciBFVkVOVF9TVEFURV9SRVFVRVNUID0gJ2J2OjpyZXF1ZXN0Ojpjb2xsYXBzZTo6c3RhdGUnOyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCQ29sbGFwc2UgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCQ29sbGFwc2UnLFxuICAgIG1peGluczogW2lkTWl4aW4sIGxpc3Rlbk9uUm9vdE1peGluLCBub3JtYWxpemVTbG90TWl4aW5dLFxuICAgIG1vZGVsOiB7XG4gICAgICBwcm9wOiAndmlzaWJsZScsXG4gICAgICBldmVudDogJ2lucHV0J1xuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGlzTmF2OiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgYWNjb3JkaW9uOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHZpc2libGU6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICB0YWc6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnZGl2J1xuICAgICAgfSxcbiAgICAgIGFwcGVhcjoge1xuICAgICAgICAvLyBJZiBgdHJ1ZWAgKGFuZCBgdmlzaWJsZWAgaXMgYHRydWVgIG9uIG1vdW50KSwgYW5pbWF0ZSBpbml0aWFsbHkgdmlzaWJsZVxuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNob3c6IHRoaXMudmlzaWJsZSxcbiAgICAgICAgdHJhbnNpdGlvbmluZzogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgY2xhc3NPYmplY3Q6IGZ1bmN0aW9uIGNsYXNzT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICduYXZiYXItY29sbGFwc2UnOiB0aGlzLmlzTmF2LFxuICAgICAgICAgIGNvbGxhcHNlOiAhdGhpcy50cmFuc2l0aW9uaW5nLFxuICAgICAgICAgIHNob3c6IHRoaXMuc2hvdyAmJiAhdGhpcy50cmFuc2l0aW9uaW5nXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgdmlzaWJsZTogZnVuY3Rpb24gdmlzaWJsZShuZXdWYWwpIHtcbiAgICAgICAgaWYgKG5ld1ZhbCAhPT0gdGhpcy5zaG93KSB7XG4gICAgICAgICAgdGhpcy5zaG93ID0gbmV3VmFsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2hvdzogZnVuY3Rpb24gc2hvdyhuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICBpZiAobmV3VmFsICE9PSBvbGRWYWwpIHtcbiAgICAgICAgICB0aGlzLmVtaXRTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgdGhpcy5zaG93ID0gdGhpcy52aXNpYmxlO1xuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuc2hvdyA9IHRoaXMudmlzaWJsZTsgLy8gTGlzdGVuIGZvciB0b2dnbGUgZXZlbnRzIHRvIG9wZW4vY2xvc2UgdXNcblxuICAgICAgdGhpcy5saXN0ZW5PblJvb3QoRVZFTlRfVE9HR0xFLCB0aGlzLmhhbmRsZVRvZ2dsZUV2dCk7IC8vIExpc3RlbiB0byBvdGhlciBjb2xsYXBzZXMgZm9yIGFjY29yZGlvbiBldmVudHNcblxuICAgICAgdGhpcy5saXN0ZW5PblJvb3QoRVZFTlRfQUNDT1JESU9OLCB0aGlzLmhhbmRsZUFjY29yZGlvbkV2dCk7XG5cbiAgICAgIGlmICh0aGlzLmlzTmF2KSB7XG4gICAgICAgIC8vIFNldCB1cCBoYW5kbGVyc1xuICAgICAgICB0aGlzLnNldFdpbmRvd0V2ZW50cyh0cnVlKTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5lbWl0U3RhdGUoKTtcbiAgICAgIH0pOyAvLyBMaXN0ZW4gZm9yIFwiU3luYyBzdGF0ZVwiIHJlcXVlc3RzIGZyb20gYHYtYi10b2dnbGVgXG5cbiAgICAgIHRoaXMubGlzdGVuT25Sb290KEVWRU5UX1NUQVRFX1JFUVVFU1QsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoaWQgPT09IF90aGlzLnNhZmVJZCgpKSB7XG4gICAgICAgICAgX3RoaXMuJG5leHRUaWNrKF90aGlzLmVtaXRTeW5jKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkKCkge1xuICAgICAgLy8gRW1pdCBhIHByaXZhdGUgZXZlbnQgZXZlcnkgdGltZSB0aGlzIGNvbXBvbmVudCB1cGRhdGVzIHRvIGVuc3VyZVxuICAgICAgLy8gdGhlIHRvZ2dsZSBidXR0b24gaXMgaW4gc3luYyB3aXRoIHRoZSBjb2xsYXBzZSdzIHN0YXRlXG4gICAgICAvLyBJdCBpcyBlbWl0dGVkIHJlZ2FyZGxlc3MgaWYgdGhlIHZpc2libGUgc3RhdGUgY2hhbmdlc1xuICAgICAgdGhpcy5lbWl0U3luYygpO1xuICAgIH0sXG4gICAgZGVhY3RpdmF0ZWQ6IGZ1bmN0aW9uIGRlYWN0aXZhdGVkKClcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHtcbiAgICAgIGlmICh0aGlzLmlzTmF2KSB7XG4gICAgICAgIHRoaXMuc2V0V2luZG93RXZlbnRzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFjdGl2YXRlZDogZnVuY3Rpb24gYWN0aXZhdGVkKClcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHtcbiAgICAgIGlmICh0aGlzLmlzTmF2KSB7XG4gICAgICAgIHRoaXMuc2V0V2luZG93RXZlbnRzKHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXRTeW5jKCk7XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgLy8gVHJpZ2dlciBzdGF0ZSBlbWl0IGlmIG5lZWRlZFxuICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmlzTmF2ICYmIGlzQnJvd3Nlcikge1xuICAgICAgICB0aGlzLnNldFdpbmRvd0V2ZW50cyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBzZXRXaW5kb3dFdmVudHM6IGZ1bmN0aW9uIHNldFdpbmRvd0V2ZW50cyhvbikge1xuICAgICAgICBldmVudE9uT2ZmKG9uLCB3aW5kb3csICdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSwgRVZFTlRfT1BUSU9OU19OT19DQVBUVVJFKTtcbiAgICAgICAgZXZlbnRPbk9mZihvbiwgd2luZG93LCAnb3JpZW50YXRpb25jaGFuZ2UnLCB0aGlzLmhhbmRsZVJlc2l6ZSwgRVZFTlRfT1BUSU9OU19OT19DQVBUVVJFKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgICAgdGhpcy5zaG93ID0gIXRoaXMuc2hvdztcbiAgICAgIH0sXG4gICAgICBvbkVudGVyOiBmdW5jdGlvbiBvbkVudGVyKCkge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSB0cnVlOyAvLyBUaGlzIHNob3VsZCBiZSBtb3ZlZCBvdXQgc28gd2UgY2FuIGFkZCBjYW5jZWxsYWJsZSBldmVudHNcblxuICAgICAgICB0aGlzLiRlbWl0KCdzaG93Jyk7XG4gICAgICB9LFxuICAgICAgb25BZnRlckVudGVyOiBmdW5jdGlvbiBvbkFmdGVyRW50ZXIoKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRlbWl0KCdzaG93bicpO1xuICAgICAgfSxcbiAgICAgIG9uTGVhdmU6IGZ1bmN0aW9uIG9uTGVhdmUoKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IHRydWU7IC8vIFRoaXMgc2hvdWxkIGJlIG1vdmVkIG91dCBzbyB3ZSBjYW4gYWRkIGNhbmNlbGxhYmxlIGV2ZW50c1xuXG4gICAgICAgIHRoaXMuJGVtaXQoJ2hpZGUnKTtcbiAgICAgIH0sXG4gICAgICBvbkFmdGVyTGVhdmU6IGZ1bmN0aW9uIG9uQWZ0ZXJMZWF2ZSgpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2hpZGRlbicpO1xuICAgICAgfSxcbiAgICAgIGVtaXRTdGF0ZTogZnVuY3Rpb24gZW1pdFN0YXRlKCkge1xuICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIHRoaXMuc2hvdyk7IC8vIExldCBgdi1iLXRvZ2dsZWAga25vdyB0aGUgc3RhdGUgb2YgdGhpcyBjb2xsYXBzZVxuXG4gICAgICAgIHRoaXMuJHJvb3QuJGVtaXQoRVZFTlRfU1RBVEUsIHRoaXMuc2FmZUlkKCksIHRoaXMuc2hvdyk7XG5cbiAgICAgICAgaWYgKHRoaXMuYWNjb3JkaW9uICYmIHRoaXMuc2hvdykge1xuICAgICAgICAgIC8vIFRlbGwgdGhlIG90aGVyIGNvbGxhcHNlcyBpbiB0aGlzIGFjY29yZGlvbiB0byBjbG9zZVxuICAgICAgICAgIHRoaXMuJHJvb3QuJGVtaXQoRVZFTlRfQUNDT1JESU9OLCB0aGlzLnNhZmVJZCgpLCB0aGlzLmFjY29yZGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlbWl0U3luYzogZnVuY3Rpb24gZW1pdFN5bmMoKSB7XG4gICAgICAgIC8vIEVtaXQgYSBwcml2YXRlIGV2ZW50IGV2ZXJ5IHRpbWUgdGhpcyBjb21wb25lbnQgdXBkYXRlcyB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhlIHRvZ2dsZSBidXR0b24gaXMgaW4gc3luYyB3aXRoIHRoZSBjb2xsYXBzZSdzIHN0YXRlXG4gICAgICAgIC8vIEl0IGlzIGVtaXR0ZWQgcmVnYXJkbGVzcyBpZiB0aGUgdmlzaWJsZSBzdGF0ZSBjaGFuZ2VzXG4gICAgICAgIHRoaXMuJHJvb3QuJGVtaXQoRVZFTlRfU1RBVEVfU1lOQywgdGhpcy5zYWZlSWQoKSwgdGhpcy5zaG93KTtcbiAgICAgIH0sXG4gICAgICBjaGVja0Rpc3BsYXlCbG9jazogZnVuY3Rpb24gY2hlY2tEaXNwbGF5QmxvY2soKSB7XG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgY29sbGFwc2UgaGFzIGBkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50YCBzZXRcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc2V0IGBkaXNwbGF5OiBub25lYCBkaXJlY3RseSBvbiBgdGhpcy4kZWxgLCBhcyBpdCB3b3VsZFxuICAgICAgICAvLyB0cmlnZ2VyIGEgbmV3IHRyYW5zaXRpb24gdG8gc3RhcnQgKG9yIGNhbmNlbCBhIGN1cnJlbnQgb25lKVxuICAgICAgICB2YXIgcmVzdG9yZSA9IGhhc0NsYXNzKHRoaXMuJGVsLCAnc2hvdycpO1xuICAgICAgICByZW1vdmVDbGFzcyh0aGlzLiRlbCwgJ3Nob3cnKTtcbiAgICAgICAgdmFyIGlzQmxvY2sgPSBnZXRDUyh0aGlzLiRlbCkuZGlzcGxheSA9PT0gJ2Jsb2NrJztcblxuICAgICAgICBpZiAocmVzdG9yZSkge1xuICAgICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCAnc2hvdycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzQmxvY2s7XG4gICAgICB9LFxuICAgICAgY2xpY2tIYW5kbGVyOiBmdW5jdGlvbiBjbGlja0hhbmRsZXIoZXZ0KSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSBpbiBhIG5hdi9uYXZiYXIsIGNsb3NlIHRoZSBjb2xsYXBzZSB3aGVuIG5vbi1kaXNhYmxlZCBsaW5rIGNsaWNrZWRcbiAgICAgICAgdmFyIGVsID0gZXZ0LnRhcmdldDtcblxuICAgICAgICBpZiAoIXRoaXMuaXNOYXYgfHwgIWVsIHx8IGdldENTKHRoaXMuJGVsKS5kaXNwbGF5ICE9PSAnYmxvY2snKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGNhbid0IHRlc3QgZ2V0Q29tcHV0ZWRTdHlsZSBpbiBKU0RPTSAqL1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaGVzKGVsLCAnLm5hdi1saW5rLC5kcm9wZG93bi1pdGVtJykgfHwgY2xvc2VzdCgnLm5hdi1saW5rLC5kcm9wZG93bi1pdGVtJywgZWwpKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmNoZWNrRGlzcGxheUJsb2NrKCkpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgY2xvc2UgdGhlIGNvbGxhcHNlIGlmIGl0IGlzIG5vdCBmb3JjZWQgdG8gYmUgYGRpc3BsYXk6IGJsb2NrICFpbXBvcnRhbnRgXG4gICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYW5kbGVUb2dnbGVFdnQ6IGZ1bmN0aW9uIGhhbmRsZVRvZ2dsZUV2dCh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gdGhpcy5zYWZlSWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQWNjb3JkaW9uRXZ0OiBmdW5jdGlvbiBoYW5kbGVBY2NvcmRpb25FdnQob3BlbmVkSWQsIGFjY29yZGlvbikge1xuICAgICAgICBpZiAoIXRoaXMuYWNjb3JkaW9uIHx8IGFjY29yZGlvbiAhPT0gdGhpcy5hY2NvcmRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3BlbmVkSWQgPT09IHRoaXMuc2FmZUlkKCkpIHtcbiAgICAgICAgICAvLyBPcGVuIHRoaXMgY29sbGFwc2UgaWYgbm90IHNob3duXG4gICAgICAgICAgaWYgKCF0aGlzLnNob3cpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENsb3NlIHRoaXMgY29sbGFwc2UgaWYgc2hvd25cbiAgICAgICAgICBpZiAodGhpcy5zaG93KSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhbmRsZVJlc2l6ZTogZnVuY3Rpb24gaGFuZGxlUmVzaXplKCkge1xuICAgICAgICAvLyBIYW5kbGVyIGZvciBvcmllbnRhdGlvbi9yZXNpemUgdG8gc2V0IGNvbGxhcHNlZCBzdGF0ZSBpbiBuYXYvbmF2YmFyXG4gICAgICAgIHRoaXMuc2hvdyA9IGdldENTKHRoaXMuJGVsKS5kaXNwbGF5ID09PSAnYmxvY2snO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBzY29wZSA9IHtcbiAgICAgICAgdmlzaWJsZTogdGhpcy5zaG93LFxuICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5zaG93ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgY29udGVudCA9IGgodGhpcy50YWcsIHtcbiAgICAgICAgY2xhc3M6IHRoaXMuY2xhc3NPYmplY3QsXG4gICAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgICAgbmFtZTogJ3Nob3cnLFxuICAgICAgICAgIHZhbHVlOiB0aGlzLnNob3dcbiAgICAgICAgfV0sXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHRoaXMuc2FmZUlkKClcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBjbGljazogdGhpcy5jbGlja0hhbmRsZXJcbiAgICAgICAgfVxuICAgICAgfSwgW3RoaXMubm9ybWFsaXplU2xvdCgnZGVmYXVsdCcsIHNjb3BlKV0pO1xuICAgICAgcmV0dXJuIGgoQlZDb2xsYXBzZSwge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGFwcGVhcjogdGhpcy5hcHBlYXJcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBlbnRlcjogdGhpcy5vbkVudGVyLFxuICAgICAgICAgIGFmdGVyRW50ZXI6IHRoaXMub25BZnRlckVudGVyLFxuICAgICAgICAgIGxlYXZlOiB0aGlzLm9uTGVhdmUsXG4gICAgICAgICAgYWZ0ZXJMZWF2ZTogdGhpcy5vbkFmdGVyTGVhdmVcbiAgICAgICAgfVxuICAgICAgfSwgW2NvbnRlbnRdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBhbGxMaXN0ZW5UeXBlcyA9IHtcbiAgICBob3ZlcjogdHJ1ZSxcbiAgICBjbGljazogdHJ1ZSxcbiAgICBmb2N1czogdHJ1ZVxuICB9O1xuICB2YXIgQlZCb3VuZExpc3RlbmVycyA9ICdfX0JWX2JvdW5kRXZlbnRMaXN0ZW5lcnNfXyc7XG5cbiAgdmFyIGdldFRhcmdldHMgPSBmdW5jdGlvbiBnZXRUYXJnZXRzKGJpbmRpbmcpIHtcbiAgICB2YXIgdGFyZ2V0cyA9IGtleXMoYmluZGluZy5tb2RpZmllcnMgfHwge30pLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuICFhbGxMaXN0ZW5UeXBlc1t0XTtcbiAgICB9KTtcblxuICAgIGlmIChiaW5kaW5nLnZhbHVlKSB7XG4gICAgICB0YXJnZXRzLnB1c2goYmluZGluZy52YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldHM7XG4gIH07XG5cbiAgdmFyIGJpbmRUYXJnZXRzID0gZnVuY3Rpb24gYmluZFRhcmdldHModm5vZGUsIGJpbmRpbmcsIGxpc3RlblR5cGVzLCBmbikge1xuICAgIHZhciB0YXJnZXRzID0gZ2V0VGFyZ2V0cyhiaW5kaW5nKTtcblxuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgZm4oe1xuICAgICAgICB0YXJnZXRzOiB0YXJnZXRzLFxuICAgICAgICB2bm9kZTogdm5vZGVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBrZXlzKGFsbExpc3RlblR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBpZiAobGlzdGVuVHlwZXNbdHlwZV0gfHwgYmluZGluZy5tb2RpZmllcnNbdHlwZV0pIHtcbiAgICAgICAgZXZlbnRPbih2bm9kZS5lbG0sIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgdmFyIGJvdW5kTGlzdGVuZXJzID0gdm5vZGUuZWxtW0JWQm91bmRMaXN0ZW5lcnNdIHx8IHt9O1xuICAgICAgICBib3VuZExpc3RlbmVyc1t0eXBlXSA9IGJvdW5kTGlzdGVuZXJzW3R5cGVdIHx8IFtdO1xuICAgICAgICBib3VuZExpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgdm5vZGUuZWxtW0JWQm91bmRMaXN0ZW5lcnNdID0gYm91bmRMaXN0ZW5lcnM7XG4gICAgICB9XG4gICAgfSk7IC8vIFJldHVybiB0aGUgbGlzdCBvZiB0YXJnZXRzXG5cbiAgICByZXR1cm4gdGFyZ2V0cztcbiAgfTtcblxuICB2YXIgdW5iaW5kVGFyZ2V0cyA9IGZ1bmN0aW9uIHVuYmluZFRhcmdldHModm5vZGUsIGJpbmRpbmcsIGxpc3RlblR5cGVzKSB7XG4gICAga2V5cyhhbGxMaXN0ZW5UeXBlcykuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgaWYgKGxpc3RlblR5cGVzW3R5cGVdIHx8IGJpbmRpbmcubW9kaWZpZXJzW3R5cGVdKSB7XG4gICAgICAgIHZhciBib3VuZExpc3RlbmVycyA9IHZub2RlLmVsbVtCVkJvdW5kTGlzdGVuZXJzXSAmJiB2bm9kZS5lbG1bQlZCb3VuZExpc3RlbmVyc11bdHlwZV07XG5cbiAgICAgICAgaWYgKGJvdW5kTGlzdGVuZXJzKSB7XG4gICAgICAgICAgYm91bmRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudE9mZih2bm9kZS5lbG0sIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgdm5vZGUuZWxtW0JWQm91bmRMaXN0ZW5lcnNdW3R5cGVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlblR5cGVzID0ge1xuICAgIGNsaWNrOiB0cnVlXG4gIH07IC8vIFByb3BlcnR5IGtleSBmb3IgaGFuZGxlciBzdG9yYWdlXG5cbiAgdmFyIEJWX1RPR0dMRSA9ICdfX0JWX3RvZ2dsZV9fJztcbiAgdmFyIEJWX1RPR0dMRV9TVEFURSA9ICdfX0JWX3RvZ2dsZV9TVEFURV9fJztcbiAgdmFyIEJWX1RPR0dMRV9DT05UUk9MUyA9ICdfX0JWX3RvZ2dsZV9DT05UUk9MU19fJztcbiAgdmFyIEJWX1RPR0dMRV9UQVJHRVRTID0gJ19fQlZfdG9nZ2xlX1RBUkdFVFNfXyc7IC8vIEVtaXR0ZWQgY29udHJvbCBldmVudCBmb3IgY29sbGFwc2UgKGVtaXR0ZWQgdG8gY29sbGFwc2UpXG5cbiAgdmFyIEVWRU5UX1RPR0dMRSQxID0gJ2J2Ojp0b2dnbGU6OmNvbGxhcHNlJzsgLy8gTGlzdGVuIHRvIGV2ZW50IGZvciB0b2dnbGUgc3RhdGUgdXBkYXRlIChlbWl0dGVkIGJ5IGNvbGxhcHNlKVxuXG4gIHZhciBFVkVOVF9TVEFURSQxID0gJ2J2Ojpjb2xsYXBzZTo6c3RhdGUnOyAvLyBQcml2YXRlIGV2ZW50IGVtaXR0ZWQgb24gJHJvb3QgdG8gZW5zdXJlIHRoZSB0b2dnbGUgc3RhdGUgaXMgYWx3YXlzIHN5bmNlZC5cbiAgLy8gR2V0cyBlbWl0dGVkIGV2ZW4gaWYgdGhlIHN0YXRlIG9mIGItY29sbGFwc2UgaGFzIG5vdCBjaGFuZ2VkLlxuICAvLyBUaGlzIGV2ZW50IGlzIE5PVCB0byBiZSBkb2N1bWVudGVkIGFzIHBlb3BsZSBzaG91bGQgbm90IGJlIHVzaW5nIGl0LlxuXG4gIHZhciBFVkVOVF9TVEFURV9TWU5DJDEgPSAnYnY6OmNvbGxhcHNlOjpzeW5jOjpzdGF0ZSc7IC8vIFByaXZhdGUgZXZlbnQgd2Ugc2VuZCB0byBjb2xsYXBzZSB0byByZXF1ZXN0IHN0YXRlIHVwZGF0ZSBzeW5jIGV2ZW50XG5cbiAgdmFyIEVWRU5UX1NUQVRFX1JFUVVFU1QkMSA9ICdidjo6cmVxdWVzdDo6Y29sbGFwc2U6OnN0YXRlJzsgLy8gUmVzZXQgYW5kIHJlbW92ZSBhIHByb3BlcnR5IGZyb20gdGhlIHByb3ZpZGVkIGVsZW1lbnRcblxuICB2YXIgcmVzZXRQcm9wID0gZnVuY3Rpb24gcmVzZXRQcm9wKGVsLCBwcm9wKSB7XG4gICAgZWxbcHJvcF0gPSBudWxsO1xuICAgIGRlbGV0ZSBlbFtwcm9wXTtcbiAgfTsgLy8gSGFuZGxlIHRhcmdldHMgdXBkYXRlXG5cblxuICB2YXIgaGFuZGxlVGFyZ2V0cyA9IGZ1bmN0aW9uIGhhbmRsZVRhcmdldHMoX3JlZikge1xuICAgIHZhciB0YXJnZXRzID0gX3JlZi50YXJnZXRzLFxuICAgICAgICB2bm9kZSA9IF9yZWYudm5vZGU7XG4gICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHZub2RlLmNvbnRleHQuJHJvb3QuJGVtaXQoRVZFTlRfVE9HR0xFJDEsIHRhcmdldCk7XG4gICAgfSk7XG4gIH07IC8vIEhhbmRsZSBkaXJlY3RpdmUgdXBkYXRlc1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBub3QgZWFzeSB0byB0ZXN0ICovXG5cblxuICB2YXIgaGFuZGxlVXBkYXRlID0gZnVuY3Rpb24gaGFuZGxlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICghaXNCcm93c2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFsb29zZUVxdWFsKGdldFRhcmdldHMoYmluZGluZyksIGVsW0JWX1RPR0dMRV9UQVJHRVRTXSkpIHtcbiAgICAgIC8vIFRhcmdldHMgaGF2ZSBjaGFuZ2VkLCBzbyB1cGRhdGUgYWNjb3JkaW5nbHlcbiAgICAgIHVuYmluZFRhcmdldHModm5vZGUsIGJpbmRpbmcsIGxpc3RlblR5cGVzKTtcbiAgICAgIHZhciB0YXJnZXRzID0gYmluZFRhcmdldHModm5vZGUsIGJpbmRpbmcsIGxpc3RlblR5cGVzLCBoYW5kbGVUYXJnZXRzKTsgLy8gVXBkYXRlIHRhcmdldHMgYXJyYXkgdG8gZWxlbWVudFxuXG4gICAgICBlbFtCVl9UT0dHTEVfVEFSR0VUU10gPSB0YXJnZXRzOyAvLyBBZGQgYXJpYSBhdHRyaWJ1dGVzIHRvIGVsZW1lbnRcblxuICAgICAgZWxbQlZfVE9HR0xFX0NPTlRST0xTXSA9IHRhcmdldHMuam9pbignICcpOyAvLyBlbnN1cmUgYXJpYS1jb250cm9scyBpcyB1cCB0byBkYXRlXG5cbiAgICAgIHNldEF0dHIoZWwsICdhcmlhLWNvbnRyb2xzJywgZWxbQlZfVE9HR0xFX0NPTlRST0xTXSk7IC8vIFJlcXVlc3QgYSBzdGF0ZSB1cGRhdGUgZnJvbSB0YXJnZXRzIHNvIHRoYXQgd2UgY2FuIGVuc3VyZVxuICAgICAgLy8gZXhwYW5kZWQgc3RhdGUgaXMgY29ycmVjdFxuXG4gICAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB2bm9kZS5jb250ZXh0LiRyb290LiRlbWl0KEVWRU5UX1NUQVRFX1JFUVVFU1QkMSwgdGFyZ2V0KTtcbiAgICAgIH0pO1xuICAgIH0gLy8gRW5zdXJlIHRoZSBjb2xsYXBzZSBjbGFzcyBhbmQgYXJpYS0qIGF0dHJpYnV0ZXMgcGVyc2lzdFxuICAgIC8vIGFmdGVyIGVsZW1lbnQgaXMgdXBkYXRlZCAoZWl0aGVyIGJ5IHBhcmVudCByZS1yZW5kZXJpbmdcbiAgICAvLyBvciBjaGFuZ2VzIHRvIHRoaXMgZWxlbWVudCBvciBpdHMgY29udGVudHNcblxuXG4gICAgaWYgKGVsW0JWX1RPR0dMRV9TVEFURV0gPT09IHRydWUpIHtcbiAgICAgIGFkZENsYXNzKGVsLCAnY29sbGFwc2VkJyk7XG4gICAgICBzZXRBdHRyKGVsLCAnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG4gICAgfSBlbHNlIGlmIChlbFtCVl9UT0dHTEVfU1RBVEVdID09PSBmYWxzZSkge1xuICAgICAgcmVtb3ZlQ2xhc3MoZWwsICdjb2xsYXBzZWQnKTtcbiAgICAgIHNldEF0dHIoZWwsICdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgfVxuXG4gICAgc2V0QXR0cihlbCwgJ2FyaWEtY29udHJvbHMnLCBlbFtCVl9UT0dHTEVfQ09OVFJPTFNdKTtcbiAgfTtcbiAgLypcbiAgICogRXhwb3J0IG91ciBkaXJlY3RpdmVcbiAgICovXG5cblxuICB2YXIgVkJUb2dnbGUgPSB7XG4gICAgYmluZDogZnVuY3Rpb24gYmluZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICAgIHZhciB0YXJnZXRzID0gYmluZFRhcmdldHModm5vZGUsIGJpbmRpbmcsIGxpc3RlblR5cGVzLCBoYW5kbGVUYXJnZXRzKTtcblxuICAgICAgaWYgKGlzQnJvd3NlciAmJiB2bm9kZS5jb250ZXh0ICYmIHRhcmdldHMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBBZGQgdGFyZ2V0cyBhcnJheSB0byBlbGVtZW50XG4gICAgICAgIGVsW0JWX1RPR0dMRV9UQVJHRVRTXSA9IHRhcmdldHM7IC8vIEFkZCBhcmlhIGF0dHJpYnV0ZXMgdG8gZWxlbWVudFxuXG4gICAgICAgIGVsW0JWX1RPR0dMRV9DT05UUk9MU10gPSB0YXJnZXRzLmpvaW4oJyAnKTsgLy8gU3RhdGUgaXMgaW5pdGlhbGx5IGNvbGxhcHNlZCB1bnRpbCB3ZSByZWNlaXZlIGEgc3RhdGUgZXZlbnRcblxuICAgICAgICBlbFtCVl9UT0dHTEVfU1RBVEVdID0gZmFsc2U7XG4gICAgICAgIHNldEF0dHIoZWwsICdhcmlhLWNvbnRyb2xzJywgZWxbQlZfVE9HR0xFX0NPTlRST0xTXSk7XG4gICAgICAgIHNldEF0dHIoZWwsICdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7IC8vIElmIGVsZW1lbnQgaXMgbm90IGEgYnV0dG9uLCB3ZSBhZGQgYHJvbGU9XCJidXR0b25cImAgZm9yIGFjY2Vzc2liaWxpdHlcblxuICAgICAgICBpZiAoZWwudGFnTmFtZSAhPT0gJ0JVVFRPTicgJiYgIWhhc0F0dHIoZWwsICdyb2xlJykpIHtcbiAgICAgICAgICBzZXRBdHRyKGVsLCAncm9sZScsICdidXR0b24nKTtcbiAgICAgICAgfSAvLyBUb2dnbGUgc3RhdGUgaGFuZGxlclxuXG5cbiAgICAgICAgdmFyIHRvZ2dsZURpcmVjdGl2ZUhhbmRsZXIgPSBmdW5jdGlvbiB0b2dnbGVEaXJlY3RpdmVIYW5kbGVyKGlkLCBzdGF0ZSkge1xuICAgICAgICAgIHZhciB0YXJnZXRzID0gZWxbQlZfVE9HR0xFX1RBUkdFVFNdIHx8IFtdO1xuXG4gICAgICAgICAgaWYgKHRhcmdldHMuaW5kZXhPZihpZCkgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBTZXQgYXJpYS1leHBhbmRlZCBzdGF0ZVxuICAgICAgICAgICAgc2V0QXR0cihlbCwgJ2FyaWEtZXhwYW5kZWQnLCBzdGF0ZSA/ICd0cnVlJyA6ICdmYWxzZScpOyAvLyBTZXQvQ2xlYXIgJ2NvbGxhcHNlZCcgY2xhc3Mgc3RhdGVcblxuICAgICAgICAgICAgZWxbQlZfVE9HR0xFX1NUQVRFXSA9IHN0YXRlO1xuXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsICdjb2xsYXBzZWQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkZENsYXNzKGVsLCAnY29sbGFwc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9OyAvLyBTdG9yZSB0aGUgdG9nZ2xlIGhhbmRsZXIgb24gdGhlIGVsZW1lbnRcblxuXG4gICAgICAgIGVsW0JWX1RPR0dMRV0gPSB0b2dnbGVEaXJlY3RpdmVIYW5kbGVyOyAvLyBMaXN0ZW4gZm9yIHRvZ2dsZSBzdGF0ZSBjaGFuZ2VzIChwdWJsaWMpXG5cbiAgICAgICAgdm5vZGUuY29udGV4dC4kcm9vdC4kb24oRVZFTlRfU1RBVEUkMSwgZWxbQlZfVE9HR0xFXSk7IC8vIExpc3RlbiBmb3IgdG9nZ2xlIHN0YXRlIHN5bmMgKHByaXZhdGUpXG5cbiAgICAgICAgdm5vZGUuY29udGV4dC4kcm9vdC4kb24oRVZFTlRfU1RBVEVfU1lOQyQxLCBlbFtCVl9UT0dHTEVdKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXBvbmVudFVwZGF0ZWQ6IGhhbmRsZVVwZGF0ZSxcbiAgICB1cGRhdGVkOiBoYW5kbGVVcGRhdGUsXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoZWwsIGJpbmRpbmcsIHZub2RlKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAge1xuICAgICAgdW5iaW5kVGFyZ2V0cyh2bm9kZSwgYmluZGluZywgbGlzdGVuVHlwZXMpOyAvLyBSZW1vdmUgb3VyICRyb290IGxpc3RlbmVyXG5cbiAgICAgIGlmIChlbFtCVl9UT0dHTEVdKSB7XG4gICAgICAgIHZub2RlLmNvbnRleHQuJHJvb3QuJG9mZihFVkVOVF9TVEFURSQxLCBlbFtCVl9UT0dHTEVdKTtcbiAgICAgICAgdm5vZGUuY29udGV4dC4kcm9vdC4kb2ZmKEVWRU5UX1NUQVRFX1NZTkMkMSwgZWxbQlZfVE9HR0xFXSk7XG4gICAgICB9IC8vIFJlc2V0IGN1c3RvbSAgcHJvcHNcblxuXG4gICAgICByZXNldFByb3AoZWwsIEJWX1RPR0dMRSk7XG4gICAgICByZXNldFByb3AoZWwsIEJWX1RPR0dMRV9TVEFURSk7XG4gICAgICByZXNldFByb3AoZWwsIEJWX1RPR0dMRV9DT05UUk9MUyk7XG4gICAgICByZXNldFByb3AoZWwsIEJWX1RPR0dMRV9UQVJHRVRTKTsgLy8gUmVzZXQgY2xhc3Nlcy9hdHRyc1xuXG4gICAgICByZW1vdmVDbGFzcyhlbCwgJ2NvbGxhcHNlZCcpO1xuICAgICAgcmVtb3ZlQXR0cihlbCwgJ2FyaWEtZXhwYW5kZWQnKTtcbiAgICAgIHJlbW92ZUF0dHIoZWwsICdhcmlhLWNvbnRyb2xzJyk7XG4gICAgICByZW1vdmVBdHRyKGVsLCAncm9sZScpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgQ29sbGFwc2VQbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJDb2xsYXBzZTogQkNvbGxhcHNlXG4gICAgfSxcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICBWQlRvZ2dsZTogVkJUb2dnbGVcbiAgICB9XG4gIH0pO1xuXG4gIC8qKiFcbiAgICogQGZpbGVPdmVydmlldyBLaWNrYXNzIGxpYnJhcnkgdG8gY3JlYXRlIGFuZCBwbGFjZSBwb3BwZXJzIG5lYXIgdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnRzLlxuICAgKiBAdmVyc2lvbiAxLjE2LjFcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IChjKSAyMDE2IEZlZGVyaWNvIFppdm9sbyBhbmQgY29udHJpYnV0b3JzXG4gICAqXG4gICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAqXG4gICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgKlxuICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgKiBTT0ZUV0FSRS5cbiAgICovXG4gIHZhciBpc0Jyb3dzZXIkMSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgdmFyIHRpbWVvdXREdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbG9uZ2VyVGltZW91dEJyb3dzZXJzID0gWydFZGdlJywgJ1RyaWRlbnQnLCAnRmlyZWZveCddO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9uZ2VyVGltZW91dEJyb3dzZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoaXNCcm93c2VyJDEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKGxvbmdlclRpbWVvdXRCcm93c2Vyc1tpXSkgPj0gMCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShmbikge1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNhbGxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgd2luZG93LlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB0YXNrRGVib3VuY2UoZm4pIHtcbiAgICB2YXIgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgIGZuKCk7XG4gICAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBzdXBwb3J0c01pY3JvVGFza3MgPSBpc0Jyb3dzZXIkMSAmJiB3aW5kb3cuUHJvbWlzZTtcblxuICAvKipcbiAgKiBDcmVhdGUgYSBkZWJvdW5jZWQgdmVyc2lvbiBvZiBhIG1ldGhvZCwgdGhhdCdzIGFzeW5jaHJvbm91c2x5IGRlZmVycmVkXG4gICogYnV0IGNhbGxlZCBpbiB0aGUgbWluaW11bSB0aW1lIHBvc3NpYmxlLlxuICAqXG4gICogQG1ldGhvZFxuICAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAgKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgKi9cbiAgdmFyIGRlYm91bmNlID0gc3VwcG9ydHNNaWNyb1Rhc2tzID8gbWljcm90YXNrRGVib3VuY2UgOiB0YXNrRGVib3VuY2U7XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICAgKiBAYXJndW1lbnQge0FueX0gZnVuY3Rpb25Ub0NoZWNrIC0gdmFyaWFibGUgdG8gY2hlY2tcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAgICovXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24kMShmdW5jdGlvblRvQ2hlY2spIHtcbiAgICB2YXIgZ2V0VHlwZSA9IHt9O1xuICAgIHJldHVybiBmdW5jdGlvblRvQ2hlY2sgJiYgZ2V0VHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IENTUyBjb21wdXRlZCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAgICogQGFyZ3VtZW50IHtFZW1lbnR9IGVsZW1lbnRcbiAgICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICAgIHZhciB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgdmFyIGNzcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICAgIHJldHVybiBwcm9wZXJ0eSA/IGNzc1twcm9wZXJ0eV0gOiBjc3M7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFyZW50Tm9kZSBvciB0aGUgaG9zdCBvZiB0aGUgZWxlbWVudFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAgICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAgICovXG4gIGZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzY3JvbGxpbmcgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICAgKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybnMge0VsZW1lbnR9IHNjcm9sbCBwYXJlbnRcbiAgICovXG4gIGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gICAgLy8gUmV0dXJuIGJvZHksIGBnZXRTY3JvbGxgIHdpbGwgdGFrZSBjYXJlIHRvIGdldCB0aGUgY29ycmVjdCBgc2Nyb2xsVG9wYCBmcm9tIGl0XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGVsZW1lbnQubm9kZU5hbWUpIHtcbiAgICAgIGNhc2UgJ0hUTUwnOlxuICAgICAgY2FzZSAnQk9EWSc6XG4gICAgICAgIHJldHVybiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICAgIHJldHVybiBlbGVtZW50LmJvZHk7XG4gICAgfVxuXG4gICAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG5cbiAgICB2YXIgX2dldFN0eWxlQ29tcHV0ZWRQcm9wID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpLFxuICAgICAgICBvdmVyZmxvdyA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvdyxcbiAgICAgICAgb3ZlcmZsb3dYID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WCxcbiAgICAgICAgb3ZlcmZsb3dZID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WTtcblxuICAgIGlmICgvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZWZlcmVuY2Ugbm9kZSBvZiB0aGUgcmVmZXJlbmNlIG9iamVjdCwgb3IgdGhlIHJlZmVyZW5jZSBvYmplY3QgaXRzZWxmLlxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAgICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpIHtcbiAgICByZXR1cm4gcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5yZWZlcmVuY2VOb2RlID8gcmVmZXJlbmNlLnJlZmVyZW5jZU5vZGUgOiByZWZlcmVuY2U7XG4gIH1cblxuICB2YXIgaXNJRTExID0gaXNCcm93c2VyJDEgJiYgISEod2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG4gIHZhciBpc0lFMTAgPSBpc0Jyb3dzZXIkMSAmJiAvTVNJRSAxMC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3JlclxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZlcnNpb24gdG8gY2hlY2tcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGlzSUVcbiAgICovXG4gIGZ1bmN0aW9uIGlzSUUkMSh2ZXJzaW9uKSB7XG4gICAgaWYgKHZlcnNpb24gPT09IDExKSB7XG4gICAgICByZXR1cm4gaXNJRTExO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbiA9PT0gMTApIHtcbiAgICAgIHJldHVybiBpc0lFMTA7XG4gICAgfVxuICAgIHJldHVybiBpc0lFMTEgfHwgaXNJRTEwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gICAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcmV0dXJucyB7RWxlbWVudH0gb2Zmc2V0IHBhcmVudFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIG5vT2Zmc2V0UGFyZW50ID0gaXNJRSQxKDEwKSA/IGRvY3VtZW50LmJvZHkgOiBudWxsO1xuXG4gICAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgbnVsbDtcbiAgICAvLyBTa2lwIGhpZGRlbiBlbGVtZW50cyB3aGljaCBkb24ndCBoYXZlIGFuIG9mZnNldFBhcmVudFxuICAgIHdoaWxlIChvZmZzZXRQYXJlbnQgPT09IG5vT2Zmc2V0UGFyZW50ICYmIGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSAoZWxlbWVudCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVOYW1lID0gb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudC5ub2RlTmFtZTtcblxuICAgIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBUSCwgVEQgb3IgVEFCTEUgaW4gY2FzZVxuICAgIC8vIG5vIG9mZnNldFBhcmVudCBpcyBwcmVzZW50LCBJIGhhdGUgdGhpcyBqb2IuLi5cbiAgICBpZiAoWydUSCcsICdURCcsICdUQUJMRSddLmluZGV4T2Yob2Zmc2V0UGFyZW50Lm5vZGVOYW1lKSAhPT0gLTEgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KG9mZnNldFBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldFBhcmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gICAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVOYW1lID09PSAnSFRNTCcgfHwgZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBlbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSByb290IG5vZGUgKGRvY3VtZW50LCBzaGFkb3dET00gcm9vdCkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gICAqIEBhcmd1bWVudCB7RWxlbWVudH0gbm9kZVxuICAgKiBAcmV0dXJucyB7RWxlbWVudH0gcm9vdCBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZ2V0Um9vdChub2RlLnBhcmVudE5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBvZmZzZXQgcGFyZW50IGNvbW1vbiB0byB0aGUgdHdvIHByb3ZpZGVkIG5vZGVzXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICAgKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQxXG4gICAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDJcbiAgICogQHJldHVybnMge0VsZW1lbnR9IGNvbW1vbiBvZmZzZXQgcGFyZW50XG4gICAqL1xuICBmdW5jdGlvbiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBlbGVtZW50Mikge1xuICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICAgIGlmICghZWxlbWVudDEgfHwgIWVsZW1lbnQxLm5vZGVUeXBlIHx8ICFlbGVtZW50MiB8fCAhZWxlbWVudDIubm9kZVR5cGUpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gSGVyZSB3ZSBtYWtlIHN1cmUgdG8gZ2l2ZSBhcyBcInN0YXJ0XCIgdGhlIGVsZW1lbnQgdGhhdCBjb21lcyBmaXJzdCBpbiB0aGUgRE9NXG4gICAgdmFyIG9yZGVyID0gZWxlbWVudDEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudDIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gICAgdmFyIHN0YXJ0ID0gb3JkZXIgPyBlbGVtZW50MSA6IGVsZW1lbnQyO1xuICAgIHZhciBlbmQgPSBvcmRlciA/IGVsZW1lbnQyIDogZWxlbWVudDE7XG5cbiAgICAvLyBHZXQgY29tbW9uIGFuY2VzdG9yIGNvbnRhaW5lclxuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQsIDApO1xuICAgIHJhbmdlLnNldEVuZChlbmQsIDApO1xuICAgIHZhciBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gICAgLy8gQm90aCBub2RlcyBhcmUgaW5zaWRlICNkb2N1bWVudFxuXG4gICAgaWYgKGVsZW1lbnQxICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciAmJiBlbGVtZW50MiAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgfHwgc3RhcnQuY29udGFpbnMoZW5kKSkge1xuICAgICAgaWYgKGlzT2Zmc2V0Q29udGFpbmVyKGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICAgIH1cblxuICAgIC8vIG9uZSBvZiB0aGUgbm9kZXMgaXMgaW5zaWRlIHNoYWRvd0RPTSwgZmluZCB3aGljaCBvbmVcbiAgICB2YXIgZWxlbWVudDFyb290ID0gZ2V0Um9vdChlbGVtZW50MSk7XG4gICAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MXJvb3QuaG9zdCwgZWxlbWVudDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNjcm9sbCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBpbiB0aGUgZ2l2ZW4gc2lkZSAodG9wIGFuZCBsZWZ0KVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAgICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBhcmd1bWVudCB7U3RyaW5nfSBzaWRlIGB0b3BgIG9yIGBsZWZ0YFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTY3JvbGwoZWxlbWVudCkge1xuICAgIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndG9wJztcblxuICAgIHZhciB1cHBlclNpZGUgPSBzaWRlID09PSAndG9wJyA/ICdzY3JvbGxUb3AnIDogJ3Njcm9sbExlZnQnO1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICB2YXIgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGh0bWw7XG4gICAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50W3VwcGVyU2lkZV07XG4gIH1cblxuICAvKlxuICAgKiBTdW0gb3Igc3VidHJhY3QgdGhlIGVsZW1lbnQgc2Nyb2xsIHZhbHVlcyAobGVmdCBhbmQgdG9wKSBmcm9tIGEgZ2l2ZW4gcmVjdCBvYmplY3RcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IC0gUmVjdCBvYmplY3QgeW91IHdhbnQgdG8gY2hhbmdlXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN1YnRyYWN0IC0gc2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gc3VidHJhY3QgdGhlIHNjcm9sbCB2YWx1ZXNcbiAgICogQHJldHVybiB7T2JqZWN0fSByZWN0IC0gVGhlIG1vZGlmaWVyIHJlY3Qgb2JqZWN0XG4gICAqL1xuICBmdW5jdGlvbiBpbmNsdWRlU2Nyb2xsKHJlY3QsIGVsZW1lbnQpIHtcbiAgICB2YXIgc3VidHJhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICB2YXIgbW9kaWZpZXIgPSBzdWJ0cmFjdCA/IC0xIDogMTtcbiAgICByZWN0LnRvcCArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICAgIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICAgIHJldHVybiByZWN0O1xuICB9XG5cbiAgLypcbiAgICogSGVscGVyIHRvIGRldGVjdCBib3JkZXJzIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAgICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcbiAgICogUmVzdWx0IG9mIGBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHlgIG9uIHRoZSBnaXZlbiBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIC0gYHhgIG9yIGB5YFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGJvcmRlcnMgLSBUaGUgYm9yZGVycyBzaXplIG9mIHRoZSBnaXZlbiBheGlzXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcywgYXhpcykge1xuICAgIHZhciBzaWRlQSA9IGF4aXMgPT09ICd4JyA/ICdMZWZ0JyA6ICdUb3AnO1xuICAgIHZhciBzaWRlQiA9IHNpZGVBID09PSAnTGVmdCcgPyAnUmlnaHQnIDogJ0JvdHRvbSc7XG5cbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQSArICdXaWR0aCddKSArIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUIgKyAnV2lkdGgnXSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTaXplKGF4aXMsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9keVsnb2Zmc2V0JyArIGF4aXNdLCBib2R5WydzY3JvbGwnICsgYXhpc10sIGh0bWxbJ2NsaWVudCcgKyBheGlzXSwgaHRtbFsnb2Zmc2V0JyArIGF4aXNdLCBodG1sWydzY3JvbGwnICsgYXhpc10sIGlzSUUkMSgxMCkgPyBwYXJzZUludChodG1sWydvZmZzZXQnICsgYXhpc10pICsgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdUb3AnIDogJ0xlZnQnKV0pICsgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdCb3R0b20nIDogJ1JpZ2h0JyldKSA6IDApO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0V2luZG93U2l6ZXMoZG9jdW1lbnQpIHtcbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBpc0lFJDEoMTApICYmIGdldENvbXB1dGVkU3R5bGUoaHRtbCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICAgIHdpZHRoOiBnZXRTaXplKCdXaWR0aCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgfTtcbiAgfSgpO1xuXG5cblxuXG5cbiAgdmFyIGRlZmluZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgdmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gICAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IENsaWVudFJlY3QgbGlrZSBvdXRwdXRcbiAgICovXG4gIGZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgb2Zmc2V0cywge1xuICAgICAgcmlnaHQ6IG9mZnNldHMubGVmdCArIG9mZnNldHMud2lkdGgsXG4gICAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgZ2l2ZW4gZWxlbWVudFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGNsaWVudCByZWN0XG4gICAqL1xuICBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICAgIHZhciByZWN0ID0ge307XG5cbiAgICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gICAgLy8gY29uc2lkZXJlZCBpbiBET00gaW4gc29tZSBjaXJjdW1zdGFuY2VzLi4uXG4gICAgLy8gVGhpcyBpc24ndCByZXByb2R1Y2libGUgaW4gSUUxMCBjb21wYXRpYmlsaXR5IG1vZGUgb2YgSUUxMVxuICAgIHRyeSB7XG4gICAgICBpZiAoaXNJRSQxKDEwKSkge1xuICAgICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gICAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgICAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQ7XG4gICAgICAgIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcDtcbiAgICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgICB9O1xuXG4gICAgLy8gc3VidHJhY3Qgc2Nyb2xsYmFyIHNpemUgZnJvbSBzaXplc1xuICAgIHZhciBzaXplcyA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJyA/IGdldFdpbmRvd1NpemVzKGVsZW1lbnQub3duZXJEb2N1bWVudCkgOiB7fTtcbiAgICB2YXIgd2lkdGggPSBzaXplcy53aWR0aCB8fCBlbGVtZW50LmNsaWVudFdpZHRoIHx8IHJlc3VsdC53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gc2l6ZXMuaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IHJlc3VsdC5oZWlnaHQ7XG5cbiAgICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gICAgdmFyIHZlcnRTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAtIGhlaWdodDtcblxuICAgIC8vIGlmIGFuIGh5cG90aGV0aWNhbCBzY3JvbGxiYXIgaXMgZGV0ZWN0ZWQsIHdlIG11c3QgYmUgc3VyZSBpdCdzIG5vdCBhIGBib3JkZXJgXG4gICAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gICAgaWYgKGhvcml6U2Nyb2xsYmFyIHx8IHZlcnRTY3JvbGxiYXIpIHtcbiAgICAgIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCk7XG4gICAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgICB2ZXJ0U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3knKTtcblxuICAgICAgcmVzdWx0LndpZHRoIC09IGhvcml6U2Nyb2xsYmFyO1xuICAgICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRDbGllbnRSZWN0KHJlc3VsdCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoY2hpbGRyZW4sIHBhcmVudCkge1xuICAgIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgIHZhciBpc0lFMTAgPSBpc0lFJDEoMTApO1xuICAgIHZhciBpc0hUTUwgPSBwYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJztcbiAgICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgICB2YXIgcGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChwYXJlbnQpO1xuICAgIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoY2hpbGRyZW4pO1xuXG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICAgIHZhciBib3JkZXJUb3BXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlclRvcFdpZHRoKTtcbiAgICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKTtcblxuICAgIC8vIEluIGNhc2VzIHdoZXJlIHRoZSBwYXJlbnQgaXMgZml4ZWQsIHdlIG11c3QgaWdub3JlIG5lZ2F0aXZlIHNjcm9sbCBpbiBvZmZzZXQgY2FsY1xuICAgIGlmIChmaXhlZFBvc2l0aW9uICYmIGlzSFRNTCkge1xuICAgICAgcGFyZW50UmVjdC50b3AgPSBNYXRoLm1heChwYXJlbnRSZWN0LnRvcCwgMCk7XG4gICAgICBwYXJlbnRSZWN0LmxlZnQgPSBNYXRoLm1heChwYXJlbnRSZWN0LmxlZnQsIDApO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0cyA9IGdldENsaWVudFJlY3Qoe1xuICAgICAgdG9wOiBjaGlsZHJlblJlY3QudG9wIC0gcGFyZW50UmVjdC50b3AgLSBib3JkZXJUb3BXaWR0aCxcbiAgICAgIGxlZnQ6IGNoaWxkcmVuUmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0IC0gYm9yZGVyTGVmdFdpZHRoLFxuICAgICAgd2lkdGg6IGNoaWxkcmVuUmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogY2hpbGRyZW5SZWN0LmhlaWdodFxuICAgIH0pO1xuICAgIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgICBvZmZzZXRzLm1hcmdpbkxlZnQgPSAwO1xuXG4gICAgLy8gU3VidHJhY3QgbWFyZ2lucyBvZiBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBpdCdzIGJlaW5nIHVzZWQgYXMgcGFyZW50XG4gICAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gICAgLy8gZGlmZmVyZW50bHkgd2hlbiBtYXJnaW5zIGFyZSBhcHBsaWVkIHRvIGl0LiBUaGUgbWFyZ2lucyBhcmUgaW5jbHVkZWQgaW5cbiAgICAvLyB0aGUgYm94IG9mIHRoZSBkb2N1bWVudEVsZW1lbnQsIGluIHRoZSBvdGhlciBjYXNlcyBub3QuXG4gICAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgICB2YXIgbWFyZ2luVG9wID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wKTtcbiAgICAgIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCk7XG5cbiAgICAgIG9mZnNldHMudG9wIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgICAgb2Zmc2V0cy5ib3R0b20gLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgICBvZmZzZXRzLmxlZnQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcbiAgICAgIG9mZnNldHMucmlnaHQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcblxuICAgICAgLy8gQXR0YWNoIG1hcmdpblRvcCBhbmQgbWFyZ2luTGVmdCBiZWNhdXNlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3ZSBtYXkgbmVlZCB0aGVtXG4gICAgICBvZmZzZXRzLm1hcmdpblRvcCA9IG1hcmdpblRvcDtcbiAgICAgIG9mZnNldHMubWFyZ2luTGVmdCA9IG1hcmdpbkxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKGlzSUUxMCAmJiAhZml4ZWRQb3NpdGlvbiA/IHBhcmVudC5jb250YWlucyhzY3JvbGxQYXJlbnQpIDogcGFyZW50ID09PSBzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50Lm5vZGVOYW1lICE9PSAnQk9EWScpIHtcbiAgICAgIG9mZnNldHMgPSBpbmNsdWRlU2Nyb2xsKG9mZnNldHMsIHBhcmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldHM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUoZWxlbWVudCkge1xuICAgIHZhciBleGNsdWRlU2Nyb2xsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gICAgdmFyIHdpZHRoID0gTWF0aC5tYXgoaHRtbC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gICAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGh0bWwuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG5cbiAgICB2YXIgc2Nyb2xsVG9wID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCkgOiAwO1xuICAgIHZhciBzY3JvbGxMZWZ0ID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCwgJ2xlZnQnKSA6IDA7XG5cbiAgICB2YXIgb2Zmc2V0ID0ge1xuICAgICAgdG9wOiBzY3JvbGxUb3AgLSByZWxhdGl2ZU9mZnNldC50b3AgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5Ub3AsXG4gICAgICBsZWZ0OiBzY3JvbGxMZWZ0IC0gcmVsYXRpdmVPZmZzZXQubGVmdCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpbkxlZnQsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG5cbiAgICByZXR1cm4gZ2V0Q2xpZW50UmVjdChvZmZzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGZpeGVkIG9yIGlzIGluc2lkZSBhIGZpeGVkIHBhcmVudFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAgICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG8gXCJpc0ZpeGVkP1wiXG4gICAqL1xuICBmdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuICAgIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRml4ZWQocGFyZW50Tm9kZSk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIGZpcnN0IHBhcmVudCBvZiBhbiBlbGVtZW50IHRoYXQgaGFzIGEgdHJhbnNmb3JtZWQgcHJvcGVydHkgZGVmaW5lZFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAgICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtFbGVtZW50fSBmaXJzdCB0cmFuc2Zvcm1lZCBwYXJlbnQgb3IgZG9jdW1lbnRFbGVtZW50XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnRFbGVtZW50IHx8IGlzSUUkMSgpKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cbiAgICB2YXIgZWwgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgd2hpbGUgKGVsICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbCwgJ3RyYW5zZm9ybScpID09PSAnbm9uZScpIHtcbiAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGVsIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlZCB0aGUgYm91bmRhcmllcyBsaW1pdHMgYW5kIHJldHVybiB0aGVtXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50IC0gRWxlbWVudCB1c2VkIHRvIGRlZmluZSB0aGUgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpeGVkUG9zaXRpb24gLSBJcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICAgIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAgIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG5cbiAgICB2YXIgYm91bmRhcmllcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gICAgdmFyIG9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpKTtcblxuICAgIC8vIEhhbmRsZSB2aWV3cG9ydCBjYXNlXG4gICAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgICBib3VuZGFyaWVzID0gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEhhbmRsZSBvdGhlciBjYXNlcyBiYXNlZCBvbiBET00gZWxlbWVudCB1c2VkIGFzIGJvdW5kYXJpZXNcbiAgICAgIHZhciBib3VuZGFyaWVzTm9kZSA9IHZvaWQgMDtcbiAgICAgIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShyZWZlcmVuY2UpKTtcbiAgICAgICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgb2Zmc2V0cyA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShib3VuZGFyaWVzTm9kZSwgb2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcblxuICAgICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdIVE1MJyAmJiAhaXNGaXhlZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgIHZhciBfZ2V0V2luZG93U2l6ZXMgPSBnZXRXaW5kb3dTaXplcyhwb3BwZXIub3duZXJEb2N1bWVudCksXG4gICAgICAgICAgICBoZWlnaHQgPSBfZ2V0V2luZG93U2l6ZXMuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGggPSBfZ2V0V2luZG93U2l6ZXMud2lkdGg7XG5cbiAgICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgICAgYm91bmRhcmllcy5ib3R0b20gPSBoZWlnaHQgKyBvZmZzZXRzLnRvcDtcbiAgICAgICAgYm91bmRhcmllcy5sZWZ0ICs9IG9mZnNldHMubGVmdCAtIG9mZnNldHMubWFyZ2luTGVmdDtcbiAgICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZm9yIGFsbCB0aGUgb3RoZXIgRE9NIGVsZW1lbnRzLCB0aGlzIG9uZSBpcyBnb29kXG4gICAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBwYWRkaW5nc1xuICAgIHBhZGRpbmcgPSBwYWRkaW5nIHx8IDA7XG4gICAgdmFyIGlzUGFkZGluZ051bWJlciA9IHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJztcbiAgICBib3VuZGFyaWVzLmxlZnQgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcubGVmdCB8fCAwO1xuICAgIGJvdW5kYXJpZXMudG9wICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnRvcCB8fCAwO1xuICAgIGJvdW5kYXJpZXMucmlnaHQgLT0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcucmlnaHQgfHwgMDtcbiAgICBib3VuZGFyaWVzLmJvdHRvbSAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5ib3R0b20gfHwgMDtcblxuICAgIHJldHVybiBib3VuZGFyaWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QXJlYShfcmVmKSB7XG4gICAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG5cbiAgICByZXR1cm4gd2lkdGggKiBoZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgYGF1dG9gIHBsYWNlbWVudCB0byB0aGUgcGxhY2VtZW50IHdpdGggbW9yZVxuICAgKiBhdmFpbGFibGUgc3BhY2UuXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICAgKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICAgKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHBsYWNlbWVudCwgcmVmUmVjdCwgcG9wcGVyLCByZWZlcmVuY2UsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gICAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG5cbiAgICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBwbGFjZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgICB2YXIgcmVjdHMgPSB7XG4gICAgICB0b3A6IHtcbiAgICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogcmVmUmVjdC50b3AgLSBib3VuZGFyaWVzLnRvcFxuICAgICAgfSxcbiAgICAgIHJpZ2h0OiB7XG4gICAgICAgIHdpZHRoOiBib3VuZGFyaWVzLnJpZ2h0IC0gcmVmUmVjdC5yaWdodCxcbiAgICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgICAgfSxcbiAgICAgIGJvdHRvbToge1xuICAgICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tXG4gICAgICB9LFxuICAgICAgbGVmdDoge1xuICAgICAgICB3aWR0aDogcmVmUmVjdC5sZWZ0IC0gYm91bmRhcmllcy5sZWZ0LFxuICAgICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzb3J0ZWRBcmVhcyA9IE9iamVjdC5rZXlzKHJlY3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAga2V5OiBrZXlcbiAgICAgIH0sIHJlY3RzW2tleV0sIHtcbiAgICAgICAgYXJlYTogZ2V0QXJlYShyZWN0c1trZXldKVxuICAgICAgfSk7XG4gICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGIuYXJlYSAtIGEuYXJlYTtcbiAgICB9KTtcblxuICAgIHZhciBmaWx0ZXJlZEFyZWFzID0gc29ydGVkQXJlYXMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgdmFyIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgICAgcmV0dXJuIHdpZHRoID49IHBvcHBlci5jbGllbnRXaWR0aCAmJiBoZWlnaHQgPj0gcG9wcGVyLmNsaWVudEhlaWdodDtcbiAgICB9KTtcblxuICAgIHZhciBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMCA/IGZpbHRlcmVkQXJlYXNbMF0ua2V5IDogc29ydGVkQXJlYXNbMF0ua2V5O1xuXG4gICAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gICAgcmV0dXJuIGNvbXB1dGVkUGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb2Zmc2V0cyB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZml4ZWRQb3NpdGlvbiAtIGlzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAgICovXG4gIGZ1bmN0aW9uIGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlKSB7XG4gICAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgICB2YXIgY29tbW9uT2Zmc2V0UGFyZW50ID0gZml4ZWRQb3NpdGlvbiA/IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQocG9wcGVyKSA6IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCBnZXRSZWZlcmVuY2VOb2RlKHJlZmVyZW5jZSkpO1xuICAgIHJldHVybiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUocmVmZXJlbmNlLCBjb21tb25PZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3V0ZXIgc2l6ZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQgKG9mZnNldCBzaXplICsgbWFyZ2lucylcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gICAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAgICovXG4gIGZ1bmN0aW9uIGdldE91dGVyU2l6ZXMoZWxlbWVudCkge1xuICAgIHZhciB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIHZhciB4ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wIHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luQm90dG9tIHx8IDApO1xuICAgIHZhciB5ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCB8fCAwKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblJpZ2h0IHx8IDApO1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksXG4gICAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgeFxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCBvZiB0aGUgZ2l2ZW4gb25lXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICAgKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50XG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50XG4gICAqL1xuICBmdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgICB2YXIgaGFzaCA9IHsgbGVmdDogJ3JpZ2h0JywgcmlnaHQ6ICdsZWZ0JywgYm90dG9tOiAndG9wJywgdG9wOiAnYm90dG9tJyB9O1xuICAgIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb2Zmc2V0cyB0byB0aGUgcG9wcGVyXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSBDU1MgcG9zaXRpb24gdGhlIFBvcHBlciB3aWxsIGdldCBhcHBsaWVkXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0cyAtIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwbGFjZW1lbnQgLSBvbmUgb2YgdGhlIHZhbGlkIHBsYWNlbWVudCBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHBvcHBlck9mZnNldHMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UG9wcGVyT2Zmc2V0cyhwb3BwZXIsIHJlZmVyZW5jZU9mZnNldHMsIHBsYWNlbWVudCkge1xuICAgIHBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gICAgLy8gR2V0IHBvcHBlciBub2RlIHNpemVzXG4gICAgdmFyIHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgICAvLyBBZGQgcG9zaXRpb24sIHdpZHRoIGFuZCBoZWlnaHQgdG8gb3VyIG9mZnNldHMgb2JqZWN0XG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSB7XG4gICAgICB3aWR0aDogcG9wcGVyUmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogcG9wcGVyUmVjdC5oZWlnaHRcbiAgICB9O1xuXG4gICAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICAgIHZhciBpc0hvcml6ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgbWFpblNpZGUgPSBpc0hvcml6ID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgdmFyIHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgc2Vjb25kYXJ5TWVhc3VyZW1lbnQgPSAhaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHBvcHBlck9mZnNldHNbbWFpblNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1ttYWluU2lkZV0gKyByZWZlcmVuY2VPZmZzZXRzW21lYXN1cmVtZW50XSAvIDIgLSBwb3BwZXJSZWN0W21lYXN1cmVtZW50XSAvIDI7XG4gICAgaWYgKHBsYWNlbWVudCA9PT0gc2Vjb25kYXJ5U2lkZSkge1xuICAgICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gLSBwb3BwZXJSZWN0W3NlY29uZGFyeU1lYXN1cmVtZW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoc2Vjb25kYXJ5U2lkZSldO1xuICAgIH1cblxuICAgIHJldHVybiBwb3BwZXJPZmZzZXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1pbWljcyB0aGUgYGZpbmRgIG1ldGhvZCBvZiBBcnJheVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAgICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gICAqIEBhcmd1bWVudCBwcm9wXG4gICAqIEBhcmd1bWVudCB2YWx1ZVxuICAgKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICAgKi9cbiAgZnVuY3Rpb24gZmluZChhcnIsIGNoZWNrKSB7XG4gICAgLy8gdXNlIG5hdGl2ZSBmaW5kIGlmIHN1cHBvcnRlZFxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgICAgcmV0dXJuIGFyci5maW5kKGNoZWNrKTtcbiAgICB9XG5cbiAgICAvLyB1c2UgYGZpbHRlcmAgdG8gb2J0YWluIHRoZSBzYW1lIGJlaGF2aW9yIG9mIGBmaW5kYFxuICAgIHJldHVybiBhcnIuZmlsdGVyKGNoZWNrKVswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBtYXRjaGluZyBvYmplY3RcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gICAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICAgKiBAYXJndW1lbnQgcHJvcFxuICAgKiBAYXJndW1lbnQgdmFsdWVcbiAgICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAgICovXG4gIGZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIHByb3AsIHZhbHVlKSB7XG4gICAgLy8gdXNlIG5hdGl2ZSBmaW5kSW5kZXggaWYgc3VwcG9ydGVkXG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICAgIHJldHVybiBhcnIuZmluZEluZGV4KGZ1bmN0aW9uIChjdXIpIHtcbiAgICAgICAgcmV0dXJuIGN1cltwcm9wXSA9PT0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyB1c2UgYGZpbmRgICsgYGluZGV4T2ZgIGlmIGBmaW5kSW5kZXhgIGlzbid0IHN1cHBvcnRlZFxuICAgIHZhciBtYXRjaCA9IGZpbmQoYXJyLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqW3Byb3BdID09PSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyLmluZGV4T2YobWF0Y2gpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvb3AgdHJvdWdoIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBhbmQgcnVuIHRoZW0gaW4gb3JkZXIsXG4gICAqIGVhY2ggb2YgdGhlbSB3aWxsIHRoZW4gZWRpdCB0aGUgZGF0YSBvYmplY3QuXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICAgKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbmRzIC0gT3B0aW9uYWwgbW9kaWZpZXIgbmFtZSB1c2VkIGFzIHN0b3BwZXJcbiAgICogQHJldHVybnMge2RhdGFPYmplY3R9XG4gICAqL1xuICBmdW5jdGlvbiBydW5Nb2RpZmllcnMobW9kaWZpZXJzLCBkYXRhLCBlbmRzKSB7XG4gICAgdmFyIG1vZGlmaWVyc1RvUnVuID0gZW5kcyA9PT0gdW5kZWZpbmVkID8gbW9kaWZpZXJzIDogbW9kaWZpZXJzLnNsaWNlKDAsIGZpbmRJbmRleChtb2RpZmllcnMsICduYW1lJywgZW5kcykpO1xuXG4gICAgbW9kaWZpZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgIGlmIChtb2RpZmllclsnZnVuY3Rpb24nXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgICBjb25zb2xlLndhcm4oJ2Btb2RpZmllci5mdW5jdGlvbmAgaXMgZGVwcmVjYXRlZCwgdXNlIGBtb2RpZmllci5mbmAhJyk7XG4gICAgICB9XG4gICAgICB2YXIgZm4gPSBtb2RpZmllclsnZnVuY3Rpb24nXSB8fCBtb2RpZmllci5mbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGlmIChtb2RpZmllci5lbmFibGVkICYmIGlzRnVuY3Rpb24kMShmbikpIHtcbiAgICAgICAgLy8gQWRkIHByb3BlcnRpZXMgdG8gb2Zmc2V0cyB0byBtYWtlIHRoZW0gYSBjb21wbGV0ZSBjbGllbnRSZWN0IG9iamVjdFxuICAgICAgICAvLyB3ZSBkbyB0aGlzIGJlZm9yZSBlYWNoIG1vZGlmaWVyIHRvIG1ha2Ugc3VyZSB0aGUgcHJldmlvdXMgb25lIGRvZXNuJ3RcbiAgICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcbiAgICAgICAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSk7XG5cbiAgICAgICAgZGF0YSA9IGZuKGRhdGEsIG1vZGlmaWVyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nXG4gICAqIHRoZSBuZXcgc3R5bGUuPGJyIC8+XG4gICAqIFByZWZlciBgc2NoZWR1bGVVcGRhdGVgIG92ZXIgYHVwZGF0ZWAgYmVjYXVzZSBvZiBwZXJmb3JtYW5jZSByZWFzb25zLlxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAvLyBpZiBwb3BwZXIgaXMgZGVzdHJveWVkLCBkb24ndCBwZXJmb3JtIGFueSBmdXJ0aGVyIHVwZGF0ZVxuICAgIGlmICh0aGlzLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBpbnN0YW5jZTogdGhpcyxcbiAgICAgIHN0eWxlczoge30sXG4gICAgICBhcnJvd1N0eWxlczoge30sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGZsaXBwZWQ6IGZhbHNlLFxuICAgICAgb2Zmc2V0czoge31cbiAgICB9O1xuXG4gICAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gICAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZU9mZnNldHModGhpcy5zdGF0ZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gICAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudCh0aGlzLm9wdGlvbnMucGxhY2VtZW50LCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gICAgLy8gc3RvcmUgdGhlIGNvbXB1dGVkIHBsYWNlbWVudCBpbnNpZGUgYG9yaWdpbmFsUGxhY2VtZW50YFxuICAgIGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcblxuICAgIGRhdGEucG9zaXRpb25GaXhlZCA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkO1xuXG4gICAgLy8gY29tcHV0ZSB0aGUgcG9wcGVyIG9mZnNldHNcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0UG9wcGVyT2Zmc2V0cyh0aGlzLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpO1xuXG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlci5wb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZSc7XG5cbiAgICAvLyBydW4gdGhlIG1vZGlmaWVyc1xuICAgIGRhdGEgPSBydW5Nb2RpZmllcnModGhpcy5tb2RpZmllcnMsIGRhdGEpO1xuXG4gICAgLy8gdGhlIGZpcnN0IGB1cGRhdGVgIHdpbGwgY2FsbCBgb25DcmVhdGVgIGNhbGxiYWNrXG4gICAgLy8gdGhlIG90aGVyIG9uZXMgd2lsbCBjYWxsIGBvblVwZGF0ZWAgY2FsbGJhY2tcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNDcmVhdGVkKSB7XG4gICAgICB0aGlzLnN0YXRlLmlzQ3JlYXRlZCA9IHRydWU7XG4gICAgICB0aGlzLm9wdGlvbnMub25DcmVhdGUoZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShkYXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgaXMgZW5hYmxlZC5cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaXNNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzLCBtb2RpZmllck5hbWUpIHtcbiAgICByZXR1cm4gbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICAgIGVuYWJsZWQgPSBfcmVmLmVuYWJsZWQ7XG4gICAgICByZXR1cm4gZW5hYmxlZCAmJiBuYW1lID09PSBtb2RpZmllck5hbWU7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwcmVmaXhlZCBzdXBwb3J0ZWQgcHJvcGVydHkgbmFtZVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAgICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5IChjYW1lbENhc2UpXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWZpeGVkIHByb3BlcnR5IChjYW1lbENhc2Ugb3IgUGFzY2FsQ2FzZSwgZGVwZW5kaW5nIG9uIHRoZSB2ZW5kb3IgcHJlZml4KVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKHByb3BlcnR5KSB7XG4gICAgdmFyIHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gICAgdmFyIHVwcGVyUHJvcCA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgICB2YXIgdG9DaGVjayA9IHByZWZpeCA/ICcnICsgcHJlZml4ICsgdXBwZXJQcm9wIDogcHJvcGVydHk7XG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGVbdG9DaGVja10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgcG9wcGVyLlxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICovXG4gIGZ1bmN0aW9uIGRlc3Ryb3kkMSgpIHtcbiAgICB0aGlzLnN0YXRlLmlzRGVzdHJveWVkID0gdHJ1ZTtcblxuICAgIC8vIHRvdWNoIERPTSBvbmx5IGlmIGBhcHBseVN0eWxlYCBtb2RpZmllciBpcyBlbmFibGVkXG4gICAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgICB0aGlzLnBvcHBlci5yZW1vdmVBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50Jyk7XG4gICAgICB0aGlzLnBvcHBlci5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICAgICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgICB0aGlzLnBvcHBlci5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgICB0aGlzLnBvcHBlci5zdHlsZS5yaWdodCA9ICcnO1xuICAgICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgICB0aGlzLnBvcHBlci5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XG4gICAgICB0aGlzLnBvcHBlci5zdHlsZVtnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpXSA9ICcnO1xuICAgIH1cblxuICAgIHRoaXMuZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICAvLyByZW1vdmUgdGhlIHBvcHBlciBpZiB1c2VyIGV4cGxpY2l0bHkgYXNrZWQgZm9yIHRoZSBkZWxldGlvbiBvbiBkZXN0cm95XG4gICAgLy8gZG8gbm90IHVzZSBgcmVtb3ZlYCBiZWNhdXNlIElFMTEgZG9lc24ndCBzdXBwb3J0IGl0XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICAgIHRoaXMucG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3BwZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAgICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtXaW5kb3d9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRXaW5kb3coZWxlbWVudCkge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxQYXJlbnQsIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cykge1xuICAgIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gc2Nyb2xsUGFyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiBzY3JvbGxQYXJlbnQ7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgICBpZiAoIWlzQm9keSkge1xuICAgICAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKGdldFNjcm9sbFBhcmVudCh0YXJnZXQucGFyZW50Tm9kZSksIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cyk7XG4gICAgfVxuICAgIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNldHVwRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBvcHRpb25zLCBzdGF0ZSwgdXBkYXRlQm91bmQpIHtcbiAgICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gICAgc3RhdGUudXBkYXRlQm91bmQgPSB1cGRhdGVCb3VuZDtcbiAgICBnZXRXaW5kb3cocmVmZXJlbmNlKS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gICAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gICAgdmFyIHNjcm9sbEVsZW1lbnQgPSBnZXRTY3JvbGxQYXJlbnQocmVmZXJlbmNlKTtcbiAgICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsRWxlbWVudCwgJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kLCBzdGF0ZS5zY3JvbGxQYXJlbnRzKTtcbiAgICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgICBzdGF0ZS5ldmVudHNFbmFibGVkID0gdHJ1ZTtcblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdCB3aWxsIGFkZCByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgc3RhcnQgcmVjYWxjdWxhdGluZ1xuICAgKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgKi9cbiAgZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gICAgLy8gUmVtb3ZlIHJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgICBnZXRXaW5kb3cocmVmZXJlbmNlKS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG5cbiAgICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gICAgc3RhdGUuc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG4gICAgfSk7XG5cbiAgICAvLyBSZXNldCBzdGF0ZVxuICAgIHN0YXRlLnVwZGF0ZUJvdW5kID0gbnVsbDtcbiAgICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gICAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gICAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGZhbHNlO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gICAqIHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLiBJdCBhbHNvIHdvbid0IHRyaWdnZXIgYG9uVXBkYXRlYCBjYWxsYmFjayBhbnltb3JlLFxuICAgKiB1bmxlc3MgeW91IGNhbGwgYHVwZGF0ZWAgbWV0aG9kIG1hbnVhbGx5LlxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICovXG4gIGZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgICAgIHRoaXMuc3RhdGUgPSByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5zdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRlbGxzIGlmIGEgZ2l2ZW4gaW5wdXQgaXMgYSBudW1iZXJcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gICAqIEBwYXJhbSB7Kn0gaW5wdXQgdG8gY2hlY2tcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gICAgcmV0dXJuIG4gIT09ICcnICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0eWxlIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gICAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvXG4gICAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAgICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIHNldFN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHZhciB1bml0ID0gJyc7XG4gICAgICAvLyBhZGQgdW5pdCBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpYyBhbmQgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAgICAgIGlmIChbJ3dpZHRoJywgJ2hlaWdodCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5pbmRleE9mKHByb3ApICE9PSAtMSAmJiBpc051bWVyaWMoc3R5bGVzW3Byb3BdKSkge1xuICAgICAgICB1bml0ID0gJ3B4JztcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBzdHlsZXNbcHJvcF0gKyB1bml0O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICAgKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGVzIHRvXG4gICAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAgICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHByb3AsIGF0dHJpYnV0ZXNbcHJvcF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAgICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICAgKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5zdHlsZXMgLSBMaXN0IG9mIHN0eWxlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAgICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuYXR0cmlidXRlcyAtIExpc3Qgb2YgYXR0cmlidXRlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAgICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2FtZSBkYXRhIG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gYXBwbHlTdHlsZShkYXRhKSB7XG4gICAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuc3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgICAvLyBpbiB0aGlzIHdheSB3ZSBjYW4gbWFrZSB0aGUgM3JkIHBhcnR5IG1vZGlmaWVycyBhZGQgY3VzdG9tIHN0eWxlcyB0byBpdFxuICAgIC8vIEJlIGF3YXJlLCBtb2RpZmllcnMgY291bGQgb3ZlcnJpZGUgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGUgcHJldmlvdXNcbiAgICAvLyBsaW5lcyBvZiB0aGlzIG1vZGlmaWVyIVxuICAgIHNldFN0eWxlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5zdHlsZXMpO1xuXG4gICAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuYXR0cmlidXRlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gICAgLy8gdGhleSB3aWxsIGJlIHNldCBhcyBIVE1MIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgICBzZXRBdHRyaWJ1dGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGRlZmluZWQgYW5kIGFycm93U3R5bGVzIGhhcyBzb21lIHByb3BlcnRpZXNcbiAgICBpZiAoZGF0YS5hcnJvd0VsZW1lbnQgJiYgT2JqZWN0LmtleXMoZGF0YS5hcnJvd1N0eWxlcykubGVuZ3RoKSB7XG4gICAgICBzZXRTdHlsZXMoZGF0YS5hcnJvd0VsZW1lbnQsIGRhdGEuYXJyb3dTdHlsZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gICAqIHRvIGFkZCBtYXJnaW5zIHRvIHRoZSBwb3BwZXIgbWFyZ2lucyBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIHRvIGdldCB0aGVcbiAgICogY29ycmVjdCBwb3BwZXIgb2Zmc2V0cy5cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBQb3BwZXIuanMgb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gYXBwbHlTdHlsZU9uTG9hZChyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBzdGF0ZSkge1xuICAgIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICAgIHZhciByZWZlcmVuY2VPZmZzZXRzID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UsIG9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gICAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgdmFyIHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KG9wdGlvbnMucGxhY2VtZW50LCByZWZlcmVuY2VPZmZzZXRzLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICAgIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JywgcGxhY2VtZW50KTtcblxuICAgIC8vIEFwcGx5IGBwb3NpdGlvbmAgdG8gcG9wcGVyIGJlZm9yZSBhbnl0aGluZyBlbHNlIGJlY2F1c2VcbiAgICAvLyB3aXRob3V0IHRoZSBwb3NpdGlvbiBhcHBsaWVkIHdlIGNhbid0IGd1YXJhbnRlZSBjb3JyZWN0IGNvbXB1dGF0aW9uc1xuICAgIHNldFN0eWxlcyhwb3BwZXIsIHsgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnIH0pO1xuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAgICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICAgKiBAYXJndW1lbnQge0Jvb2xlYW59IHNob3VsZFJvdW5kIC0gSWYgdGhlIG9mZnNldHMgc2hvdWxkIGJlIHJvdW5kZWQgYXQgYWxsXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwb3BwZXIncyBwb3NpdGlvbiBvZmZzZXRzIHJvdW5kZWRcbiAgICpcbiAgICogVGhlIHRhbGUgb2YgcGl4ZWwtcGVyZmVjdCBwb3NpdGlvbmluZy4gSXQncyBzdGlsbCBub3QgMTAwJSBwZXJmZWN0LCBidXQgYXNcbiAgICogZ29vZCBhcyBpdCBjYW4gYmUgd2l0aGluIHJlYXNvbi5cbiAgICogRGlzY3Vzc2lvbiBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9wdWxsLzcxNVxuICAgKlxuICAgKiBMb3cgRFBJIHNjcmVlbnMgY2F1c2UgYSBwb3BwZXIgdG8gYmUgYmx1cnJ5IGlmIG5vdCB1c2luZyBmdWxsIHBpeGVscyAoU2FmYXJpXG4gICAqIGFzIHdlbGwgb24gSGlnaCBEUEkgc2NyZWVucykuXG4gICAqXG4gICAqIEZpcmVmb3ggcHJlZmVycyBubyByb3VuZGluZyBmb3IgcG9zaXRpb25pbmcgYW5kIGRvZXMgbm90IGhhdmUgYmx1cnJpbmVzcyBvblxuICAgKiBoaWdoIERQSSBzY3JlZW5zLlxuICAgKlxuICAgKiBPbmx5IGhvcml6b250YWwgcGxhY2VtZW50IGFuZCBsZWZ0L3JpZ2h0IHZhbHVlcyBuZWVkIHRvIGJlIGNvbnNpZGVyZWQuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRSb3VuZGVkT2Zmc2V0cyhkYXRhLCBzaG91bGRSb3VuZCkge1xuICAgIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICAgICAgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4gICAgdmFyIG5vUm91bmQgPSBmdW5jdGlvbiBub1JvdW5kKHYpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH07XG5cbiAgICB2YXIgcmVmZXJlbmNlV2lkdGggPSByb3VuZChyZWZlcmVuY2Uud2lkdGgpO1xuICAgIHZhciBwb3BwZXJXaWR0aCA9IHJvdW5kKHBvcHBlci53aWR0aCk7XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZGF0YS5wbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgaXNWYXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5pbmRleE9mKCctJykgIT09IC0xO1xuICAgIHZhciBzYW1lV2lkdGhQYXJpdHkgPSByZWZlcmVuY2VXaWR0aCAlIDIgPT09IHBvcHBlcldpZHRoICUgMjtcbiAgICB2YXIgYm90aE9kZFdpZHRoID0gcmVmZXJlbmNlV2lkdGggJSAyID09PSAxICYmIHBvcHBlcldpZHRoICUgMiA9PT0gMTtcblxuICAgIHZhciBob3Jpem9udGFsVG9JbnRlZ2VyID0gIXNob3VsZFJvdW5kID8gbm9Sb3VuZCA6IGlzVmVydGljYWwgfHwgaXNWYXJpYXRpb24gfHwgc2FtZVdpZHRoUGFyaXR5ID8gcm91bmQgOiBmbG9vcjtcbiAgICB2YXIgdmVydGljYWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogcm91bmQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogaG9yaXpvbnRhbFRvSW50ZWdlcihib3RoT2RkV2lkdGggJiYgIWlzVmFyaWF0aW9uICYmIHNob3VsZFJvdW5kID8gcG9wcGVyLmxlZnQgLSAxIDogcG9wcGVyLmxlZnQpLFxuICAgICAgdG9wOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIudG9wKSxcbiAgICAgIGJvdHRvbTogdmVydGljYWxUb0ludGVnZXIocG9wcGVyLmJvdHRvbSksXG4gICAgICByaWdodDogaG9yaXpvbnRhbFRvSW50ZWdlcihwb3BwZXIucmlnaHQpXG4gICAgfTtcbiAgfVxuXG4gIHZhciBpc0ZpcmVmb3ggPSBpc0Jyb3dzZXIkMSAmJiAvRmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gICAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAgICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gICAqL1xuICBmdW5jdGlvbiBjb21wdXRlU3R5bGUoZGF0YSwgb3B0aW9ucykge1xuICAgIHZhciB4ID0gb3B0aW9ucy54LFxuICAgICAgICB5ID0gb3B0aW9ucy55O1xuICAgIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gICAgLy8gUmVtb3ZlIHRoaXMgbGVnYWN5IHN1cHBvcnQgaW4gUG9wcGVyLmpzIHYyXG5cbiAgICB2YXIgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ2FwcGx5U3R5bGUnO1xuICAgIH0pLmdwdUFjY2VsZXJhdGlvbjtcbiAgICBpZiAobGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGdwdUFjY2VsZXJhdGlvbmAgb3B0aW9uIG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyIGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIFBvcHBlci5qcyEnKTtcbiAgICB9XG4gICAgdmFyIGdwdUFjY2VsZXJhdGlvbiA9IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkID8gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIDogb3B0aW9ucy5ncHVBY2NlbGVyYXRpb247XG5cbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuXG4gICAgLy8gU3R5bGVzXG4gICAgdmFyIHN0eWxlcyA9IHtcbiAgICAgIHBvc2l0aW9uOiBwb3BwZXIucG9zaXRpb25cbiAgICB9O1xuXG4gICAgdmFyIG9mZnNldHMgPSBnZXRSb3VuZGVkT2Zmc2V0cyhkYXRhLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA8IDIgfHwgIWlzRmlyZWZveCk7XG5cbiAgICB2YXIgc2lkZUEgPSB4ID09PSAnYm90dG9tJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgdmFyIHNpZGVCID0geSA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cbiAgICAvLyBpZiBncHVBY2NlbGVyYXRpb24gaXMgc2V0IHRvIGB0cnVlYCBhbmQgdHJhbnNmb3JtIGlzIHN1cHBvcnRlZCxcbiAgICAvLyAgd2UgdXNlIGB0cmFuc2xhdGUzZGAgdG8gYXBwbHkgdGhlIHBvc2l0aW9uIHRvIHRoZSBwb3BwZXIgd2VcbiAgICAvLyBhdXRvbWF0aWNhbGx5IHVzZSB0aGUgc3VwcG9ydGVkIHByZWZpeGVkIHZlcnNpb24gaWYgbmVlZGVkXG4gICAgdmFyIHByZWZpeGVkUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuXG4gICAgLy8gbm93LCBsZXQncyBtYWtlIGEgc3RlcCBiYWNrIGFuZCBsb29rIGF0IHRoaXMgY29kZSBjbG9zZWx5ICh3dGY/KVxuICAgIC8vIElmIHRoZSBjb250ZW50IG9mIHRoZSBwb3BwZXIgZ3Jvd3Mgb25jZSBpdCdzIGJlZW4gcG9zaXRpb25lZCwgaXRcbiAgICAvLyBtYXkgaGFwcGVuIHRoYXQgdGhlIHBvcHBlciBnZXRzIG1pc3BsYWNlZCBiZWNhdXNlIG9mIHRoZSBuZXcgY29udGVudFxuICAgIC8vIG92ZXJmbG93aW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAgIC8vIFRvIGF2b2lkIHRoaXMgcHJvYmxlbSwgd2UgcHJvdmlkZSB0d28gb3B0aW9ucyAoeCBhbmQgeSksIHdoaWNoIGFsbG93XG4gICAgLy8gdGhlIGNvbnN1bWVyIHRvIGRlZmluZSB0aGUgb2Zmc2V0IG9yaWdpbi5cbiAgICAvLyBJZiB3ZSBwb3NpdGlvbiBhIHBvcHBlciBvbiB0b3Agb2YgYSByZWZlcmVuY2UgZWxlbWVudCwgd2UgY2FuIHNldFxuICAgIC8vIGB4YCB0byBgdG9wYCB0byBtYWtlIHRoZSBwb3BwZXIgZ3JvdyB0b3dhcmRzIGl0cyB0b3AgaW5zdGVhZCBvZlxuICAgIC8vIGl0cyBib3R0b20uXG4gICAgdmFyIGxlZnQgPSB2b2lkIDAsXG4gICAgICAgIHRvcCA9IHZvaWQgMDtcbiAgICBpZiAoc2lkZUEgPT09ICdib3R0b20nKSB7XG4gICAgICAvLyB3aGVuIG9mZnNldFBhcmVudCBpcyA8aHRtbD4gdGhlIHBvc2l0aW9uaW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiAoZXhjbHVkaW5nIHRoZSBzY3JvbGxiYXIpXG4gICAgICAvLyBhbmQgbm90IHRoZSBib3R0b20gb2YgdGhlIGh0bWwgZWxlbWVudFxuICAgICAgaWYgKG9mZnNldFBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3AgPSAtb2Zmc2V0UGFyZW50UmVjdC5oZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdG9wID0gb2Zmc2V0cy50b3A7XG4gICAgfVxuICAgIGlmIChzaWRlQiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgaWYgKG9mZnNldFBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50UmVjdC53aWR0aCArIG9mZnNldHMucmlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBvZmZzZXRzLmxlZnQ7XG4gICAgfVxuICAgIGlmIChncHVBY2NlbGVyYXRpb24gJiYgcHJlZml4ZWRQcm9wZXJ0eSkge1xuICAgICAgc3R5bGVzW3ByZWZpeGVkUHJvcGVydHldID0gJ3RyYW5zbGF0ZTNkKCcgKyBsZWZ0ICsgJ3B4LCAnICsgdG9wICsgJ3B4LCAwKSc7XG4gICAgICBzdHlsZXNbc2lkZUFdID0gMDtcbiAgICAgIHN0eWxlc1tzaWRlQl0gPSAwO1xuICAgICAgc3R5bGVzLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3Rod2VyaXNlLCB3ZSB1c2UgdGhlIHN0YW5kYXJkIGB0b3BgLCBgbGVmdGAsIGBib3R0b21gIGFuZCBgcmlnaHRgIHByb3BlcnRpZXNcbiAgICAgIHZhciBpbnZlcnRUb3AgPSBzaWRlQSA9PT0gJ2JvdHRvbScgPyAtMSA6IDE7XG4gICAgICB2YXIgaW52ZXJ0TGVmdCA9IHNpZGVCID09PSAncmlnaHQnID8gLTEgOiAxO1xuICAgICAgc3R5bGVzW3NpZGVBXSA9IHRvcCAqIGludmVydFRvcDtcbiAgICAgIHN0eWxlc1tzaWRlQl0gPSBsZWZ0ICogaW52ZXJ0TGVmdDtcbiAgICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gc2lkZUEgKyAnLCAnICsgc2lkZUI7XG4gICAgfVxuXG4gICAgLy8gQXR0cmlidXRlc1xuICAgIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICAgJ3gtcGxhY2VtZW50JzogZGF0YS5wbGFjZW1lbnRcbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIGBkYXRhYCBhdHRyaWJ1dGVzLCBzdHlsZXMgYW5kIGFycm93U3R5bGVzXG4gICAgZGF0YS5hdHRyaWJ1dGVzID0gX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIGRhdGEuYXR0cmlidXRlcyk7XG4gICAgZGF0YS5zdHlsZXMgPSBfZXh0ZW5kcyh7fSwgc3R5bGVzLCBkYXRhLnN0eWxlcyk7XG4gICAgZGF0YS5hcnJvd1N0eWxlcyA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMuYXJyb3csIGRhdGEuYXJyb3dTdHlsZXMpO1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgZGVwZW5kcyBmcm9tIGFub3RoZXIgb25lLjxiciAvPlxuICAgKiBJdCBjaGVja3MgaWYgdGhlIG5lZWRlZCBtb2RpZmllciBpcyBsaXN0ZWQgYW5kIGVuYWJsZWQuXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICAgKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMgLSBsaXN0IG9mIG1vZGlmaWVyc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGluZ05hbWUgLSBuYW1lIG9mIHJlcXVlc3RpbmcgbW9kaWZpZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RlZE5hbWUgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGlzTW9kaWZpZXJSZXF1aXJlZChtb2RpZmllcnMsIHJlcXVlc3RpbmdOYW1lLCByZXF1ZXN0ZWROYW1lKSB7XG4gICAgdmFyIHJlcXVlc3RpbmcgPSBmaW5kKG1vZGlmaWVycywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgICAgcmV0dXJuIG5hbWUgPT09IHJlcXVlc3RpbmdOYW1lO1xuICAgIH0pO1xuXG4gICAgdmFyIGlzUmVxdWlyZWQgPSAhIXJlcXVlc3RpbmcgJiYgbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJiBtb2RpZmllci5lbmFibGVkICYmIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlcjtcbiAgICB9KTtcblxuICAgIGlmICghaXNSZXF1aXJlZCkge1xuICAgICAgdmFyIF9yZXF1ZXN0aW5nID0gJ2AnICsgcmVxdWVzdGluZ05hbWUgKyAnYCc7XG4gICAgICB2YXIgcmVxdWVzdGVkID0gJ2AnICsgcmVxdWVzdGVkTmFtZSArICdgJztcbiAgICAgIGNvbnNvbGUud2FybihyZXF1ZXN0ZWQgKyAnIG1vZGlmaWVyIGlzIHJlcXVpcmVkIGJ5ICcgKyBfcmVxdWVzdGluZyArICcgbW9kaWZpZXIgaW4gb3JkZXIgdG8gd29yaywgYmUgc3VyZSB0byBpbmNsdWRlIGl0IGJlZm9yZSAnICsgX3JlcXVlc3RpbmcgKyAnIScpO1xuICAgIH1cbiAgICByZXR1cm4gaXNSZXF1aXJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICAgKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICAgKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAgICovXG4gIGZ1bmN0aW9uIGFycm93KGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyRhcnJvdztcblxuICAgIC8vIGFycm93IGRlcGVuZHMgb24ga2VlcFRvZ2V0aGVyIGluIG9yZGVyIHRvIHdvcmtcbiAgICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2Fycm93JywgJ2tlZXBUb2dldGhlcicpKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuXG4gICAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGEgc3RyaW5nLCBzdXBwb3NlIGl0J3MgYSBDU1Mgc2VsZWN0b3JcbiAgICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGFycm93RWxlbWVudCA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgICAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIG5vdCBmb3VuZCwgZG9uJ3QgcnVuIHRoZSBtb2RpZmllclxuICAgICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHRoZSBhcnJvd0VsZW1lbnQgaXNuJ3QgYSBxdWVyeSBzZWxlY3RvciB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhlXG4gICAgICAvLyBwcm92aWRlZCBET00gbm9kZSBpcyBjaGlsZCBvZiBpdHMgcG9wcGVyIG5vZGVcbiAgICAgIGlmICghZGF0YS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoYXJyb3dFbGVtZW50KSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBhcnJvdy5lbGVtZW50YCBtdXN0IGJlIGNoaWxkIG9mIGl0cyBwb3BwZXIgZWxlbWVudCEnKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICAgIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBzaWRlQ2FwaXRhbGl6ZWQgPSBpc1ZlcnRpY2FsID8gJ1RvcCcgOiAnTGVmdCc7XG4gICAgdmFyIHNpZGUgPSBzaWRlQ2FwaXRhbGl6ZWQudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgYWx0U2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICB2YXIgYXJyb3dFbGVtZW50U2l6ZSA9IGdldE91dGVyU2l6ZXMoYXJyb3dFbGVtZW50KVtsZW5dO1xuXG4gICAgLy9cbiAgICAvLyBleHRlbmRzIGtlZXBUb2dldGhlciBiZWhhdmlvciBtYWtpbmcgc3VyZSB0aGUgcG9wcGVyIGFuZCBpdHNcbiAgICAvLyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1bmN0aW9uXG4gICAgLy9cblxuICAgIC8vIHRvcC9sZWZ0IHNpZGVcbiAgICBpZiAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplIDwgcG9wcGVyW3NpZGVdKSB7XG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC09IHBvcHBlcltzaWRlXSAtIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUpO1xuICAgIH1cbiAgICAvLyBib3R0b20vcmlnaHQgc2lkZVxuICAgIGlmIChyZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplID4gcG9wcGVyW29wU2lkZV0pIHtcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gKz0gcmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSAtIHBvcHBlcltvcFNpZGVdO1xuICAgIH1cbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcblxuICAgIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgICB2YXIgY2VudGVyID0gcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW2xlbl0gLyAyIC0gYXJyb3dFbGVtZW50U2l6ZSAvIDI7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBzaWRlVmFsdWUgdXNpbmcgdGhlIHVwZGF0ZWQgcG9wcGVyIG9mZnNldHNcbiAgICAvLyB0YWtlIHBvcHBlciBtYXJnaW4gaW4gYWNjb3VudCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgdGhpcyBpbmZvIGF2YWlsYWJsZVxuICAgIHZhciBjc3MgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICAgIHZhciBwb3BwZXJNYXJnaW5TaWRlID0gcGFyc2VGbG9hdChjc3NbJ21hcmdpbicgKyBzaWRlQ2FwaXRhbGl6ZWRdKTtcbiAgICB2YXIgcG9wcGVyQm9yZGVyU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydib3JkZXInICsgc2lkZUNhcGl0YWxpemVkICsgJ1dpZHRoJ10pO1xuICAgIHZhciBzaWRlVmFsdWUgPSBjZW50ZXIgLSBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC0gcG9wcGVyTWFyZ2luU2lkZSAtIHBvcHBlckJvcmRlclNpZGU7XG5cbiAgICAvLyBwcmV2ZW50IGFycm93RWxlbWVudCBmcm9tIGJlaW5nIHBsYWNlZCBub3QgY29udGlndW91c2x5IHRvIGl0cyBwb3BwZXJcbiAgICBzaWRlVmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihwb3BwZXJbbGVuXSAtIGFycm93RWxlbWVudFNpemUsIHNpZGVWYWx1ZSksIDApO1xuXG4gICAgZGF0YS5hcnJvd0VsZW1lbnQgPSBhcnJvd0VsZW1lbnQ7XG4gICAgZGF0YS5vZmZzZXRzLmFycm93ID0gKF9kYXRhJG9mZnNldHMkYXJyb3cgPSB7fSwgZGVmaW5lUHJvcGVydHkkMShfZGF0YSRvZmZzZXRzJGFycm93LCBzaWRlLCBNYXRoLnJvdW5kKHNpZGVWYWx1ZSkpLCBkZWZpbmVQcm9wZXJ0eSQxKF9kYXRhJG9mZnNldHMkYXJyb3csIGFsdFNpZGUsICcnKSwgX2RhdGEkb2Zmc2V0cyRhcnJvdyk7XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCB2YXJpYXRpb24gb2YgdGhlIGdpdmVuIG9uZVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAgICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCB2YXJpYXRpb25cbiAgICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pIHtcbiAgICBpZiAodmFyaWF0aW9uID09PSAnZW5kJykge1xuICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfSBlbHNlIGlmICh2YXJpYXRpb24gPT09ICdzdGFydCcpIHtcbiAgICAgIHJldHVybiAnZW5kJztcbiAgICB9XG4gICAgcmV0dXJuIHZhcmlhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFjY2VwdGVkIHBsYWNlbWVudHMgdG8gdXNlIGFzIHZhbHVlcyBvZiB0aGUgYHBsYWNlbWVudGAgb3B0aW9uLjxiciAvPlxuICAgKiBWYWxpZCBwbGFjZW1lbnRzIGFyZTpcbiAgICogLSBgYXV0b2BcbiAgICogLSBgdG9wYFxuICAgKiAtIGByaWdodGBcbiAgICogLSBgYm90dG9tYFxuICAgKiAtIGBsZWZ0YFxuICAgKlxuICAgKiBFYWNoIHBsYWNlbWVudCBjYW4gaGF2ZSBhIHZhcmlhdGlvbiBmcm9tIHRoaXMgbGlzdDpcbiAgICogLSBgLXN0YXJ0YFxuICAgKiAtIGAtZW5kYFxuICAgKlxuICAgKiBWYXJpYXRpb25zIGFyZSBpbnRlcnByZXRlZCBlYXNpbHkgaWYgeW91IHRoaW5rIG9mIHRoZW0gYXMgdGhlIGxlZnQgdG8gcmlnaHRcbiAgICogd3JpdHRlbiBsYW5ndWFnZXMuIEhvcml6b250YWxseSAoYHRvcGAgYW5kIGBib3R0b21gKSwgYHN0YXJ0YCBpcyBsZWZ0IGFuZCBgZW5kYFxuICAgKiBpcyByaWdodC48YnIgLz5cbiAgICogVmVydGljYWxseSAoYGxlZnRgIGFuZCBgcmlnaHRgKSwgYHN0YXJ0YCBpcyB0b3AgYW5kIGBlbmRgIGlzIGJvdHRvbS5cbiAgICpcbiAgICogU29tZSB2YWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIC0gYHRvcC1lbmRgIChvbiB0b3Agb2YgcmVmZXJlbmNlLCByaWdodCBhbGlnbmVkKVxuICAgKiAtIGByaWdodC1zdGFydGAgKG9uIHJpZ2h0IG9mIHJlZmVyZW5jZSwgdG9wIGFsaWduZWQpXG4gICAqIC0gYGJvdHRvbWAgKG9uIGJvdHRvbSwgY2VudGVyZWQpXG4gICAqIC0gYGF1dG8tZW5kYCAob24gdGhlIHNpZGUgd2l0aCBtb3JlIHNwYWNlIGF2YWlsYWJsZSwgYWxpZ25tZW50IGRlcGVuZHMgYnkgcGxhY2VtZW50KVxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICogQGVudW0ge1N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqIEBtZXRob2QgcGxhY2VtZW50c1xuICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAqL1xuICB2YXIgcGxhY2VtZW50cyA9IFsnYXV0by1zdGFydCcsICdhdXRvJywgJ2F1dG8tZW5kJywgJ3RvcC1zdGFydCcsICd0b3AnLCAndG9wLWVuZCcsICdyaWdodC1zdGFydCcsICdyaWdodCcsICdyaWdodC1lbmQnLCAnYm90dG9tLWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2xlZnQtZW5kJywgJ2xlZnQnLCAnbGVmdC1zdGFydCddO1xuXG4gIC8vIEdldCByaWQgb2YgYGF1dG9gIGBhdXRvLXN0YXJ0YCBhbmQgYGF1dG8tZW5kYFxuICB2YXIgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuICAvKipcbiAgICogR2l2ZW4gYW4gaW5pdGlhbCBwbGFjZW1lbnQsIHJldHVybnMgYWxsIHRoZSBzdWJzZXF1ZW50IHBsYWNlbWVudHNcbiAgICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gICAqXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICAgKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IC0gQSB2YWxpZCBwbGFjZW1lbnQgKGl0IGFjY2VwdHMgdmFyaWF0aW9ucylcbiAgICogQGFyZ3VtZW50IHtCb29sZWFufSBjb3VudGVyIC0gU2V0IHRvIHRydWUgdG8gd2FsayB0aGUgcGxhY2VtZW50cyBjb3VudGVyY2xvY2t3aXNlXG4gICAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gY2xvY2t3aXNlKHBsYWNlbWVudCkge1xuICAgIHZhciBjb3VudGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIHZhciBpbmRleCA9IHZhbGlkUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCk7XG4gICAgdmFyIGFyciA9IHZhbGlkUGxhY2VtZW50cy5zbGljZShpbmRleCArIDEpLmNvbmNhdCh2YWxpZFBsYWNlbWVudHMuc2xpY2UoMCwgaW5kZXgpKTtcbiAgICByZXR1cm4gY291bnRlciA/IGFyci5yZXZlcnNlKCkgOiBhcnI7XG4gIH1cblxuICB2YXIgQkVIQVZJT1JTID0ge1xuICAgIEZMSVA6ICdmbGlwJyxcbiAgICBDTE9DS1dJU0U6ICdjbG9ja3dpc2UnLFxuICAgIENPVU5URVJDTE9DS1dJU0U6ICdjb3VudGVyY2xvY2t3aXNlJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICAgKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICAgKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAgICovXG4gIGZ1bmN0aW9uIGZsaXAoZGF0YSwgb3B0aW9ucykge1xuICAgIC8vIGlmIGBpbm5lcmAgbW9kaWZpZXIgaXMgZW5hYmxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBgZmxpcGAgbW9kaWZpZXJcbiAgICBpZiAoaXNNb2RpZmllckVuYWJsZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdpbm5lcicpKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5mbGlwcGVkICYmIGRhdGEucGxhY2VtZW50ID09PSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50KSB7XG4gICAgICAvLyBzZWVtcyBsaWtlIGZsaXAgaXMgdHJ5aW5nIHRvIGxvb3AsIHByb2JhYmx5IHRoZXJlJ3Mgbm90IGVub3VnaCBzcGFjZSBvbiBhbnkgb2YgdGhlIGZsaXBwYWJsZSBzaWRlc1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gICAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgdmFyIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICB2YXIgdmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVsxXSB8fCAnJztcblxuICAgIHZhciBmbGlwT3JkZXIgPSBbXTtcblxuICAgIHN3aXRjaCAob3B0aW9ucy5iZWhhdmlvcikge1xuICAgICAgY2FzZSBCRUhBVklPUlMuRkxJUDpcbiAgICAgICAgZmxpcE9yZGVyID0gW3BsYWNlbWVudCwgcGxhY2VtZW50T3Bwb3NpdGVdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQkVIQVZJT1JTLkNMT0NLV0lTRTpcbiAgICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCRUhBVklPUlMuQ09VTlRFUkNMT0NLV0lTRTpcbiAgICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCwgdHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZmxpcE9yZGVyID0gb3B0aW9ucy5iZWhhdmlvcjtcbiAgICB9XG5cbiAgICBmbGlwT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCwgaW5kZXgpIHtcbiAgICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgICAgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG4gICAgICB2YXIgcmVmT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICAgIC8vIHVzaW5nIGZsb29yIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSBvZmZzZXRzIG1heSBjb250YWluIGRlY2ltYWxzIHdlIGFyZSBub3QgZ29pbmcgdG8gY29uc2lkZXIgaGVyZVxuICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgIHZhciBvdmVybGFwc1JlZiA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IocmVmT2Zmc2V0cy5sZWZ0KSB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKHJlZk9mZnNldHMucmlnaHQpIHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IocmVmT2Zmc2V0cy50b3ApIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IocmVmT2Zmc2V0cy5ib3R0b20pO1xuXG4gICAgICB2YXIgb3ZlcmZsb3dzTGVmdCA9IGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihib3VuZGFyaWVzLmxlZnQpO1xuICAgICAgdmFyIG92ZXJmbG93c1JpZ2h0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihib3VuZGFyaWVzLnJpZ2h0KTtcbiAgICAgIHZhciBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgICB2YXIgb3ZlcmZsb3dzQm90dG9tID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IoYm91bmRhcmllcy5ib3R0b20pO1xuXG4gICAgICB2YXIgb3ZlcmZsb3dzQm91bmRhcmllcyA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIG92ZXJmbG93c0xlZnQgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIG92ZXJmbG93c1JpZ2h0IHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgb3ZlcmZsb3dzVG9wIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgb3ZlcmZsb3dzQm90dG9tO1xuXG4gICAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICAgIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICAgICAgLy8gZmxpcHMgdmFyaWF0aW9uIGlmIHJlZmVyZW5jZSBlbGVtZW50IG92ZXJmbG93cyBib3VuZGFyaWVzXG4gICAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbkJ5UmVmID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NSaWdodCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzVG9wIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzQm90dG9tKTtcblxuICAgICAgLy8gZmxpcHMgdmFyaWF0aW9uIGlmIHBvcHBlciBjb250ZW50IG92ZXJmbG93cyBib3VuZGFyaWVzXG4gICAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbkJ5Q29udGVudCA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9uc0J5Q29udGVudCAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0xlZnQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0JvdHRvbSB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1RvcCk7XG5cbiAgICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uID0gZmxpcHBlZFZhcmlhdGlvbkJ5UmVmIHx8IGZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQ7XG5cbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzIHx8IGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgLy8gdGhpcyBib29sZWFuIHRvIGRldGVjdCBhbnkgZmxpcCBsb29wXG4gICAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMpIHtcbiAgICAgICAgICBwbGFjZW1lbnQgPSBmbGlwT3JkZXJbaW5kZXggKyAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAgICAgdmFyaWF0aW9uID0gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEucGxhY2VtZW50ID0gcGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcblxuICAgICAgICAvLyB0aGlzIG9iamVjdCBjb250YWlucyBgcG9zaXRpb25gLCB3ZSB3YW50IHRvIHByZXNlcnZlIGl0IGFsb25nIHdpdGhcbiAgICAgICAgLy8gYW55IGFkZGl0aW9uYWwgcHJvcGVydHkgd2UgbWF5IGFkZCBpbiB0aGUgZnV0dXJlXG4gICAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLnBvcHBlciwgZ2V0UG9wcGVyT2Zmc2V0cyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpKTtcblxuICAgICAgICBkYXRhID0gcnVuTW9kaWZpZXJzKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBkYXRhLCAnZmxpcCcpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gICAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gICAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICAgKi9cbiAgZnVuY3Rpb24ga2VlcFRvZ2V0aGVyKGRhdGEpIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gICAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gICAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xuICAgIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICAgIGlmIChwb3BwZXJbc2lkZV0gPCBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkpIHtcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSAtIHBvcHBlclttZWFzdXJlbWVudF07XG4gICAgfVxuICAgIGlmIChwb3BwZXJbb3BTaWRlXSA+IGZsb29yKHJlZmVyZW5jZVtzaWRlXSkpIHtcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9IGZsb29yKHJlZmVyZW5jZVtzaWRlXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBzdHJpbmcgY29udGFpbmluZyB2YWx1ZSArIHVuaXQgaW50byBhIHB4IHZhbHVlIG51bWJlclxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAYXJndW1lbnQge1N0cmluZ30gc3RyIC0gVmFsdWUgKyB1bml0IHN0cmluZ1xuICAgKiBAYXJndW1lbnQge1N0cmluZ30gbWVhc3VyZW1lbnQgLSBgaGVpZ2h0YCBvciBgd2lkdGhgXG4gICAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gICAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICAgKiBWYWx1ZSBpbiBwaXhlbHMsIG9yIG9yaWdpbmFsIHN0cmluZyBpZiBubyB2YWx1ZXMgd2VyZSBleHRyYWN0ZWRcbiAgICovXG4gIGZ1bmN0aW9uIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cykge1xuICAgIC8vIHNlcGFyYXRlIHZhbHVlIGZyb20gdW5pdFxuICAgIHZhciBzcGxpdCA9IHN0ci5tYXRjaCgvKCg/OlxcLXxcXCspP1xcZCpcXC4/XFxkKikoLiopLyk7XG4gICAgdmFyIHZhbHVlID0gK3NwbGl0WzFdO1xuICAgIHZhciB1bml0ID0gc3BsaXRbMl07XG5cbiAgICAvLyBJZiBpdCdzIG5vdCBhIG51bWJlciBpdCdzIGFuIG9wZXJhdG9yLCBJIGd1ZXNzXG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICBpZiAodW5pdC5pbmRleE9mKCclJykgPT09IDApIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgJyVwJzpcbiAgICAgICAgICBlbGVtZW50ID0gcG9wcGVyT2Zmc2V0cztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgIGNhc2UgJyVyJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBlbGVtZW50ID0gcmVmZXJlbmNlT2Zmc2V0cztcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0KGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gICAgfSBlbHNlIGlmICh1bml0ID09PSAndmgnIHx8IHVuaXQgPT09ICd2dycpIHtcbiAgICAgIC8vIGlmIGlzIGEgdmggb3IgdncsIHdlIGNhbGN1bGF0ZSB0aGUgc2l6ZSBiYXNlZCBvbiB0aGUgdmlld3BvcnRcbiAgICAgIHZhciBzaXplID0gdm9pZCAwO1xuICAgICAgaWYgKHVuaXQgPT09ICd2aCcpIHtcbiAgICAgICAgc2l6ZSA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgaXMgYW4gZXhwbGljaXQgcGl4ZWwgdW5pdCwgd2UgZ2V0IHJpZCBvZiB0aGUgdW5pdCBhbmQga2VlcCB0aGUgdmFsdWVcbiAgICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYW4gYG9mZnNldGAgc3RyaW5nIHRvIGV4dHJhcG9sYXRlIGB4YCBhbmQgYHlgIG51bWVyaWMgb2Zmc2V0cy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAgICogQHByaXZhdGVcbiAgICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICAgKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICAgKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICAgKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGEgdHdvIGNlbGxzIGFycmF5IHdpdGggeCBhbmQgeSBvZmZzZXRzIGluIG51bWJlcnNcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cywgYmFzZVBsYWNlbWVudCkge1xuICAgIHZhciBvZmZzZXRzID0gWzAsIDBdO1xuXG4gICAgLy8gVXNlIGhlaWdodCBpZiBwbGFjZW1lbnQgaXMgbGVmdCBvciByaWdodCBhbmQgaW5kZXggaXMgMCBvdGhlcndpc2UgdXNlIHdpZHRoXG4gICAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAgIC8vIHdpbGwgdXNlIHRoZSBvdGhlciBvbmVcbiAgICB2YXIgdXNlSGVpZ2h0ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICAvLyBTcGxpdCB0aGUgb2Zmc2V0IHN0cmluZyB0byBvYnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHNcbiAgICAvLyBUaGUgcmVnZXggYWRkcmVzc2VzIHZhbHVlcyB3aXRoIHRoZSBwbHVzIG9yIG1pbnVzIHNpZ24gaW4gZnJvbnQgKCsxMCwgLTIwLCBldGMpXG4gICAgdmFyIGZyYWdtZW50cyA9IG9mZnNldC5zcGxpdCgvKFxcK3xcXC0pLykubWFwKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICByZXR1cm4gZnJhZy50cmltKCk7XG4gICAgfSk7XG5cbiAgICAvLyBEZXRlY3QgaWYgdGhlIG9mZnNldCBzdHJpbmcgY29udGFpbnMgYSBwYWlyIG9mIHZhbHVlcyBvciBhIHNpbmdsZSBvbmVcbiAgICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICAgIHZhciBkaXZpZGVyID0gZnJhZ21lbnRzLmluZGV4T2YoZmluZChmcmFnbWVudHMsIGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICByZXR1cm4gZnJhZy5zZWFyY2goLyx8XFxzLykgIT09IC0xO1xuICAgIH0pKTtcblxuICAgIGlmIChmcmFnbWVudHNbZGl2aWRlcl0gJiYgZnJhZ21lbnRzW2RpdmlkZXJdLmluZGV4T2YoJywnKSA9PT0gLTEpIHtcbiAgICAgIGNvbnNvbGUud2FybignT2Zmc2V0cyBzZXBhcmF0ZWQgYnkgd2hpdGUgc3BhY2UocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhIGNvbW1hICgsKSBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIC8vIElmIGRpdmlkZXIgaXMgZm91bmQsIHdlIGRpdmlkZSB0aGUgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzIHRvIGRpdmlkZVxuICAgIC8vIHRoZW0gYnkgb2ZzZXQgWCBhbmQgWS5cbiAgICB2YXIgc3BsaXRSZWdleCA9IC9cXHMqLFxccyp8XFxzKy87XG4gICAgdmFyIG9wcyA9IGRpdmlkZXIgIT09IC0xID8gW2ZyYWdtZW50cy5zbGljZSgwLCBkaXZpZGVyKS5jb25jYXQoW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVswXV0pLCBbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzFdXS5jb25jYXQoZnJhZ21lbnRzLnNsaWNlKGRpdmlkZXIgKyAxKSldIDogW2ZyYWdtZW50c107XG5cbiAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZXMgd2l0aCB1bml0cyB0byBhYnNvbHV0ZSBwaXhlbHMgdG8gYWxsb3cgb3VyIGNvbXB1dGF0aW9uc1xuICAgIG9wcyA9IG9wcy5tYXAoZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgICAgLy8gTW9zdCBvZiB0aGUgdW5pdHMgcmVseSBvbiB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHBvcHBlclxuICAgICAgdmFyIG1lYXN1cmVtZW50ID0gKGluZGV4ID09PSAxID8gIXVzZUhlaWdodCA6IHVzZUhlaWdodCkgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICB2YXIgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICAgIHJldHVybiBvcFxuICAgICAgLy8gVGhpcyBhZ2dyZWdhdGVzIGFueSBgK2Agb3IgYC1gIHNpZ24gdGhhdCBhcmVuJ3QgY29uc2lkZXJlZCBvcGVyYXRvcnNcbiAgICAgIC8vIGUuZy46IDEwICsgKzUgPT4gWzEwLCArLCArNV1cbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgaWYgKGFbYS5sZW5ndGggLSAxXSA9PT0gJycgJiYgWycrJywgJy0nXS5pbmRleE9mKGIpICE9PSAtMSkge1xuICAgICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IGI7XG4gICAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9IGVsc2UgaWYgKG1lcmdlV2l0aFByZXZpb3VzKSB7XG4gICAgICAgICAgYVthLmxlbmd0aCAtIDFdICs9IGI7XG4gICAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICAgIH1cbiAgICAgIH0sIFtdKVxuICAgICAgLy8gSGVyZSB3ZSBjb252ZXJ0IHRoZSBzdHJpbmcgdmFsdWVzIGludG8gbnVtYmVyIHZhbHVlcyAoaW4gcHgpXG4gICAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIExvb3AgdHJvdWdoIHRoZSBvZmZzZXRzIGFycmF5cyBhbmQgZXhlY3V0ZSB0aGUgb3BlcmF0aW9uc1xuICAgIG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICAgIG9wLmZvckVhY2goZnVuY3Rpb24gKGZyYWcsIGluZGV4Mikge1xuICAgICAgICBpZiAoaXNOdW1lcmljKGZyYWcpKSB7XG4gICAgICAgICAgb2Zmc2V0c1tpbmRleF0gKz0gZnJhZyAqIChvcFtpbmRleDIgLSAxXSA9PT0gJy0nID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9mZnNldHM7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAgICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAgICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICAgKiBAYXJndW1lbnQge051bWJlcnxTdHJpbmd9IG9wdGlvbnMub2Zmc2V0PTBcbiAgICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAgICovXG4gIGZ1bmN0aW9uIG9mZnNldCQxKGRhdGEsIF9yZWYpIHtcbiAgICB2YXIgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gICAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LFxuICAgICAgICBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gICAgdmFyIG9mZnNldHMgPSB2b2lkIDA7XG4gICAgaWYgKGlzTnVtZXJpYygrb2Zmc2V0KSkge1xuICAgICAgb2Zmc2V0cyA9IFsrb2Zmc2V0LCAwXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0cyA9IHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyLCByZWZlcmVuY2UsIGJhc2VQbGFjZW1lbnQpO1xuICAgIH1cblxuICAgIGlmIChiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICAgIHBvcHBlci5sZWZ0IC09IG9mZnNldHNbMV07XG4gICAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzFdO1xuICAgIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgICBwb3BwZXIudG9wIC09IG9mZnNldHNbMV07XG4gICAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1sxXTtcbiAgICB9XG5cbiAgICBkYXRhLnBvcHBlciA9IHBvcHBlcjtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICAgKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gICAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICAgKi9cbiAgZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgYm91bmRhcmllc0VsZW1lbnQgPSBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50IHx8IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG5cbiAgICAvLyBJZiBvZmZzZXRQYXJlbnQgaXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSByZWFsbHkgd2FudCB0b1xuICAgIC8vIGdvIG9uZSBzdGVwIHVwIGFuZCB1c2UgdGhlIG5leHQgb2Zmc2V0UGFyZW50IGFzIHJlZmVyZW5jZSB0b1xuICAgIC8vIGF2b2lkIHRvIG1ha2UgdGhpcyBtb2RpZmllciBjb21wbGV0ZWx5IHVzZWxlc3MgYW5kIGxvb2sgbGlrZSBicm9rZW5cbiAgICBpZiAoZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UgPT09IGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gICAgICBib3VuZGFyaWVzRWxlbWVudCA9IGdldE9mZnNldFBhcmVudChib3VuZGFyaWVzRWxlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gTk9URTogRE9NIGFjY2VzcyBoZXJlXG4gICAgLy8gcmVzZXRzIHRoZSBwb3BwZXIncyBwb3NpdGlvbiBzbyB0aGF0IHRoZSBkb2N1bWVudCBzaXplIGNhbiBiZSBjYWxjdWxhdGVkIGV4Y2x1ZGluZ1xuICAgIC8vIHRoZSBzaXplIG9mIHRoZSBwb3BwZXIgZWxlbWVudCBpdHNlbGZcbiAgICB2YXIgdHJhbnNmb3JtUHJvcCA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG4gICAgdmFyIHBvcHBlclN0eWxlcyA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnN0eWxlOyAvLyBhc3NpZ25tZW50IHRvIGhlbHAgbWluaWZpY2F0aW9uXG4gICAgdmFyIHRvcCA9IHBvcHBlclN0eWxlcy50b3AsXG4gICAgICAgIGxlZnQgPSBwb3BwZXJTdHlsZXMubGVmdCxcbiAgICAgICAgdHJhbnNmb3JtID0gcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdO1xuXG4gICAgcG9wcGVyU3R5bGVzLnRvcCA9ICcnO1xuICAgIHBvcHBlclN0eWxlcy5sZWZ0ID0gJyc7XG4gICAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gJyc7XG5cbiAgICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gICAgLy8gTk9URTogRE9NIGFjY2VzcyBoZXJlXG4gICAgLy8gcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIG9mZnNldHMgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gICAgcG9wcGVyU3R5bGVzLnRvcCA9IHRvcDtcbiAgICBwb3BwZXJTdHlsZXMubGVmdCA9IGxlZnQ7XG4gICAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuXG4gICAgb3B0aW9ucy5ib3VuZGFyaWVzID0gYm91bmRhcmllcztcblxuICAgIHZhciBvcmRlciA9IG9wdGlvbnMucHJpb3JpdHk7XG4gICAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgICB2YXIgY2hlY2sgPSB7XG4gICAgICBwcmltYXJ5OiBmdW5jdGlvbiBwcmltYXJ5KHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdIDwgYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KHBvcHBlcltwbGFjZW1lbnRdLCBib3VuZGFyaWVzW3BsYWNlbWVudF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSQxKHt9LCBwbGFjZW1lbnQsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBzZWNvbmRhcnk6IGZ1bmN0aW9uIHNlY29uZGFyeShwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIG1haW5TaWRlID0gcGxhY2VtZW50ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA+IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihwb3BwZXJbbWFpblNpZGVdLCBib3VuZGFyaWVzW3BsYWNlbWVudF0gLSAocGxhY2VtZW50ID09PSAncmlnaHQnID8gcG9wcGVyLndpZHRoIDogcG9wcGVyLmhlaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSQxKHt9LCBtYWluU2lkZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBvcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICAgIHZhciBzaWRlID0gWydsZWZ0JywgJ3RvcCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5JztcbiAgICAgIHBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIGNoZWNrW3NpZGVdKHBsYWNlbWVudCkpO1xuICAgIH0pO1xuXG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gICAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAgICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gICAqL1xuICBmdW5jdGlvbiBzaGlmdChkYXRhKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICAgIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgdmFyIHNoaWZ0dmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgICAvLyBpZiBzaGlmdCBzaGlmdHZhcmlhdGlvbiBpcyBzcGVjaWZpZWQsIHJ1biB0aGUgbW9kaWZpZXJcbiAgICBpZiAoc2hpZnR2YXJpYXRpb24pIHtcbiAgICAgIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlLFxuICAgICAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyO1xuXG4gICAgICB2YXIgaXNWZXJ0aWNhbCA9IFsnYm90dG9tJywgJ3RvcCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuICAgICAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgICB2YXIgc2hpZnRPZmZzZXRzID0ge1xuICAgICAgICBzdGFydDogZGVmaW5lUHJvcGVydHkkMSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdKSxcbiAgICAgICAgZW5kOiBkZWZpbmVQcm9wZXJ0eSQxKHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbWVhc3VyZW1lbnRdIC0gcG9wcGVyW21lYXN1cmVtZW50XSlcbiAgICAgIH07XG5cbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBzaGlmdE9mZnNldHNbc2hpZnR2YXJpYXRpb25dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICAgKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICAgKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAgICovXG4gIGZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICAgIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaGlkZScsICdwcmV2ZW50T3ZlcmZsb3cnKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgdmFyIHJlZlJlY3QgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuICAgIHZhciBib3VuZCA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdwcmV2ZW50T3ZlcmZsb3cnO1xuICAgIH0pLmJvdW5kYXJpZXM7XG5cbiAgICBpZiAocmVmUmVjdC5ib3R0b20gPCBib3VuZC50b3AgfHwgcmVmUmVjdC5sZWZ0ID4gYm91bmQucmlnaHQgfHwgcmVmUmVjdC50b3AgPiBib3VuZC5ib3R0b20gfHwgcmVmUmVjdC5yaWdodCA8IGJvdW5kLmxlZnQpIHtcbiAgICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgICAgaWYgKGRhdGEuaGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5oaWRlID0gdHJ1ZTtcbiAgICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgICAgaWYgKGRhdGEuaGlkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG5cbiAgICAgIGRhdGEuaGlkZSA9IGZhbHNlO1xuICAgICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICAgKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gICAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICAgKi9cbiAgZnVuY3Rpb24gaW5uZXIoZGF0YSkge1xuICAgIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICB2YXIgaXNIb3JpeiA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgdmFyIHN1YnRyYWN0TGVuZ3RoID0gWyd0b3AnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPT09IC0xO1xuXG4gICAgcG9wcGVyW2lzSG9yaXogPyAnbGVmdCcgOiAndG9wJ10gPSByZWZlcmVuY2VbYmFzZVBsYWNlbWVudF0gLSAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICAgIGRhdGEucGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChwb3BwZXIpO1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAgICogdG8gaXRzIGBmbmAgcHJvcGVydHkuPGJyIC8+XG4gICAqIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZSwgdGhpcyBtZWFucyB0aGF0IHlvdSBtdXN0XG4gICAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIE1vZGlmaWVyRm5cbiAgICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAgICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7ZGF0YU9iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICAgKi9cblxuICAvKipcbiAgICogTW9kaWZpZXJzIGFyZSBwbHVnaW5zIHVzZWQgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHlvdXIgcG9wcGVycy48YnIgLz5cbiAgICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICAgKiBuZWVkZWQgYnkgdGhlIGxpYnJhcnkuXG4gICAqXG4gICAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICAgKiBBbGwgdGhlIG90aGVyIHByb3BlcnRpZXMgYXJlIGNvbmZpZ3VyYXRpb25zIHRoYXQgY291bGQgYmUgdHdlYWtlZC5cbiAgICogQG5hbWVzcGFjZSBtb2RpZmllcnNcbiAgICovXG4gIHZhciBtb2RpZmllcnMgPSB7XG4gICAgLyoqXG4gICAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZVxuICAgICAqIGVsZW1lbnQuPGJyIC8+XG4gICAgICogSXQgd2lsbCByZWFkIHRoZSB2YXJpYXRpb24gb2YgdGhlIGBwbGFjZW1lbnRgIHByb3BlcnR5LjxiciAvPlxuICAgICAqIEl0IGNhbiBiZSBvbmUgZWl0aGVyIGAtZW5kYCBvciBgLXN0YXJ0YC5cbiAgICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgc2hpZnQ6IHtcbiAgICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0xMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgICBvcmRlcjogMTAwLFxuICAgICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICAgIGZuOiBzaGlmdFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYG9mZnNldGAgbW9kaWZpZXIgY2FuIHNoaWZ0IHlvdXIgcG9wcGVyIG9uIGJvdGggaXRzIGF4aXMuXG4gICAgICpcbiAgICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAgICogLSBgcHhgIG9yIHVuaXQtbGVzcywgaW50ZXJwcmV0ZWQgYXMgcGl4ZWxzXG4gICAgICogLSBgJWAgb3IgYCVyYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICAgICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgICAqIC0gYHZ3YCwgQ1NTIHZpZXdwb3J0IHdpZHRoIHVuaXRcbiAgICAgKiAtIGB2aGAsIENTUyB2aWV3cG9ydCBoZWlnaHQgdW5pdFxuICAgICAqXG4gICAgICogRm9yIGxlbmd0aCBpcyBpbnRlbmRlZCB0aGUgbWFpbiBheGlzIHJlbGF0aXZlIHRvIHRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcHBlci48YnIgLz5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgaWYgdGhlIHBsYWNlbWVudCBpcyBgdG9wYCBvciBgYm90dG9tYCwgdGhlIGxlbmd0aCB3aWxsIGJlIHRoZVxuICAgICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGBoZWlnaHRgLlxuICAgICAqXG4gICAgICogWW91IGNhbiBwcm92aWRlIGEgc2luZ2xlIHZhbHVlIChhcyBgTnVtYmVyYCBvciBgU3RyaW5nYCksIG9yIGEgcGFpciBvZiB2YWx1ZXNcbiAgICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAgICogVGhlIGxhdHRlciBpcyBhIGRlcHJlY2F0ZWQgbWV0aG9kIGJlY2F1c2UgaXQgbGVhZHMgdG8gY29uZnVzaW9uIGFuZCB3aWxsIGJlXG4gICAgICogcmVtb3ZlZCBpbiB2Mi48YnIgLz5cbiAgICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAgICogTm90ZSB0aGF0IG11bHRpcGxpY2F0aW9ucyBhbmQgZGl2aXNpb25zIGFyZW4ndCBzdXBwb3J0ZWQuXG4gICAgICpcbiAgICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAgICogYGBgXG4gICAgICogMTBcbiAgICAgKiAnMTAlJ1xuICAgICAqICcxMCwgMTAnXG4gICAgICogJzEwJSwgMTAnXG4gICAgICogJzEwICsgMTAlJ1xuICAgICAqICcxMCAtIDV2aCArIDMlJ1xuICAgICAqICctMTBweCArIDV2aCwgNXB4IC0gNiUnXG4gICAgICogYGBgXG4gICAgICogPiAqKk5CKio6IElmIHlvdSBkZXNpcmUgdG8gYXBwbHkgb2Zmc2V0cyB0byB5b3VyIHBvcHBlcnMgaW4gYSB3YXkgdGhhdCBtYXkgbWFrZSB0aGVtIG92ZXJsYXBcbiAgICAgKiA+IHdpdGggdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnQsIHVuZm9ydHVuYXRlbHksIHlvdSB3aWxsIGhhdmUgdG8gZGlzYWJsZSB0aGUgYGZsaXBgIG1vZGlmaWVyLlxuICAgICAqID4gWW91IGNhbiByZWFkIG1vcmUgb24gdGhpcyBhdCB0aGlzIFtpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzM3MykuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgb2Zmc2V0OiB7XG4gICAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgICAgb3JkZXI6IDIwMCxcbiAgICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgICBmbjogb2Zmc2V0JDEsXG4gICAgICAvKiogQHByb3Age051bWJlcnxTdHJpbmd9IG9mZnNldD0wXG4gICAgICAgKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAgICAgICAqL1xuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVyIHVzZWQgdG8gcHJldmVudCB0aGUgcG9wcGVyIGZyb20gYmVpbmcgcG9zaXRpb25lZCBvdXRzaWRlIHRoZSBib3VuZGFyeS5cbiAgICAgKlxuICAgICAqIEEgc2NlbmFyaW8gZXhpc3RzIHdoZXJlIHRoZSByZWZlcmVuY2UgaXRzZWxmIGlzIG5vdCB3aXRoaW4gdGhlIGJvdW5kYXJpZXMuPGJyIC8+XG4gICAgICogV2UgY2FuIHNheSBpdCBoYXMgXCJlc2NhcGVkIHRoZSBib3VuZGFyaWVzXCIg4oCUIG9yIGp1c3QgXCJlc2NhcGVkXCIuPGJyIC8+XG4gICAgICogSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHBvcHBlciBzaG91bGQgZWl0aGVyOlxuICAgICAqXG4gICAgICogLSBkZXRhY2ggZnJvbSB0aGUgcmVmZXJlbmNlIGFuZCByZW1haW4gXCJ0cmFwcGVkXCIgaW4gdGhlIGJvdW5kYXJpZXMsIG9yXG4gICAgICogLSBpZiBpdCBzaG91bGQgaWdub3JlIHRoZSBib3VuZGFyeSBhbmQgXCJlc2NhcGUgd2l0aCBpdHMgcmVmZXJlbmNlXCJcbiAgICAgKlxuICAgICAqIFdoZW4gYGVzY2FwZVdpdGhSZWZlcmVuY2VgIGlzIHNldCB0b2B0cnVlYCBhbmQgcmVmZXJlbmNlIGlzIGNvbXBsZXRlbHlcbiAgICAgKiBvdXRzaWRlIGl0cyBib3VuZGFyaWVzLCB0aGUgcG9wcGVyIHdpbGwgb3ZlcmZsb3cgKG9yIGNvbXBsZXRlbHkgbGVhdmUpXG4gICAgICogdGhlIGJvdW5kYXJpZXMgaW4gb3JkZXIgdG8gcmVtYWluIGF0dGFjaGVkIHRvIHRoZSBlZGdlIG9mIHRoZSByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgICAgb3JkZXI6IDMwMCxcbiAgICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgICAgLyoqXG4gICAgICAgKiBAcHJvcCB7QXJyYXl9IFtwcmlvcml0eT1bJ2xlZnQnLCdyaWdodCcsJ3RvcCcsJ2JvdHRvbSddXVxuICAgICAgICogUG9wcGVyIHdpbGwgdHJ5IHRvIHByZXZlbnQgb3ZlcmZsb3cgZm9sbG93aW5nIHRoZXNlIHByaW9yaXRpZXMgYnkgZGVmYXVsdCxcbiAgICAgICAqIHRoZW4sIGl0IGNvdWxkIG92ZXJmbG93IG9uIHRoZSBsZWZ0IGFuZCBvbiB0b3Agb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgICAqL1xuICAgICAgcHJpb3JpdHk6IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG4gICAgICAvKipcbiAgICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAgICogQW1vdW50IG9mIHBpeGVsIHVzZWQgdG8gZGVmaW5lIGEgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib3VuZGFyaWVzXG4gICAgICAgKiBhbmQgdGhlIHBvcHBlci4gVGhpcyBtYWtlcyBzdXJlIHRoZSBwb3BwZXIgYWx3YXlzIGhhcyBhIGxpdHRsZSBwYWRkaW5nXG4gICAgICAgKiBiZXR3ZWVuIHRoZSBlZGdlcyBvZiBpdHMgY29udGFpbmVyXG4gICAgICAgKi9cbiAgICAgIHBhZGRpbmc6IDUsXG4gICAgICAvKipcbiAgICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSdzY3JvbGxQYXJlbnQnXG4gICAgICAgKiBCb3VuZGFyaWVzIHVzZWQgYnkgdGhlIG1vZGlmaWVyLiBDYW4gYmUgYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgLFxuICAgICAgICogYHZpZXdwb3J0YCBvciBhbnkgRE9NIGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlIGFuZCBpdHMgcG9wcGVyIHN0YXkgbmVhciBlYWNoIG90aGVyXG4gICAgICogd2l0aG91dCBsZWF2aW5nIGFueSBnYXAgYmV0d2VlbiB0aGUgdHdvLiBFc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIHRoZSBhcnJvdyBpc1xuICAgICAqIGVuYWJsZWQgYW5kIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0IGl0IHBvaW50cyB0byBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAgICogSXQgY2FyZXMgb25seSBhYm91dCB0aGUgZmlyc3QgYXhpcy4gWW91IGNhbiBzdGlsbCBoYXZlIHBvcHBlcnMgd2l0aCBtYXJnaW5cbiAgICAgKiBiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAga2VlcFRvZ2V0aGVyOiB7XG4gICAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NDAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgICAgb3JkZXI6IDQwMCxcbiAgICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgICBmbjoga2VlcFRvZ2V0aGVyXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbW9kaWZpZXIgaXMgdXNlZCB0byBtb3ZlIHRoZSBgYXJyb3dFbGVtZW50YCBvZiB0aGUgcG9wcGVyIHRvIG1ha2VcbiAgICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICAgKiBJdCB3aWxsIHJlYWQgdGhlIG91dGVyIHNpemUgb2YgdGhlIGBhcnJvd0VsZW1lbnRgIG5vZGUgdG8gZGV0ZWN0IGhvdyBtYW55XG4gICAgICogcGl4ZWxzIG9mIGNvbmp1bmN0aW9uIGFyZSBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBJdCBoYXMgbm8gZWZmZWN0IGlmIG5vIGBhcnJvd0VsZW1lbnRgIGlzIHByb3ZpZGVkLlxuICAgICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBhcnJvdzoge1xuICAgICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICAgIG9yZGVyOiA1MDAsXG4gICAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgICAgZm46IGFycm93LFxuICAgICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICAgIGVsZW1lbnQ6ICdbeC1hcnJvd10nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVyIHVzZWQgdG8gZmxpcCB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50IHdoZW4gaXQgc3RhcnRzIHRvIG92ZXJsYXAgaXRzXG4gICAgICogcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAgICpcbiAgICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICAgKiByZXN0YXJ0IGl0IGlmIGl0IGRldGVjdHMgdGhlIG5lZWQgdG8gZmxpcCB0aGUgcGxhY2VtZW50LlxuICAgICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmbGlwOiB7XG4gICAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgICAgb3JkZXI6IDYwMCxcbiAgICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgICBmbjogZmxpcCxcbiAgICAgIC8qKlxuICAgICAgICogQHByb3Age1N0cmluZ3xBcnJheX0gYmVoYXZpb3I9J2ZsaXAnXG4gICAgICAgKiBUaGUgYmVoYXZpb3IgdXNlZCB0byBjaGFuZ2UgdGhlIHBvcHBlcidzIHBsYWNlbWVudC4gSXQgY2FuIGJlIG9uZSBvZlxuICAgICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICAgKiBwbGFjZW1lbnRzICh3aXRoIG9wdGlvbmFsIHZhcmlhdGlvbnMpXG4gICAgICAgKi9cbiAgICAgIGJlaGF2aW9yOiAnZmxpcCcsXG4gICAgICAvKipcbiAgICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAgICogVGhlIHBvcHBlciB3aWxsIGZsaXAgaWYgaXQgaGl0cyB0aGUgZWRnZXMgb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgICAqL1xuICAgICAgcGFkZGluZzogNSxcbiAgICAgIC8qKlxuICAgICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3ZpZXdwb3J0J1xuICAgICAgICogVGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBvcHBlciBwb3NpdGlvbi5cbiAgICAgICAqIFRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgZGVmaW5lZCBib3VuZGFyaWVzXG4gICAgICAgKiAoZXhjZXB0IGlmIGBrZWVwVG9nZXRoZXJgIGlzIGVuYWJsZWQpXG4gICAgICAgKi9cbiAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiAndmlld3BvcnQnLFxuICAgICAgLyoqXG4gICAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnM9ZmFsc2VcbiAgICAgICAqIFRoZSBwb3BwZXIgd2lsbCBzd2l0Y2ggcGxhY2VtZW50IHZhcmlhdGlvbiBiZXR3ZWVuIGAtc3RhcnRgIGFuZCBgLWVuZGAgd2hlblxuICAgICAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50IG92ZXJsYXBzIGl0cyBib3VuZGFyaWVzLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAgICovXG4gICAgICBmbGlwVmFyaWF0aW9uczogZmFsc2UsXG4gICAgICAvKipcbiAgICAgICAqIEBwcm9wIHtCb29sZWFufSBmbGlwVmFyaWF0aW9uc0J5Q29udGVudD1mYWxzZVxuICAgICAgICogVGhlIHBvcHBlciB3aWxsIHN3aXRjaCBwbGFjZW1lbnQgdmFyaWF0aW9uIGJldHdlZW4gYC1zdGFydGAgYW5kIGAtZW5kYCB3aGVuXG4gICAgICAgKiB0aGUgcG9wcGVyIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIHJlZmVyZW5jZSBib3VuZGFyaWVzLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAgICovXG4gICAgICBmbGlwVmFyaWF0aW9uc0J5Q29udGVudDogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHRoZSBwb3BwZXIgZmxvdyB0b3dhcmQgdGhlIGlubmVyIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICAgKiBCeSBkZWZhdWx0LCB3aGVuIHRoaXMgbW9kaWZpZXIgaXMgZGlzYWJsZWQsIHRoZSBwb3BwZXIgd2lsbCBiZSBwbGFjZWQgb3V0c2lkZVxuICAgICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgaW5uZXI6IHtcbiAgICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj03MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgICBvcmRlcjogNzAwLFxuICAgICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPWZhbHNlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgICAgZm46IGlubmVyXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVyIHVzZWQgdG8gaGlkZSB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dHNpZGUgb2YgdGhlXG4gICAgICogcG9wcGVyIGJvdW5kYXJpZXMuIEl0IHdpbGwgc2V0IGEgYHgtb3V0LW9mLWJvdW5kYXJpZXNgIGF0dHJpYnV0ZSB3aGljaCBjYW5cbiAgICAgKiBiZSB1c2VkIHRvIGhpZGUgd2l0aCBhIENTUyBzZWxlY3RvciB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBpc1xuICAgICAqIG91dCBvZiBib3VuZGFyaWVzLlxuICAgICAqXG4gICAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBoaWRlOiB7XG4gICAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgICAgb3JkZXI6IDgwMCxcbiAgICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgICBmbjogaGlkZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3R5bGUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBlbGVtZW50IHRvIGdldHNcbiAgICAgKiBwcm9wZXJseSBwb3NpdGlvbmVkLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbW9kaWZpZXIgd2lsbCBub3QgdG91Y2ggdGhlIERPTSwgaXQganVzdCBwcmVwYXJlcyB0aGUgc3R5bGVzXG4gICAgICogc28gdGhhdCBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgY2FuIGFwcGx5IGl0LiBUaGlzIHNlcGFyYXRpb24gaXMgdXNlZnVsXG4gICAgICogaW4gY2FzZSB5b3UgbmVlZCB0byByZXBsYWNlIGBhcHBseVN0eWxlYCB3aXRoIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBtb2RpZmllciBoYXMgYDg1MGAgYXMgYG9yZGVyYCB2YWx1ZSB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICogd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBQb3BwZXIuanMuIEV4cGVjdCB0aGUgbW9kaWZpZXJzIG9yZGVyaW5nIG1ldGhvZFxuICAgICAqIHRvIGNoYW5nZSBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMgb2YgdGhlIGxpYnJhcnkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgY29tcHV0ZVN0eWxlOiB7XG4gICAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODUwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgICAgb3JkZXI6IDg1MCxcbiAgICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgICBmbjogY29tcHV0ZVN0eWxlLFxuICAgICAgLyoqXG4gICAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzXG4gICAgICAgKi9cbiAgICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAgIC8qKlxuICAgICAgICogQHByb3Age3N0cmluZ30gW3g9J2JvdHRvbSddXG4gICAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYGJvdHRvbWBcbiAgICAgICAqL1xuICAgICAgeDogJ2JvdHRvbScsXG4gICAgICAvKipcbiAgICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdsZWZ0J11cbiAgICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgcmlnaHRgXG4gICAgICAgKi9cbiAgICAgIHk6ICdyaWdodCdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgYXJlIGxpbWl0ZWQgdG8gdGhpcyBtb2RpZmllci4gVGhpcyBpcyB1c2VmdWwgaW4gY2FzZVxuICAgICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAgICogd2FudCB0byBkZWxlZ2F0ZSBhbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIHRvIGl0LlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICAgKiBoYXMgaXRzIHBvc2l0aW9uIHNldCB0byBgYWJzb2x1dGVgIGJlZm9yZSBQb3BwZXIuanMgY2FuIGRvIGl0cyB3b3JrIVxuICAgICAqXG4gICAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3VyIG93biB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBhcHBseVN0eWxlOiB7XG4gICAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9OTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgICAgb3JkZXI6IDkwMCxcbiAgICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgICBmbjogYXBwbHlTdHlsZSxcbiAgICAgIC8qKiBAcHJvcCB7RnVuY3Rpb259ICovXG4gICAgICBvbkxvYWQ6IGFwcGx5U3R5bGVPbkxvYWQsXG4gICAgICAvKipcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xMC4wLCB0aGUgcHJvcGVydHkgbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXJcbiAgICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNEIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgICAqL1xuICAgICAgZ3B1QWNjZWxlcmF0aW9uOiB1bmRlZmluZWRcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBgZGF0YU9iamVjdGAgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvcm1hdGlvbiB1c2VkIGJ5IFBvcHBlci5qcy5cbiAgICogVGhpcyBvYmplY3QgaXMgcGFzc2VkIHRvIG1vZGlmaWVycyBhbmQgdG8gdGhlIGBvbkNyZWF0ZWAgYW5kIGBvblVwZGF0ZWAgY2FsbGJhY2tzLlxuICAgKiBAbmFtZSBkYXRhT2JqZWN0XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmluc3RhbmNlIFRoZSBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGRhdGEucGxhY2VtZW50IFBsYWNlbWVudCBhcHBsaWVkIHRvIHBvcHBlclxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmZsaXBwZWQgVHJ1ZSBpZiBwb3BwZXIgaGFzIGJlZW4gZmxpcHBlZCBieSBmbGlwIG1vZGlmaWVyXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5oaWRlIFRydWUgaWYgdGhlIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dCBvZiBib3VuZGFyaWVzLCB1c2VmdWwgdG8ga25vdyB3aGVuIHRvIGhpZGUgdGhlIHBvcHBlclxuICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBkYXRhLmFycm93RWxlbWVudCBOb2RlIHVzZWQgYXMgYXJyb3cgYnkgYXJyb3cgbW9kaWZpZXJcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuc3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICAgKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5hcnJvd1N0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBhcnJvdy4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYm91bmRhcmllcyBPZmZzZXRzIG9mIHRoZSBwb3BwZXIgYm91bmRhcmllc1xuICAgKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzIFRoZSBtZWFzdXJlbWVudHMgb2YgcG9wcGVyLCByZWZlcmVuY2UgYW5kIGFycm93IGVsZW1lbnRzXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucG9wcGVyIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICAgKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5hcnJvd10gYHRvcGAgYW5kIGBsZWZ0YCBvZmZzZXRzLCBvbmx5IG9uZSBvZiB0aGVtIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gMFxuICAgKi9cblxuICAvKipcbiAgICogRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkIHRvIFBvcHBlci5qcyBjb25zdHJ1Y3Rvci48YnIgLz5cbiAgICogVGhlc2UgY2FuIGJlIG92ZXJyaWRkZW4gdXNpbmcgdGhlIGBvcHRpb25zYCBhcmd1bWVudCBvZiBQb3BwZXIuanMuPGJyIC8+XG4gICAqIFRvIG92ZXJyaWRlIGFuIG9wdGlvbiwgc2ltcGx5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWVcbiAgICogc3RydWN0dXJlIG9mIHRoZSBgb3B0aW9uc2Agb2JqZWN0LCBhcyB0aGUgM3JkIGFyZ3VtZW50LiBGb3IgZXhhbXBsZTpcbiAgICogYGBgXG4gICAqIG5ldyBQb3BwZXIocmVmLCBwb3AsIHtcbiAgICogICBtb2RpZmllcnM6IHtcbiAgICogICAgIHByZXZlbnRPdmVyZmxvdzogeyBlbmFibGVkOiBmYWxzZSB9XG4gICAqICAgfVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAqL1xuICB2YXIgRGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogUG9wcGVyJ3MgcGxhY2VtZW50LlxuICAgICAqIEBwcm9wIHtQb3BwZXIucGxhY2VtZW50c30gcGxhY2VtZW50PSdib3R0b20nXG4gICAgICovXG4gICAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIHRvIHRydWUgaWYgeW91IHdhbnQgcG9wcGVyIHRvIHBvc2l0aW9uIGl0IHNlbGYgaW4gJ2ZpeGVkJyBtb2RlXG4gICAgICogQHByb3Age0Jvb2xlYW59IHBvc2l0aW9uRml4ZWQ9ZmFsc2VcbiAgICAgKi9cbiAgICBwb3NpdGlvbkZpeGVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZXZlbnRzIChyZXNpemUsIHNjcm9sbCkgYXJlIGluaXRpYWxseSBlbmFibGVkLlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBldmVudHNFbmFibGVkPXRydWVcbiAgICAgKi9cbiAgICBldmVudHNFbmFibGVkOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZW1vdmUgdGhlIHBvcHBlciB3aGVuXG4gICAgICogeW91IGNhbGwgdGhlIGBkZXN0cm95YCBtZXRob2QuXG4gICAgICogQHByb3Age0Jvb2xlYW59IHJlbW92ZU9uRGVzdHJveT1mYWxzZVxuICAgICAqL1xuICAgIHJlbW92ZU9uRGVzdHJveTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIGNyZWF0ZWQuPGJyIC8+XG4gICAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAgICogQHByb3Age29uQ3JlYXRlfVxuICAgICAqL1xuICAgIG9uQ3JlYXRlOiBmdW5jdGlvbiBvbkNyZWF0ZSgpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICAgKiBvbiB0aGUgaW5pdGlhbGl6YXRpb24vY3JlYXRpb24gb2YgdGhlIHBvcHBlciwgYnV0IG9ubHkgb24gc3Vic2VxdWVudFxuICAgICAqIHVwZGF0ZXMuPGJyIC8+XG4gICAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAgICogQHByb3Age29uVXBkYXRlfVxuICAgICAqL1xuICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZSgpIHt9LFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICAgKiBUaGV5IHByb3ZpZGUgbW9zdCBvZiB0aGUgZnVuY3Rpb25hbGl0aWVzIG9mIFBvcHBlci5qcy5cbiAgICAgKiBAcHJvcCB7bW9kaWZpZXJzfVxuICAgICAqL1xuICAgIG1vZGlmaWVyczogbW9kaWZpZXJzXG4gIH07XG5cbiAgLyoqXG4gICAqIEBjYWxsYmFjayBvbkNyZWF0ZVxuICAgKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAgICovXG5cbiAgLyoqXG4gICAqIEBjYWxsYmFjayBvblVwZGF0ZVxuICAgKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAgICovXG5cbiAgLy8gVXRpbHNcbiAgLy8gTWV0aG9kc1xuICB2YXIgUG9wcGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgUG9wcGVyLmpzIGluc3RhbmNlLlxuICAgICAqIEBjbGFzcyBQb3BwZXJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8cmVmZXJlbmNlT2JqZWN0fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCAvIFhNTCBlbGVtZW50IHVzZWQgYXMgdGhlIHBvcHBlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gWW91ciBjdXN0b20gb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgb25lcyBkZWZpbmVkIGluIFtEZWZhdWx0c10oI2RlZmF1bHRzKVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gaW5zdGFuY2UgLSBUaGUgZ2VuZXJhdGVkIFBvcHBlci5qcyBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBvcHBlcihyZWZlcmVuY2UsIHBvcHBlcikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wcGVyKTtcblxuICAgICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy51cGRhdGUpO1xuICAgICAgfTtcblxuICAgICAgLy8gbWFrZSB1cGRhdGUoKSBkZWJvdW5jZWQsIHNvIHRoYXQgaXQgb25seSBydW5zIGF0IG1vc3Qgb25jZS1wZXItdGlja1xuICAgICAgdGhpcy51cGRhdGUgPSBkZWJvdW5jZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgICAgLy8gd2l0aCB7fSB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG9wdGlvbnMgaW5zaWRlIGl0XG4gICAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgLy8gaW5pdCBzdGF0ZVxuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgICAgICBpc0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgICBzY3JvbGxQYXJlbnRzOiBbXVxuICAgICAgfTtcblxuICAgICAgLy8gZ2V0IHJlZmVyZW5jZSBhbmQgcG9wcGVyIGVsZW1lbnRzIChhbGxvdyBqUXVlcnkgd3JhcHBlcnMpXG4gICAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgICAgdGhpcy5wb3BwZXIgPSBwb3BwZXIgJiYgcG9wcGVyLmpxdWVyeSA/IHBvcHBlclswXSA6IHBvcHBlcjtcblxuICAgICAgLy8gRGVlcCBtZXJnZSBtb2RpZmllcnMgb3B0aW9uc1xuICAgICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycyA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMoX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnMsIG9wdGlvbnMubW9kaWZpZXJzKSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzW25hbWVdIHx8IHt9LCBvcHRpb25zLm1vZGlmaWVycyA/IG9wdGlvbnMubW9kaWZpZXJzW25hbWVdIDoge30pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlZmFjdG9yaW5nIG1vZGlmaWVycycgbGlzdCAoT2JqZWN0ID0+IEFycmF5KVxuICAgICAgdGhpcy5tb2RpZmllcnMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMubW9kaWZpZXJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH0sIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdKTtcbiAgICAgIH0pXG4gICAgICAvLyBzb3J0IHRoZSBtb2RpZmllcnMgYnkgb3JkZXJcbiAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBtb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIHdoZW4gUG9wcGVyLmpzIGdldCBpbml0ZWRcbiAgICAgIC8vIHN1Y2ggY29kZSBpcyBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBvZiBpdHMgbW9kaWZpZXJcbiAgICAgIC8vIHRoZXkgY291bGQgYWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZWlyIG9wdGlvbnMgY29uZmlndXJhdGlvblxuICAgICAgLy8gQkUgQVdBUkU6IGRvbid0IGFkZCBvcHRpb25zIHRvIGBvcHRpb25zLm1vZGlmaWVycy5uYW1lYCBidXQgdG8gYG1vZGlmaWVyT3B0aW9uc2AhXG4gICAgICB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVyT3B0aW9ucy5lbmFibGVkICYmIGlzRnVuY3Rpb24kMShtb2RpZmllck9wdGlvbnMub25Mb2FkKSkge1xuICAgICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoX3RoaXMucmVmZXJlbmNlLCBfdGhpcy5wb3BwZXIsIF90aGlzLm9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgX3RoaXMuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICB2YXIgZXZlbnRzRW5hYmxlZCA9IHRoaXMub3B0aW9ucy5ldmVudHNFbmFibGVkO1xuICAgICAgaWYgKGV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzLCB0aGV5IHdpbGwgdGFrZSBjYXJlIG9mIHVwZGF0ZSB0aGUgcG9zaXRpb24gaW4gc3BlY2lmaWMgc2l0dWF0aW9uc1xuICAgICAgICB0aGlzLmVuYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGV2ZW50c0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgdXNlIGNsYXNzIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IGdldCBsaXN0ZWQgaW4gdGhlXG4gICAgLy8gY2xhc3MgcHJvdG90eXBlIGFuZCBicmVhayBzdHVmZiBsaWtlIFNpbm9uIHN0dWJzXG5cblxuICAgIGNyZWF0ZUNsYXNzKFBvcHBlciwgW3tcbiAgICAgIGtleTogJ3VwZGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlJCQxKCkge1xuICAgICAgICByZXR1cm4gdXBkYXRlLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSQkMSgpIHtcbiAgICAgICAgcmV0dXJuIGRlc3Ryb3kkMS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2VuYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgICAgcmV0dXJuIGVuYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTY2hlZHVsZXMgYW4gdXBkYXRlLiBJdCB3aWxsIHJ1biBvbiB0aGUgbmV4dCBVSSB1cGRhdGUgYXZhaWxhYmxlLlxuICAgICAgICogQG1ldGhvZCBzY2hlZHVsZVVwZGF0ZVxuICAgICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAgICovXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICAgKiBTdGFydGluZyBmcm9tIHZlcnNpb24gMS43LCB0aGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgb25seSBpZiB5b3VcbiAgICAgICAqIGluY2x1ZGUgYHBvcHBlci11dGlscy5qc2AgYmVmb3JlIGBwb3BwZXIuanNgLlxuICAgICAgICpcbiAgICAgICAqICoqREVQUkVDQVRJT04qKjogVGhpcyB3YXkgdG8gYWNjZXNzIFBvcHBlclV0aWxzIGlzIGRlcHJlY2F0ZWRcbiAgICAgICAqIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjIhIFVzZSB0aGUgUG9wcGVyVXRpbHMgbW9kdWxlIGRpcmVjdGx5IGluc3RlYWQuXG4gICAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAgICogZ3VhcmFudGVlIHRoZW0gdG8gZm9sbG93IHNlbXZlci4gVXNlIHRoZW0gYXQgeW91ciBvd24gcmlzayFcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjhcbiAgICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgICAqL1xuXG4gICAgfV0pO1xuICAgIHJldHVybiBQb3BwZXI7XG4gIH0oKTtcblxuICAvKipcbiAgICogVGhlIGByZWZlcmVuY2VPYmplY3RgIGlzIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIGFuIGludGVyZmFjZSBjb21wYXRpYmxlIHdpdGggUG9wcGVyLmpzXG4gICAqIGFuZCBsZXRzIHlvdSB1c2UgaXQgYXMgcmVwbGFjZW1lbnQgb2YgYSByZWFsIERPTSBub2RlLjxiciAvPlxuICAgKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gICAqIGluIGNhc2UgeW91IGRvbid0IGhhdmUgYSBET00gbm9kZSB0byB1c2UgYXMgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBgYGBcbiAgICogbmV3IFBvcHBlcihyZWZlcmVuY2VPYmplY3QsIHBvcHBlck5vZGUpO1xuICAgKiBgYGBcbiAgICpcbiAgICogTkI6IFRoaXMgZmVhdHVyZSBpc24ndCBzdXBwb3J0ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAuXG4gICAqIEBuYW1lIHJlZmVyZW5jZU9iamVjdFxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkYXRhLmdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudFdpZHRoXG4gICAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgd2lkdGggb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICAgKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAgICovXG5cblxuICBQb3BwZXIuVXRpbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpLlBvcHBlclV0aWxzO1xuICBQb3BwZXIucGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG4gIFBvcHBlci5EZWZhdWx0cyA9IERlZmF1bHRzO1xuXG4gIHZhciBCdkV2ZW50ID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnZFdmVudCh0eXBlKSB7XG4gICAgICB2YXIgZXZlbnRJbml0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ2RXZlbnQpO1xuXG4gICAgICAvLyBTdGFydCBieSBlbXVsYXRpbmcgbmF0aXZlIEV2ZW50IGNvbnN0cnVjdG9yXG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1wiLmNvbmNhdCh0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIFwiJy4gMSBhcmd1bWVudCByZXF1aXJlZCwgXCIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoLCBcIiBnaXZlbi5cIikpO1xuICAgICAgfSAvLyBNZXJnZSBkZWZhdWx0cyBmaXJzdCwgdGhlIGV2ZW50SW5pdCwgYW5kIHRoZSB0eXBlIGxhc3RcbiAgICAgIC8vIHNvIGl0IGNhbid0IGJlIG92ZXJ3cml0dGVuXG5cblxuICAgICAgYXNzaWduKHRoaXMsIEJ2RXZlbnQuRGVmYXVsdHMsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdHMsIGV2ZW50SW5pdCwge1xuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9KTsgLy8gRnJlZXplIHNvbWUgcHJvcHMgYXMgcmVhZG9ubHksIGJ1dCBsZWF2ZSB0aGVtIGVudW1lcmFibGVcblxuICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgIHR5cGU6IHJlYWRvbmx5RGVzY3JpcHRvcigpLFxuICAgICAgICBjYW5jZWxhYmxlOiByZWFkb25seURlc2NyaXB0b3IoKSxcbiAgICAgICAgbmF0aXZlRXZlbnQ6IHJlYWRvbmx5RGVzY3JpcHRvcigpLFxuICAgICAgICB0YXJnZXQ6IHJlYWRvbmx5RGVzY3JpcHRvcigpLFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWFkb25seURlc2NyaXB0b3IoKSxcbiAgICAgICAgdnVlVGFyZ2V0OiByZWFkb25seURlc2NyaXB0b3IoKSxcbiAgICAgICAgY29tcG9uZW50SWQ6IHJlYWRvbmx5RGVzY3JpcHRvcigpXG4gICAgICB9KTsgLy8gQ3JlYXRlIGEgcHJpdmF0ZSB2YXJpYWJsZSB1c2luZyBjbG9zdXJlIHNjb3BpbmdcblxuICAgICAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTsgLy8gUmVjcmVhdGUgcHJldmVudERlZmF1bHQgbWV0aG9kLiBPbmUgd2F5IHNldHRlclxuXG4gICAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICBkZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTsgLy8gQ3JlYXRlIGBkZWZhdWx0UHJldmVudGVkYCBwdWJsaWNseSBhY2Nlc3NpYmxlIHByb3AgdGhhdFxuICAgICAgLy8gY2FuIG9ubHkgYmUgYWx0ZXJlZCBieSB0aGUgcHJldmVudERlZmF1bHQgbWV0aG9kXG5cblxuICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgJ2RlZmF1bHRQcmV2ZW50ZWQnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0UHJldmVudGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQnZFdmVudCwgbnVsbCwgW3tcbiAgICAgIGtleTogXCJEZWZhdWx0c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJycsXG4gICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICBuYXRpdmVFdmVudDogbnVsbCxcbiAgICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogbnVsbCxcbiAgICAgICAgICB2dWVUYXJnZXQ6IG51bGwsXG4gICAgICAgICAgY29tcG9uZW50SWQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQnZFdmVudDtcbiAgfSgpOyAvLyBOYW1lZCBFeHBvcnRzXG5cbiAgdmFyIGNsaWNrT3V0TWl4aW4gPSB7XG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpc3RlbkZvckNsaWNrT3V0OiBmYWxzZVxuICAgICAgfTtcbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICBsaXN0ZW5Gb3JDbGlja091dDogZnVuY3Rpb24gbGlzdGVuRm9yQ2xpY2tPdXQobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICBldmVudE9mZih0aGlzLmNsaWNrT3V0RWxlbWVudCwgdGhpcy5jbGlja091dEV2ZW50TmFtZSwgdGhpcy5fY2xpY2tPdXRIYW5kbGVyLCBFVkVOVF9PUFRJT05TX05PX0NBUFRVUkUpO1xuXG4gICAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBldmVudE9uKHRoaXMuY2xpY2tPdXRFbGVtZW50LCB0aGlzLmNsaWNrT3V0RXZlbnROYW1lLCB0aGlzLl9jbGlja091dEhhbmRsZXIsIEVWRU5UX09QVElPTlNfTk9fQ0FQVFVSRSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVDcmVhdGU6IGZ1bmN0aW9uIGJlZm9yZUNyZWF0ZSgpIHtcbiAgICAgIC8vIERlY2xhcmUgbm9uLXJlYWN0aXZlIHByb3BlcnRpZXNcbiAgICAgIHRoaXMuY2xpY2tPdXRFbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuY2xpY2tPdXRFdmVudE5hbWUgPSBudWxsO1xuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgIGlmICghdGhpcy5jbGlja091dEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5jbGlja091dEVsZW1lbnQgPSBkb2N1bWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmNsaWNrT3V0RXZlbnROYW1lKSB7XG4gICAgICAgIHRoaXMuY2xpY2tPdXRFdmVudE5hbWUgPSAnY2xpY2snO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5saXN0ZW5Gb3JDbGlja091dCkge1xuICAgICAgICBldmVudE9uKHRoaXMuY2xpY2tPdXRFbGVtZW50LCB0aGlzLmNsaWNrT3V0RXZlbnROYW1lLCB0aGlzLl9jbGlja091dEhhbmRsZXIsIEVWRU5UX09QVElPTlNfTk9fQ0FQVFVSRSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KClcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHtcbiAgICAgIGV2ZW50T2ZmKHRoaXMuY2xpY2tPdXRFbGVtZW50LCB0aGlzLmNsaWNrT3V0RXZlbnROYW1lLCB0aGlzLl9jbGlja091dEhhbmRsZXIsIEVWRU5UX09QVElPTlNfTk9fQ0FQVFVSRSk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBpc0NsaWNrT3V0OiBmdW5jdGlvbiBpc0NsaWNrT3V0KGV2dCkge1xuICAgICAgICByZXR1cm4gIWNvbnRhaW5zKHRoaXMuJGVsLCBldnQudGFyZ2V0KTtcbiAgICAgIH0sXG4gICAgICBfY2xpY2tPdXRIYW5kbGVyOiBmdW5jdGlvbiBfY2xpY2tPdXRIYW5kbGVyKGV2dCkge1xuICAgICAgICBpZiAodGhpcy5jbGlja091dEhhbmRsZXIgJiYgdGhpcy5pc0NsaWNrT3V0KGV2dCkpIHtcbiAgICAgICAgICB0aGlzLmNsaWNrT3V0SGFuZGxlcihldnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBmb2N1c0luTWl4aW4gPSB7XG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpc3RlbkZvckZvY3VzSW46IGZhbHNlXG4gICAgICB9O1xuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgIGxpc3RlbkZvckZvY3VzSW46IGZ1bmN0aW9uIGxpc3RlbkZvckZvY3VzSW4obmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICBldmVudE9mZih0aGlzLmZvY3VzSW5FbGVtZW50LCAnZm9jdXNpbicsIHRoaXMuX2ZvY3VzSW5IYW5kbGVyLCBFVkVOVF9PUFRJT05TX05PX0NBUFRVUkUpO1xuXG4gICAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBldmVudE9uKHRoaXMuZm9jdXNJbkVsZW1lbnQsICdmb2N1c2luJywgdGhpcy5fZm9jdXNJbkhhbmRsZXIsIEVWRU5UX09QVElPTlNfTk9fQ0FQVFVSRSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVDcmVhdGU6IGZ1bmN0aW9uIGJlZm9yZUNyZWF0ZSgpIHtcbiAgICAgIC8vIERlY2xhcmUgbm9uLXJlYWN0aXZlIHByb3BlcnRpZXNcbiAgICAgIHRoaXMuZm9jdXNJbkVsZW1lbnQgPSBudWxsO1xuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgIGlmICghdGhpcy5mb2N1c0luRWxlbWVudCkge1xuICAgICAgICB0aGlzLmZvY3VzSW5FbGVtZW50ID0gZG9jdW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmxpc3RlbkZvckZvY3VzSW4pIHtcbiAgICAgICAgZXZlbnRPbih0aGlzLmZvY3VzSW5FbGVtZW50LCAnZm9jdXNpbicsIHRoaXMuX2ZvY3VzSW5IYW5kbGVyLCBFVkVOVF9PUFRJT05TX05PX0NBUFRVUkUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB7XG4gICAgICBldmVudE9mZih0aGlzLmZvY3VzSW5FbGVtZW50LCAnZm9jdXNpbicsIHRoaXMuX2ZvY3VzSW5IYW5kbGVyLCBFVkVOVF9PUFRJT05TX05PX0NBUFRVUkUpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgX2ZvY3VzSW5IYW5kbGVyOiBmdW5jdGlvbiBfZm9jdXNJbkhhbmRsZXIoZXZ0KSB7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzSW5IYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c0luSGFuZGxlcihldnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBmaWx0ZXJWaXNpYmxlcyA9IGZ1bmN0aW9uIGZpbHRlclZpc2libGVzKGVscykge1xuICAgIHJldHVybiAoZWxzIHx8IFtdKS5maWx0ZXIoaXNWaXNpYmxlKTtcbiAgfTsgLy8gUm9vdCBkcm9wZG93biBldmVudCBuYW1lc1xuXG5cbiAgdmFyIFJPT1RfRFJPUERPV05fUFJFRklYID0gJ2J2Ojpkcm9wZG93bjo6JztcbiAgdmFyIFJPT1RfRFJPUERPV05fU0hPV04gPSBcIlwiLmNvbmNhdChST09UX0RST1BET1dOX1BSRUZJWCwgXCJzaG93blwiKTtcbiAgdmFyIFJPT1RfRFJPUERPV05fSElEREVOID0gXCJcIi5jb25jYXQoUk9PVF9EUk9QRE9XTl9QUkVGSVgsIFwiaGlkZGVuXCIpOyAvLyBEcm9wZG93biBpdGVtIENTUyBzZWxlY3RvcnNcblxuICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgRk9STV9DSElMRDogJy5kcm9wZG93biBmb3JtJyxcbiAgICBJVEVNX1NFTEVDVE9SOiBbJy5kcm9wZG93bi1pdGVtJywgJy5iLWRyb3Bkb3duLWZvcm0nXS5tYXAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQoc2VsZWN0b3IsIFwiOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKVwiKTtcbiAgICB9KS5qb2luKCcsICcpXG4gIH07IC8vIFBvcHBlciBhdHRhY2htZW50IHBvc2l0aW9uc1xuXG4gIHZhciBBdHRhY2htZW50TWFwID0ge1xuICAgIC8vIERyb3B1cCBsZWZ0IGFsaWduXG4gICAgVE9QOiAndG9wLXN0YXJ0JyxcbiAgICAvLyBEcm9wdXAgcmlnaHQgYWxpZ25cbiAgICBUT1BFTkQ6ICd0b3AtZW5kJyxcbiAgICAvLyBEcm9wZG93biBsZWZ0IGFsaWduXG4gICAgQk9UVE9NOiAnYm90dG9tLXN0YXJ0JyxcbiAgICAvLyBEcm9wZG93biByaWdodCBhbGlnblxuICAgIEJPVFRPTUVORDogJ2JvdHRvbS1lbmQnLFxuICAgIC8vIERyb3ByaWdodCBsZWZ0IGFsaWduXG4gICAgUklHSFQ6ICdyaWdodC1zdGFydCcsXG4gICAgLy8gRHJvcHJpZ2h0IHJpZ2h0IGFsaWduXG4gICAgUklHSFRFTkQ6ICdyaWdodC1lbmQnLFxuICAgIC8vIERyb3BsZWZ0IGxlZnQgYWxpZ25cbiAgICBMRUZUOiAnbGVmdC1zdGFydCcsXG4gICAgLy8gRHJvcGxlZnQgcmlnaHQgYWxpZ25cbiAgICBMRUZURU5EOiAnbGVmdC1lbmQnXG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIGRyb3Bkb3duTWl4aW4gPSB7XG4gICAgbWl4aW5zOiBbaWRNaXhpbiwgY2xpY2tPdXRNaXhpbiwgZm9jdXNJbk1peGluXSxcbiAgICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnZEcm9wZG93bjogdGhpc1xuICAgICAgfTtcbiAgICB9LFxuICAgIGluamVjdDoge1xuICAgICAgYnZOYXZiYXI6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZHJvcHVwOiB7XG4gICAgICAgIC8vIHBsYWNlIG9uIHRvcCBpZiBwb3NzaWJsZVxuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGRyb3ByaWdodDoge1xuICAgICAgICAvLyBwbGFjZSByaWdodCBpZiBwb3NzaWJsZVxuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGRyb3BsZWZ0OiB7XG4gICAgICAgIC8vIHBsYWNlIGxlZnQgaWYgcG9zc2libGVcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICByaWdodDoge1xuICAgICAgICAvLyBSaWdodCBhbGlnbiBtZW51IChkZWZhdWx0IGlzIGxlZnQgYWxpZ24pXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgb2Zmc2V0OiB7XG4gICAgICAgIC8vIE51bWJlciBvZiBwaXhlbHMgdG8gb2Zmc2V0IG1lbnUsIG9yIGEgQ1NTIHVuaXQgdmFsdWUgKGkuZS4gMXB4LCAxcmVtLCBldGMpXG4gICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgIH0sXG4gICAgICBub0ZsaXA6IHtcbiAgICAgICAgLy8gRGlzYWJsZSBhdXRvLWZsaXBwaW5nIG9mIG1lbnUgZnJvbSBib3R0b208PT50b3BcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBwb3BwZXJPcHRzOiB7XG4gICAgICAgIC8vIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fVxuICAgICAgfSxcbiAgICAgIGJvdW5kYXJ5OiB7XG4gICAgICAgIC8vIFN0cmluZzogYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgIG9yIGB2aWV3cG9ydGBcbiAgICAgICAgLy8gSFRNTEVsZW1lbnQ6IEhUTUwgRWxlbWVudCByZWZlcmVuY2VcbiAgICAgICAgdHlwZTogW1N0cmluZywgSFRNTEVsZW1lbnRdLFxuICAgICAgICBkZWZhdWx0OiAnc2Nyb2xsUGFyZW50J1xuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICB2aXNpYmxlQ2hhbmdlUHJldmVudGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBpbk5hdmJhcjogZnVuY3Rpb24gaW5OYXZiYXIoKSB7XG4gICAgICAgIHJldHVybiAhaXNOdWxsKHRoaXMuYnZOYXZiYXIpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZXI6IGZ1bmN0aW9uIHRvZ2dsZXIoKSB7XG4gICAgICAgIHZhciB0b2dnbGUgPSB0aGlzLiRyZWZzLnRvZ2dsZTtcbiAgICAgICAgcmV0dXJuIHRvZ2dsZSA/IHRvZ2dsZS4kZWwgfHwgdG9nZ2xlIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBkaXJlY3Rpb25DbGFzczogZnVuY3Rpb24gZGlyZWN0aW9uQ2xhc3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmRyb3B1cCkge1xuICAgICAgICAgIHJldHVybiAnZHJvcHVwJztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRyb3ByaWdodCkge1xuICAgICAgICAgIHJldHVybiAnZHJvcHJpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRyb3BsZWZ0KSB7XG4gICAgICAgICAgcmV0dXJuICdkcm9wbGVmdCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgdmlzaWJsZTogZnVuY3Rpb24gdmlzaWJsZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZUNoYW5nZVByZXZlbnRlZCkge1xuICAgICAgICAgIHRoaXMudmlzaWJsZUNoYW5nZVByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICB2YXIgZXZ0TmFtZSA9IG5ld1ZhbHVlID8gJ3Nob3cnIDogJ2hpZGUnO1xuICAgICAgICAgIHZhciBidkV2dCA9IG5ldyBCdkV2ZW50KGV2dE5hbWUsIHtcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICB2dWVUYXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuJHJlZnMubWVudSxcbiAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG51bGwsXG4gICAgICAgICAgICBjb21wb25lbnRJZDogdGhpcy5zYWZlSWQgPyB0aGlzLnNhZmVJZCgpIDogdGhpcy5pZCB8fCBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5lbWl0RXZlbnQoYnZFdnQpO1xuXG4gICAgICAgICAgaWYgKGJ2RXZ0LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IHZhbHVlIGFuZCBleGl0IGlmIGNhbmNlbGVkXG4gICAgICAgICAgICB0aGlzLnZpc2libGVDaGFuZ2VQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gb2xkVmFsdWU7IC8vIEp1c3QgaW4gY2FzZSBhIGNoaWxkIGVsZW1lbnQgdHJpZ2dlcmVkIGB0aGlzLmhpZGUodHJ1ZSlgXG5cbiAgICAgICAgICAgIHRoaXMuJG9mZignaGlkZGVuJywgdGhpcy5mb2N1c1RvZ2dsZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChldnROYW1lID09PSAnc2hvdycpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd01lbnUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaWRlTWVudSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc2FibGVkOiBmdW5jdGlvbiBkaXNhYmxlZChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSAmJiBuZXdWYWx1ZSAmJiB0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAvLyBIaWRlIGRyb3Bkb3duIGlmIGRpc2FibGVkIGNoYW5nZXMgdG8gdHJ1ZVxuICAgICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgLy8gQ3JlYXRlIG5vbi1yZWFjdGl2ZSBwcm9wZXJ0eVxuICAgICAgdGhpcy4kX3BvcHBlciA9IG51bGw7XG4gICAgfSxcbiAgICBkZWFjdGl2YXRlZDogZnVuY3Rpb24gZGVhY3RpdmF0ZWQoKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBub3QgZWFzeSB0byB0ZXN0ICovXG4gICAge1xuICAgICAgLy8gSW4gY2FzZSB3ZSBhcmUgaW5zaWRlIGEgYDxrZWVwLWFsaXZlPmBcbiAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy53aGlsZU9wZW5MaXN0ZW4oZmFsc2UpO1xuICAgICAgdGhpcy5kZXN0cm95UG9wcGVyKCk7XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLndoaWxlT3Blbkxpc3RlbihmYWxzZSk7XG4gICAgICB0aGlzLmRlc3Ryb3lQb3BwZXIoKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIC8vIEV2ZW50IGVtaXR0ZXJcbiAgICAgIGVtaXRFdmVudDogZnVuY3Rpb24gZW1pdEV2ZW50KGJ2RXZ0KSB7XG4gICAgICAgIHZhciB0eXBlID0gYnZFdnQudHlwZTtcbiAgICAgICAgdGhpcy4kZW1pdCh0eXBlLCBidkV2dCk7XG4gICAgICAgIHRoaXMuJHJvb3QuJGVtaXQoXCJcIi5jb25jYXQoUk9PVF9EUk9QRE9XTl9QUkVGSVgpLmNvbmNhdCh0eXBlKSwgYnZFdnQpO1xuICAgICAgfSxcbiAgICAgIHNob3dNZW51OiBmdW5jdGlvbiBzaG93TWVudSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIE9ubHkgaW5zdGFudGlhdGUgUG9wcGVyLmpzIHdoZW4gZHJvcGRvd24gaXMgbm90IGluIGA8Yi1uYXZiYXI+YFxuXG5cbiAgICAgICAgaWYgKCF0aGlzLmluTmF2YmFyKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBQb3BwZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgd2FybignUG9wcGVyLmpzIG5vdCBmb3VuZC4gRmFsbGluZyBiYWNrIHRvIENTUyBwb3NpdGlvbmluZycsICdCRHJvcGRvd24nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIGRyb3B1cCB3aXRoIGFsaWdubWVudCB3ZSB1c2UgdGhlIHBhcmVudCBlbGVtZW50IGFzIHBvcHBlciBjb250YWluZXJcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZHJvcHVwICYmIHRoaXMucmlnaHQgfHwgdGhpcy5zcGxpdCA/IHRoaXMuJGVsIDogdGhpcy4kcmVmcy50b2dnbGU7IC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgcmVmZXJlbmNlIHRvIGFuIGVsZW1lbnQsIG5vdCBhIGNvbXBvbmVudCFcblxuICAgICAgICAgICAgZWwgPSBlbC4kZWwgfHwgZWw7IC8vIEluc3RhbnRpYXRlIFBvcHBlci5qc1xuXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVBvcHBlcihlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEVuc3VyZSBvdGhlciBtZW51cyBhcmUgY2xvc2VkXG5cblxuICAgICAgICB0aGlzLiRyb290LiRlbWl0KFJPT1RfRFJPUERPV05fU0hPV04sIHRoaXMpOyAvLyBFbmFibGUgbGlzdGVuZXJzXG5cbiAgICAgICAgdGhpcy53aGlsZU9wZW5MaXN0ZW4odHJ1ZSk7IC8vIFdyYXAgaW4gYCRuZXh0VGljaygpYCB0byBlbnN1cmUgbWVudSBpcyBmdWxseSByZW5kZXJlZC9zaG93blxuXG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBGb2N1cyBvbiB0aGUgbWVudSBjb250YWluZXIgb24gc2hvd1xuICAgICAgICAgIF90aGlzLmZvY3VzTWVudSgpOyAvLyBFbWl0IHRoZSBzaG93biBldmVudFxuXG5cbiAgICAgICAgICBfdGhpcy4kZW1pdCgnc2hvd24nKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgaGlkZU1lbnU6IGZ1bmN0aW9uIGhpZGVNZW51KCkge1xuICAgICAgICB0aGlzLndoaWxlT3Blbkxpc3RlbihmYWxzZSk7XG4gICAgICAgIHRoaXMuJHJvb3QuJGVtaXQoUk9PVF9EUk9QRE9XTl9ISURERU4sIHRoaXMpO1xuICAgICAgICB0aGlzLiRlbWl0KCdoaWRkZW4nKTtcbiAgICAgICAgdGhpcy5kZXN0cm95UG9wcGVyKCk7XG4gICAgICB9LFxuICAgICAgY3JlYXRlUG9wcGVyOiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIoZWxlbWVudCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lQb3BwZXIoKTtcbiAgICAgICAgdGhpcy4kX3BvcHBlciA9IG5ldyBQb3BwZXIoZWxlbWVudCwgdGhpcy4kcmVmcy5tZW51LCB0aGlzLmdldFBvcHBlckNvbmZpZygpKTtcbiAgICAgIH0sXG4gICAgICBkZXN0cm95UG9wcGVyOiBmdW5jdGlvbiBkZXN0cm95UG9wcGVyKCkge1xuICAgICAgICAvLyBFbnN1cmUgcG9wcGVyIGV2ZW50IGxpc3RlbmVycyBhcmUgcmVtb3ZlZCBjbGVhbmx5XG4gICAgICAgIGlmICh0aGlzLiRfcG9wcGVyKSB7XG4gICAgICAgICAgdGhpcy4kX3BvcHBlci5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRfcG9wcGVyID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVQb3BwZXI6IGZ1bmN0aW9uIHVwZGF0ZVBvcHBlcigpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbm90IGVhc3kgdG8gdGVzdCAqL1xuICAgICAge1xuICAgICAgICAvLyBJbnN0cnVjdHMgcG9wcGVyIHRvIHJlLWNvbXB1dGVzIHRoZSBkcm9wZG93biBwb3NpdGlvblxuICAgICAgICAvLyB1c2VmdWxsIGlmIHRoZSBjb250ZW50IGNoYW5nZXMgc2l6ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuJF9wb3BwZXIuc2NoZWR1bGVVcGRhdGUoKTtcbiAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkge31cbiAgICAgIH0sXG4gICAgICBnZXRQb3BwZXJDb25maWc6IGZ1bmN0aW9uIGdldFBvcHBlckNvbmZpZygpIHtcbiAgICAgICAgdmFyIHBsYWNlbWVudCA9IEF0dGFjaG1lbnRNYXAuQk9UVE9NO1xuXG4gICAgICAgIGlmICh0aGlzLmRyb3B1cCkge1xuICAgICAgICAgIHBsYWNlbWVudCA9IHRoaXMucmlnaHQgPyBBdHRhY2htZW50TWFwLlRPUEVORCA6IEF0dGFjaG1lbnRNYXAuVE9QO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZHJvcHJpZ2h0KSB7XG4gICAgICAgICAgcGxhY2VtZW50ID0gQXR0YWNobWVudE1hcC5SSUdIVDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRyb3BsZWZ0KSB7XG4gICAgICAgICAgcGxhY2VtZW50ID0gQXR0YWNobWVudE1hcC5MRUZUO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmlnaHQpIHtcbiAgICAgICAgICBwbGFjZW1lbnQgPSBBdHRhY2htZW50TWFwLkJPVFRPTUVORDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3BwZXJDb25maWcgPSB7XG4gICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCB8fCAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmxpcDoge1xuICAgICAgICAgICAgICBlbmFibGVkOiAhdGhpcy5ub0ZsaXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkpIHtcbiAgICAgICAgICBwb3BwZXJDb25maWcubW9kaWZpZXJzLnByZXZlbnRPdmVyZmxvdyA9IHtcbiAgICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiB0aGlzLmJvdW5kYXJ5XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMih7fSwgcG9wcGVyQ29uZmlnLCB7fSwgdGhpcy5wb3BwZXJPcHRzIHx8IHt9KTtcbiAgICAgIH0sXG4gICAgICAvLyBUdXJuIGxpc3RlbmVycyBvbi9vZmYgd2hpbGUgb3BlblxuICAgICAgd2hpbGVPcGVuTGlzdGVuOiBmdW5jdGlvbiB3aGlsZU9wZW5MaXN0ZW4oaXNPcGVuKSB7XG4gICAgICAgIC8vIEhpZGUgdGhlIGRyb3Bkb3duIHdoZW4gY2xpY2tlZCBvdXRzaWRlXG4gICAgICAgIHRoaXMubGlzdGVuRm9yQ2xpY2tPdXQgPSBpc09wZW47IC8vIEhpZGUgdGhlIGRyb3Bkb3duIHdoZW4gaXQgbG9zZXMgZm9jdXNcblxuICAgICAgICB0aGlzLmxpc3RlbkZvckZvY3VzSW4gPSBpc09wZW47IC8vIEhpZGUgdGhlIGRyb3Bkb3duIHdoZW4gYW5vdGhlciBkcm9wZG93biBpcyBvcGVuZWRcblxuICAgICAgICB2YXIgbWV0aG9kID0gaXNPcGVuID8gJyRvbicgOiAnJG9mZic7XG4gICAgICAgIHRoaXMuJHJvb3RbbWV0aG9kXShST09UX0RST1BET1dOX1NIT1dOLCB0aGlzLnJvb3RDbG9zZUxpc3RlbmVyKTtcbiAgICAgIH0sXG4gICAgICByb290Q2xvc2VMaXN0ZW5lcjogZnVuY3Rpb24gcm9vdENsb3NlTGlzdGVuZXIodm0pIHtcbiAgICAgICAgaWYgKHZtICE9PSB0aGlzKSB7XG4gICAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAvLyBQdWJsaWMgbWV0aG9kIHRvIHNob3cgZHJvcGRvd25cbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gV3JhcCBpbiBhIGByZXF1ZXN0QUYoKWAgdG8gYWxsb3cgYW55IHByZXZpb3VzXG4gICAgICAgIC8vIGNsaWNrIGhhbmRsaW5nIHRvIG9jY3VyIGZpcnN0XG5cblxuICAgICAgICByZXF1ZXN0QUYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgICAgdmFyIHJlZm9jdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICAgIC8vIFB1YmxpYyBtZXRob2QgdG8gaGlkZSBkcm9wZG93blxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHJlZm9jdXMpIHtcbiAgICAgICAgICAvLyBDaGlsZCBlbGVtZW50IGlzIGNsb3NpbmcgdGhlIGRyb3Bkb3duIG9uIGNsaWNrXG4gICAgICAgICAgdGhpcy4kb25jZSgnaGlkZGVuJywgdGhpcy5mb2N1c1RvZ2dsZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQ2FsbGVkIG9ubHkgYnkgYSBidXR0b24gdGhhdCB0b2dnbGVzIHRoZSBtZW51XG4gICAgICB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZShldnQpIHtcbiAgICAgICAgZXZ0ID0gZXZ0IHx8IHt9OyAvLyBFYXJseSBleGl0IHdoZW4gbm90IGEgY2xpY2sgZXZlbnQgb3IgRU5URVIsIFNQQUNFIG9yIERPV04gd2VyZSBwcmVzc2VkXG5cbiAgICAgICAgdmFyIF9ldnQgPSBldnQsXG4gICAgICAgICAgICB0eXBlID0gX2V2dC50eXBlLFxuICAgICAgICAgICAga2V5Q29kZSA9IF9ldnQua2V5Q29kZTtcblxuICAgICAgICBpZiAodHlwZSAhPT0gJ2NsaWNrJyAmJiAhKHR5cGUgPT09ICdrZXlkb3duJyAmJiBbS0VZX0NPREVTLkVOVEVSLCBLRVlfQ09ERVMuU1BBQ0UsIEtFWV9DT0RFUy5ET1dOXS5pbmRleE9mKGtleUNvZGUpICE9PSAtMSkpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5cbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRlbWl0KCd0b2dnbGUnLCBldnQpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBUb2dnbGUgdmlzaWJpbGl0eVxuXG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICB0aGlzLmhpZGUodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBNb3VzZWRvd24gaGFuZGxlciBmb3IgdGhlIHRvZ2dsZVxuICAgICAgb25Nb3VzZWRvd246IGZ1bmN0aW9uIG9uTW91c2Vkb3duKGV2dClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB7XG4gICAgICAgIC8vIFdlIHByZXZlbnQgdGhlICdtb3VzZWRvd24nIGV2ZW50IGZvciB0aGUgdG9nZ2xlIHRvIHN0b3AgdGhlXG4gICAgICAgIC8vICdmb2N1c2luJyBldmVudCBmcm9tIGJlaW5nIGZpcmVkXG4gICAgICAgIC8vIFRoZSBldmVudCB3b3VsZCBvdGhlcndpc2UgYmUgcGlja2VkIHVwIGJ5IHRoZSBnbG9iYWwgJ2ZvY3VzaW4nXG4gICAgICAgIC8vIGxpc3RlbmVyIGFuZCB0aGVyZSBpcyBubyBjcm9zcy1icm93c2VyIHNvbHV0aW9uIHRvIGRldGVjdCBpdFxuICAgICAgICAvLyByZWxhdGVzIHRvIHRoZSB0b2dnbGUgY2xpY2tcbiAgICAgICAgLy8gVGhlICdjbGljaycgZXZlbnQgd2lsbCBzdGlsbCBiZSBmaXJlZCBhbmQgd2UgaGFuZGxlIGNsb3NpbmdcbiAgICAgICAgLy8gb3RoZXIgZHJvcGRvd25zIHRoZXJlIHRvb1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jvb3RzdHJhcC12dWUvYm9vdHN0cmFwLXZ1ZS9pc3N1ZXMvNDMyOFxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sXG4gICAgICAvLyBDYWxsZWQgZnJvbSBkcm9wZG93biBtZW51IGNvbnRleHRcbiAgICAgIG9uS2V5ZG93bjogZnVuY3Rpb24gb25LZXlkb3duKGV2dCkge1xuICAgICAgICB2YXIga2V5Q29kZSA9IGV2dC5rZXlDb2RlO1xuXG4gICAgICAgIGlmIChrZXlDb2RlID09PSBLRVlfQ09ERVMuRVNDKSB7XG4gICAgICAgICAgLy8gQ2xvc2Ugb24gRVNDXG4gICAgICAgICAgdGhpcy5vbkVzYyhldnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEtFWV9DT0RFUy5ET1dOKSB7XG4gICAgICAgICAgLy8gRG93biBBcnJvd1xuICAgICAgICAgIHRoaXMuZm9jdXNOZXh0KGV2dCwgZmFsc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEtFWV9DT0RFUy5VUCkge1xuICAgICAgICAgIC8vIFVwIEFycm93XG4gICAgICAgICAgdGhpcy5mb2N1c05leHQoZXZ0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIElmIHVzZXIgcHJlc3NlcyBFU0MsIGNsb3NlIHRoZSBtZW51XG4gICAgICBvbkVzYzogZnVuY3Rpb24gb25Fc2MoZXZ0KSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIFJldHVybiBmb2N1cyB0byBvcmlnaW5hbCB0cmlnZ2VyIGJ1dHRvblxuXG4gICAgICAgICAgdGhpcy4kb25jZSgnaGlkZGVuJywgdGhpcy5mb2N1c1RvZ2dsZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQ2FsbGVkIG9ubHkgaW4gc3BsaXQgYnV0dG9uIG1vZGUsIGZvciB0aGUgc3BsaXQgYnV0dG9uXG4gICAgICBvblNwbGl0Q2xpY2s6IGZ1bmN0aW9uIG9uU3BsaXRDbGljayhldnQpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2dCk7XG4gICAgICB9LFxuICAgICAgLy8gU2hhcmVkIGhpZGUgaGFuZGxlciBiZXR3ZWVuIGNsaWNrLW91dCBhbmQgZm9jdXMtaW4gZXZlbnRzXG4gICAgICBoaWRlSGFuZGxlcjogZnVuY3Rpb24gaGlkZUhhbmRsZXIoZXZ0KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBldnQudGFyZ2V0O1xuXG4gICAgICAgIGlmICh0aGlzLnZpc2libGUgJiYgIWNvbnRhaW5zKHRoaXMuJHJlZnMubWVudSwgdGFyZ2V0KSAmJiAhY29udGFpbnModGhpcy50b2dnbGVyLCB0YXJnZXQpKSB7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBEb2N1bWVudCBjbGljay1vdXQgbGlzdGVuZXJcbiAgICAgIGNsaWNrT3V0SGFuZGxlcjogZnVuY3Rpb24gY2xpY2tPdXRIYW5kbGVyKGV2dCkge1xuICAgICAgICB0aGlzLmhpZGVIYW5kbGVyKGV2dCk7XG4gICAgICB9LFxuICAgICAgLy8gRG9jdW1lbnQgZm9jdXMtaW4gbGlzdGVuZXJcbiAgICAgIGZvY3VzSW5IYW5kbGVyOiBmdW5jdGlvbiBmb2N1c0luSGFuZGxlcihldnQpIHtcbiAgICAgICAgdGhpcy5oaWRlSGFuZGxlcihldnQpO1xuICAgICAgfSxcbiAgICAgIC8vIEtleWJvYXJkIG5hdlxuICAgICAgZm9jdXNOZXh0OiBmdW5jdGlvbiBmb2N1c05leHQoZXZ0LCB1cCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAvLyBJZ25vcmUga2V5IHVwL2Rvd24gb24gZm9ybSBlbGVtZW50c1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZXZ0LnRhcmdldDtcblxuICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCBldnQgJiYgY2xvc2VzdChTZWxlY3Rvci5GT1JNX0NISUxELCB0YXJnZXQpKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNob3VsZCBuZXZlciBoYXBwZW4gKi9cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGl0ZW1zID0gX3RoaXMzLmdldEl0ZW1zKCk7XG5cbiAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNob3VsZCBuZXZlciBoYXBwZW4gKi9cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5kZXggPSBpdGVtcy5pbmRleE9mKHRhcmdldCk7XG5cbiAgICAgICAgICBpZiAodXAgJiYgaW5kZXggPiAwKSB7XG4gICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXVwICYmIGluZGV4IDwgaXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2hvdWxkIG5ldmVyIGhhcHBlbiAqL1xuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzMy5mb2N1c0l0ZW0oaW5kZXgsIGl0ZW1zKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZm9jdXNJdGVtOiBmdW5jdGlvbiBmb2N1c0l0ZW0oaWR4LCBpdGVtcykge1xuICAgICAgICB2YXIgZWwgPSBpdGVtcy5maW5kKGZ1bmN0aW9uIChlbCwgaSkge1xuICAgICAgICAgIHJldHVybiBpID09PSBpZHg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlbCAmJiBlbC5mb2N1cykge1xuICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXRJdGVtczogZnVuY3Rpb24gZ2V0SXRlbXMoKSB7XG4gICAgICAgIC8vIEdldCBhbGwgaXRlbXNcbiAgICAgICAgcmV0dXJuIGZpbHRlclZpc2libGVzKHNlbGVjdEFsbChTZWxlY3Rvci5JVEVNX1NFTEVDVE9SLCB0aGlzLiRyZWZzLm1lbnUpKTtcbiAgICAgIH0sXG4gICAgICBmb2N1c01lbnU6IGZ1bmN0aW9uIGZvY3VzTWVudSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLm1lbnUuZm9jdXMoKTtcbiAgICAgICAgfSBjYXRjaCAoX3VudXNlZDIpIHt9XG4gICAgICB9LFxuICAgICAgZm9jdXNUb2dnbGVyOiBmdW5jdGlvbiBmb2N1c1RvZ2dsZXIoKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdG9nZ2xlciA9IF90aGlzNC50b2dnbGVyO1xuXG4gICAgICAgICAgaWYgKHRvZ2dsZXIgJiYgdG9nZ2xlci5mb2N1cykge1xuICAgICAgICAgICAgdG9nZ2xlci5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBOQU1FJGIgPSAnQkRyb3Bkb3duJztcbiAgdmFyIHByb3BzJGogPSB7XG4gICAgdGV4dDoge1xuICAgICAgLy8gQnV0dG9uIGxhYmVsXG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnJ1xuICAgIH0sXG4gICAgaHRtbDoge1xuICAgICAgLy8gQnV0dG9uIGxhYmVsXG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuICAgIHNpemU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkYiwgJ3NpemUnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhcmlhbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkYiwgJ3ZhcmlhbnQnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGJsb2NrOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIG1lbnVDbGFzczoge1xuICAgICAgdHlwZTogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICB0b2dnbGVUYWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdidXR0b24nXG4gICAgfSxcbiAgICB0b2dnbGVUZXh0OiB7XG4gICAgICAvLyBUaGlzIHJlYWxseSBzaG91bGQgYmUgdG9nZ2xlTGFiZWxcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkYiwgJ3RvZ2dsZVRleHQnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvZ2dsZUNsYXNzOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIG5vQ2FyZXQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgc3BsaXQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgc3BsaXRIcmVmOiB7XG4gICAgICB0eXBlOiBTdHJpbmcgLy8gZGVmYXVsdDogdW5kZWZpbmVkXG5cbiAgICB9LFxuICAgIHNwbGl0VG86IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIE9iamVjdF0gLy8gZGVmYXVsdDogdW5kZWZpbmVkXG5cbiAgICB9LFxuICAgIHNwbGl0VmFyaWFudDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRiLCAnc3BsaXRWYXJpYW50Jyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzcGxpdENsYXNzOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIHNwbGl0QnV0dG9uVHlwZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2J1dHRvbicsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYXJyYXlJbmNsdWRlcyhbJ2J1dHRvbicsICdzdWJtaXQnLCAncmVzZXQnXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGF6eToge1xuICAgICAgLy8gSWYgdHJ1ZSwgb25seSByZW5kZXIgbWVudSBjb250ZW50cyB3aGVuIG9wZW5cbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgcm9sZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ21lbnUnXG4gICAgfVxuICB9OyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCRHJvcGRvd24gPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6IE5BTUUkYixcbiAgICBtaXhpbnM6IFtpZE1peGluLCBkcm9wZG93bk1peGluLCBub3JtYWxpemVTbG90TWl4aW5dLFxuICAgIHByb3BzOiBwcm9wcyRqLFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBkcm9wZG93bkNsYXNzZXM6IGZ1bmN0aW9uIGRyb3Bkb3duQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmRpcmVjdGlvbkNsYXNzLCB7XG4gICAgICAgICAgc2hvdzogdGhpcy52aXNpYmxlLFxuICAgICAgICAgIC8vIFRoZSAnYnRuLWdyb3VwJyBjbGFzcyBpcyByZXF1aXJlZCBpbiBgc3BsaXRgIG1vZGUgZm9yIGJ1dHRvbiBhbGlnbm1lbnRcbiAgICAgICAgICAvLyBJdCBuZWVkcyBhbHNvIHRvIGJlIGFwcGxpZWQgd2hlbiBgYmxvY2tgIGlzIGRpc2FibGVkIHRvIGFsbG93IG11bHRpcGxlXG4gICAgICAgICAgLy8gZHJvcGRvd25zIHRvIGJlIGFsaWduZWQgb25lIGxpbmVcbiAgICAgICAgICAnYnRuLWdyb3VwJzogdGhpcy5zcGxpdCB8fCAhdGhpcy5ibG9jayxcbiAgICAgICAgICAvLyBXaGVuIGBibG9ja2AgaXMgZW5hYmxlZCBhbmQgd2UgYXJlIGluIGBzcGxpdGAgbW9kZSB0aGUgJ2QtZmxleCcgY2xhc3NcbiAgICAgICAgICAvLyBuZWVkcyB0byBiZSBhcHBsaWVkIHRvIGFsbG93IHRoZSBidXR0b25zIHRvIHN0cmV0Y2ggdG8gZnVsbCB3aWR0aFxuICAgICAgICAgICdkLWZsZXgnOiB0aGlzLmJsb2NrICYmIHRoaXMuc3BsaXQsXG4gICAgICAgICAgLy8gUG9zaXRpb24gYHN0YXRpY2AgaXMgbmVlZGVkIHRvIGFsbG93IG1lbnUgdG8gXCJicmVha291dFwiIG9mIHRoZSBgc2Nyb2xsUGFyZW50YFxuICAgICAgICAgIC8vIGJvdW5kYXJpZXMgd2hlbiBib3VuZGFyeSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGBzY3JvbGxQYXJlbnRgXG4gICAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvaXNzdWVzLzI0MjUxI2lzc3VlY29tbWVudC0zNDE0MTM3ODZcbiAgICAgICAgICAncG9zaXRpb24tc3RhdGljJzogdGhpcy5ib3VuZGFyeSAhPT0gJ3Njcm9sbFBhcmVudCcgfHwgIXRoaXMuYm91bmRhcnlcbiAgICAgICAgfV07XG4gICAgICB9LFxuICAgICAgbWVudUNsYXNzZXM6IGZ1bmN0aW9uIG1lbnVDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMubWVudUNsYXNzLCB7XG4gICAgICAgICAgJ2Ryb3Bkb3duLW1lbnUtcmlnaHQnOiB0aGlzLnJpZ2h0LFxuICAgICAgICAgIHNob3c6IHRoaXMudmlzaWJsZVxuICAgICAgICB9XTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVDbGFzc2VzOiBmdW5jdGlvbiB0b2dnbGVDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMudG9nZ2xlQ2xhc3MsIHtcbiAgICAgICAgICAnZHJvcGRvd24tdG9nZ2xlLXNwbGl0JzogdGhpcy5zcGxpdCxcbiAgICAgICAgICAnZHJvcGRvd24tdG9nZ2xlLW5vLWNhcmV0JzogdGhpcy5ub0NhcmV0ICYmICF0aGlzLnNwbGl0XG4gICAgICAgIH1dO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgdmFyIHNwbGl0ID0gaCgpO1xuICAgICAgdmFyIGJ1dHRvbkNvbnRlbnQgPSB0aGlzLm5vcm1hbGl6ZVNsb3QoJ2J1dHRvbi1jb250ZW50JykgfHwgdGhpcy5odG1sIHx8IHN0cmlwVGFncyh0aGlzLnRleHQpO1xuXG4gICAgICBpZiAodGhpcy5zcGxpdCkge1xuICAgICAgICB2YXIgYnRuUHJvcHMgPSB7XG4gICAgICAgICAgdmFyaWFudDogdGhpcy5zcGxpdFZhcmlhbnQgfHwgdGhpcy52YXJpYW50LFxuICAgICAgICAgIHNpemU6IHRoaXMuc2l6ZSxcbiAgICAgICAgICBibG9jazogdGhpcy5ibG9jayxcbiAgICAgICAgICBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZFxuICAgICAgICB9OyAvLyBXZSBhZGQgdGhlc2UgYXMgbmVlZGVkIGR1ZSB0byByb3V0ZXItbGluayBpc3N1ZXMgd2l0aCBkZWZpbmVkIHByb3BlcnR5IHdpdGggdW5kZWZpbmVkL251bGwgdmFsdWVzXG5cbiAgICAgICAgaWYgKHRoaXMuc3BsaXRUbykge1xuICAgICAgICAgIGJ0blByb3BzLnRvID0gdGhpcy5zcGxpdFRvO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3BsaXRIcmVmKSB7XG4gICAgICAgICAgYnRuUHJvcHMuaHJlZiA9IHRoaXMuc3BsaXRIcmVmO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3BsaXRCdXR0b25UeXBlKSB7XG4gICAgICAgICAgYnRuUHJvcHMudHlwZSA9IHRoaXMuc3BsaXRCdXR0b25UeXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3BsaXQgPSBoKEJCdXR0b24sIHtcbiAgICAgICAgICByZWY6ICdidXR0b24nLFxuICAgICAgICAgIHByb3BzOiBidG5Qcm9wcyxcbiAgICAgICAgICBjbGFzczogdGhpcy5zcGxpdENsYXNzLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5zYWZlSWQoJ19CVl9idXR0b25fJylcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBjbGljazogdGhpcy5vblNwbGl0Q2xpY2tcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFtidXR0b25Db250ZW50XSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b2dnbGUgPSBoKEJCdXR0b24sIHtcbiAgICAgICAgcmVmOiAndG9nZ2xlJyxcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdkcm9wZG93bi10b2dnbGUnLFxuICAgICAgICBjbGFzczogdGhpcy50b2dnbGVDbGFzc2VzLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHRhZzogdGhpcy50b2dnbGVUYWcsXG4gICAgICAgICAgdmFyaWFudDogdGhpcy52YXJpYW50LFxuICAgICAgICAgIHNpemU6IHRoaXMuc2l6ZSxcbiAgICAgICAgICBibG9jazogdGhpcy5ibG9jayAmJiAhdGhpcy5zcGxpdCxcbiAgICAgICAgICBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZFxuICAgICAgICB9LFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiB0aGlzLnNhZmVJZCgnX0JWX3RvZ2dsZV8nKSxcbiAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6ICd0cnVlJyxcbiAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IHRoaXMudmlzaWJsZSA/ICd0cnVlJyA6ICdmYWxzZSdcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBtb3VzZWRvd246IHRoaXMub25Nb3VzZWRvd24sXG4gICAgICAgICAgY2xpY2s6IHRoaXMudG9nZ2xlLFxuICAgICAgICAgIGtleWRvd246IHRoaXMudG9nZ2xlIC8vIEhhbmRsZSBFTlRFUiwgU1BBQ0UgYW5kIERPV05cblxuICAgICAgICB9XG4gICAgICB9LCBbdGhpcy5zcGxpdCA/IGgoJ3NwYW4nLCB7XG4gICAgICAgIGNsYXNzOiBbJ3NyLW9ubHknXVxuICAgICAgfSwgW3RoaXMudG9nZ2xlVGV4dF0pIDogYnV0dG9uQ29udGVudF0pO1xuICAgICAgdmFyIG1lbnUgPSBoKCd1bCcsIHtcbiAgICAgICAgcmVmOiAnbWVudScsXG4gICAgICAgIHN0YXRpY0NsYXNzOiAnZHJvcGRvd24tbWVudScsXG4gICAgICAgIGNsYXNzOiB0aGlzLm1lbnVDbGFzc2VzLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHJvbGU6IHRoaXMucm9sZSxcbiAgICAgICAgICB0YWJpbmRleDogJy0xJyxcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogdGhpcy5zYWZlSWQodGhpcy5zcGxpdCA/ICdfQlZfYnV0dG9uXycgOiAnX0JWX3RvZ2dsZV8nKVxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGtleWRvd246IHRoaXMub25LZXlkb3duIC8vIEhhbmRsZSBVUCwgRE9XTiBhbmQgRVNDXG5cbiAgICAgICAgfVxuICAgICAgfSwgIXRoaXMubGF6eSB8fCB0aGlzLnZpc2libGUgPyB0aGlzLm5vcm1hbGl6ZVNsb3QoJ2RlZmF1bHQnLCB7XG4gICAgICAgIGhpZGU6IHRoaXMuaGlkZVxuICAgICAgfSkgOiBbaCgpXSk7XG4gICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2Ryb3Bkb3duIGItZHJvcGRvd24nLFxuICAgICAgICBjbGFzczogdGhpcy5kcm9wZG93bkNsYXNzZXMsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHRoaXMuc2FmZUlkKClcbiAgICAgICAgfVxuICAgICAgfSwgW3NwbGl0LCB0b2dnbGUsIG1lbnVdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwcm9wcyRrID0gcHJvcHNGYWN0b3J5KCk7IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJEcm9wZG93bkl0ZW0gPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCRHJvcGRvd25JdGVtJyxcbiAgICBtaXhpbnM6IFtub3JtYWxpemVTbG90TWl4aW5dLFxuICAgIGluaGVyaXRBdHRyczogZmFsc2UsXG4gICAgaW5qZWN0OiB7XG4gICAgICBidkRyb3Bkb3duOiB7XG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BzOiBfb2JqZWN0U3ByZWFkMih7fSwgcHJvcHMkaywge1xuICAgICAgdmFyaWFudDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH1cbiAgICB9KSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBjbG9zZURyb3Bkb3duOiBmdW5jdGlvbiBjbG9zZURyb3Bkb3duKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIC8vIENsb3NlIG9uIG5leHQgYW5pbWF0aW9uIGZyYW1lIHRvIGFsbG93IDxiLWxpbms+IHRpbWUgdG8gcHJvY2Vzc1xuICAgICAgICByZXF1ZXN0QUYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5idkRyb3Bkb3duKSB7XG4gICAgICAgICAgICBfdGhpcy5idkRyb3Bkb3duLmhpZGUodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGV2dCkge1xuICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2dCk7XG4gICAgICAgIHRoaXMuY2xvc2VEcm9wZG93bigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgcmV0dXJuIGgoJ2xpJywge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nXG4gICAgICAgIH1cbiAgICAgIH0sIFtoKEJMaW5rLCB7XG4gICAgICAgIHByb3BzOiB0aGlzLiRwcm9wcyxcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdkcm9wZG93bi1pdGVtJyxcbiAgICAgICAgY2xhc3M6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJ0ZXh0LVwiLmNvbmNhdCh0aGlzLnZhcmlhbnQpLCB0aGlzLnZhcmlhbnQgJiYgISh0aGlzLmFjdGl2ZSB8fCB0aGlzLmRpc2FibGVkKSksXG4gICAgICAgIGF0dHJzOiBfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy4kYXR0cnMsIHtcbiAgICAgICAgICByb2xlOiAnbWVudWl0ZW0nXG4gICAgICAgIH0pLFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGNsaWNrOiB0aGlzLm9uQ2xpY2tcbiAgICAgICAgfSxcbiAgICAgICAgcmVmOiAnaXRlbSdcbiAgICAgIH0sIHRoaXMubm9ybWFsaXplU2xvdCgnZGVmYXVsdCcpKV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHByb3BzJGwgPSB7XG4gICAgYWN0aXZlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGFjdGl2ZUNsYXNzOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnYWN0aXZlJ1xuICAgIH0sXG4gICAgZGlzYWJsZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgdmFyaWFudDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkRyb3Bkb3duSXRlbUJ1dHRvbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JEcm9wZG93bkl0ZW1CdXR0b24nLFxuICAgIG1peGluczogW25vcm1hbGl6ZVNsb3RNaXhpbl0sXG4gICAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgICBpbmplY3Q6IHtcbiAgICAgIGJ2RHJvcGRvd246IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcHM6IHByb3BzJGwsXG4gICAgbWV0aG9kczoge1xuICAgICAgY2xvc2VEcm9wZG93bjogZnVuY3Rpb24gY2xvc2VEcm9wZG93bigpIHtcbiAgICAgICAgaWYgKHRoaXMuYnZEcm9wZG93bikge1xuICAgICAgICAgIHRoaXMuYnZEcm9wZG93bi5oaWRlKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhldnQpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldnQpO1xuICAgICAgICB0aGlzLmNsb3NlRHJvcGRvd24oKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHZhciBfY2xhc3M7XG5cbiAgICAgIHJldHVybiBoKCdsaScsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJ1xuICAgICAgICB9XG4gICAgICB9LCBbaCgnYnV0dG9uJywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2Ryb3Bkb3duLWl0ZW0nLFxuICAgICAgICBjbGFzczogKF9jbGFzcyA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzLCB0aGlzLmFjdGl2ZUNsYXNzLCB0aGlzLmFjdGl2ZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsIFwidGV4dC1cIi5jb25jYXQodGhpcy52YXJpYW50KSwgdGhpcy52YXJpYW50ICYmICEodGhpcy5hY3RpdmUgfHwgdGhpcy5kaXNhYmxlZCkpLCBfY2xhc3MpLFxuICAgICAgICBhdHRyczogX29iamVjdFNwcmVhZDIoe30sIHRoaXMuJGF0dHJzLCB7XG4gICAgICAgICAgcm9sZTogJ21lbnVpdGVtJyxcbiAgICAgICAgICB0eXBlOiAnYnV0dG9uJyxcbiAgICAgICAgICBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZFxuICAgICAgICB9KSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBjbGljazogdGhpcy5vbkNsaWNrXG4gICAgICAgIH0sXG4gICAgICAgIHJlZjogJ2J1dHRvbidcbiAgICAgIH0sIHRoaXMubm9ybWFsaXplU2xvdCgnZGVmYXVsdCcpKV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHByb3BzJG0gPSB7XG4gICAgaWQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2hlYWRlcidcbiAgICB9LFxuICAgIHZhcmlhbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9XG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJEcm9wZG93bkhlYWRlciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JEcm9wZG93bkhlYWRlcicsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczogcHJvcHMkbSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICAgICAgdmFyICRhdHRycyA9IGRhdGEuYXR0cnMgfHwge307XG4gICAgICBkYXRhLmF0dHJzID0ge307XG4gICAgICByZXR1cm4gaCgnbGknLCBhKGRhdGEsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJ1xuICAgICAgICB9XG4gICAgICB9KSwgW2gocHJvcHMudGFnLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnZHJvcGRvd24taGVhZGVyJyxcbiAgICAgICAgY2xhc3M6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJ0ZXh0LVwiLmNvbmNhdChwcm9wcy52YXJpYW50KSwgcHJvcHMudmFyaWFudCksXG4gICAgICAgIGF0dHJzOiBfb2JqZWN0U3ByZWFkMih7fSwgJGF0dHJzLCB7XG4gICAgICAgICAgaWQ6IHByb3BzLmlkIHx8IG51bGwsXG4gICAgICAgICAgcm9sZTogJ2hlYWRpbmcnXG4gICAgICAgIH0pLFxuICAgICAgICByZWY6ICdoZWFkZXInXG4gICAgICB9LCBjaGlsZHJlbildKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwcm9wcyRuID0ge1xuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2hyJ1xuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkRyb3Bkb3duRGl2aWRlciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JEcm9wZG93bkRpdmlkZXInLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IHByb3BzJG4sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX3JlZikge1xuICAgICAgdmFyIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3JlZi5kYXRhO1xuICAgICAgdmFyICRhdHRycyA9IGRhdGEuYXR0cnMgfHwge307XG4gICAgICBkYXRhLmF0dHJzID0ge307XG4gICAgICByZXR1cm4gaCgnbGknLCBhKGRhdGEsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJ1xuICAgICAgICB9XG4gICAgICB9KSwgW2gocHJvcHMudGFnLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnZHJvcGRvd24tZGl2aWRlcicsXG4gICAgICAgIGF0dHJzOiBfb2JqZWN0U3ByZWFkMih7fSwgJGF0dHJzLCB7XG4gICAgICAgICAgcm9sZTogJ3NlcGFyYXRvcicsXG4gICAgICAgICAgJ2FyaWEtb3JpZW50YXRpb24nOiAnaG9yaXpvbnRhbCdcbiAgICAgICAgfSksXG4gICAgICAgIHJlZjogJ2RpdmlkZXInXG4gICAgICB9KV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHByb3BzJG8gPSB7XG4gICAgaWQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGlubGluZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBub3ZhbGlkYXRlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHZhbGlkYXRlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9OyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCRm9ybSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JGb3JtJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBwcm9wcyRvLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gICAgICByZXR1cm4gaCgnZm9ybScsIGEoZGF0YSwge1xuICAgICAgICBjbGFzczoge1xuICAgICAgICAgICdmb3JtLWlubGluZSc6IHByb3BzLmlubGluZSxcbiAgICAgICAgICAnd2FzLXZhbGlkYXRlZCc6IHByb3BzLnZhbGlkYXRlZFxuICAgICAgICB9LFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiBwcm9wcy5pZCxcbiAgICAgICAgICBub3ZhbGlkYXRlOiBwcm9wcy5ub3ZhbGlkYXRlXG4gICAgICAgIH1cbiAgICAgIH0pLCBjaGlsZHJlbik7XG4gICAgfVxuICB9KTtcblxuICB2YXIgQkRyb3Bkb3duRm9ybSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JEcm9wZG93bkZvcm0nLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IF9vYmplY3RTcHJlYWQyKHt9LCBwcm9wcyRvLCB7XG4gICAgICBkaXNhYmxlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGZvcm1DbGFzczoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3QsIEFycmF5XSxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfVxuICAgIH0pLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gICAgICB2YXIgJGF0dHJzID0gZGF0YS5hdHRycyB8fCB7fTtcbiAgICAgIHZhciAkbGlzdGVuZXJzID0gZGF0YS5vbiB8fCB7fTtcbiAgICAgIGRhdGEuYXR0cnMgPSB7fTtcbiAgICAgIGRhdGEub24gPSB7fTtcbiAgICAgIHJldHVybiBoKCdsaScsIGEoZGF0YSwge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nXG4gICAgICAgIH1cbiAgICAgIH0pLCBbaChCRm9ybSwge1xuICAgICAgICByZWY6ICdmb3JtJyxcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdiLWRyb3Bkb3duLWZvcm0nLFxuICAgICAgICBjbGFzczogW3Byb3BzLmZvcm1DbGFzcywge1xuICAgICAgICAgIGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZFxuICAgICAgICB9XSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBhdHRyczogX29iamVjdFNwcmVhZDIoe30sICRhdHRycywge1xuICAgICAgICAgIGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCxcbiAgICAgICAgICAvLyBUYWIgaW5kZXggb2YgLTEgZm9yIGtleWJvYXJkIG5hdmlnYXRpb25cbiAgICAgICAgICB0YWJpbmRleDogcHJvcHMuZGlzYWJsZWQgPyBudWxsIDogJy0xJ1xuICAgICAgICB9KSxcbiAgICAgICAgb246ICRsaXN0ZW5lcnNcbiAgICAgIH0sIGNoaWxkcmVuKV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIEJEcm9wZG93blRleHQgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCRHJvcGRvd25UZXh0JyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiB7XG4gICAgICB0YWc6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAncCdcbiAgICAgIH0sXG4gICAgICB2YXJpYW50OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX3JlZikge1xuICAgICAgdmFyIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgICAgIHZhciAkYXR0cnMgPSBkYXRhLmF0dHJzIHx8IHt9O1xuICAgICAgZGF0YS5hdHRycyA9IHt9O1xuICAgICAgcmV0dXJuIGgoJ2xpJywgYShkYXRhLCB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbidcbiAgICAgICAgfVxuICAgICAgfSksIFtoKHByb3BzLnRhZywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2ItZHJvcGRvd24tdGV4dCcsXG4gICAgICAgIGNsYXNzOiBfZGVmaW5lUHJvcGVydHkoe30sIFwidGV4dC1cIi5jb25jYXQocHJvcHMudmFyaWFudCksIHByb3BzLnZhcmlhbnQpLFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIGF0dHJzOiAkYXR0cnMsXG4gICAgICAgIHJlZjogJ3RleHQnXG4gICAgICB9LCBjaGlsZHJlbildKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwcm9wcyRwID0ge1xuICAgIGlkOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBoZWFkZXI6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGhlYWRlclRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2hlYWRlcidcbiAgICB9LFxuICAgIGhlYWRlclZhcmlhbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGhlYWRlckNsYXNzZXM6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgYXJpYURlc2NyaWJlZGJ5OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfVxuICB9OyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCRHJvcGRvd25Hcm91cCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JEcm9wZG93bkdyb3VwJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBwcm9wcyRwLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBzbG90cyA9IF9yZWYuc2xvdHMsXG4gICAgICAgICAgc2NvcGVkU2xvdHMgPSBfcmVmLnNjb3BlZFNsb3RzO1xuICAgICAgdmFyICRzbG90cyA9IHNsb3RzKCk7XG4gICAgICB2YXIgJHNjb3BlZFNsb3RzID0gc2NvcGVkU2xvdHMgfHwge307XG4gICAgICB2YXIgJGF0dHJzID0gZGF0YS5hdHRycyB8fCB7fTtcbiAgICAgIGRhdGEuYXR0cnMgPSB7fTtcbiAgICAgIHZhciBoZWFkZXI7XG4gICAgICB2YXIgaGVhZGVySWQgPSBudWxsO1xuXG4gICAgICBpZiAoaGFzTm9ybWFsaXplZFNsb3QoJ2hlYWRlcicsICRzY29wZWRTbG90cywgJHNsb3RzKSB8fCBwcm9wcy5oZWFkZXIpIHtcbiAgICAgICAgaGVhZGVySWQgPSBwcm9wcy5pZCA/IFwiX2J2X1wiLmNvbmNhdChwcm9wcy5pZCwgXCJfZ3JvdXBfZGRfaGVhZGVyXCIpIDogbnVsbDtcbiAgICAgICAgaGVhZGVyID0gaChwcm9wcy5oZWFkZXJUYWcsIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogJ2Ryb3Bkb3duLWhlYWRlcicsXG4gICAgICAgICAgY2xhc3M6IFtwcm9wcy5oZWFkZXJDbGFzc2VzLCBfZGVmaW5lUHJvcGVydHkoe30sIFwidGV4dC1cIi5jb25jYXQocHJvcHMudmFyaWFudCksIHByb3BzLnZhcmlhbnQpXSxcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgaWQ6IGhlYWRlcklkLFxuICAgICAgICAgICAgcm9sZTogJ2hlYWRpbmcnXG4gICAgICAgICAgfVxuICAgICAgICB9LCBub3JtYWxpemVTbG90KCdoZWFkZXInLCB7fSwgJHNjb3BlZFNsb3RzLCAkc2xvdHMpIHx8IHByb3BzLmhlYWRlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBhZGIgPSBbaGVhZGVySWQsIHByb3BzLmFyaWFEZXNjcmliZWRCeV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKS50cmltKCk7XG4gICAgICByZXR1cm4gaCgnbGknLCBhKGRhdGEsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJ1xuICAgICAgICB9XG4gICAgICB9KSwgW2hlYWRlciB8fCBoKCksIGgoJ3VsJywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2xpc3QtdW5zdHlsZWQnLFxuICAgICAgICBhdHRyczogX29iamVjdFNwcmVhZDIoe30sICRhdHRycywge1xuICAgICAgICAgIGlkOiBwcm9wcy5pZCB8fCBudWxsLFxuICAgICAgICAgIHJvbGU6ICdncm91cCcsXG4gICAgICAgICAgJ2FyaWEtZGVzY3JpYmVkYnknOiBhZGIgfHwgbnVsbFxuICAgICAgICB9KVxuICAgICAgfSwgbm9ybWFsaXplU2xvdCgnZGVmYXVsdCcsIHt9LCAkc2NvcGVkU2xvdHMsICRzbG90cykpXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgRHJvcGRvd25QbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJEcm9wZG93bjogQkRyb3Bkb3duLFxuICAgICAgQkRkOiBCRHJvcGRvd24sXG4gICAgICBCRHJvcGRvd25JdGVtOiBCRHJvcGRvd25JdGVtLFxuICAgICAgQkRkSXRlbTogQkRyb3Bkb3duSXRlbSxcbiAgICAgIEJEcm9wZG93bkl0ZW1CdXR0b246IEJEcm9wZG93bkl0ZW1CdXR0b24sXG4gICAgICBCRHJvcGRvd25JdGVtQnRuOiBCRHJvcGRvd25JdGVtQnV0dG9uLFxuICAgICAgQkRkSXRlbUJ1dHRvbjogQkRyb3Bkb3duSXRlbUJ1dHRvbixcbiAgICAgIEJEZEl0ZW1CdG46IEJEcm9wZG93bkl0ZW1CdXR0b24sXG4gICAgICBCRHJvcGRvd25IZWFkZXI6IEJEcm9wZG93bkhlYWRlcixcbiAgICAgIEJEZEhlYWRlcjogQkRyb3Bkb3duSGVhZGVyLFxuICAgICAgQkRyb3Bkb3duRGl2aWRlcjogQkRyb3Bkb3duRGl2aWRlcixcbiAgICAgIEJEZERpdmlkZXI6IEJEcm9wZG93bkRpdmlkZXIsXG4gICAgICBCRHJvcGRvd25Gb3JtOiBCRHJvcGRvd25Gb3JtLFxuICAgICAgQkRkRm9ybTogQkRyb3Bkb3duRm9ybSxcbiAgICAgIEJEcm9wZG93blRleHQ6IEJEcm9wZG93blRleHQsXG4gICAgICBCRGRUZXh0OiBCRHJvcGRvd25UZXh0LFxuICAgICAgQkRyb3Bkb3duR3JvdXA6IEJEcm9wZG93bkdyb3VwLFxuICAgICAgQkRkR3JvdXA6IEJEcm9wZG93bkdyb3VwXG4gICAgfVxuICB9KTtcblxuICB2YXIgcHJvcHMkcSA9IHtcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnaWZyYW1lJyxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHN0cikge1xuICAgICAgICByZXR1cm4gYXJyYXlJbmNsdWRlcyhbJ2lmcmFtZScsICdlbWJlZCcsICd2aWRlbycsICdvYmplY3QnLCAnaW1nJywgJ2ItaW1nJywgJ2ItaW1nLWxhenknXSwgc3RyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2RpdidcbiAgICB9LFxuICAgIGFzcGVjdDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJzE2Ynk5J1xuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkVtYmVkID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQkVtYmVkJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBwcm9wcyRxLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gICAgICByZXR1cm4gaChwcm9wcy50YWcsIHtcbiAgICAgICAgcmVmOiBkYXRhLnJlZixcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdlbWJlZC1yZXNwb25zaXZlJyxcbiAgICAgICAgY2xhc3M6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJlbWJlZC1yZXNwb25zaXZlLVwiLmNvbmNhdChwcm9wcy5hc3BlY3QpLCBwcm9wcy5hc3BlY3QpXG4gICAgICB9LCBbaChwcm9wcy50eXBlLCBhKGRhdGEsIHtcbiAgICAgICAgcmVmOiAnJyxcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdlbWJlZC1yZXNwb25zaXZlLWl0ZW0nXG4gICAgICB9KSwgY2hpbGRyZW4pXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgRW1iZWRQbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJFbWJlZDogQkVtYmVkXG4gICAgfVxuICB9KTtcblxuICB2YXIgT1BUSU9OU19PQkpFQ1RfREVQUkVDQVRFRF9NU0cgPSAnU2V0dGluZyBwcm9wIFwib3B0aW9uc1wiIHRvIGFuIG9iamVjdCBpcyBkZXByZWNhdGVkLiBVc2UgdGhlIGFycmF5IGZvcm1hdCBpbnN0ZWFkLic7IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIGZvcm1PcHRpb25zTWl4aW4gPSB7XG4gICAgcHJvcHM6IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogW0FycmF5LCBPYmplY3RdLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2YWx1ZUZpZWxkOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ3ZhbHVlJ1xuICAgICAgfSxcbiAgICAgIHRleHRGaWVsZDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICd0ZXh0J1xuICAgICAgfSxcbiAgICAgIGh0bWxGaWVsZDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICdodG1sJ1xuICAgICAgfSxcbiAgICAgIGRpc2FibGVkRmllbGQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnZGlzYWJsZWQnXG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgZm9ybU9wdGlvbnM6IGZ1bmN0aW9uIGZvcm1PcHRpb25zKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zOyAvLyBOb3JtYWxpemUgdGhlIGdpdmVuIG9wdGlvbnMgYXJyYXlcblxuICAgICAgICBpZiAoaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgIHJldHVybiBvcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubm9ybWFsaXplT3B0aW9uKG9wdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gRGVwcmVjYXRlIHRoZSBvYmplY3Qgb3B0aW9ucyBmb3JtYXRcblxuXG4gICAgICAgIHdhcm4oT1BUSU9OU19PQkpFQ1RfREVQUkVDQVRFRF9NU0csIHRoaXMuJG9wdGlvbnMubmFtZSk7IC8vIE5vcm1hbGl6ZSBhIGBvcHRpb25zYCBvYmplY3QgdG8gYW4gYXJyYXkgb2Ygb3B0aW9uc1xuXG4gICAgICAgIHJldHVybiBrZXlzKG9wdGlvbnMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm5vcm1hbGl6ZU9wdGlvbihvcHRpb25zW2tleV0gfHwge30sIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgbm9ybWFsaXplT3B0aW9uOiBmdW5jdGlvbiBub3JtYWxpemVPcHRpb24ob3B0aW9uKSB7XG4gICAgICAgIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgICAgLy8gV2hlbiB0aGUgb3B0aW9uIGlzIGFuIG9iamVjdCwgbm9ybWFsaXplIGl0XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KG9wdGlvbikpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBnZXQob3B0aW9uLCB0aGlzLnZhbHVlRmllbGQpO1xuICAgICAgICAgIHZhciB0ZXh0ID0gZ2V0KG9wdGlvbiwgdGhpcy50ZXh0RmllbGQpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogaXNVbmRlZmluZWQodmFsdWUpID8ga2V5IHx8IHRleHQgOiB2YWx1ZSxcbiAgICAgICAgICAgIHRleHQ6IHN0cmlwVGFncyhTdHJpbmcoaXNVbmRlZmluZWQodGV4dCkgPyBrZXkgOiB0ZXh0KSksXG4gICAgICAgICAgICBodG1sOiBnZXQob3B0aW9uLCB0aGlzLmh0bWxGaWVsZCksXG4gICAgICAgICAgICBkaXNhYmxlZDogQm9vbGVhbihnZXQob3B0aW9uLCB0aGlzLmRpc2FibGVkRmllbGQpKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gLy8gT3RoZXJ3aXNlIGNyZWF0ZSBhbiBgPG9wdGlvbj5gIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB2YWx1ZVxuXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZToga2V5IHx8IG9wdGlvbixcbiAgICAgICAgICB0ZXh0OiBzdHJpcFRhZ3MoU3RyaW5nKG9wdGlvbikpLFxuICAgICAgICAgIGRpc2FibGVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgQkZvcm1EYXRhbGlzdCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JGb3JtRGF0YWxpc3QnLFxuICAgIG1peGluczogW2Zvcm1PcHRpb25zTWl4aW4sIG5vcm1hbGl6ZVNsb3RNaXhpbl0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGlkOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5mb3JtT3B0aW9ucy5tYXAoZnVuY3Rpb24gKG9wdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGgoJ29wdGlvbicsIHtcbiAgICAgICAgICBrZXk6IFwib3B0aW9uX1wiLmNvbmNhdChpbmRleCwgXCJfb3B0XCIpLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBkaXNhYmxlZDogb3B0aW9uLmRpc2FibGVkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkb21Qcm9wczogX29iamVjdFNwcmVhZDIoe30sIGh0bWxPclRleHQob3B0aW9uLmh0bWwsIG9wdGlvbi50ZXh0KSwge1xuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbi52YWx1ZVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaCgnZGF0YWxpc3QnLCB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgfVxuICAgICAgfSwgW29wdGlvbnMsIHRoaXMubm9ybWFsaXplU2xvdCgnZGVmYXVsdCcpXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgTkFNRSRjID0gJ0JGb3JtVGV4dCc7XG4gIHZhciBwcm9wcyRyID0ge1xuICAgIGlkOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdzbWFsbCdcbiAgICB9LFxuICAgIHRleHRWYXJpYW50OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJGMsICd0ZXh0VmFyaWFudCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5saW5lOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJGb3JtVGV4dCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogTkFNRSRjLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IHByb3BzJHIsXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX3JlZikge1xuICAgICAgdmFyIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgICAgIHJldHVybiBoKHByb3BzLnRhZywgYShkYXRhLCB7XG4gICAgICAgIGNsYXNzOiBfZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgICdmb3JtLXRleHQnOiAhcHJvcHMuaW5saW5lXG4gICAgICAgIH0sIFwidGV4dC1cIi5jb25jYXQocHJvcHMudGV4dFZhcmlhbnQpLCBwcm9wcy50ZXh0VmFyaWFudCksXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHByb3BzLmlkXG4gICAgICAgIH1cbiAgICAgIH0pLCBjaGlsZHJlbik7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcHJvcHMkcyA9IHtcbiAgICBpZDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGl2J1xuICAgIH0sXG4gICAgdG9vbHRpcDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBmb3JjZVNob3c6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgc3RhdGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBhcmlhTGl2ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgcm9sZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkZvcm1JbnZhbGlkRmVlZGJhY2sgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCRm9ybUludmFsaWRGZWVkYmFjaycsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczogcHJvcHMkcyxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICAgICAgdmFyIHNob3cgPSBwcm9wcy5mb3JjZVNob3cgPT09IHRydWUgfHwgcHJvcHMuc3RhdGUgPT09IGZhbHNlO1xuICAgICAgcmV0dXJuIGgocHJvcHMudGFnLCBhKGRhdGEsIHtcbiAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAnaW52YWxpZC1mZWVkYmFjayc6ICFwcm9wcy50b29sdGlwLFxuICAgICAgICAgICdpbnZhbGlkLXRvb2x0aXAnOiBwcm9wcy50b29sdGlwLFxuICAgICAgICAgICdkLWJsb2NrJzogc2hvd1xuICAgICAgICB9LFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiBwcm9wcy5pZCxcbiAgICAgICAgICByb2xlOiBwcm9wcy5yb2xlLFxuICAgICAgICAgICdhcmlhLWxpdmUnOiBwcm9wcy5hcmlhTGl2ZSxcbiAgICAgICAgICAnYXJpYS1hdG9taWMnOiBwcm9wcy5hcmlhTGl2ZSA/ICd0cnVlJyA6IG51bGxcbiAgICAgICAgfVxuICAgICAgfSksIGNoaWxkcmVuKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwcm9wcyR0ID0ge1xuICAgIGlkOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdkaXYnXG4gICAgfSxcbiAgICB0b29sdGlwOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGZvcmNlU2hvdzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBzdGF0ZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGFyaWFMaXZlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICByb2xlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfVxuICB9OyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCRm9ybVZhbGlkRmVlZGJhY2sgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCRm9ybVZhbGlkRmVlZGJhY2snLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IHByb3BzJHQsXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX3JlZikge1xuICAgICAgdmFyIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgICAgIHZhciBzaG93ID0gcHJvcHMuZm9yY2VTaG93ID09PSB0cnVlIHx8IHByb3BzLnN0YXRlID09PSB0cnVlO1xuICAgICAgcmV0dXJuIGgocHJvcHMudGFnLCBhKGRhdGEsIHtcbiAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAndmFsaWQtZmVlZGJhY2snOiAhcHJvcHMudG9vbHRpcCxcbiAgICAgICAgICAndmFsaWQtdG9vbHRpcCc6IHByb3BzLnRvb2x0aXAsXG4gICAgICAgICAgJ2QtYmxvY2snOiBzaG93XG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHByb3BzLmlkLFxuICAgICAgICAgIHJvbGU6IHByb3BzLnJvbGUsXG4gICAgICAgICAgJ2FyaWEtbGl2ZSc6IHByb3BzLmFyaWFMaXZlLFxuICAgICAgICAgICdhcmlhLWF0b21pYyc6IHByb3BzLmFyaWFMaXZlID8gJ3RydWUnIDogbnVsbFxuICAgICAgICB9XG4gICAgICB9KSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHByb3BzJHUgPSB7XG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGl2J1xuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkZvcm1Sb3cgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCRm9ybVJvdycsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczogcHJvcHMkdSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICAgICAgcmV0dXJuIGgocHJvcHMudGFnLCBhKGRhdGEsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdmb3JtLXJvdydcbiAgICAgIH0pLCBjaGlsZHJlbik7XG4gICAgfVxuICB9KTtcblxuICB2YXIgRm9ybVBsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgY29tcG9uZW50czoge1xuICAgICAgQkZvcm06IEJGb3JtLFxuICAgICAgQkZvcm1EYXRhbGlzdDogQkZvcm1EYXRhbGlzdCxcbiAgICAgIEJEYXRhbGlzdDogQkZvcm1EYXRhbGlzdCxcbiAgICAgIEJGb3JtVGV4dDogQkZvcm1UZXh0LFxuICAgICAgQkZvcm1JbnZhbGlkRmVlZGJhY2s6IEJGb3JtSW52YWxpZEZlZWRiYWNrLFxuICAgICAgQkZvcm1GZWVkYmFjazogQkZvcm1JbnZhbGlkRmVlZGJhY2ssXG4gICAgICBCRm9ybVZhbGlkRmVlZGJhY2s6IEJGb3JtVmFsaWRGZWVkYmFjayxcbiAgICAgIC8vIEFkZGVkIGhlcmUgZm9yIGNvbnZlbmllbmNlXG4gICAgICBCRm9ybVJvdzogQkZvcm1Sb3dcbiAgICB9XG4gIH0pOyAvLyBCRm9ybVJvdyBpcyBub3QgZXhwb3J0ZWQgaGVyZSBhcyBhIG5hbWVkIGV4cG9ydCwgYXMgaXQgaXMgZXhwb3J0ZWQgYnkgTGF5b3V0XG5cbiAgdmFyIGxvb3NlSW5kZXhPZiA9IGZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xuICAgIC8vIEFzc3VtZXMgdGhhdCB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICB2YXIgU0VMRUNUT1IgPSAnaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QnOyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBmb3JtTWl4aW4gPSB7XG4gICAgcHJvcHM6IHtcbiAgICAgIG5hbWU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nIC8vIGRlZmF1bHQ6IHVuZGVmaW5lZFxuXG4gICAgICB9LFxuICAgICAgaWQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nIC8vIGRlZmF1bHQ6IHVuZGVmaW5lZFxuXG4gICAgICB9LFxuICAgICAgZGlzYWJsZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhblxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZm9ybToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBhdXRvZm9jdXM6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLmhhbmRsZUF1dG9mb2N1cygpO1xuICAgIH0sXG4gICAgYWN0aXZhdGVkOiBmdW5jdGlvbiBhY3RpdmF0ZWQoKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAge1xuICAgICAgdGhpcy5oYW5kbGVBdXRvZm9jdXMoKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGhhbmRsZUF1dG9mb2N1czogZnVuY3Rpb24gaGFuZGxlQXV0b2ZvY3VzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXF1ZXN0QUYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVsID0gX3RoaXMuJGVsO1xuXG4gICAgICAgICAgICBpZiAoX3RoaXMuYXV0b2ZvY3VzICYmIGlzVmlzaWJsZShlbCkpIHtcbiAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzKGVsLCBTRUxFQ1RPUikpIHtcbiAgICAgICAgICAgICAgICBlbCA9IHNlbGVjdChTRUxFQ1RPUiwgZWwpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZWwgJiYgZWwuZm9jdXMgJiYgZWwuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBmb3JtUmFkaW9DaGVja01peGluID0ge1xuICAgIG1peGluczogW25vcm1hbGl6ZVNsb3RNaXhpbl0sXG4gICAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgICBtb2RlbDoge1xuICAgICAgcHJvcDogJ2NoZWNrZWQnLFxuICAgICAgZXZlbnQ6ICdpbnB1dCdcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICB2YWx1ZTogey8vIFZhbHVlIHdoZW4gY2hlY2tlZFxuICAgICAgICAvLyB0eXBlOiBPYmplY3QsXG4gICAgICAgIC8vIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIGNoZWNrZWQ6IHsvLyBUaGlzIGlzIHRoZSB2LW1vZGVsXG4gICAgICAgIC8vIHR5cGU6IE9iamVjdCxcbiAgICAgICAgLy8gZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAgaW5saW5lOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgcGxhaW46IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBidXR0b246IHtcbiAgICAgICAgLy8gT25seSBhcHBsaWNhYmxlIGluIHN0YW5kYWxvbmUgbW9kZSAobm9uIGdyb3VwKVxuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGJ1dHRvblZhcmlhbnQ6IHtcbiAgICAgICAgLy8gT25seSBhcHBsaWNhYmxlIHdoZW4gcmVuZGVyZWQgd2l0aCBidXR0b24gc3R5bGVcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgYXJpYUxhYmVsOiB7XG4gICAgICAgIC8vIFBsYWNlZCBvbiB0aGUgaW5wdXQgaWYgcHJlc2VudC5cbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgYXJpYUxhYmVsbGVkYnk6IHtcbiAgICAgICAgLy8gUGxhY2VkIG9uIHRoZSBpbnB1dCBpZiBwcmVzZW50LlxuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbENoZWNrZWQ6IHRoaXMuaXNHcm91cCA/IHRoaXMuYnZHcm91cC5jaGVja2VkIDogdGhpcy5jaGVja2VkLFxuICAgICAgICBoYXNGb2N1czogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgY29tcHV0ZWRMb2NhbENoZWNrZWQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNHcm91cCA/IHRoaXMuYnZHcm91cC5sb2NhbENoZWNrZWQgOiB0aGlzLmxvY2FsQ2hlY2tlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNHcm91cCkge1xuICAgICAgICAgICAgdGhpcy5idkdyb3VwLmxvY2FsQ2hlY2tlZCA9IHZhbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2NhbENoZWNrZWQgPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXNHcm91cDogZnVuY3Rpb24gaXNHcm91cCgpIHtcbiAgICAgICAgLy8gSXMgdGhpcyBjaGVjay9yYWRpbyBhIGNoaWxkIG9mIGNoZWNrLWdyb3VwIG9yIHJhZGlvLWdyb3VwP1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmJ2R3JvdXApO1xuICAgICAgfSxcbiAgICAgIGlzQnRuTW9kZTogZnVuY3Rpb24gaXNCdG5Nb2RlKCkge1xuICAgICAgICAvLyBTdXBwb3J0IGJ1dHRvbiBzdHlsZSBpbiBzaW5nbGUgaW5wdXQgbW9kZVxuICAgICAgICByZXR1cm4gdGhpcy5pc0dyb3VwID8gdGhpcy5idkdyb3VwLmJ1dHRvbnMgOiB0aGlzLmJ1dHRvbjtcbiAgICAgIH0sXG4gICAgICBpc1BsYWluOiBmdW5jdGlvbiBpc1BsYWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0J0bk1vZGUgPyBmYWxzZSA6IHRoaXMuaXNHcm91cCA/IHRoaXMuYnZHcm91cC5wbGFpbiA6IHRoaXMucGxhaW47XG4gICAgICB9LFxuICAgICAgaXNDdXN0b206IGZ1bmN0aW9uIGlzQ3VzdG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0J0bk1vZGUgPyBmYWxzZSA6ICF0aGlzLmlzUGxhaW47XG4gICAgICB9LFxuICAgICAgaXNTd2l0Y2g6IGZ1bmN0aW9uIGlzU3dpdGNoKCkge1xuICAgICAgICAvLyBDdXN0b20gc3dpdGNoIHN0eWxpbmcgKGNoZWNrYm94ZXMgb25seSlcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNCdG5Nb2RlIHx8IHRoaXMuaXNSYWRpbyB8fCB0aGlzLmlzUGxhaW4gPyBmYWxzZSA6IHRoaXMuaXNHcm91cCA/IHRoaXMuYnZHcm91cC5zd2l0Y2hlcyA6IHRoaXMuc3dpdGNoO1xuICAgICAgfSxcbiAgICAgIGlzSW5saW5lOiBmdW5jdGlvbiBpc0lubGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNHcm91cCA/IHRoaXMuYnZHcm91cC5pbmxpbmUgOiB0aGlzLmlubGluZTtcbiAgICAgIH0sXG4gICAgICBpc0Rpc2FibGVkOiBmdW5jdGlvbiBpc0Rpc2FibGVkKCkge1xuICAgICAgICAvLyBDaGlsZCBjYW4gYmUgZGlzYWJsZWQgd2hpbGUgcGFyZW50IGlzbid0LCBidXQgaXMgYWx3YXlzIGRpc2FibGVkIGlmIGdyb3VwIGlzXG4gICAgICAgIHJldHVybiB0aGlzLmlzR3JvdXAgPyB0aGlzLmJ2R3JvdXAuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZCA6IHRoaXMuZGlzYWJsZWQ7XG4gICAgICB9LFxuICAgICAgaXNSZXF1aXJlZDogZnVuY3Rpb24gaXNSZXF1aXJlZCgpIHtcbiAgICAgICAgLy8gUmVxdWlyZWQgb25seSB3b3JrcyB3aGVuIGEgbmFtZSBpcyBwcm92aWRlZCBmb3IgdGhlIGlucHV0KHMpXG4gICAgICAgIC8vIENoaWxkIGNhbiBvbmx5IGJlIHJlcXVpcmVkIHdoZW4gcGFyZW50IGlzXG4gICAgICAgIC8vIEdyb3VwcyB3aWxsIGFsd2F5cyBoYXZlIGEgbmFtZSAoZWl0aGVyIHVzZXIgc3VwcGxpZWQgb3IgYXV0byBnZW5lcmF0ZWQpXG4gICAgICAgIHJldHVybiB0aGlzLmdldE5hbWUgJiYgKHRoaXMuaXNHcm91cCA/IHRoaXMuYnZHcm91cC5yZXF1aXJlZCA6IHRoaXMucmVxdWlyZWQpO1xuICAgICAgfSxcbiAgICAgIGdldE5hbWU6IGZ1bmN0aW9uIGdldE5hbWUoKSB7XG4gICAgICAgIC8vIEdyb3VwIG5hbWUgcHJlZmVycmVkIG92ZXIgbG9jYWwgbmFtZVxuICAgICAgICByZXR1cm4gKHRoaXMuaXNHcm91cCA/IHRoaXMuYnZHcm91cC5ncm91cE5hbWUgOiB0aGlzLm5hbWUpIHx8IG51bGw7XG4gICAgICB9LFxuICAgICAgZ2V0Rm9ybTogZnVuY3Rpb24gZ2V0Rm9ybSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzR3JvdXAgPyB0aGlzLmJ2R3JvdXAuZm9ybSA6IHRoaXMuZm9ybSkgfHwgbnVsbDtcbiAgICAgIH0sXG4gICAgICBnZXRTaXplOiBmdW5jdGlvbiBnZXRTaXplKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaXNHcm91cCA/IHRoaXMuYnZHcm91cC5zaXplIDogdGhpcy5zaXplKSB8fCAnJztcbiAgICAgIH0sXG4gICAgICBnZXRTdGF0ZTogZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzR3JvdXAgPyB0aGlzLmJ2R3JvdXAuY29tcHV0ZWRTdGF0ZSA6IHRoaXMuY29tcHV0ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICBnZXRCdXR0b25WYXJpYW50OiBmdW5jdGlvbiBnZXRCdXR0b25WYXJpYW50KCkge1xuICAgICAgICAvLyBMb2NhbCB2YXJpYW50IHByZWZlcnJlZCBvdmVyIGdyb3VwIHZhcmlhbnRcbiAgICAgICAgaWYgKHRoaXMuYnV0dG9uVmFyaWFudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJ1dHRvblZhcmlhbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0dyb3VwICYmIHRoaXMuYnZHcm91cC5idXR0b25WYXJpYW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYnZHcm91cC5idXR0b25WYXJpYW50O1xuICAgICAgICB9IC8vIGRlZmF1bHQgdmFyaWFudFxuXG5cbiAgICAgICAgcmV0dXJuICdzZWNvbmRhcnknO1xuICAgICAgfSxcbiAgICAgIGJ1dHRvbkNsYXNzZXM6IGZ1bmN0aW9uIGJ1dHRvbkNsYXNzZXMoKSB7XG4gICAgICAgIHZhciBfcmVmO1xuXG4gICAgICAgIC8vIFNhbWUgZm9yIHJhZGlvICYgY2hlY2tcbiAgICAgICAgcmV0dXJuIFsnYnRuJywgXCJidG4tXCIuY29uY2F0KHRoaXMuZ2V0QnV0dG9uVmFyaWFudCksIChfcmVmID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfcmVmLCBcImJ0bi1cIi5jb25jYXQodGhpcy5nZXRTaXplKSwgdGhpcy5nZXRTaXplKSwgX2RlZmluZVByb3BlcnR5KF9yZWYsIFwiZGlzYWJsZWRcIiwgdGhpcy5pc0Rpc2FibGVkKSwgX2RlZmluZVByb3BlcnR5KF9yZWYsIFwiYWN0aXZlXCIsIHRoaXMuaXNDaGVja2VkKSwgX2RlZmluZVByb3BlcnR5KF9yZWYsIFwiZm9jdXNcIiwgdGhpcy5oYXNGb2N1cyksIF9yZWYpXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICBjaGVja2VkOiBmdW5jdGlvbiBjaGVja2VkKG5ld1ZhbCkge1xuICAgICAgICB0aGlzLmNvbXB1dGVkTG9jYWxDaGVja2VkID0gbmV3VmFsO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgaGFuZGxlRm9jdXM6IGZ1bmN0aW9uIGhhbmRsZUZvY3VzKGV2dCkge1xuICAgICAgICAvLyBXaGVuIGluIGJ1dHRvbnMgbW9kZSwgd2UgbmVlZCB0byBhZGQgJ2ZvY3VzJyBjbGFzcyB0byBsYWJlbCB3aGVuIGlucHV0IGZvY3VzZWRcbiAgICAgICAgLy8gQXMgaXQgaXMgdGhlIGhpZGRlbiBpbnB1dCB3aGljaCBoYXMgYWN0dWFsIGZvY3VzXG4gICAgICAgIGlmIChldnQudGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKGV2dC50eXBlID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2dC50eXBlID09PSAnYmx1cicpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBDb252ZW5pZW5jZSBtZXRob2RzIGZvciBmb2N1c2luZyB0aGUgaW5wdXRcbiAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRGlzYWJsZWQgJiYgdGhpcy4kcmVmcy5pbnB1dCAmJiB0aGlzLiRyZWZzLmlucHV0LmZvY3VzKSB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5pbnB1dC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYmx1cjogZnVuY3Rpb24gYmx1cigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRGlzYWJsZWQgJiYgdGhpcy4kcmVmcy5pbnB1dCAmJiB0aGlzLiRyZWZzLmlucHV0LmJsdXIpIHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmlucHV0LmJsdXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgdmFyIGRlZmF1bHRTbG90ID0gdGhpcy5ub3JtYWxpemVTbG90KCdkZWZhdWx0Jyk7IC8vIEdlbmVyYXRlIHRoZSBpbnB1dCBlbGVtZW50XG5cbiAgICAgIHZhciBvbiA9IHtcbiAgICAgICAgY2hhbmdlOiB0aGlzLmhhbmRsZUNoYW5nZVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuaXNCdG5Nb2RlKSB7XG4gICAgICAgIC8vIEhhbmRsZXJzIGZvciBmb2N1cyBzdHlsaW5nIHdoZW4gaW4gYnV0dG9uIG1vZGVcbiAgICAgICAgb24uZm9jdXMgPSBvbi5ibHVyID0gdGhpcy5oYW5kbGVGb2N1cztcbiAgICAgIH1cblxuICAgICAgdmFyIGlucHV0ID0gaCgnaW5wdXQnLCB7XG4gICAgICAgIHJlZjogJ2lucHV0JyxcbiAgICAgICAga2V5OiAnaW5wdXQnLFxuICAgICAgICBvbjogb24sXG4gICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgJ2Zvcm0tY2hlY2staW5wdXQnOiB0aGlzLmlzUGxhaW4sXG4gICAgICAgICAgJ2N1c3RvbS1jb250cm9sLWlucHV0JzogdGhpcy5pc0N1c3RvbSxcbiAgICAgICAgICAnaXMtdmFsaWQnOiB0aGlzLmdldFN0YXRlID09PSB0cnVlICYmICF0aGlzLmlzQnRuTW9kZSxcbiAgICAgICAgICAnaXMtaW52YWxpZCc6IHRoaXMuZ2V0U3RhdGUgPT09IGZhbHNlICYmICF0aGlzLmlzQnRuTW9kZSxcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYm9vdHN0cmFwLXZ1ZS9ib290c3RyYXAtdnVlL2lzc3Vlcy8yOTExXG4gICAgICAgICAgJ3Bvc2l0aW9uLXN0YXRpYyc6IHRoaXMuaXNQbGFpbiAmJiAhZGVmYXVsdFNsb3RcbiAgICAgICAgfSxcbiAgICAgICAgZGlyZWN0aXZlczogW3tcbiAgICAgICAgICBuYW1lOiAnbW9kZWwnLFxuICAgICAgICAgIHJhd05hbWU6ICd2LW1vZGVsJyxcbiAgICAgICAgICB2YWx1ZTogdGhpcy5jb21wdXRlZExvY2FsQ2hlY2tlZCxcbiAgICAgICAgICBleHByZXNzaW9uOiAnY29tcHV0ZWRMb2NhbENoZWNrZWQnXG4gICAgICAgIH1dLFxuICAgICAgICBhdHRyczogX29iamVjdFNwcmVhZDIoe30sIHRoaXMuJGF0dHJzLCB7XG4gICAgICAgICAgaWQ6IHRoaXMuc2FmZUlkKCksXG4gICAgICAgICAgdHlwZTogdGhpcy5pc1JhZGlvID8gJ3JhZGlvJyA6ICdjaGVja2JveCcsXG4gICAgICAgICAgbmFtZTogdGhpcy5nZXROYW1lLFxuICAgICAgICAgIGZvcm06IHRoaXMuZ2V0Rm9ybSxcbiAgICAgICAgICBkaXNhYmxlZDogdGhpcy5pc0Rpc2FibGVkLFxuICAgICAgICAgIHJlcXVpcmVkOiB0aGlzLmlzUmVxdWlyZWQsXG4gICAgICAgICAgYXV0b2NvbXBsZXRlOiAnb2ZmJyxcbiAgICAgICAgICAnYXJpYS1yZXF1aXJlZCc6IHRoaXMuaXNSZXF1aXJlZCB8fCBudWxsLFxuICAgICAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5hcmlhTGFiZWwgfHwgbnVsbCxcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogdGhpcy5hcmlhTGFiZWxsZWRieSB8fCBudWxsXG4gICAgICAgIH0pLFxuICAgICAgICBkb21Qcm9wczoge1xuICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgIGNoZWNrZWQ6IHRoaXMuaXNDaGVja2VkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5pc0J0bk1vZGUpIHtcbiAgICAgICAgLy8gQnV0dG9uIG1vZGVcbiAgICAgICAgdmFyIGJ1dHRvbiA9IGgoJ2xhYmVsJywge1xuICAgICAgICAgIGNsYXNzOiB0aGlzLmJ1dHRvbkNsYXNzZXNcbiAgICAgICAgfSwgW2lucHV0LCBkZWZhdWx0U2xvdF0pO1xuXG4gICAgICAgIGlmICghdGhpcy5pc0dyb3VwKSB7XG4gICAgICAgICAgLy8gU3RhbmRhbG9uZSBidXR0b24gbW9kZSwgc28gd3JhcCBpbiAnYnRuLWdyb3VwLXRvZ2dsZSdcbiAgICAgICAgICAvLyBhbmQgZmxhZyBpdCBhcyBpbmxpbmUtYmxvY2sgdG8gbWltaWMgcmVndWxhciBidXR0b25zXG4gICAgICAgICAgYnV0dG9uID0gaCgnZGl2Jywge1xuICAgICAgICAgICAgY2xhc3M6IFsnYnRuLWdyb3VwLXRvZ2dsZScsICdkLWlubGluZS1ibG9jayddXG4gICAgICAgICAgfSwgW2J1dHRvbl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vdCBidXR0b24gbW9kZVxuICAgICAgICB2YXIgbGFiZWwgPSBoKCk7IC8vIElmIG5vIGxhYmVsIGNvbnRlbnQgaW4gcGxhaW4gbW9kZSB3ZSBkb250IHJlbmRlciB0aGUgbGFiZWxcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jvb3RzdHJhcC12dWUvYm9vdHN0cmFwLXZ1ZS9pc3N1ZXMvMjkxMVxuXG4gICAgICAgIGlmICghKHRoaXMuaXNQbGFpbiAmJiAhZGVmYXVsdFNsb3QpKSB7XG4gICAgICAgICAgbGFiZWwgPSBoKCdsYWJlbCcsIHtcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICdmb3JtLWNoZWNrLWxhYmVsJzogdGhpcy5pc1BsYWluLFxuICAgICAgICAgICAgICAnY3VzdG9tLWNvbnRyb2wtbGFiZWwnOiB0aGlzLmlzQ3VzdG9tXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgZm9yOiB0aGlzLnNhZmVJZCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZGVmYXVsdFNsb3QpO1xuICAgICAgICB9IC8vIFdyYXAgaXQgaW4gYSBkaXZcblxuXG4gICAgICAgIHJldHVybiBoKCdkaXYnLCB7XG4gICAgICAgICAgY2xhc3M6IF9kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICAgICAgICAnZm9ybS1jaGVjayc6IHRoaXMuaXNQbGFpbixcbiAgICAgICAgICAgICdmb3JtLWNoZWNrLWlubGluZSc6IHRoaXMuaXNQbGFpbiAmJiB0aGlzLmlzSW5saW5lLFxuICAgICAgICAgICAgJ2N1c3RvbS1jb250cm9sJzogdGhpcy5pc0N1c3RvbSxcbiAgICAgICAgICAgICdjdXN0b20tY29udHJvbC1pbmxpbmUnOiB0aGlzLmlzQ3VzdG9tICYmIHRoaXMuaXNJbmxpbmUsXG4gICAgICAgICAgICAnY3VzdG9tLWNoZWNrYm94JzogdGhpcy5pc0N1c3RvbSAmJiB0aGlzLmlzQ2hlY2sgJiYgIXRoaXMuaXNTd2l0Y2gsXG4gICAgICAgICAgICAnY3VzdG9tLXN3aXRjaCc6IHRoaXMuaXNTd2l0Y2gsXG4gICAgICAgICAgICAnY3VzdG9tLXJhZGlvJzogdGhpcy5pc0N1c3RvbSAmJiB0aGlzLmlzUmFkaW9cbiAgICAgICAgICB9LCBcImItY3VzdG9tLWNvbnRyb2wtXCIuY29uY2F0KHRoaXMuZ2V0U2l6ZSksIEJvb2xlYW4odGhpcy5nZXRTaXplICYmICF0aGlzLmlzQnRuTW9kZSkpXG4gICAgICAgIH0sIFtpbnB1dCwgbGFiZWxdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGZvcm1TaXplTWl4aW4gPSB7XG4gICAgcHJvcHM6IHtcbiAgICAgIHNpemU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKCdmb3JtQ29udHJvbHMnLCAnc2l6ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgc2l6ZUZvcm1DbGFzczogZnVuY3Rpb24gc2l6ZUZvcm1DbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnNpemUgPyBcImZvcm0tY29udHJvbC1cIi5jb25jYXQodGhpcy5zaXplKSA6IG51bGxdO1xuICAgICAgfSxcbiAgICAgIHNpemVCdG5DbGFzczogZnVuY3Rpb24gc2l6ZUJ0bkNsYXNzKClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkb24ndCB0aGluayB0aGlzIGlzIHVzZWQgKi9cbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnNpemUgPyBcImJ0bi1cIi5jb25jYXQodGhpcy5zaXplKSA6IG51bGxdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKiBGb3JtIGNvbnRyb2wgY29udGV4dHVhbCBzdGF0ZSBjbGFzcyBjb21wdXRhdGlvblxuICAgKlxuICAgKiBSZXR1cm5lZCBjbGFzcyBpcyBlaXRoZXIgJ2lzLXZhbGlkJyBvciAnaXMtaW52YWxpZCcgYmFzZWQgb24gdGhlICdzdGF0ZScgcHJvcFxuICAgKiBzdGF0ZSBjYW4gYmUgb25lIG9mIGZpdmUgdmFsdWVzOlxuICAgKiAgLSB0cnVlIGZvciBpcy12YWxpZFxuICAgKiAgLSBmYWxzZSBmb3IgaXMtaW52YWxpZFxuICAgKiAgLSBudWxsIGZvciBubyBjb250ZXh0dWFsIHN0YXRlXG4gICAqL1xuXG4gIHZhciBmb3JtU3RhdGVNaXhpbiA9IHtcbiAgICBwcm9wczoge1xuICAgICAgc3RhdGU6IHtcbiAgICAgICAgLy8gVHJpLXN0YXRlIHByb3A6IHRydWUsIGZhbHNlLCBudWxsIChvciB1bmRlZmluZWQpXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBjb21wdXRlZFN0YXRlOiBmdW5jdGlvbiBjb21wdXRlZFN0YXRlKCkge1xuICAgICAgICAvLyBJZiBub3QgYSBib29sZWFuLCBlbnN1cmUgdGhhdCB2YWx1ZSBpcyBudWxsXG4gICAgICAgIHJldHVybiBpc0Jvb2xlYW4odGhpcy5zdGF0ZSkgPyB0aGlzLnN0YXRlIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBzdGF0ZUNsYXNzOiBmdW5jdGlvbiBzdGF0ZUNsYXNzKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmNvbXB1dGVkU3RhdGU7XG4gICAgICAgIHJldHVybiBzdGF0ZSA9PT0gdHJ1ZSA/ICdpcy12YWxpZCcgOiBzdGF0ZSA9PT0gZmFsc2UgPyAnaXMtaW52YWxpZCcgOiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgQkZvcm1DaGVja2JveCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JGb3JtQ2hlY2tib3gnLFxuICAgIG1peGluczogW2Zvcm1SYWRpb0NoZWNrTWl4aW4sIC8vIEluY2x1ZGVzIHNoYXJlZCByZW5kZXIgZnVuY3Rpb25cbiAgICBpZE1peGluLCBmb3JtTWl4aW4sIGZvcm1TaXplTWl4aW4sIGZvcm1TdGF0ZU1peGluXSxcbiAgICBpbmplY3Q6IHtcbiAgICAgIGJ2R3JvdXA6IHtcbiAgICAgICAgZnJvbTogJ2J2Q2hlY2tHcm91cCcsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgLy8gdHlwZTogW1N0cmluZywgTnVtYmVyLCBCb29sZWFuLCBPYmplY3RdLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9LFxuICAgICAgdW5jaGVja2VkVmFsdWU6IHtcbiAgICAgICAgLy8gdHlwZTogW1N0cmluZywgTnVtYmVyLCBCb29sZWFuLCBPYmplY3RdLFxuICAgICAgICAvLyBOb3QgYXBwbGljYWJsZSBpbiBtdWx0aS1jaGVjayBtb2RlXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgaW5kZXRlcm1pbmF0ZToge1xuICAgICAgICAvLyBOb3QgYXBwbGljYWJsZSBpbiBtdWx0aS1jaGVjayBtb2RlXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc3dpdGNoOiB7XG4gICAgICAgIC8vIEN1c3RvbSBzd2l0Y2ggc3R5bGluZ1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGNoZWNrZWQ6IHtcbiAgICAgICAgLy8gdi1tb2RlbCAoQXJyYXkgd2hlbiBtdWx0aXBsZSBjaGVja2JveGVzIGhhdmUgc2FtZSBuYW1lKVxuICAgICAgICAvLyB0eXBlOiBbU3RyaW5nLCBOdW1iZXIsIEJvb2xlYW4sIE9iamVjdCwgQXJyYXldLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgaXNDaGVja2VkOiBmdW5jdGlvbiBpc0NoZWNrZWQoKSB7XG4gICAgICAgIHZhciBjaGVja2VkID0gdGhpcy5jb21wdXRlZExvY2FsQ2hlY2tlZDtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcblxuICAgICAgICBpZiAoaXNBcnJheShjaGVja2VkKSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUluZGV4T2YoY2hlY2tlZCwgdmFsdWUpID4gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoY2hlY2tlZCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXNSYWRpbzogZnVuY3Rpb24gaXNSYWRpbygpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGlzQ2hlY2s6IGZ1bmN0aW9uIGlzQ2hlY2soKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgIGNvbXB1dGVkTG9jYWxDaGVja2VkOiBmdW5jdGlvbiBjb21wdXRlZExvY2FsQ2hlY2tlZChuZXdWYWwpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBuZXdWYWwpO1xuXG4gICAgICAgIGlmICh0aGlzLiRyZWZzICYmIHRoaXMuJHJlZnMuaW5wdXQpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6aW5kZXRlcm1pbmF0ZScsIHRoaXMuJHJlZnMuaW5wdXQuaW5kZXRlcm1pbmF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbmRldGVybWluYXRlOiBmdW5jdGlvbiBpbmRldGVybWluYXRlKG5ld1ZhbCkge1xuICAgICAgICB0aGlzLnNldEluZGV0ZXJtaW5hdGUobmV3VmFsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAvLyBTZXQgaW5pdGlhbCBpbmRldGVybWluYXRlIHN0YXRlXG4gICAgICB0aGlzLnNldEluZGV0ZXJtaW5hdGUodGhpcy5pbmRldGVybWluYXRlKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKF9yZWYpIHtcbiAgICAgICAgdmFyIF9yZWYkdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICAgICAgICBjaGVja2VkID0gX3JlZiR0YXJnZXQuY2hlY2tlZCxcbiAgICAgICAgICAgIGluZGV0ZXJtaW5hdGUgPSBfcmVmJHRhcmdldC5pbmRldGVybWluYXRlO1xuICAgICAgICB2YXIgbG9jYWxDaGVja2VkID0gdGhpcy5jb21wdXRlZExvY2FsQ2hlY2tlZDtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShsb2NhbENoZWNrZWQpO1xuICAgICAgICB2YXIgdW5jaGVja2VkVmFsdWUgPSBpc0FyciA/IG51bGwgOiB0aGlzLnVuY2hlY2tlZFZhbHVlOyAvLyBVcGRhdGUgY29tcHV0ZWRMb2NhbENoZWNrZWRcblxuICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICB2YXIgaWR4ID0gbG9vc2VJbmRleE9mKGxvY2FsQ2hlY2tlZCwgdmFsdWUpO1xuXG4gICAgICAgICAgaWYgKGNoZWNrZWQgJiYgaWR4IDwgMCkge1xuICAgICAgICAgICAgLy8gQWRkIHZhbHVlIHRvIGFycmF5XG4gICAgICAgICAgICBsb2NhbENoZWNrZWQgPSBsb2NhbENoZWNrZWQuY29uY2F0KHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjaGVja2VkICYmIGlkeCA+IC0xKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdmFsdWUgZnJvbSBhcnJheVxuICAgICAgICAgICAgbG9jYWxDaGVja2VkID0gbG9jYWxDaGVja2VkLnNsaWNlKDAsIGlkeCkuY29uY2F0KGxvY2FsQ2hlY2tlZC5zbGljZShpZHggKyAxKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvY2FsQ2hlY2tlZCA9IGNoZWNrZWQgPyB2YWx1ZSA6IHVuY2hlY2tlZFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21wdXRlZExvY2FsQ2hlY2tlZCA9IGxvY2FsQ2hlY2tlZDsgLy8gQ2hhbmdlIGlzIG9ubHkgZW1pdHRlZCBvbiB1c2VyIGludGVyYWN0aW9uXG5cbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgY2hlY2tlZCA/IHZhbHVlIDogdW5jaGVja2VkVmFsdWUpOyAvLyBJZiB0aGlzIGlzIGEgY2hpbGQgb2YgZm9ybS1jaGVja2JveC1ncm91cCwgd2UgZW1pdCBhIGNoYW5nZSBldmVudCBvbiBpdCBhcyB3ZWxsXG5cbiAgICAgICAgaWYgKHRoaXMuaXNHcm91cCkge1xuICAgICAgICAgIHRoaXMuYnZHcm91cC4kZW1pdCgnY2hhbmdlJywgbG9jYWxDaGVja2VkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTppbmRldGVybWluYXRlJywgaW5kZXRlcm1pbmF0ZSk7XG4gICAgICB9LFxuICAgICAgc2V0SW5kZXRlcm1pbmF0ZTogZnVuY3Rpb24gc2V0SW5kZXRlcm1pbmF0ZShzdGF0ZSkge1xuICAgICAgICAvLyBJbmRldGVybWluYXRlIG9ubHkgc3VwcG9ydGVkIGluIHNpbmdsZSBjaGVja2JveCBtb2RlXG4gICAgICAgIGlmIChpc0FycmF5KHRoaXMuY29tcHV0ZWRMb2NhbENoZWNrZWQpKSB7XG4gICAgICAgICAgc3RhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLiRyZWZzICYmIHRoaXMuJHJlZnMuaW5wdXQpIHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmlucHV0LmluZGV0ZXJtaW5hdGUgPSBzdGF0ZTsgLy8gRW1pdCB1cGRhdGUgZXZlbnQgdG8gcHJvcFxuXG4gICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOmluZGV0ZXJtaW5hdGUnLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBCRm9ybVJhZGlvID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQkZvcm1SYWRpbycsXG4gICAgbWl4aW5zOiBbaWRNaXhpbiwgZm9ybVJhZGlvQ2hlY2tNaXhpbiwgLy8gSW5jbHVkZXMgc2hhcmVkIHJlbmRlciBmdW5jdGlvblxuICAgIGZvcm1NaXhpbiwgZm9ybVNpemVNaXhpbiwgZm9ybVN0YXRlTWl4aW5dLFxuICAgIGluamVjdDoge1xuICAgICAgYnZHcm91cDoge1xuICAgICAgICBmcm9tOiAnYnZSYWRpb0dyb3VwJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBjaGVja2VkOiB7XG4gICAgICAgIC8vIHYtbW9kZWxcbiAgICAgICAgLy8gdHlwZTogW1N0cmluZywgTnVtYmVyLCBCb29sZWFuLCBPYmplY3RdLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgLy8gUmFkaW8gR3JvdXBzIGNhbiBvbmx5IGhhdmUgYSBzaW5nbGUgdmFsdWUsIHNvIGRldGVybWluaW5nIGlmIGNoZWNrZWQgaXMgc2ltcGxlXG4gICAgICBpc0NoZWNrZWQ6IGZ1bmN0aW9uIGlzQ2hlY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwodGhpcy52YWx1ZSwgdGhpcy5jb21wdXRlZExvY2FsQ2hlY2tlZCk7XG4gICAgICB9LFxuICAgICAgLy8gRmxhZ3MgZm9yIGZvcm0tcmFkaW8tY2hlY2sgbWl4aW5cbiAgICAgIGlzUmFkaW86IGZ1bmN0aW9uIGlzUmFkaW8oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGlzQ2hlY2s6IGZ1bmN0aW9uIGlzQ2hlY2soKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAvLyBSYWRpbyBHcm91cHMgY2FuIG9ubHkgaGF2ZSBhIHNpbmdsZSB2YWx1ZSwgc28gb3VyIHdhdGNoZXJzIGFyZSBzaW1wbGVcbiAgICAgIGNvbXB1dGVkTG9jYWxDaGVja2VkOiBmdW5jdGlvbiBjb21wdXRlZExvY2FsQ2hlY2tlZCgpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB0aGlzLmNvbXB1dGVkTG9jYWxDaGVja2VkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKF9yZWYpIHtcbiAgICAgICAgdmFyIGNoZWNrZWQgPSBfcmVmLnRhcmdldC5jaGVja2VkO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLmNvbXB1dGVkTG9jYWxDaGVja2VkID0gdmFsdWU7IC8vIENoYW5nZSBpcyBvbmx5IGVtaXR0ZWQgb24gdXNlciBpbnRlcmFjdGlvblxuXG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGNoZWNrZWQgPyB2YWx1ZSA6IG51bGwpOyAvLyBJZiB0aGlzIGlzIGEgY2hpbGQgb2YgZm9ybS1yYWRpby1ncm91cCwgd2UgZW1pdCBhIGNoYW5nZSBldmVudCBvbiBpdCBhcyB3ZWxsXG5cbiAgICAgICAgaWYgKHRoaXMuaXNHcm91cCkge1xuICAgICAgICAgIHRoaXMuYnZHcm91cC4kZW1pdCgnY2hhbmdlJywgY2hlY2tlZCA/IHZhbHVlIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBmb3JtUmFkaW9DaGVja0dyb3VwTWl4aW4gPSB7XG4gICAgbWl4aW5zOiBbbm9ybWFsaXplU2xvdE1peGluXSxcbiAgICBtb2RlbDoge1xuICAgICAgcHJvcDogJ2NoZWNrZWQnLFxuICAgICAgZXZlbnQ6ICdpbnB1dCdcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICB2YWxpZGF0ZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBhcmlhSW52YWxpZDoge1xuICAgICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzdGFja2VkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgcGxhaW46IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBidXR0b25zOiB7XG4gICAgICAgIC8vIFJlbmRlciBhcyBidXR0b24gc3R5bGVcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBidXR0b25WYXJpYW50OiB7XG4gICAgICAgIC8vIE9ubHkgYXBwbGljYWJsZSB3aGVuIHJlbmRlcmVkIHdpdGggYnV0dG9uIHN0eWxlXG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ3NlY29uZGFyeSdcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBpbmxpbmU6IGZ1bmN0aW9uIGlubGluZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnN0YWNrZWQ7XG4gICAgICB9LFxuICAgICAgZ3JvdXBOYW1lOiBmdW5jdGlvbiBncm91cE5hbWUoKSB7XG4gICAgICAgIC8vIENoZWNrcy9SYWRpb3MgdGllZCB0byB0aGUgc2FtZSBtb2RlbCBtdXN0IGhhdmUgdGhlIHNhbWUgbmFtZSxcbiAgICAgICAgLy8gZXNwZWNpYWxseSBmb3IgQVJJQSBhY2Nlc3NpYmlsaXR5LlxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lIHx8IHRoaXMuc2FmZUlkKCk7XG4gICAgICB9LFxuICAgICAgZ3JvdXBDbGFzc2VzOiBmdW5jdGlvbiBncm91cENsYXNzZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1dHRvbnMpIHtcbiAgICAgICAgICByZXR1cm4gWydidG4tZ3JvdXAtdG9nZ2xlJywgdGhpcy5pbmxpbmUgPyAnYnRuLWdyb3VwJyA6ICdidG4tZ3JvdXAtdmVydGljYWwnLCB0aGlzLnNpemUgPyBcImJ0bi1ncm91cC1cIi5jb25jYXQodGhpcy5zaXplKSA6ICcnLCB0aGlzLnZhbGlkYXRlZCA/IFwid2FzLXZhbGlkYXRlZFwiIDogJyddO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt0aGlzLnZhbGlkYXRlZCA/IFwid2FzLXZhbGlkYXRlZFwiIDogJyddO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkQXJpYUludmFsaWQ6IGZ1bmN0aW9uIGNvbXB1dGVkQXJpYUludmFsaWQoKSB7XG4gICAgICAgIHZhciBhcmlhSW52YWxpZCA9IHRoaXMuYXJpYUludmFsaWQ7XG5cbiAgICAgICAgaWYgKGFyaWFJbnZhbGlkID09PSB0cnVlIHx8IGFyaWFJbnZhbGlkID09PSAndHJ1ZScgfHwgYXJpYUludmFsaWQgPT09ICcnKSB7XG4gICAgICAgICAgcmV0dXJuICd0cnVlJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVkU3RhdGUgPT09IGZhbHNlID8gJ3RydWUnIDogbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICBjaGVja2VkOiBmdW5jdGlvbiBjaGVja2VkKG5ld1ZhbCkge1xuICAgICAgICB0aGlzLmxvY2FsQ2hlY2tlZCA9IG5ld1ZhbDtcbiAgICAgIH0sXG4gICAgICBsb2NhbENoZWNrZWQ6IGZ1bmN0aW9uIGxvY2FsQ2hlY2tlZChuZXdWYWwpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBuZXdWYWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGlucHV0cyA9IHRoaXMuZm9ybU9wdGlvbnMubWFwKGZ1bmN0aW9uIChvcHRpb24sIGlkeCkge1xuICAgICAgICB2YXIgdWlkID0gXCJfQlZfb3B0aW9uX1wiLmNvbmNhdChpZHgsIFwiX1wiKTtcbiAgICAgICAgcmV0dXJuIGgoX3RoaXMuaXNSYWRpb0dyb3VwID8gQkZvcm1SYWRpbyA6IEJGb3JtQ2hlY2tib3gsIHtcbiAgICAgICAgICBrZXk6IHVpZCxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaWQ6IF90aGlzLnNhZmVJZCh1aWQpLFxuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbi52YWx1ZSxcbiAgICAgICAgICAgIC8vIEluZGl2aWR1YWwgcmFkaW9zIG9yIGNoZWNrcyBjYW4gYmUgZGlzYWJsZWQgaW4gYSBncm91cFxuICAgICAgICAgICAgZGlzYWJsZWQ6IG9wdGlvbi5kaXNhYmxlZCB8fCBmYWxzZSAvLyBXZSBkb24ndCBuZWVkIHRvIGluY2x1ZGUgdGhlc2UsIHNpbmNlIHRoZSBpbnB1dCdzIHdpbGwga25vdyB0aGV5IGFyZSBpbnNpZGUgaGVyZVxuICAgICAgICAgICAgLy8gbmFtZTogdGhpcy5ncm91cE5hbWUsXG4gICAgICAgICAgICAvLyBmb3JtOiB0aGlzLmZvcm0gfHwgbnVsbCxcbiAgICAgICAgICAgIC8vIHJlcXVpcmVkOiBCb29sZWFuKHRoaXMubmFtZSAmJiB0aGlzLnJlcXVpcmVkKVxuXG4gICAgICAgICAgfVxuICAgICAgICB9LCBbaCgnc3BhbicsIHtcbiAgICAgICAgICBkb21Qcm9wczogaHRtbE9yVGV4dChvcHRpb24uaHRtbCwgb3B0aW9uLnRleHQpXG4gICAgICAgIH0pXSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBoKCdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiBbdGhpcy5ncm91cENsYXNzZXMsICdidi1uby1mb2N1cy1yaW5nJ10sXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHRoaXMuc2FmZUlkKCksXG4gICAgICAgICAgcm9sZTogdGhpcy5pc1JhZGlvR3JvdXAgPyAncmFkaW9ncm91cCcgOiAnZ3JvdXAnLFxuICAgICAgICAgIC8vIFRhYmluZGV4IHRvIGFsbG93IGdyb3VwIHRvIGJlIGZvY3VzZWRcbiAgICAgICAgICAvLyBpZiBuZWVkZWQgYnkgc2NyZWVuIHJlYWRlcnNcbiAgICAgICAgICB0YWJpbmRleDogJy0xJyxcbiAgICAgICAgICAnYXJpYS1yZXF1aXJlZCc6IHRoaXMucmVxdWlyZWQgPyAndHJ1ZScgOiBudWxsLFxuICAgICAgICAgICdhcmlhLWludmFsaWQnOiB0aGlzLmNvbXB1dGVkQXJpYUludmFsaWRcbiAgICAgICAgfVxuICAgICAgfSwgW3RoaXMubm9ybWFsaXplU2xvdCgnZmlyc3QnKSwgaW5wdXRzLCB0aGlzLm5vcm1hbGl6ZVNsb3QoJ2RlZmF1bHQnKV0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcHJvcHMkdiA9IHtcbiAgICBzd2l0Y2hlczoge1xuICAgICAgLy8gQ3VzdG9tIHN3aXRjaCBzdHlsaW5nXG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGNoZWNrZWQ6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkZvcm1DaGVja2JveEdyb3VwID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQkZvcm1DaGVja2JveEdyb3VwJyxcbiAgICBtaXhpbnM6IFtpZE1peGluLCBmb3JtTWl4aW4sIGZvcm1SYWRpb0NoZWNrR3JvdXBNaXhpbiwgLy8gSW5jbHVkZXMgcmVuZGVyIGZ1bmN0aW9uXG4gICAgZm9ybU9wdGlvbnNNaXhpbiwgZm9ybVNpemVNaXhpbiwgZm9ybVN0YXRlTWl4aW5dLFxuICAgIHByb3ZpZGU6IGZ1bmN0aW9uIHByb3ZpZGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBidkNoZWNrR3JvdXA6IHRoaXNcbiAgICAgIH07XG4gICAgfSxcbiAgICBwcm9wczogcHJvcHMkdixcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbG9jYWxDaGVja2VkOiB0aGlzLmNoZWNrZWQgfHwgW11cbiAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgaXNSYWRpb0dyb3VwOiBmdW5jdGlvbiBpc1JhZGlvR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBGb3JtQ2hlY2tib3hQbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJGb3JtQ2hlY2tib3g6IEJGb3JtQ2hlY2tib3gsXG4gICAgICBCQ2hlY2tib3g6IEJGb3JtQ2hlY2tib3gsXG4gICAgICBCQ2hlY2s6IEJGb3JtQ2hlY2tib3gsXG4gICAgICBCRm9ybUNoZWNrYm94R3JvdXA6IEJGb3JtQ2hlY2tib3hHcm91cCxcbiAgICAgIEJDaGVja2JveEdyb3VwOiBCRm9ybUNoZWNrYm94R3JvdXAsXG4gICAgICBCQ2hlY2tHcm91cDogQkZvcm1DaGVja2JveEdyb3VwXG4gICAgfVxuICB9KTtcblxuICAvLyB2LWItaG92ZXIgZGlyZWN0aXZlXG5cbiAgdmFyIFBST1AgPSAnX19CVl9ob3Zlcl9oYW5kbGVyX18nO1xuICB2YXIgTU9VU0VFTlRFUiA9ICdtb3VzZWVudGVyJztcbiAgdmFyIE1PVVNFTEVBVkUgPSAnbW91c2VsZWF2ZSc7IC8vIC0tLSBVdGlsaXR5IG1ldGhvZHMgLS0tXG5cbiAgdmFyIGNyZWF0ZUxpc3RlbmVyID0gZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXIoaGFuZGxlcikge1xuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKGV2dCkge1xuICAgICAgaGFuZGxlcihldnQudHlwZSA9PT0gTU9VU0VFTlRFUiwgZXZ0KTtcbiAgICB9O1xuXG4gICAgbGlzdGVuZXIuZm4gPSBoYW5kbGVyO1xuICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgfTtcblxuICB2YXIgdXBkYXRlTGlzdGVuZXJzID0gZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzKG9uLCBlbCwgbGlzdGVuZXIpIHtcbiAgICBldmVudE9uT2ZmKG9uLCBlbCwgTU9VU0VFTlRFUiwgbGlzdGVuZXIsIEVWRU5UX09QVElPTlNfTk9fQ0FQVFVSRSk7XG4gICAgZXZlbnRPbk9mZihvbiwgZWwsIE1PVVNFTEVBVkUsIGxpc3RlbmVyLCBFVkVOVF9PUFRJT05TX05PX0NBUFRVUkUpO1xuICB9OyAvLyAtLS0gRGlyZWN0aXZlIGJpbmQvdW5iaW5kL3VwZGF0ZSBoYW5kbGVyIC0tLVxuXG5cbiAgdmFyIGRpcmVjdGl2ZSA9IGZ1bmN0aW9uIGRpcmVjdGl2ZShlbCwgX3JlZikge1xuICAgIHZhciBfcmVmJHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgICAgaGFuZGxlciA9IF9yZWYkdmFsdWUgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmJHZhbHVlO1xuXG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgdmFyIGxpc3RlbmVyID0gZWxbUFJPUF07XG4gICAgICB2YXIgaGFzTGlzdGVuZXIgPSBpc0Z1bmN0aW9uKGxpc3RlbmVyKTtcbiAgICAgIHZhciBoYW5kbGVyQ2hhbmdlZCA9ICEoaGFzTGlzdGVuZXIgJiYgbGlzdGVuZXIuZm4gPT09IGhhbmRsZXIpO1xuXG4gICAgICBpZiAoaGFzTGlzdGVuZXIgJiYgaGFuZGxlckNoYW5nZWQpIHtcbiAgICAgICAgdXBkYXRlTGlzdGVuZXJzKGZhbHNlLCBlbCwgbGlzdGVuZXIpO1xuICAgICAgICBkZWxldGUgZWxbUFJPUF07XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpICYmIGhhbmRsZXJDaGFuZ2VkKSB7XG4gICAgICAgIGVsW1BST1BdID0gY3JlYXRlTGlzdGVuZXIoaGFuZGxlcik7XG4gICAgICAgIHVwZGF0ZUxpc3RlbmVycyh0cnVlLCBlbCwgZWxbUFJPUF0pO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gVkJIb3ZlciBkaXJlY3RpdmVcblxuXG4gIHZhciBWQkhvdmVyID0ge1xuICAgIGJpbmQ6IGRpcmVjdGl2ZSxcbiAgICBjb21wb25lbnRVcGRhdGVkOiBkaXJlY3RpdmUsXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoZWwpIHtcbiAgICAgIGRpcmVjdGl2ZShlbCwge1xuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBOQU1FJGQgPSAnQkZvcm1EYXRlcGlja2VyJzsgLy8gRmFsbGJhY2sgdG8gQkNhbGVuZGFyIHByb3AgaWYgbm8gdmFsdWUgZm91bmRcblxuICB2YXIgZ2V0Q29uZmlnRmFsbGJhY2sgPSBmdW5jdGlvbiBnZXRDb25maWdGYWxsYmFjayhwcm9wKSB7XG4gICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJGQsIHByb3ApIHx8IGdldENvbXBvbmVudENvbmZpZygnQkNhbGVuZGFyJywgcHJvcCk7XG4gIH07IC8vIFdlIGNyZWF0ZSBvdXIgcHJvcHMgYXMgYSBtaXhpbiBzbyB0aGF0IHdlIGNhbiBjb250cm9sXG4gIC8vIHdoZXJlIHRoZXkgYXBwZWFyIGluIHRoZSBwcm9wcyBsaXN0aW5nIHJlZmVyZW5jZSBzZWN0aW9uXG5cblxuICB2YXIgcHJvcHNNaXhpbiA9IHtcbiAgICBwcm9wczoge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogW1N0cmluZywgRGF0ZV0sXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICB2YWx1ZUFzRGF0ZToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHJlc2V0VmFsdWU6IHtcbiAgICAgICAgdHlwZTogW1N0cmluZywgRGF0ZV0sXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9LFxuICAgICAgcGxhY2Vob2xkZXI6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAvLyBEZWZhdWx0cyB0byBgbGFiZWxOb0RhdGVTZWxlY3RlZGAgZnJvbSBjYWxlbmRhciBjb250ZXh0XG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIG1pbjoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBEYXRlXSxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIG1heDoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBEYXRlXSxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgcmVhZG9ubHk6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDoge1xuICAgICAgICAvLyBJZiB0cnVlIGFkZHMgdGhlIGBhcmlhLXJlcXVpcmVkYCBhdHRyaWJ1dGVcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBuYW1lOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgc3RhdGU6IHtcbiAgICAgICAgLy8gVHJpLXN0YXRlIHByb3A6IGB0cnVlYCwgYGZhbHNlYCBvciBgbnVsbGBcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIGRhdGVEaXNhYmxlZEZuOiB7XG4gICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgbm9DbG9zZU9uU2VsZWN0OiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgaGlkZUhlYWRlcjoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGxvY2FsZToge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0sXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBzdGFydFdlZWtkYXk6IHtcbiAgICAgICAgLy8gYDBgIChTdW5kYXkpLCBgMWAgKE1vbmRheSksIC4uLiBgNmAgKFNhdHVyZGF5KVxuICAgICAgICAvLyBEYXkgb2Ygd2VlayB0byBzdGFydCBjYWxlbmRhciBvblxuICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICBkZWZhdWx0OiAwXG4gICAgICB9LFxuICAgICAgZGlyZWN0aW9uOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkVmFyaWFudDoge1xuICAgICAgICAvLyBWYXJpYW50IGNvbG9yIHRvIHVzZSBmb3IgdGhlIHNlbGVjdGVkIGRhdGVcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAncHJpbWFyeSdcbiAgICAgIH0sXG4gICAgICB0b2RheVZhcmlhbnQ6IHtcbiAgICAgICAgLy8gVmFyaWFudCBjb2xvciB0byB1c2UgZm9yIHRvZGF5J3MgZGF0ZSAoZGVmYXVsdHMgdG8gYHZhcmlhbnRgKVxuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBub0hpZ2hsaWdodFRvZGF5OiB7XG4gICAgICAgIC8vIERpc2FibGUgaGlnaGxpZ2h0aW5nIHRvZGF5J3MgZGF0ZVxuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHRvZGF5QnV0dG9uOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgbGFiZWxUb2RheUJ1dHRvbjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRkLCAnbGFiZWxUb2RheUJ1dHRvbicpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9kYXlCdXR0b25WYXJpYW50OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ291dGxpbmUtcHJpbWFyeSdcbiAgICAgIH0sXG4gICAgICByZXNldEJ1dHRvbjoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGxhYmVsUmVzZXRCdXR0b246IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkZCwgJ2xhYmVsUmVzZXRCdXR0b24nKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc2V0QnV0dG9uVmFyaWFudDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICdvdXRsaW5lLWRhbmdlcidcbiAgICAgIH0sXG4gICAgICBjbG9zZUJ1dHRvbjoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGxhYmVsQ2xvc2VCdXR0b246IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkZCwgJ2xhYmVsQ2xvc2VCdXR0b24nKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNsb3NlQnV0dG9uVmFyaWFudDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICdvdXRsaW5lLXNlY29uZGFyeSdcbiAgICAgIH0sXG4gICAgICAvLyBMYWJlbHMgZm9yIGJ1dHRvbnMgYW5kIGtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAgLy8gVGhlc2UgcGljayBCQ2FsZW5kYXIgZ2xvYmFsIGNvbmZpZyBpZiBubyBCRm9ybURhdGUgZ2xvYmFsIGNvbmZpZ1xuICAgICAgbGFiZWxQcmV2WWVhcjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb25maWdGYWxsYmFjaygnbGFiZWxQcmV2WWVhcicpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGFiZWxQcmV2TW9udGg6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29uZmlnRmFsbGJhY2soJ2xhYmVsUHJldk1vbnRoJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsYWJlbEN1cnJlbnRNb250aDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb25maWdGYWxsYmFjaygnbGFiZWxDdXJyZW50TW9udGgnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxhYmVsTmV4dE1vbnRoOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbmZpZ0ZhbGxiYWNrKCdsYWJlbE5leHRNb250aCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGFiZWxOZXh0WWVhcjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb25maWdGYWxsYmFjaygnbGFiZWxOZXh0WWVhcicpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGFiZWxUb2RheToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb25maWdGYWxsYmFjaygnbGFiZWxUb2RheScpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGFiZWxTZWxlY3RlZDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb25maWdGYWxsYmFjaygnbGFiZWxTZWxlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGFiZWxOb0RhdGVTZWxlY3RlZDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb25maWdGYWxsYmFjaygnbGFiZWxOb0RhdGVTZWxlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGFiZWxDYWxlbmRhcjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb25maWdGYWxsYmFjaygnbGFiZWxDYWxlbmRhcicpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGFiZWxOYXY6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29uZmlnRmFsbGJhY2soJ2xhYmVsTmF2Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsYWJlbEhlbHA6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29uZmlnRmFsbGJhY2soJ2xhYmVsSGVscCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gRGFyayBtb2RlXG4gICAgICBkYXJrOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9OyAvLyAtLS0gQkZvcm1EYXRlIGNvbXBvbmVudCAtLS1cbiAgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkZvcm1EYXRlcGlja2VyID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiBOQU1FJGQsXG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgQkhvdmVyOiBWQkhvdmVyXG4gICAgfSxcbiAgICAvLyBUaGUgbWl4aW5zIG9yZGVyIGRldGVybWluZXMgdGhlIG9yZGVyIG9mIGFwcGVhcmFuY2UgaW4gdGhlIHByb3BzIHJlZmVyZW5jZSBzZWN0aW9uXG4gICAgbWl4aW5zOiBbaWRNaXhpbiwgcHJvcHNNaXhpbiwgZHJvcGRvd25NaXhpbl0sXG4gICAgbW9kZWw6IHtcbiAgICAgIHByb3A6ICd2YWx1ZScsXG4gICAgICBldmVudDogJ2lucHV0J1xuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIFdlIGFsd2F5cyB1c2UgYFlZWVktTU0tRERgIHZhbHVlIGludGVybmFsbHlcbiAgICAgICAgbG9jYWxZTUQ6IGZvcm1hdFlNRCh0aGlzLnZhbHVlKSB8fCAnJyxcbiAgICAgICAgLy8gQ29udGV4dCBkYXRhIGZyb20gQkNhbGVuZGFyXG4gICAgICAgIGxvY2FsTG9jYWxlOiBudWxsLFxuICAgICAgICBpc1JUTDogZmFsc2UsXG4gICAgICAgIGZvcm1hdGVkVmFsdWU6ICcnLFxuICAgICAgICBhY3RpdmVZTUQ6ICcnLFxuICAgICAgICAvLyBGbGFnIHRvIGFkZCBmb2N1cyByaW5nIHRvIG91dGVyIHdyYXBwZXJcbiAgICAgICAgaGFzRm9jdXM6IGZhbHNlLFxuICAgICAgICAvLyBJZiB0aGUgY29udHJvbCBpcyBob3ZlcmVkXG4gICAgICAgIGlzSG92ZXJlZDogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgY2FsZW5kYXJZTTogZnVuY3Rpb24gY2FsZW5kYXJZTSgpIHtcbiAgICAgICAgLy8gUmV0dXJucyB0aGUgY2FsZW5kYXIgeWVhci9tb250aFxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBgWVlZWS1NTWAgcG9ydGlvbiBvZiB0aGUgYWN0aXZlIGNhbGVuZGFyIGRhdGVcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlWU1ELnNsaWNlKDAsIC0zKTtcbiAgICAgIH0sXG4gICAgICBjYWxlbmRhclByb3BzOiBmdW5jdGlvbiBjYWxlbmRhclByb3BzKCkge1xuICAgICAgICAvLyBUT0RPOiBNYWtlIHRoZSBJRCdzIGNvbXB1dGVkIHByb3BzXG4gICAgICAgIHZhciBpZExhYmVsID0gdGhpcy5zYWZlSWQoJ192YWx1ZV8nKTtcbiAgICAgICAgdmFyIGlkV3JhcHBlciA9IHRoaXMuc2FmZUlkKCdfYi1mb3JtLWRhdGVfJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLy8gaWQ6IHRoaXMuc2FmZUlkKCdfcGlja2VyXycpLFxuICAgICAgICAgIGFyaWFDb250cm9sczogW2lkTGFiZWwsIGlkV3JhcHBlcl0uZmlsdGVyKGlkZW50aXR5KS5qb2luKCcgJykgfHwgbnVsbCxcbiAgICAgICAgICB2YWx1ZTogdGhpcy5sb2NhbFlNRCxcbiAgICAgICAgICBoaWRkZW46ICF0aGlzLnZpc2libGUsXG4gICAgICAgICAgbWluOiB0aGlzLm1pbixcbiAgICAgICAgICBtYXg6IHRoaXMubWF4LFxuICAgICAgICAgIHJlYWRvbmx5OiB0aGlzLnJlYWRvbmx5LFxuICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkLFxuICAgICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGUsXG4gICAgICAgICAgc3RhcnRXZWVrZGF5OiB0aGlzLnN0YXJ0V2Vla2RheSxcbiAgICAgICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uLFxuICAgICAgICAgIGRhdGVEaXNhYmxlZEZuOiB0aGlzLmRhdGVEaXNhYmxlZEZuLFxuICAgICAgICAgIHNlbGVjdGVkVmFyaWFudDogdGhpcy5zZWxlY3RlZFZhcmlhbnQsXG4gICAgICAgICAgdG9kYXlWYXJpYW50OiB0aGlzLnRvZGF5VmFyaWFudCxcbiAgICAgICAgICBoaWRlSGVhZGVyOiB0aGlzLmhpZGVIZWFkZXIsXG4gICAgICAgICAgbGFiZWxQcmV2WWVhcjogdGhpcy5sYWJlbFByZXZZZWFyLFxuICAgICAgICAgIGxhYmVsUHJldk1vbnRoOiB0aGlzLmxhYmVsUHJldk1vbnRoLFxuICAgICAgICAgIGxhYmVsQ3VycmVudE1vbnRoOiB0aGlzLmxhYmVsQ3VycmVudE1vbnRoLFxuICAgICAgICAgIGxhYmVsTmV4dE1vbnRoOiB0aGlzLmxhYmVsTmV4dE1vbnRoLFxuICAgICAgICAgIGxhYmVsTmV4dFllYXI6IHRoaXMubGFiZWxOZXh0WWVhcixcbiAgICAgICAgICBsYWJlbFRvZGF5OiB0aGlzLmxhYmVsVG9kYXksXG4gICAgICAgICAgbGFiZWxTZWxlY3RlZDogdGhpcy5sYWJlbFNlbGVjdGVkLFxuICAgICAgICAgIGxhYmVsTm9EYXRlU2VsZWN0ZWQ6IHRoaXMubGFiZWxOb0RhdGVTZWxlY3RlZCxcbiAgICAgICAgICBsYWJlbENhbGVuZGFyOiB0aGlzLmxhYmVsQ2FsZW5kYXIsXG4gICAgICAgICAgbGFiZWxOYXY6IHRoaXMubGFiZWxOYXYsXG4gICAgICAgICAgbGFiZWxIZWxwOiB0aGlzLmxhYmVsSGVscFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkUmVzZXRWYWx1ZTogZnVuY3Rpb24gY29tcHV0ZWRSZXNldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gcGFyc2VZTUQodGhpcy5yZXNldFZhbHVlKSB8fCAnJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobmV3VmFsKSB7XG4gICAgICAgIHRoaXMubG9jYWxZTUQgPSBmb3JtYXRZTUQobmV3VmFsKSB8fCAnJztcbiAgICAgIH0sXG4gICAgICBsb2NhbFlNRDogZnVuY3Rpb24gbG9jYWxZTUQobmV3VmFsKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgdGhpcy52YWx1ZUFzRGF0ZSA/IHBhcnNlWU1EKG5ld1ZhbCkgfHwgbnVsbCA6IG5ld1ZhbCB8fCAnJyk7XG4gICAgICB9LFxuICAgICAgY2FsZW5kYXJZTTogZnVuY3Rpb24gY2FsZW5kYXJZTShuZXdWYWwsIG9sZFZhbClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB7XG4gICAgICAgIC8vIERpc3BsYXllZCBjYWxlbmRhciBtb250aCBoYXMgY2hhbmdlZFxuICAgICAgICAvLyBTbyBwb3NzaWJseSB0aGUgY2FsZW5kYXIgaGVpZ2h0IGhhcyBjaGFuZ2VkLi4uXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gdXBkYXRlIHBvcHBlciBjb21wdXRlZCBwb3NpdGlvblxuICAgICAgICBpZiAobmV3VmFsICE9PSBvbGRWYWwgJiYgb2xkVmFsKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVQb3BwZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJG9uKCdzaG93bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTWF5IHdhbnQgdG8gbWFrZSBhbiBvcHRpb24gdG8gZm9jdXNcbiAgICAgICAgLy8gdGhlIGVudGlyZSBjYWxlbmRhciAoZHJvcGRvd24tbWVudSkgb3IganVzdCB0aGUgZGF0ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIF90aGlzLiRyZWZzLmNhbGVuZGFyLmZvY3VzKCk7XG4gICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHt9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIC8vIFB1YmxpYyBtZXRob2RzXG4gICAgICBmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUaGlzIGFzc3VtZXMgdGhlIHRvZ2dsZSBpcyBhbiBlbGVtZW50IGFuZCBub3QgYSBjb21wb25lbnRcbiAgICAgICAgICAgIHRoaXMuJHJlZnMudG9nZ2xlLmZvY3VzKCk7XG4gICAgICAgICAgfSBjYXRjaCAoX3VudXNlZDIpIHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBibHVyOiBmdW5jdGlvbiBibHVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVGhpcyBhc3N1bWVzIHRoZSB0b2dnbGUgaXMgYW4gZWxlbWVudCBhbmQgbm90IGEgY29tcG9uZW50XG4gICAgICAgICAgICB0aGlzLiRyZWZzLnRvZ2dsZS5ibHVyKCk7XG4gICAgICAgICAgfSBjYXRjaCAoX3VudXNlZDMpIHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBQcml2YXRlIG1ldGhvZHNcbiAgICAgIHNldEFuZENsb3NlOiBmdW5jdGlvbiBzZXRBbmRDbG9zZSh5bWQpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5sb2NhbFlNRCA9IHltZDsgLy8gQ2xvc2UgY2FsZW5kYXIgcG9wdXAsIHVubGVzcyBgbm9DbG9zZU9uU2VsZWN0YFxuXG4gICAgICAgIGlmICghdGhpcy5ub0Nsb3NlT25TZWxlY3QpIHtcbiAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuaGlkZSh0cnVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uU2VsZWN0ZWQ6IGZ1bmN0aW9uIG9uU2VsZWN0ZWQoeW1kKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczMuc2V0QW5kQ2xvc2UoeW1kKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25JbnB1dDogZnVuY3Rpb24gb25JbnB1dCh5bWQpIHtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxZTUQgIT09IHltZCkge1xuICAgICAgICAgIHRoaXMubG9jYWxZTUQgPSB5bWQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNvbnRleHQ6IGZ1bmN0aW9uIG9uQ29udGV4dChjdHgpIHtcbiAgICAgICAgdmFyIGFjdGl2ZVlNRCA9IGN0eC5hY3RpdmVZTUQsXG4gICAgICAgICAgICBpc1JUTCA9IGN0eC5pc1JUTCxcbiAgICAgICAgICAgIGxvY2FsZSA9IGN0eC5sb2NhbGUsXG4gICAgICAgICAgICBzZWxlY3RlZFlNRCA9IGN0eC5zZWxlY3RlZFlNRCxcbiAgICAgICAgICAgIHNlbGVjdGVkRm9ybWF0dGVkID0gY3R4LnNlbGVjdGVkRm9ybWF0dGVkO1xuICAgICAgICB0aGlzLmlzUlRMID0gaXNSVEw7XG4gICAgICAgIHRoaXMubG9jYWxMb2NhbGUgPSBsb2NhbGU7XG4gICAgICAgIHRoaXMuZm9ybWF0dGVkVmFsdWUgPSBzZWxlY3RlZEZvcm1hdHRlZDtcbiAgICAgICAgdGhpcy5sb2NhbFlNRCA9IHNlbGVjdGVkWU1EO1xuICAgICAgICB0aGlzLmFjdGl2ZVlNRCA9IGFjdGl2ZVlNRDsgLy8gUmUtZW1pdCB0aGUgY29udGV4dCBldmVudFxuXG4gICAgICAgIHRoaXMuJGVtaXQoJ2NvbnRleHQnLCBjdHgpO1xuICAgICAgfSxcbiAgICAgIG9uVG9kYXlCdXR0b246IGZ1bmN0aW9uIG9uVG9kYXlCdXR0b24oKSB7XG4gICAgICAgIHRoaXMuc2V0QW5kQ2xvc2UoZm9ybWF0WU1EKGNyZWF0ZURhdGUoKSkpO1xuICAgICAgfSxcbiAgICAgIG9uUmVzZXRCdXR0b246IGZ1bmN0aW9uIG9uUmVzZXRCdXR0b24oKSB7XG4gICAgICAgIHRoaXMuc2V0QW5kQ2xvc2UodGhpcy5jb21wdXRlZFJlc2V0VmFsdWUpO1xuICAgICAgfSxcbiAgICAgIG9uQ2xvc2VCdXR0b246IGZ1bmN0aW9uIG9uQ2xvc2VCdXR0b24oKSB7XG4gICAgICAgIHRoaXMuaGlkZSh0cnVlKTtcbiAgICAgIH0sXG4gICAgICBzZXRGb2N1czogZnVuY3Rpb24gc2V0Rm9jdXMoZXZ0KSB7XG4gICAgICAgIHRoaXMuaGFzRm9jdXMgPSBldnQudHlwZSA9PT0gJ2ZvY3VzJztcbiAgICAgIH0sXG4gICAgICBoYW5kbGVIb3ZlcjogZnVuY3Rpb24gaGFuZGxlSG92ZXIoaG92ZXJlZCkge1xuICAgICAgICB0aGlzLmlzSG92ZXJlZCA9IGhvdmVyZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICB2YXIgX2NsYXNzMiwgX3JlZjtcblxuICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgdmFyIGxvY2FsWU1EID0gdGhpcy5sb2NhbFlNRDtcbiAgICAgIHZhciBkaXNhYmxlZCA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgICB2YXIgcmVhZG9ubHkgPSB0aGlzLnJlYWRvbmx5O1xuICAgICAgdmFyIGlkQnV0dG9uID0gdGhpcy5zYWZlSWQoKTtcbiAgICAgIHZhciBpZExhYmVsID0gdGhpcy5zYWZlSWQoJ192YWx1ZV8nKTtcbiAgICAgIHZhciBpZE1lbnUgPSB0aGlzLnNhZmVJZCgnX2RpYWxvZ18nKTtcbiAgICAgIHZhciBpZFdyYXBwZXIgPSB0aGlzLnNhZmVJZCgnX2ItZm9ybS1kYXRlXycpO1xuICAgICAgdmFyICRidXR0b24gPSBoKCdkaXYnLCB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnXG4gICAgICAgIH1cbiAgICAgIH0sIFt0aGlzLmlzSG92ZXJlZCB8fCB0aGlzLmhhc0ZvY3VzID8gaChCSWNvbkNhbGVuZGFyRmlsbCwge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHNjYWxlOiAxLjI1XG4gICAgICAgIH1cbiAgICAgIH0pIDogaChCSWNvbkNhbGVuZGFyLCB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgc2NhbGU6IDEuMjVcbiAgICAgICAgfVxuICAgICAgfSldKTtcbiAgICAgICRidXR0b24gPSBoKCdidXR0b24nLCB7XG4gICAgICAgIHJlZjogJ3RvZ2dsZScsXG4gICAgICAgIHN0YXRpY0NsYXNzOiAnYnRuIGJvcmRlci0wIGgtYXV0byBweS0wJyxcbiAgICAgICAgY2xhc3M6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJidG4tXCIuY29uY2F0KHNpemUpLCAhIXNpemUpLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiBpZEJ1dHRvbixcbiAgICAgICAgICB0eXBlOiAnYnV0dG9uJyxcbiAgICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiAnZGlhbG9nJyxcbiAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IHRoaXMudmlzaWJsZSA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgICAgICAgJ2FyaWEtaW52YWxpZCc6IHN0YXRlID09PSBmYWxzZSA/ICd0cnVlJyA6IG51bGwsXG4gICAgICAgICAgJ2FyaWEtcmVxdWlyZWQnOiB0aGlzLnJlcXVpcmVkID8gJ3RydWUnIDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIG1vdXNlZG93bjogdGhpcy5vbk1vdXNlZG93bixcbiAgICAgICAgICBjbGljazogdGhpcy50b2dnbGUsXG4gICAgICAgICAga2V5ZG93bjogdGhpcy50b2dnbGUsXG4gICAgICAgICAgLy8gSGFuZGxlIEVOVEVSLCBTUEFDRSBhbmQgRE9XTlxuICAgICAgICAgICchZm9jdXMnOiB0aGlzLnNldEZvY3VzLFxuICAgICAgICAgICchYmx1cic6IHRoaXMuc2V0Rm9jdXNcbiAgICAgICAgfVxuICAgICAgfSwgWyRidXR0b25dKTsgLy8gTGFiZWwgYXMgYSBcImZha2VcIiBpbnB1dFxuICAgICAgLy8gVGhpcyBsYWJlbCB3aWxsIGJlIHJlYWQgYnkgc2NyZWVuIHJlYWRlcnMgd2hlbiB0aGUgYnV0dG9uIGlzIGZvY3VzZWRcblxuICAgICAgdmFyICRpbnB1dCA9IGgoJ2xhYmVsJywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2Zvcm0tY29udHJvbCB0ZXh0LWJyZWFrIHRleHQtd3JhcCBib3JkZXItMCBiZy10cmFuc3BhcmVudCBoLWF1dG8gcGwtMSBtLTAnLFxuICAgICAgICBjbGFzczogKF9jbGFzczIgPSB7XG4gICAgICAgICAgLy8gTXV0ZSB0aGUgdGV4dCBpZiBzaG93aW5nIHRoZSBwbGFjZWhvbGRlclxuICAgICAgICAgICd0ZXh0LW11dGVkJzogIWxvY2FsWU1EXG4gICAgICAgIH0sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MyLCBcImZvcm0tY29udHJvbC1cIi5jb25jYXQoc2l6ZSksICEhc2l6ZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MyLCAnaXMtaW52YWxpZCcsIHN0YXRlID09PSBmYWxzZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MyLCAnaXMtdmFsaWQnLCBzdGF0ZSA9PT0gdHJ1ZSksIF9jbGFzczIpLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiBpZExhYmVsLFxuICAgICAgICAgIGZvcjogaWRCdXR0b24sXG4gICAgICAgICAgZGlyOiB0aGlzLmlzUlRMID8gJ3J0bCcgOiAnbHRyJyxcbiAgICAgICAgICBsYW5nOiB0aGlzLmxvY2FsTG9jYWxlIHx8IG51bGwsXG4gICAgICAgICAgJ2FyaWEtaW52YWxpZCc6IHN0YXRlID09PSBmYWxzZSA/ICd0cnVlJyA6IG51bGwsXG4gICAgICAgICAgJ2FyaWEtcmVxdWlyZWQnOiB0aGlzLnJlcXVpcmVkID8gJ3RydWUnIDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIC8vIERpc2FibGUgYnViYmxpbmcgb2YgdGhlIGNsaWNrIGV2ZW50IHRvXG4gICAgICAgICAgLy8gcHJldmVudCBtZW51IGZyb20gY2xvc2luZyBhbmQgcmUtb3BlbmluZ1xuICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljayhldnQpXG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICB7XG4gICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBbLy8gQWRkIHRoZSBmb3JtYXR0ZWQgdmFsdWUgb3IgcGxhY2Vob2xkZXJcbiAgICAgIGxvY2FsWU1EID8gdGhpcy5mb3JtYXR0ZWRWYWx1ZSA6IHRoaXMucGxhY2Vob2xkZXIgfHwgdGhpcy5sYWJlbE5vRGF0ZVNlbGVjdGVkLCAvLyBBZGQgYW4gc3Itb25seSAnc2VsZWN0ZWQgZGF0ZScgbGFiZWwgaWYgYSBkYXRlIGlzIHNlbGVjdGVkXG4gICAgICBsb2NhbFlNRCA/IGgoJ3NwYW4nLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnc3Itb25seSdcbiAgICAgIH0sIFwiIChcIi5jb25jYXQodGhpcy5sYWJlbFNlbGVjdGVkLCBcIikgXCIpKSA6IGgoKV0pOyAvLyBPcHRpb25hbCBmb290ZXIgYnV0dG9uc1xuXG4gICAgICB2YXIgJGNvbnRyb2xzID0gW107XG5cbiAgICAgIGlmICh0aGlzLnRvZGF5QnV0dG9uKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IHRoaXMubGFiZWxUb2RheUJ1dHRvbjtcbiAgICAgICAgJGNvbnRyb2xzLnB1c2goaChCQnV0dG9uLCB7XG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIHNpemU6ICdzbScsXG4gICAgICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQgfHwgcmVhZG9ubHksXG4gICAgICAgICAgICB2YXJpYW50OiB0aGlzLnRvZGF5QnV0dG9uVmFyaWFudFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICdhcmlhLWxhYmVsJzogbGFiZWwgfHwgbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNsaWNrOiB0aGlzLm9uVG9kYXlCdXR0b25cbiAgICAgICAgICB9XG4gICAgICAgIH0sIGxhYmVsKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJlc2V0QnV0dG9uKSB7XG4gICAgICAgIHZhciBfbGFiZWwgPSB0aGlzLmxhYmVsUmVzZXRCdXR0b247XG4gICAgICAgICRjb250cm9scy5wdXNoKGgoQkJ1dHRvbiwge1xuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBzaXplOiAnc20nLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkIHx8IHJlYWRvbmx5LFxuICAgICAgICAgICAgdmFyaWFudDogdGhpcy5yZXNldEJ1dHRvblZhcmlhbnRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAnYXJpYS1sYWJlbCc6IF9sYWJlbCB8fCBudWxsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgY2xpY2s6IHRoaXMub25SZXNldEJ1dHRvblxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2xhYmVsKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsb3NlQnV0dG9uKSB7XG4gICAgICAgIHZhciBfbGFiZWwyID0gdGhpcy5sYWJlbENsb3NlQnV0dG9uO1xuICAgICAgICAkY29udHJvbHMucHVzaChoKEJCdXR0b24sIHtcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgc2l6ZTogJ3NtJyxcbiAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkLFxuICAgICAgICAgICAgdmFyaWFudDogdGhpcy5jbG9zZUJ1dHRvblZhcmlhbnRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAnYXJpYS1sYWJlbCc6IF9sYWJlbDIgfHwgbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNsaWNrOiB0aGlzLm9uQ2xvc2VCdXR0b25cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9sYWJlbDIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCRjb250cm9scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICRjb250cm9scyA9IFtoKCdkaXYnLCB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICdiLWZvcm0tZGF0ZS1jb250cm9scyBkLWZsZXggZmxleC13cmFwJyxcbiAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgJ2p1c3RpZnktY29udGVudC1iZXR3ZWVuJzogJGNvbnRyb2xzLmxlbmd0aCA+IDEsXG4gICAgICAgICAgICAnanVzdGlmeS1jb250ZW50LWVuZCc6ICRjb250cm9scy5sZW5ndGggPCAyXG4gICAgICAgICAgfVxuICAgICAgICB9LCAkY29udHJvbHMpXTtcbiAgICAgIH1cblxuICAgICAgdmFyICRjYWxlbmRhciA9IGgoQkNhbGVuZGFyLCB7XG4gICAgICAgIGtleTogJ2NhbGVuZGFyJyxcbiAgICAgICAgcmVmOiAnY2FsZW5kYXInLFxuICAgICAgICBzdGF0aWNDbGFzczogJ2ItZm9ybS1kYXRlLWNhbGVuZGFyJyxcbiAgICAgICAgcHJvcHM6IHRoaXMuY2FsZW5kYXJQcm9wcyxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBzZWxlY3RlZDogdGhpcy5vblNlbGVjdGVkLFxuICAgICAgICAgIGlucHV0OiB0aGlzLm9uSW5wdXQsXG4gICAgICAgICAgY29udGV4dDogdGhpcy5vbkNvbnRleHRcbiAgICAgICAgfVxuICAgICAgfSwgJGNvbnRyb2xzKTtcbiAgICAgIHZhciAkbWVudSA9IGgoJ2RpdicsIHtcbiAgICAgICAgcmVmOiAnbWVudScsXG4gICAgICAgIHN0YXRpY0NsYXNzOiAnZHJvcGRvd24tbWVudSBwLTInLFxuICAgICAgICBjbGFzczoge1xuICAgICAgICAgIHNob3c6IHRoaXMudmlzaWJsZSxcbiAgICAgICAgICAnZHJvcGRvd24tbWVudS1yaWdodCc6IHRoaXMucmlnaHQsXG4gICAgICAgICAgJ2JnLWRhcmsnOiB0aGlzLmRhcmssXG4gICAgICAgICAgJ3RleHQtbGlnaHQnOiB0aGlzLmRhcmtcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBpZDogaWRNZW51LFxuICAgICAgICAgIHJvbGU6ICdkaWFsb2cnLFxuICAgICAgICAgICdhcmlhLW1vZGFsJzogJ2ZhbHNlJyxcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogaWRMYWJlbFxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGtleWRvd246IHRoaXMub25LZXlkb3duIC8vIEhhbmRsZSBFU0NcblxuICAgICAgICB9XG4gICAgICB9LCBbJGNhbGVuZGFyXSk7XG4gICAgICB2YXIgJGhpZGRlbiA9IGgoKTtcblxuICAgICAgaWYgKHRoaXMubmFtZSAmJiAhZGlzYWJsZWQpIHtcbiAgICAgICAgJGhpZGRlbiA9IGgoJ2lucHV0Jywge1xuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICB0eXBlOiAnaGlkZGVuJyxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGZvcm06IHRoaXMuZm9ybSxcbiAgICAgICAgICAgIHZhbHVlOiBsb2NhbFlNRCB8fCAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoKCdkaXYnLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnYi1mb3JtLWRhdGVwaWNrZXIgZm9ybS1jb250cm9sIGRyb3Bkb3duIGgtYXV0byBwLTAgZC1mbGV4JyxcbiAgICAgICAgY2xhc3M6IFt0aGlzLmRpcmVjdGlvbkNsYXNzLCAoX3JlZiA9IHtcbiAgICAgICAgICBzaG93OiB0aGlzLnZpc2libGUsXG4gICAgICAgICAgZm9jdXM6IHRoaXMuaGFzRm9jdXNcbiAgICAgICAgfSwgX2RlZmluZVByb3BlcnR5KF9yZWYsIFwiZm9ybS1jb250cm9sLVwiLmNvbmNhdChzaXplKSwgISFzaXplKSwgX2RlZmluZVByb3BlcnR5KF9yZWYsICdpcy1pbnZhbGlkJywgc3RhdGUgPT09IGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9yZWYsICdpcy12YWxpZCcsIHN0YXRlID09PSB0cnVlKSwgX3JlZildLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiBpZFdyYXBwZXIsXG4gICAgICAgICAgcm9sZTogJ2dyb3VwJyxcbiAgICAgICAgICAnYXJpYS1kaXNhYmxlZCc6IGRpc2FibGVkLFxuICAgICAgICAgICdhcmlhLXJlYWRvbmx5JzogcmVhZG9ubHkgJiYgIWRpc2FibGVkLFxuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBpZExhYmVsLFxuICAgICAgICAgICdhcmlhLWludmFsaWQnOiBzdGF0ZSA9PT0gZmFsc2UgPyAndHJ1ZScgOiBudWxsLFxuICAgICAgICAgICdhcmlhLXJlcXVpcmVkJzogdGhpcy5yZXF1aXJlZCA/ICd0cnVlJyA6IG51bGwsXG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0aGUgZmxleCBvcmRlciB0byBjaGFuZ2UgaGVyZVxuICAgICAgICAgIC8vIFNvIHdlIGFsd2F5cyB1c2UgJ2x0cidcbiAgICAgICAgICBkaXI6ICdsdHInXG4gICAgICAgIH0sXG4gICAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgICAgbmFtZTogJ2ItaG92ZXInLFxuICAgICAgICAgIHZhbHVlOiB0aGlzLmhhbmRsZUhvdmVyXG4gICAgICAgIH1dXG4gICAgICB9LCBbJGJ1dHRvbiwgJGhpZGRlbiwgJG1lbnUsICRpbnB1dF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIEZvcm1EYXRlcGlja2VyUGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBCRm9ybURhdGVwaWNrZXI6IEJGb3JtRGF0ZXBpY2tlcixcbiAgICAgIEJEYXRlcGlja2VyOiBCRm9ybURhdGVwaWNrZXJcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEB2dWUvY29tcG9uZW50XG4gIHZhciBmb3JtQ3VzdG9tTWl4aW4gPSB7XG4gICAgcHJvcHM6IHtcbiAgICAgIHBsYWluOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgY3VzdG9tOiBmdW5jdGlvbiBjdXN0b20oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5wbGFpbjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIE5BTUUkZSA9ICdCRm9ybUZpbGUnO1xuICB2YXIgVkFMVUVfRU1QVFlfREVQUkVDQVRFRF9NU0cgPSAnU2V0dGluZyBcInZhbHVlXCIvXCJ2LW1vZGVsXCIgdG8gYW4gZW1wdHkgc3RyaW5nIGZvciByZXNldCBpcyBkZXByZWNhdGVkLiBTZXQgdG8gXCJudWxsXCIgaW5zdGVhZC4nOyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCRm9ybUZpbGUgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6IE5BTUUkZSxcbiAgICBtaXhpbnM6IFtpZE1peGluLCBmb3JtTWl4aW4sIGZvcm1TdGF0ZU1peGluLCBmb3JtQ3VzdG9tTWl4aW4sIG5vcm1hbGl6ZVNsb3RNaXhpbl0sXG4gICAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgICBtb2RlbDoge1xuICAgICAgcHJvcDogJ3ZhbHVlJyxcbiAgICAgIGV2ZW50OiAnaW5wdXQnXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgc2l6ZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoJ0JGb3JtQ29udHJvbCcsICdzaXplJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0eXBlOiBbRmlsZSwgQXJyYXldLFxuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcih2YWwpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGlmICh2YWwgPT09ICcnKSB7XG4gICAgICAgICAgICB3YXJuKFZBTFVFX0VNUFRZX0RFUFJFQ0FURURfTVNHLCBOQU1FJGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkT3JOdWxsKHZhbCkgfHwgaXNGaWxlKHZhbCkgfHwgaXNBcnJheSh2YWwpICYmICh2YWwubGVuZ3RoID09PSAwIHx8IHZhbC5ldmVyeShpc0ZpbGUpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFjY2VwdDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9LFxuICAgICAgLy8gSW5zdHJ1Y3QgaW5wdXQgdG8gY2FwdHVyZSBmcm9tIGNhbWVyYVxuICAgICAgY2FwdHVyZToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHBsYWNlaG9sZGVyOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJGUsICdwbGFjZWhvbGRlcicpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYnJvd3NlVGV4dDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRlLCAnYnJvd3NlVGV4dCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZHJvcFBsYWNlaG9sZGVyOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJGUsICdkcm9wUGxhY2Vob2xkZXInKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG11bHRpcGxlOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZGlyZWN0b3J5OiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgbm9UcmF2ZXJzZToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIG5vRHJvcDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGZpbGVOYW1lRm9ybWF0dGVyOiB7XG4gICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0ZWRGaWxlOiBudWxsLFxuICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIGhhc0ZvY3VzOiBmYWxzZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBzZWxlY3RMYWJlbDogZnVuY3Rpb24gc2VsZWN0TGFiZWwoKSB7XG4gICAgICAgIC8vIERyYWdpbmcgYWN0aXZlXG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJvcFBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcFBsYWNlaG9sZGVyO1xuICAgICAgICB9IC8vIE5vIGZpbGUgY2hvc2VuXG5cblxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0ZWRGaWxlIHx8IHRoaXMuc2VsZWN0ZWRGaWxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBsYWNlaG9sZGVyO1xuICAgICAgICB9IC8vIENvbnZlcnQgc2VsZWN0ZWRGaWxlIHRvIGFuIGFycmF5IChpZiBub3QgYWxyZWFkeSBvbmUpXG5cblxuICAgICAgICB2YXIgZmlsZXMgPSBjb25jYXQodGhpcy5zZWxlY3RlZEZpbGUpLmZpbHRlcihpZGVudGl0eSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzTm9ybWFsaXplZFNsb3QoJ2ZpbGUtbmFtZScpKSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgYSBzbG90IGZvciBmb3JtYXR0aW5nIHRoZSBmaWxlcy9uYW1lc1xuICAgICAgICAgIHJldHVybiBbdGhpcy5ub3JtYWxpemVTbG90KCdmaWxlLW5hbWUnLCB7XG4gICAgICAgICAgICBmaWxlczogZmlsZXMsXG4gICAgICAgICAgICBuYW1lczogZmlsZXMubWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmLm5hbWU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIHVzZXIgc3VwcGxpZWQgZm9ybWF0dGVyLCBvciB0aGUgYnVpbHQgaW4gb25lLlxuICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHRoaXMuZmlsZU5hbWVGb3JtYXR0ZXIpID8gdG9TdHJpbmckMSh0aGlzLmZpbGVOYW1lRm9ybWF0dGVyKGZpbGVzKSkgOiBmaWxlcy5tYXAoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlLm5hbWU7XG4gICAgICAgICAgfSkuam9pbignLCAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgIHNlbGVjdGVkRmlsZTogZnVuY3Rpb24gc2VsZWN0ZWRGaWxlKG5ld1ZhbCwgb2xkVmFsKSB7XG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgdGVzdCBpcyBuZWVkZWQgd2hlbiB0aGUgZmlsZSBpbnB1dCBpcyBcInJlc2V0XCIgb3IgdGhlXG4gICAgICAgIC8vIGV4YWN0IHNhbWUgZmlsZShzKSBhcmUgc2VsZWN0ZWQgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlxuICAgICAgICAvLyBXaGVuIGluIGBtdWx0aXBsZWAgbW9kZSB3ZSBuZWVkIHRvIGNoZWNrIGZvciB0d28gZW1wdHkgYXJyYXlzIG9yXG4gICAgICAgIC8vIHR3byBhcnJheXMgd2l0aCBpZGVudGljYWwgZmlsZXNcbiAgICAgICAgaWYgKG5ld1ZhbCA9PT0gb2xkVmFsIHx8IGlzQXJyYXkobmV3VmFsKSAmJiBpc0FycmF5KG9sZFZhbCkgJiYgbmV3VmFsLmxlbmd0aCA9PT0gb2xkVmFsLmxlbmd0aCAmJiBuZXdWYWwuZXZlcnkoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICByZXR1cm4gdiA9PT0gb2xkVmFsW2ldO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmV3VmFsICYmIHRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIFtdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIG5ld1ZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobmV3VmFsKSB7XG4gICAgICAgIGlmICghbmV3VmFsIHx8IGlzQXJyYXkobmV3VmFsKSAmJiBuZXdWYWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBmb2N1c0hhbmRsZXI6IGZ1bmN0aW9uIGZvY3VzSGFuZGxlcihldnQpIHtcbiAgICAgICAgLy8gQm9vdHN0cmFwIHY0IGRvZXNuJ3QgaGF2ZSBmb2N1cyBzdHlsaW5nIGZvciBjdXN0b20gZmlsZSBpbnB1dFxuICAgICAgICAvLyBGaXJlZm94IGhhcyBhICdbdHlwZT1maWxlXTpmb2N1cyB+IHNpYmxpbmcnIHNlbGVjdG9yIGlzc3VlLFxuICAgICAgICAvLyBzbyB3ZSBhZGQgYSAnZm9jdXMnIGNsYXNzIHRvIGdldCBhcm91bmQgdGhlc2UgYnVnc1xuICAgICAgICBpZiAodGhpcy5wbGFpbiB8fCBldnQudHlwZSA9PT0gJ2ZvY3Vzb3V0Jykge1xuICAgICAgICAgIHRoaXMuaGFzRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBZGQgZm9jdXMgc3R5bGluZyBmb3IgY3VzdG9tIGZpbGUgaW5wdXRcbiAgICAgICAgICB0aGlzLmhhc0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBXcmFwcGVkIGluIHRyeSBpbiBjYXNlIElFIDExIGNyYXBzIG91dFxuICAgICAgICAgIHRoaXMuJHJlZnMuaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgfSBjYXRjaCAoZSkge30gLy8gSUUgMTEgZG9lc24ndCBzdXBwb3J0IHNldHRpbmcgYGlucHV0LnZhbHVlYCB0byAnJyBvciBudWxsXG4gICAgICAgIC8vIFNvIHdlIHVzZSB0aGlzIGxpdHRsZSBleHRyYSBoYWNrIHRvIHJlc2V0IHRoZSB2YWx1ZSwganVzdCBpbiBjYXNlLlxuICAgICAgICAvLyBUaGlzIGFsc28gYXBwZWFycyB0byB3b3JrIG9uIG1vZGVybiBicm93c2VycyBhcyB3ZWxsLlxuXG5cbiAgICAgICAgdGhpcy4kcmVmcy5pbnB1dC50eXBlID0gJyc7XG4gICAgICAgIHRoaXMuJHJlZnMuaW5wdXQudHlwZSA9ICdmaWxlJztcbiAgICAgICAgdGhpcy5zZWxlY3RlZEZpbGUgPSB0aGlzLm11bHRpcGxlID8gW10gOiBudWxsO1xuICAgICAgfSxcbiAgICAgIG9uRmlsZUNoYW5nZTogZnVuY3Rpb24gb25GaWxlQ2hhbmdlKGV2dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIC8vIEFsd2F5cyBlbWl0IG9yaWdpbmFsIGV2ZW50XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGV2dCk7IC8vIENoZWNrIGlmIHNwZWNpYWwgYGl0ZW1zYCBwcm9wIGlzIGF2YWlsYWJsZSBvbiBldmVudCAoZHJvcCBtb2RlKVxuICAgICAgICAvLyBDYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyBuby10cmF2ZXJzZVxuXG4gICAgICAgIHZhciBpdGVtcyA9IGV2dC5kYXRhVHJhbnNmZXIgJiYgZXZ0LmRhdGFUcmFuc2Zlci5pdGVtcztcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCBzdXBwb3J0ZWQgaW4gSlNET00gKi9cblxuICAgICAgICBpZiAoaXRlbXMgJiYgIXRoaXMubm9UcmF2ZXJzZSkge1xuICAgICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXS53ZWJraXRHZXRBc0VudHJ5KCk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgIHF1ZXVlLnB1c2godGhpcy50cmF2ZXJzZUZpbGVUcmVlKGl0ZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBQcm9taXNlLmFsbChxdWV1ZSkudGhlbihmdW5jdGlvbiAoZmlsZXNBcnIpIHtcbiAgICAgICAgICAgIF90aGlzLnNldEZpbGVzKGZyb20oZmlsZXNBcnIpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gTm9ybWFsIGhhbmRsaW5nXG5cblxuICAgICAgICB0aGlzLnNldEZpbGVzKGV2dC50YXJnZXQuZmlsZXMgfHwgZXZ0LmRhdGFUcmFuc2Zlci5maWxlcyk7XG4gICAgICB9LFxuICAgICAgc2V0RmlsZXM6IGZ1bmN0aW9uIHNldEZpbGVzKCkge1xuICAgICAgICB2YXIgZmlsZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuXG4gICAgICAgIGlmICghZmlsZXMpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdGhpcyB3aWxsIHByb2JhYmx5IG5vdCBoYXBwZW4gKi9cbiAgICAgICAgICB0aGlzLnNlbGVjdGVkRmlsZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgIC8vIENvbnZlcnQgZmlsZXMgdG8gYXJyYXlcbiAgICAgICAgICB2YXIgZmlsZXNBcnJheSA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZmlsZXNBcnJheS5wdXNoKGZpbGVzW2ldKTtcbiAgICAgICAgICB9IC8vIFJldHVybiBmaWxlKHMpIGFzIGFycmF5XG5cblxuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRGaWxlID0gZmlsZXNBcnJheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZXR1cm4gc2luZ2xlIGZpbGUgb2JqZWN0XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZEZpbGUgPSBmaWxlc1swXSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25SZXNldDogZnVuY3Rpb24gb25SZXNldCgpIHtcbiAgICAgICAgLy8gVHJpZ2dlcmVkIHdoZW4gdGhlIHBhcmVudCBmb3JtIChpZiBhbnkpIGlzIHJlc2V0XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRGaWxlID0gdGhpcy5tdWx0aXBsZSA/IFtdIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBvbkRyYWdvdmVyOiBmdW5jdGlvbiBvbkRyYWdvdmVyKGV2dClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gdGVzdCBpbiBKU0RPTSAqL1xuICAgICAge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGlmICh0aGlzLm5vRHJvcCB8fCAhdGhpcy5jdXN0b20pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgZXZ0LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ2NvcHknO1xuICAgICAgfSxcbiAgICAgIG9uRHJhZ2xlYXZlOiBmdW5jdGlvbiBvbkRyYWdsZWF2ZShldnQpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIHRlc3QgaW4gSlNET00gKi9cbiAgICAgIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIG9uRHJvcDogZnVuY3Rpb24gb25Ecm9wKGV2dClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gdGVzdCBpbiBKU0RPTSAqL1xuICAgICAge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGlmICh0aGlzLm5vRHJvcCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoZXZ0LmRhdGFUcmFuc2Zlci5maWxlcyAmJiBldnQuZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLm9uRmlsZUNoYW5nZShldnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHJhdmVyc2VGaWxlVHJlZTogZnVuY3Rpb24gdHJhdmVyc2VGaWxlVHJlZShpdGVtLCBwYXRoKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCBzdXBwb3J0ZWQgaW4gSlNET00gKi9cbiAgICAgIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTkwMDU4XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHBhdGggPSBwYXRoIHx8ICcnO1xuXG4gICAgICAgICAgaWYgKGl0ZW0uaXNGaWxlKSB7XG4gICAgICAgICAgICAvLyBHZXQgZmlsZVxuICAgICAgICAgICAgaXRlbS5maWxlKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgIGZpbGUuJHBhdGggPSBwYXRoOyAvLyBJbmplY3QgJHBhdGggdG8gZmlsZSBvYmpcblxuICAgICAgICAgICAgICByZXNvbHZlKGZpbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmlzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICAvLyBHZXQgZm9sZGVyIGNvbnRlbnRzXG4gICAgICAgICAgICBpdGVtLmNyZWF0ZVJlYWRlcigpLnJlYWRFbnRyaWVzKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goX3RoaXMyLnRyYXZlcnNlRmlsZVRyZWUoZW50cmllc1tpXSwgcGF0aCArIGl0ZW0ubmFtZSArICcvJykpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocXVldWUpLnRoZW4oZnVuY3Rpb24gKGZpbGVzQXJyKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShmcm9tKGZpbGVzQXJyKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIC8vIEZvcm0gSW5wdXRcbiAgICAgIHZhciBpbnB1dCA9IGgoJ2lucHV0Jywge1xuICAgICAgICByZWY6ICdpbnB1dCcsXG4gICAgICAgIGNsYXNzOiBbe1xuICAgICAgICAgICdmb3JtLWNvbnRyb2wtZmlsZSc6IHRoaXMucGxhaW4sXG4gICAgICAgICAgJ2N1c3RvbS1maWxlLWlucHV0JzogdGhpcy5jdXN0b20sXG4gICAgICAgICAgZm9jdXM6IHRoaXMuY3VzdG9tICYmIHRoaXMuaGFzRm9jdXNcbiAgICAgICAgfSwgdGhpcy5zdGF0ZUNsYXNzXSxcbiAgICAgICAgYXR0cnM6IF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLiRhdHRycywge1xuICAgICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgICAgICBpZDogdGhpcy5zYWZlSWQoKSxcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQsXG4gICAgICAgICAgcmVxdWlyZWQ6IHRoaXMucmVxdWlyZWQsXG4gICAgICAgICAgZm9ybTogdGhpcy5mb3JtIHx8IG51bGwsXG4gICAgICAgICAgY2FwdHVyZTogdGhpcy5jYXB0dXJlIHx8IG51bGwsXG4gICAgICAgICAgYWNjZXB0OiB0aGlzLmFjY2VwdCB8fCBudWxsLFxuICAgICAgICAgIG11bHRpcGxlOiB0aGlzLm11bHRpcGxlLFxuICAgICAgICAgIHdlYmtpdGRpcmVjdG9yeTogdGhpcy5kaXJlY3RvcnksXG4gICAgICAgICAgJ2FyaWEtcmVxdWlyZWQnOiB0aGlzLnJlcXVpcmVkID8gJ3RydWUnIDogbnVsbFxuICAgICAgICB9KSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBjaGFuZ2U6IHRoaXMub25GaWxlQ2hhbmdlLFxuICAgICAgICAgIGZvY3VzaW46IHRoaXMuZm9jdXNIYW5kbGVyLFxuICAgICAgICAgIGZvY3Vzb3V0OiB0aGlzLmZvY3VzSGFuZGxlcixcbiAgICAgICAgICByZXNldDogdGhpcy5vblJlc2V0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5wbGFpbikge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICB9IC8vIE92ZXJsYXkgTGFiZWxzXG5cblxuICAgICAgdmFyIGxhYmVsID0gaCgnbGFiZWwnLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnY3VzdG9tLWZpbGUtbGFiZWwnLFxuICAgICAgICBjbGFzczogW3RoaXMuZHJhZ2dpbmcgPyAnZHJhZ2dpbmcnIDogbnVsbF0sXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgZm9yOiB0aGlzLnNhZmVJZCgpLFxuICAgICAgICAgICdkYXRhLWJyb3dzZSc6IHRoaXMuYnJvd3NlVGV4dCB8fCBudWxsXG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuc2VsZWN0TGFiZWwpOyAvLyBSZXR1cm4gcmVuZGVyZWQgY3VzdG9tIGZpbGUgaW5wdXRcblxuICAgICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdjdXN0b20tZmlsZSBiLWZvcm0tZmlsZScsXG4gICAgICAgIGNsYXNzOiBbdGhpcy5zdGF0ZUNsYXNzLCBfZGVmaW5lUHJvcGVydHkoe30sIFwiYi1jdXN0b20tY29udHJvbC1cIi5jb25jYXQodGhpcy5zaXplKSwgdGhpcy5zaXplKV0sXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHRoaXMuc2FmZUlkKCdfQlZfZmlsZV9vdXRlcl8nKVxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGRyYWdvdmVyOiB0aGlzLm9uRHJhZ292ZXIsXG4gICAgICAgICAgZHJhZ2xlYXZlOiB0aGlzLm9uRHJhZ2xlYXZlLFxuICAgICAgICAgIGRyb3A6IHRoaXMub25Ecm9wXG4gICAgICAgIH1cbiAgICAgIH0sIFtpbnB1dCwgbGFiZWxdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBGb3JtRmlsZVBsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgY29tcG9uZW50czoge1xuICAgICAgQkZvcm1GaWxlOiBCRm9ybUZpbGUsXG4gICAgICBCRmlsZTogQkZvcm1GaWxlXG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogU3VmZml4IGNhbiBiZSBhIGZhbHNleSB2YWx1ZSBzbyBub3RoaW5nIGlzIGFwcGVuZGVkIHRvIHN0cmluZy5cbiAgICogKGhlbHBzIHdoZW4gbG9vcGluZyBvdmVyIHByb3BzICYgc29tZSBzaG91bGRuJ3QgY2hhbmdlKVxuICAgKiBVc2UgZGF0YSBsYXN0IHBhcmFtZXRlcnMgdG8gYWxsb3cgZm9yIGN1cnJ5aW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3VmZml4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICovXG5cbiAgdmFyIHN1ZmZpeFByb3BOYW1lID0gZnVuY3Rpb24gc3VmZml4UHJvcE5hbWUoc3VmZml4LCBzdHIpIHtcbiAgICByZXR1cm4gc3RyICsgKHN1ZmZpeCA/IHVwcGVyRmlyc3Qoc3VmZml4KSA6ICcnKTtcbiAgfTtcblxuICB2YXIgUlhfQ09MX0NMQVNTID0gL15jb2wtLzsgLy8gR2VuZXJhdGVzIGEgcHJvcCBvYmplY3Qgd2l0aCBhIHR5cGUgb2YgYFtCb29sZWFuLCBTdHJpbmcsIE51bWJlcl1gXG5cbiAgdmFyIGJvb2xTdHJOdW0gPSBmdW5jdGlvbiBib29sU3RyTnVtKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9O1xuICB9OyAvLyBHZW5lcmF0ZXMgYSBwcm9wIG9iamVjdCB3aXRoIGEgdHlwZSBvZiBgW1N0cmluZywgTnVtYmVyXWBcblxuXG4gIHZhciBzdHJOdW0gPSBmdW5jdGlvbiBzdHJOdW0oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfTtcbiAgfTsgLy8gQ29tcHV0ZSBhIGJyZWFrcG9pbnQgY2xhc3MgbmFtZVxuXG5cbiAgdmFyIGNvbXB1dGVCcmVha3BvaW50ID0gZnVuY3Rpb24gY29tcHV0ZUJyZWFrcG9pbnQodHlwZSwgYnJlYWtwb2ludCwgdmFsKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHR5cGU7XG5cbiAgICBpZiAoaXNVbmRlZmluZWRPck51bGwodmFsKSB8fCB2YWwgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChicmVha3BvaW50KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCItXCIuY29uY2F0KGJyZWFrcG9pbnQpO1xuICAgIH0gLy8gSGFuZGxpbmcgdGhlIGJvb2xlYW4gc3R5bGUgcHJvcCB3aGVuIGFjY2VwdGluZyBbQm9vbGVhbiwgU3RyaW5nLCBOdW1iZXJdXG4gICAgLy8gbWVhbnMgVnVlIHdpbGwgbm90IGNvbnZlcnQgPGItY29sIHNtPjwvYi1jb2w+IHRvIHNtOiB0cnVlIGZvciB1cy5cbiAgICAvLyBTaW5jZSB0aGUgZGVmYXVsdCBpcyBmYWxzZSwgYW4gZW1wdHkgc3RyaW5nIGluZGljYXRlcyB0aGUgcHJvcCdzIHByZXNlbmNlLlxuXG5cbiAgICBpZiAodHlwZSA9PT0gJ2NvbCcgJiYgKHZhbCA9PT0gJycgfHwgdmFsID09PSB0cnVlKSkge1xuICAgICAgLy8gLmNvbC1tZFxuICAgICAgcmV0dXJuIGxvd2VyQ2FzZShjbGFzc05hbWUpO1xuICAgIH0gLy8gLm9yZGVyLW1kLTZcblxuXG4gICAgY2xhc3NOYW1lICs9IFwiLVwiLmNvbmNhdCh2YWwpO1xuICAgIHJldHVybiBsb3dlckNhc2UoY2xhc3NOYW1lKTtcbiAgfTsgLy8gTWVtb2l6ZWQgZnVuY3Rpb24gZm9yIGJldHRlciBwZXJmb3JtYW5jZSBvbiBnZW5lcmF0aW5nIGNsYXNzIG5hbWVzXG5cblxuICB2YXIgY29tcHV0ZUJyZWFrcG9pbnRDbGFzcyA9IG1lbW9pemUoY29tcHV0ZUJyZWFrcG9pbnQpOyAvLyBDYWNoZWQgY29weSBvZiB0aGUgYnJlYWtwb2ludCBwcm9wIG5hbWVzXG5cbiAgdmFyIGJyZWFrcG9pbnRQcm9wTWFwID0gY3JlYXRlKG51bGwpOyAvLyBMYXp5IGV2YWxlZCBwcm9wcyBmYWN0b3J5IGZvciBCQ29sXG5cbiAgdmFyIGdlbmVyYXRlUHJvcHMgPSBmdW5jdGlvbiBnZW5lcmF0ZVByb3BzKCkge1xuICAgIC8vIEdyYWIgdGhlIGJyZWFrcG9pbnRzIGZyb20gdGhlIGNhY2hlZCBjb25maWcgKGV4Y2x1ZGUgdGhlICcnICh4cykgYnJlYWtwb2ludClcbiAgICB2YXIgYnJlYWtwb2ludHMgPSBnZXRCcmVha3BvaW50c1VwQ2FjaGVkKCkuZmlsdGVyKGlkZW50aXR5KTsgLy8gU3VwcG9ydHMgY2xhc3NlcyBsaWtlOiAuY29sLXNtLCAuY29sLW1kLTYsIC5jb2wtbGctYXV0b1xuXG4gICAgdmFyIGJyZWFrcG9pbnRDb2wgPSBicmVha3BvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHByb3BNYXAsIGJyZWFrcG9pbnQpIHtcbiAgICAgIGlmIChicmVha3BvaW50KSB7XG4gICAgICAgIC8vIFdlIGZpbHRlciBvdXQgdGhlICcnIGJyZWFrcG9pbnQgKHhzKSwgYXMgbWFraW5nIGEgcHJvcCBuYW1lICcnXG4gICAgICAgIC8vIHdvdWxkIG5vdCB3b3JrLiBUaGUgYGNvbHNgIHByb3AgaXMgdXNlZCBmb3IgYHhzYFxuICAgICAgICBwcm9wTWFwW2JyZWFrcG9pbnRdID0gYm9vbFN0ck51bSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcE1hcDtcbiAgICB9LCBjcmVhdGUobnVsbCkpOyAvLyBTdXBwb3J0cyBjbGFzc2VzIGxpa2U6IC5vZmZzZXQtbWQtMSwgLm9mZnNldC1sZy0xMlxuXG4gICAgdmFyIGJyZWFrcG9pbnRPZmZzZXQgPSBicmVha3BvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHByb3BNYXAsIGJyZWFrcG9pbnQpIHtcbiAgICAgIHByb3BNYXBbc3VmZml4UHJvcE5hbWUoYnJlYWtwb2ludCwgJ29mZnNldCcpXSA9IHN0ck51bSgpO1xuICAgICAgcmV0dXJuIHByb3BNYXA7XG4gICAgfSwgY3JlYXRlKG51bGwpKTsgLy8gU3VwcG9ydHMgY2xhc3NlcyBsaWtlOiAub3JkZXItbWQtMSwgLm9yZGVyLWxnLTEyXG5cbiAgICB2YXIgYnJlYWtwb2ludE9yZGVyID0gYnJlYWtwb2ludHMucmVkdWNlKGZ1bmN0aW9uIChwcm9wTWFwLCBicmVha3BvaW50KSB7XG4gICAgICBwcm9wTWFwW3N1ZmZpeFByb3BOYW1lKGJyZWFrcG9pbnQsICdvcmRlcicpXSA9IHN0ck51bSgpO1xuICAgICAgcmV0dXJuIHByb3BNYXA7XG4gICAgfSwgY3JlYXRlKG51bGwpKTsgLy8gRm9yIGxvb3AgZG9lc24ndCBuZWVkIHRvIGNoZWNrIGhhc093blByb3BlcnR5XG4gICAgLy8gd2hlbiB1c2luZyBhbiBvYmplY3QgY3JlYXRlZCBmcm9tIG51bGxcblxuICAgIGJyZWFrcG9pbnRQcm9wTWFwID0gYXNzaWduKGNyZWF0ZShudWxsKSwge1xuICAgICAgY29sOiBrZXlzKGJyZWFrcG9pbnRDb2wpLFxuICAgICAgb2Zmc2V0OiBrZXlzKGJyZWFrcG9pbnRPZmZzZXQpLFxuICAgICAgb3JkZXI6IGtleXMoYnJlYWtwb2ludE9yZGVyKVxuICAgIH0pOyAvLyBSZXR1cm4gdGhlIGdlbmVyYXRlZCBwcm9wc1xuXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIC8vIEdlbmVyaWMgZmxleGJveCAuY29sICh4cylcbiAgICAgIGNvbDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIC8vIC5jb2wtWzEtMTJdfGF1dG8gICh4cylcbiAgICAgIGNvbHM6IHN0ck51bSgpXG4gICAgfSwgYnJlYWtwb2ludENvbCwge1xuICAgICAgb2Zmc2V0OiBzdHJOdW0oKVxuICAgIH0sIGJyZWFrcG9pbnRPZmZzZXQsIHtcbiAgICAgIG9yZGVyOiBzdHJOdW0oKVxuICAgIH0sIGJyZWFrcG9pbnRPcmRlciwge1xuICAgICAgLy8gRmxleCBhbGlnbm1lbnRcbiAgICAgIGFsaWduU2VsZjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHN0cikge1xuICAgICAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKFsnYXV0bycsICdzdGFydCcsICdlbmQnLCAnY2VudGVyJywgJ2Jhc2VsaW5lJywgJ3N0cmV0Y2gnXSwgc3RyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRhZzoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICdkaXYnXG4gICAgICB9XG4gICAgfSk7XG4gIH07IC8vIFdlIGRvIG5vdCB1c2UgVnVlLmV4dGVuZCBoZXJlIGFzIHRoYXQgd291bGQgZXZhbHVhdGUgdGhlIHByb3BzXG4gIC8vIGltbWVkaWF0ZWx5LCB3aGljaCB3ZSBkbyBub3Qgd2FudCB0byBoYXBwZW5cbiAgLy8gQHZ1ZS9jb21wb25lbnRcblxuXG4gIHZhciBCQ29sID0ge1xuICAgIG5hbWU6ICdCQ29sJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuXG4gICAgZ2V0IHByb3BzKCkge1xuICAgICAgLy8gQWxsb3cgcHJvcHMgdG8gYmUgbGF6eSBldmFsZWQgb24gZmlyc3QgYWNjZXNzIGFuZFxuICAgICAgLy8gdGhlbiB0aGV5IGJlY29tZSBhIG5vbi1nZXR0ZXIgYWZ0ZXJ3YXJkcy5cbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Z1bmN0aW9ucy9nZXQjU21hcnRfc2VsZi1vdmVyd3JpdGluZ19sYXp5X2dldHRlcnNcbiAgICAgIGRlbGV0ZSB0aGlzLnByb3BzOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmV0dXJuLWFzc2lnblxuXG4gICAgICByZXR1cm4gdGhpcy5wcm9wcyA9IGdlbmVyYXRlUHJvcHMoKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX3JlZikge1xuICAgICAgdmFyIF9jbGFzc0xpc3QkcHVzaDtcblxuICAgICAgdmFyIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgICAgIHZhciBjbGFzc0xpc3QgPSBbXTsgLy8gTG9vcCB0aHJvdWdoIGBjb2xgLCBgb2Zmc2V0YCwgYG9yZGVyYCBicmVha3BvaW50IHByb3BzXG5cbiAgICAgIGZvciAodmFyIHR5cGUgaW4gYnJlYWtwb2ludFByb3BNYXApIHtcbiAgICAgICAgLy8gUmV0dXJucyBjb2xTbSwgb2Zmc2V0LCBvZmZzZXRTbSwgb3JkZXJNZCwgZXRjLlxuICAgICAgICB2YXIgX2tleXMgPSBicmVha3BvaW50UHJvcE1hcFt0eXBlXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9rZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gY29tcHV0ZUJyZWFrcG9pbnQoY29sLCBjb2xTbSA9PiBTbSwgdmFsdWU9W1N0cmluZywgTnVtYmVyLCBCb29sZWFuXSlcbiAgICAgICAgICB2YXIgYyA9IGNvbXB1dGVCcmVha3BvaW50Q2xhc3ModHlwZSwgX2tleXNbaV0ucmVwbGFjZSh0eXBlLCAnJyksIHByb3BzW19rZXlzW2ldXSk7IC8vIElmIGEgY2xhc3MgaXMgcmV0dXJuZWQsIHB1c2ggaXQgb250byB0aGUgYXJyYXkuXG5cbiAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgY2xhc3NMaXN0LnB1c2goYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNDb2xDbGFzc2VzID0gY2xhc3NMaXN0LnNvbWUoZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gUlhfQ09MX0NMQVNTLnRlc3QoY2xhc3NOYW1lKTtcbiAgICAgIH0pO1xuICAgICAgY2xhc3NMaXN0LnB1c2goKF9jbGFzc0xpc3QkcHVzaCA9IHtcbiAgICAgICAgLy8gRGVmYXVsdCB0byAuY29sIGlmIG5vIG90aGVyIGNvbC17YnB9LSogY2xhc3NlcyBnZW5lcmF0ZWQgbm9yIGBjb2xzYCBzcGVjaWZpZWQuXG4gICAgICAgIGNvbDogcHJvcHMuY29sIHx8ICFoYXNDb2xDbGFzc2VzICYmICFwcm9wcy5jb2xzXG4gICAgICB9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTGlzdCRwdXNoLCBcImNvbC1cIi5jb25jYXQocHJvcHMuY29scyksIHByb3BzLmNvbHMpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTGlzdCRwdXNoLCBcIm9mZnNldC1cIi5jb25jYXQocHJvcHMub2Zmc2V0KSwgcHJvcHMub2Zmc2V0KSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc0xpc3QkcHVzaCwgXCJvcmRlci1cIi5jb25jYXQocHJvcHMub3JkZXIpLCBwcm9wcy5vcmRlciksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NMaXN0JHB1c2gsIFwiYWxpZ24tc2VsZi1cIi5jb25jYXQocHJvcHMuYWxpZ25TZWxmKSwgcHJvcHMuYWxpZ25TZWxmKSwgX2NsYXNzTGlzdCRwdXNoKSk7XG4gICAgICByZXR1cm4gaChwcm9wcy50YWcsIGEoZGF0YSwge1xuICAgICAgICBjbGFzczogY2xhc3NMaXN0XG4gICAgICB9KSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgTkFNRSRmID0gJ0JGb3JtR3JvdXAnOyAvLyBTZWxlY3RvciBmb3IgZmluZGluZyBmaXJzdCBpbnB1dCBpbiB0aGUgZm9ybS1ncm91cFxuXG4gIHZhciBTRUxFQ1RPUiQxID0gJ2lucHV0Om5vdChbZGlzYWJsZWRdKSx0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksc2VsZWN0Om5vdChbZGlzYWJsZWRdKSc7IC8vIFJlbmRlciBoZWxwZXIgZnVuY3Rpb25zIChoZXJlIHJhdGhlciB0aGFuIHBvbGx1dGluZyB0aGUgaW5zdGFuY2Ugd2l0aCBtb3JlIG1ldGhvZHMpXG5cbiAgdmFyIHJlbmRlckludmFsaWRGZWVkYmFjayA9IGZ1bmN0aW9uIHJlbmRlckludmFsaWRGZWVkYmFjayhoLCBjdHgpIHtcbiAgICB2YXIgY29udGVudCA9IGN0eC5ub3JtYWxpemVTbG90KCdpbnZhbGlkLWZlZWRiYWNrJykgfHwgY3R4LmludmFsaWRGZWVkYmFjaztcbiAgICB2YXIgaW52YWxpZEZlZWRiYWNrID0gaCgpO1xuXG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIGludmFsaWRGZWVkYmFjayA9IGgoQkZvcm1JbnZhbGlkRmVlZGJhY2ssIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBpZDogY3R4LmludmFsaWRGZWVkYmFja0lkLFxuICAgICAgICAgIC8vIElmIHN0YXRlIGlzIGV4cGxpY2l0bHkgZmFsc2UsIGFsd2F5cyBzaG93IHRoZSBmZWVkYmFja1xuICAgICAgICAgIHN0YXRlOiBjdHguY29tcHV0ZWRTdGF0ZSxcbiAgICAgICAgICB0b29sdGlwOiBjdHgudG9vbHRpcCxcbiAgICAgICAgICBhcmlhTGl2ZTogY3R4LmZlZWRiYWNrQXJpYUxpdmUsXG4gICAgICAgICAgcm9sZTogY3R4LmZlZWRiYWNrQXJpYUxpdmUgPyAnYWxlcnQnIDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHRhYmluZGV4OiBjb250ZW50ID8gJy0xJyA6IG51bGxcbiAgICAgICAgfVxuICAgICAgfSwgW2NvbnRlbnRdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW52YWxpZEZlZWRiYWNrO1xuICB9O1xuXG4gIHZhciByZW5kZXJWYWxpZEZlZWRiYWNrID0gZnVuY3Rpb24gcmVuZGVyVmFsaWRGZWVkYmFjayhoLCBjdHgpIHtcbiAgICB2YXIgY29udGVudCA9IGN0eC5ub3JtYWxpemVTbG90KCd2YWxpZC1mZWVkYmFjaycpIHx8IGN0eC52YWxpZEZlZWRiYWNrO1xuICAgIHZhciB2YWxpZEZlZWRiYWNrID0gaCgpO1xuXG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIHZhbGlkRmVlZGJhY2sgPSBoKEJGb3JtVmFsaWRGZWVkYmFjaywge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGlkOiBjdHgudmFsaWRGZWVkYmFja0lkLFxuICAgICAgICAgIC8vIElmIHN0YXRlIGlzIGV4cGxpY2l0bHkgdHJ1ZSwgYWx3YXlzIHNob3cgdGhlIGZlZWRiYWNrXG4gICAgICAgICAgc3RhdGU6IGN0eC5jb21wdXRlZFN0YXRlLFxuICAgICAgICAgIHRvb2x0aXA6IGN0eC50b29sdGlwLFxuICAgICAgICAgIGFyaWFMaXZlOiBjdHguZmVlZGJhY2tBcmlhTGl2ZSxcbiAgICAgICAgICByb2xlOiBjdHguZmVlZGJhY2tBcmlhTGl2ZSA/ICdhbGVydCcgOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgdGFiaW5kZXg6IGNvbnRlbnQgPyAnLTEnIDogbnVsbFxuICAgICAgICB9XG4gICAgICB9LCBbY29udGVudF0pO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZEZlZWRiYWNrO1xuICB9O1xuXG4gIHZhciByZW5kZXJIZWxwVGV4dCA9IGZ1bmN0aW9uIHJlbmRlckhlbHBUZXh0KGgsIGN0eCkge1xuICAgIC8vIEZvcm0gaGVscCB0ZXh0IChkZXNjcmlwdGlvbilcbiAgICB2YXIgY29udGVudCA9IGN0eC5ub3JtYWxpemVTbG90KCdkZXNjcmlwdGlvbicpIHx8IGN0eC5kZXNjcmlwdGlvbjtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSBoKCk7XG5cbiAgICBpZiAoY29udGVudCkge1xuICAgICAgZGVzY3JpcHRpb24gPSBoKEJGb3JtVGV4dCwge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiBjdHguZGVzY3JpcHRpb25JZCxcbiAgICAgICAgICB0YWJpbmRleDogY29udGVudCA/ICctMScgOiBudWxsXG4gICAgICAgIH1cbiAgICAgIH0sIFtjb250ZW50XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICB9O1xuXG4gIHZhciByZW5kZXJMYWJlbCA9IGZ1bmN0aW9uIHJlbmRlckxhYmVsKGgsIGN0eCkge1xuICAgIC8vIFJlbmRlciBsYWJlbC9sZWdlbmQgaW5zaWRlIGItY29sIGlmIG5lY2Vzc2FyeVxuICAgIHZhciBjb250ZW50ID0gY3R4Lm5vcm1hbGl6ZVNsb3QoJ2xhYmVsJykgfHwgY3R4LmxhYmVsO1xuICAgIHZhciBsYWJlbEZvciA9IGN0eC5sYWJlbEZvcjtcbiAgICB2YXIgaXNMZWdlbmQgPSAhbGFiZWxGb3I7XG4gICAgdmFyIGlzSG9yaXpvbnRhbCA9IGN0eC5pc0hvcml6b250YWw7XG4gICAgdmFyIGxhYmVsVGFnID0gaXNMZWdlbmQgPyAnbGVnZW5kJyA6ICdsYWJlbCc7XG5cbiAgICBpZiAoIWNvbnRlbnQgJiYgIWlzSG9yaXpvbnRhbCkge1xuICAgICAgcmV0dXJuIGgoKTtcbiAgICB9IGVsc2UgaWYgKGN0eC5sYWJlbFNyT25seSkge1xuICAgICAgdmFyIGxhYmVsID0gaCgpO1xuXG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICBsYWJlbCA9IGgobGFiZWxUYWcsIHtcbiAgICAgICAgICBjbGFzczogJ3NyLW9ubHknLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBpZDogY3R4LmxhYmVsSWQsXG4gICAgICAgICAgICBmb3I6IGxhYmVsRm9yIHx8IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFtjb250ZW50XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoKGlzSG9yaXpvbnRhbCA/IEJDb2wgOiAnZGl2Jywge1xuICAgICAgICBwcm9wczogaXNIb3Jpem9udGFsID8gY3R4LmxhYmVsQ29sUHJvcHMgOiB7fVxuICAgICAgfSwgW2xhYmVsXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBoKGlzSG9yaXpvbnRhbCA/IEJDb2wgOiBsYWJlbFRhZywge1xuICAgICAgICBvbjogaXNMZWdlbmQgPyB7XG4gICAgICAgICAgY2xpY2s6IGN0eC5sZWdlbmRDbGlja1xuICAgICAgICB9IDoge30sXG4gICAgICAgIHByb3BzOiBpc0hvcml6b250YWwgPyBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgdGFnOiBsYWJlbFRhZ1xuICAgICAgICB9LCBjdHgubGFiZWxDb2xQcm9wcykgOiB7fSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBpZDogY3R4LmxhYmVsSWQsXG4gICAgICAgICAgZm9yOiBsYWJlbEZvciB8fCBudWxsLFxuICAgICAgICAgIC8vIFdlIGFkZCBhIHRhYiBpbmRleCB0byBsZWdlbmQgc28gdGhhdCBzY3JlZW4gcmVhZGVyc1xuICAgICAgICAgIC8vIHdpbGwgcHJvcGVybHkgcmVhZCB0aGUgYXJpYS1sYWJlbGxlZGJ5IGluIElFLlxuICAgICAgICAgIHRhYmluZGV4OiBpc0xlZ2VuZCA/ICctMScgOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzOiBbLy8gSGlkZSB0aGUgZm9jdXMgcmluZyBvbiB0aGUgbGVnZW5kXG4gICAgICAgIGlzTGVnZW5kID8gJ2J2LW5vLWZvY3VzLXJpbmcnIDogJycsIC8vIFdoZW4gaG9yaXpvbnRhbCBvciBpZiBhIGxlZ2VuZCBpcyByZW5kZXJlZCwgYWRkIGNvbC1mb3JtLWxhYmVsXG4gICAgICAgIC8vIGZvciBjb3JyZWN0IHNpemluZyBhcyBCb290c3RyYXAgaGFzIGluY29uc2lzdGVudCBmb250IHN0eWxpbmdcbiAgICAgICAgLy8gZm9yIGxlZ2VuZCBpbiBub24taG9yaXpvbnRhbCBmb3JtLWdyb3Vwcy5cbiAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvaXNzdWVzLzI3ODA1XG4gICAgICAgIGlzSG9yaXpvbnRhbCB8fCBpc0xlZ2VuZCA/ICdjb2wtZm9ybS1sYWJlbCcgOiAnJywgLy8gRW11bGF0ZSBsYWJlbCBwYWRkaW5nIHRvcCBvZiAwIG9uIGxlZ2VuZCB3aGVuIG5vdCBob3Jpem9udGFsXG4gICAgICAgICFpc0hvcml6b250YWwgJiYgaXNMZWdlbmQgPyAncHQtMCcgOiAnJywgLy8gSWYgbm90IGhvcml6b250YWwgYW5kIG5vdCBhIGxlZ2VuZCwgd2UgYWRkIGQtYmxvY2sgdG8gbGFiZWxcbiAgICAgICAgLy8gc28gdGhhdCBsYWJlbC1hbGlnbiB3b3Jrc1xuICAgICAgICAhaXNIb3Jpem9udGFsICYmICFpc0xlZ2VuZCA/ICdkLWJsb2NrJyA6ICcnLCBjdHgubGFiZWxTaXplID8gXCJjb2wtZm9ybS1sYWJlbC1cIi5jb25jYXQoY3R4LmxhYmVsU2l6ZSkgOiAnJywgY3R4LmxhYmVsQWxpZ25DbGFzc2VzLCBjdHgubGFiZWxDbGFzc11cbiAgICAgIH0sIFtjb250ZW50XSk7XG4gICAgfVxuICB9OyAvLyAtLSBCRm9ybUdyb3VwIFByb3AgZmFjdG9yeSAtLSB1c2VkIGZvciBsYXp5IGdlbmVyYXRpb24gb2YgcHJvcHNcbiAgLy8gTWVtb2l6ZSB0aGlzIGZ1bmN0aW9uIHRvIHJldHVybiBjYWNoZWQgdmFsdWVzIHRvXG4gIC8vIHNhdmUgdGltZSBpbiBjb21wdXRlZCBmdW5jdGlvbnNcblxuXG4gIHZhciBtYWtlUHJvcE5hbWUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYnJlYWtwb2ludCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gICAgdmFyIHByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChwcmVmaXgpLmNvbmNhdCh1cHBlckZpcnN0KGJyZWFrcG9pbnQpKTtcbiAgfSk7IC8vIEJGb3JtR3JvdXAgcHJvcCBnZW5lcmF0b3IgZm9yIGxhenkgZ2VuZXJhdGlvbiBvZiBwcm9wc1xuXG4gIHZhciBnZW5lcmF0ZVByb3BzJDEgPSBmdW5jdGlvbiBnZW5lcmF0ZVByb3BzKCkge1xuICAgIHZhciBCUkVBS1BPSU5UUyA9IGdldEJyZWFrcG9pbnRzVXBDYWNoZWQoKTsgLy8gR2VuZXJhdGUgdGhlIGxhYmVsQ29sIGJyZWFrcG9pbnQgcHJvcHNcblxuICAgIHZhciBicExhYmVsQ29sUHJvcHMgPSBCUkVBS1BPSU5UUy5yZWR1Y2UoZnVuY3Rpb24gKHByb3BzLCBicmVha3BvaW50KSB7XG4gICAgICAvLyBpLmUuIGxhYmVsLWNvbHMsIGxhYmVsLWNvbHMtc20sIGxhYmVsLWNvbHMtbWQsIC4uLlxuICAgICAgcHJvcHNbbWFrZVByb3BOYW1lKGJyZWFrcG9pbnQsICdsYWJlbENvbHMnKV0gPSB7XG4gICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZywgQm9vbGVhbl0sXG4gICAgICAgIGRlZmF1bHQ6IGJyZWFrcG9pbnQgPyBmYWxzZSA6IG51bGxcbiAgICAgIH07XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfSwgY3JlYXRlKG51bGwpKTsgLy8gR2VuZXJhdGUgdGhlIGxhYmVsQWxpZ24gYnJlYWtwb2ludCBwcm9wc1xuXG4gICAgdmFyIGJwTGFiZWxBbGlnblByb3BzID0gQlJFQUtQT0lOVFMucmVkdWNlKGZ1bmN0aW9uIChwcm9wcywgYnJlYWtwb2ludCkge1xuICAgICAgLy8gbGFiZWwtYWxpZ24sIGxhYmVsLWFsaWduLXNtLCBsYWJlbC1hbGlnbi1tZCwgLi4uXG4gICAgICBwcm9wc1ttYWtlUHJvcE5hbWUoYnJlYWtwb2ludCwgJ2xhYmVsQWxpZ24nKV0gPSB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgLy8gbGVmdCwgcmlnaHQsIGNlbnRlclxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH0sIGNyZWF0ZShudWxsKSk7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIGxhYmVsRm9yOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIGxhYmVsU2l6ZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBsYWJlbFNyT25seToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfVxuICAgIH0sIGJwTGFiZWxDb2xQcm9wcywge30sIGJwTGFiZWxBbGlnblByb3BzLCB7XG4gICAgICBsYWJlbENsYXNzOiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgaW52YWxpZEZlZWRiYWNrOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHZhbGlkRmVlZGJhY2s6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgdG9vbHRpcDoge1xuICAgICAgICAvLyBFbmFibGUgdG9vbHRpcCBzdHlsZSBmZWVkYmFja1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGZlZWRiYWNrQXJpYUxpdmU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnYXNzZXJ0aXZlJ1xuICAgICAgfSxcbiAgICAgIHZhbGlkYXRlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gIH07IC8vIFdlIGRvIG5vdCB1c2UgVnVlLmV4dGVuZCBoZXJlIGFzIHRoYXQgd291bGQgZXZhbHVhdGUgdGhlIHByb3BzXG4gIC8vIGltbWVkaWF0ZWx5LCB3aGljaCB3ZSBkbyBub3Qgd2FudCB0byBoYXBwZW5cbiAgLy8gQHZ1ZS9jb21wb25lbnRcblxuXG4gIHZhciBCRm9ybUdyb3VwID0ge1xuICAgIG5hbWU6IE5BTUUkZixcbiAgICBtaXhpbnM6IFtpZE1peGluLCBmb3JtU3RhdGVNaXhpbiwgbm9ybWFsaXplU2xvdE1peGluXSxcblxuICAgIGdldCBwcm9wcygpIHtcbiAgICAgIC8vIEFsbG93IHByb3BzIHRvIGJlIGxhenkgZXZhbGVkIG9uIGZpcnN0IGFjY2VzcyBhbmRcbiAgICAgIC8vIHRoZW4gdGhleSBiZWNvbWUgYSBub24tZ2V0dGVyIGFmdGVyd2FyZHMuXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9GdW5jdGlvbnMvZ2V0I1NtYXJ0X3NlbGYtb3ZlcndyaXRpbmdfbGF6eV9nZXR0ZXJzXG4gICAgICBkZWxldGUgdGhpcy5wcm9wczsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJldHVybi1hc3NpZ25cblxuICAgICAgcmV0dXJuIHRoaXMucHJvcHMgPSBnZW5lcmF0ZVByb3BzJDEoKTtcbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGxhYmVsQ29sUHJvcHM6IGZ1bmN0aW9uIGxhYmVsQ29sUHJvcHMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICAgIGdldEJyZWFrcG9pbnRzVXBDYWNoZWQoKS5mb3JFYWNoKGZ1bmN0aW9uIChicmVha3BvaW50KSB7XG4gICAgICAgICAgLy8gR3JhYiB0aGUgdmFsdWUgaWYgdGhlIGxhYmVsIGNvbHVtbiBicmVha3BvaW50IHByb3BcbiAgICAgICAgICB2YXIgcHJvcFZhbCA9IF90aGlzW21ha2VQcm9wTmFtZShicmVha3BvaW50LCAnbGFiZWxDb2xzJyldOyAvLyBIYW5kbGUgY2FzZSB3aGVyZSB0aGUgcHJvcCdzIHZhbHVlIGlzIGFuIGVtcHR5IHN0cmluZyxcbiAgICAgICAgICAvLyB3aGljaCByZXByZXNlbnRzIHRydWVcblxuXG4gICAgICAgICAgcHJvcFZhbCA9IHByb3BWYWwgPT09ICcnID8gdHJ1ZSA6IHByb3BWYWwgfHwgZmFsc2U7XG5cbiAgICAgICAgICBpZiAoIWlzQm9vbGVhbihwcm9wVmFsKSAmJiBwcm9wVmFsICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gY29sdW1uIHNpemUgdG8gbnVtYmVyXG4gICAgICAgICAgICBwcm9wVmFsID0gcGFyc2VJbnQocHJvcFZhbCwgMTApIHx8IDA7IC8vIEVuc3VyZSBjb2x1bW4gc2l6ZSBpcyBncmVhdGVyIHRoYW4gMFxuXG4gICAgICAgICAgICBwcm9wVmFsID0gcHJvcFZhbCA+IDAgPyBwcm9wVmFsIDogZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHByb3BWYWwpIHtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgcHJvcCB0byB0aGUgbGlzdCBvZiBwcm9wcyB0byBnaXZlIHRvIGItY29sXG4gICAgICAgICAgICAvLyBJZiBicmVha3BvaW50IGlzICcnIChsYWJlbENvbHM9dHJ1ZSksIHRoZW4gd2UgdXNlIHRoZVxuICAgICAgICAgICAgLy8gY29sIHByb3AgdG8gbWFrZSBlcXVhbCB3aWR0aCBhdCB4c1xuICAgICAgICAgICAgdmFyIGJDb2xQcm9wTmFtZSA9IGJyZWFrcG9pbnQgfHwgKGlzQm9vbGVhbihwcm9wVmFsKSA/ICdjb2wnIDogJ2NvbHMnKTsgLy8gQWRkIGl0IHRvIHRoZSBwcm9wc1xuXG4gICAgICAgICAgICBwcm9wc1tiQ29sUHJvcE5hbWVdID0gcHJvcFZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICB9LFxuICAgICAgbGFiZWxBbGlnbkNsYXNzZXM6IGZ1bmN0aW9uIGxhYmVsQWxpZ25DbGFzc2VzKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgY2xhc3NlcyA9IFtdO1xuICAgICAgICBnZXRCcmVha3BvaW50c1VwQ2FjaGVkKCkuZm9yRWFjaChmdW5jdGlvbiAoYnJlYWtwb2ludCkge1xuICAgICAgICAgIC8vIEFzc2VtYmxlIHRoZSBsYWJlbCBjb2x1bW4gYnJlYWtwb2ludCBhbGlnbiBjbGFzc2VzXG4gICAgICAgICAgdmFyIHByb3BWYWwgPSBfdGhpczJbbWFrZVByb3BOYW1lKGJyZWFrcG9pbnQsICdsYWJlbEFsaWduJyldIHx8IG51bGw7XG5cbiAgICAgICAgICBpZiAocHJvcFZhbCkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGJyZWFrcG9pbnQgPyBcInRleHQtXCIuY29uY2F0KGJyZWFrcG9pbnQsIFwiLVwiKS5jb25jYXQocHJvcFZhbCkgOiBcInRleHQtXCIuY29uY2F0KHByb3BWYWwpO1xuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsYXNzZXM7XG4gICAgICB9LFxuICAgICAgaXNIb3Jpem9udGFsOiBmdW5jdGlvbiBpc0hvcml6b250YWwoKSB7XG4gICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgcmVzdWx0YW50IGZvcm0tZ3JvdXAgd2lsbCBiZSByZW5kZXJlZFxuICAgICAgICAvLyBob3Jpem9udGFsIChtZWFuaW5nIGl0IGhhcyBsYWJlbC1jb2wgYnJlYWtwb2ludHMpXG4gICAgICAgIHJldHVybiBrZXlzKHRoaXMubGFiZWxDb2xQcm9wcykubGVuZ3RoID4gMDtcbiAgICAgIH0sXG4gICAgICBsYWJlbElkOiBmdW5jdGlvbiBsYWJlbElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNOb3JtYWxpemVkU2xvdCgnbGFiZWwnKSB8fCB0aGlzLmxhYmVsID8gdGhpcy5zYWZlSWQoJ19CVl9sYWJlbF8nKSA6IG51bGw7XG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb25JZDogZnVuY3Rpb24gZGVzY3JpcHRpb25JZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzTm9ybWFsaXplZFNsb3QoJ2Rlc2NyaXB0aW9uJykgfHwgdGhpcy5kZXNjcmlwdGlvbiA/IHRoaXMuc2FmZUlkKCdfQlZfZGVzY3JpcHRpb25fJykgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIGhhc0ludmFsaWRGZWVkYmFjazogZnVuY3Rpb24gaGFzSW52YWxpZEZlZWRiYWNrKCkge1xuICAgICAgICAvLyBVc2VkIGZvciBjb21wdXRpbmcgYXJpYS1kZXNjcmliZWRieVxuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlZFN0YXRlID09PSBmYWxzZSAmJiAodGhpcy5oYXNOb3JtYWxpemVkU2xvdCgnaW52YWxpZC1mZWVkYmFjaycpIHx8IHRoaXMuaW52YWxpZEZlZWRiYWNrKTtcbiAgICAgIH0sXG4gICAgICBpbnZhbGlkRmVlZGJhY2tJZDogZnVuY3Rpb24gaW52YWxpZEZlZWRiYWNrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0ludmFsaWRGZWVkYmFjayA/IHRoaXMuc2FmZUlkKCdfQlZfZmVlZGJhY2tfaW52YWxpZF8nKSA6IG51bGw7XG4gICAgICB9LFxuICAgICAgaGFzVmFsaWRGZWVkYmFjazogZnVuY3Rpb24gaGFzVmFsaWRGZWVkYmFjaygpIHtcbiAgICAgICAgLy8gVXNlZCBmb3IgY29tcHV0aW5nIGFyaWEtZGVzY3JpYmVkYnlcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZWRTdGF0ZSA9PT0gdHJ1ZSAmJiAodGhpcy5oYXNOb3JtYWxpemVkU2xvdCgndmFsaWQtZmVlZGJhY2snKSB8fCB0aGlzLnZhbGlkRmVlZGJhY2spO1xuICAgICAgfSxcbiAgICAgIHZhbGlkRmVlZGJhY2tJZDogZnVuY3Rpb24gdmFsaWRGZWVkYmFja0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNWYWxpZEZlZWRiYWNrID8gdGhpcy5zYWZlSWQoJ19CVl9mZWVkYmFja192YWxpZF8nKSA6IG51bGw7XG4gICAgICB9LFxuICAgICAgZGVzY3JpYmVkQnlJZHM6IGZ1bmN0aW9uIGRlc2NyaWJlZEJ5SWRzKCkge1xuICAgICAgICAvLyBTY3JlZW4gcmVhZGVycyB3aWxsIHJlYWQgb3V0IGFueSBjb250ZW50IGxpbmtlZCB0byBieSBhcmlhLWRlc2NyaWJlZGJ5XG4gICAgICAgIC8vIGV2ZW4gaWYgdGhlIGNvbnRlbnQgaXMgaGlkZGVuIHdpdGggYGRpc3BsYXk6IG5vbmU7YCwgaGVuY2Ugd2Ugb25seSBpbmNsdWRlXG4gICAgICAgIC8vIGZlZWRiYWNrIElEcyBpZiB0aGUgZm9ybS1ncm91cCdzIHN0YXRlIGlzIGV4cGxpY2l0bHkgdmFsaWQgb3IgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIFt0aGlzLmRlc2NyaXB0aW9uSWQsIHRoaXMuaW52YWxpZEZlZWRiYWNrSWQsIHRoaXMudmFsaWRGZWVkYmFja0lkXS5maWx0ZXIoQm9vbGVhbikuam9pbignICcpIHx8IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgZGVzY3JpYmVkQnlJZHM6IGZ1bmN0aW9uIGRlc2NyaWJlZEJ5SWRzKGFkZCwgcmVtb3ZlKSB7XG4gICAgICAgIGlmIChhZGQgIT09IHJlbW92ZSkge1xuICAgICAgICAgIHRoaXMuc2V0SW5wdXREZXNjcmliZWRCeShhZGQsIHJlbW92ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBTZXQgdGhlIGFyaWEtZGVzY3JpYmVkYnkgSURzIG9uIHRoZSBpbnB1dCBzcGVjaWZpZWQgYnkgbGFiZWwtZm9yXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgaW4gYSBuZXh0VGljayB0byBlbnN1cmUgdGhlIGNoaWxkcmVuIGhhdmUgZmluaXNoZWQgcmVuZGVyaW5nXG4gICAgICAgIF90aGlzMy5zZXRJbnB1dERlc2NyaWJlZEJ5KF90aGlzMy5kZXNjcmliZWRCeUlkcyk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGxlZ2VuZENsaWNrOiBmdW5jdGlvbiBsZWdlbmRDbGljayhldnQpIHtcbiAgICAgICAgaWYgKHRoaXMubGFiZWxGb3IpIHtcbiAgICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBsYWJlbEZvciBpcyBzZXRcblxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBjbGlja2luZyBhIGxhYmVsIHdpbGwgZm9jdXMgdGhlIGlucHV0LCBzbyBubyBuZWVkIHRvIHRlc3QgKi9cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGFnTmFtZSA9IGV2dC50YXJnZXQgPyBldnQudGFyZ2V0LnRhZ05hbWUgOiAnJztcblxuICAgICAgICBpZiAoL14oaW5wdXR8c2VsZWN0fHRleHRhcmVhfGxhYmVsfGJ1dHRvbnxhKSQvaS50ZXN0KHRhZ05hbWUpKSB7XG4gICAgICAgICAgLy8gSWYgY2xpY2tlZCBhbiBpbnRlcmFjdGl2ZSBlbGVtZW50IGluc2lkZSBsZWdlbmQsXG4gICAgICAgICAgLy8gd2UganVzdCBsZXQgdGhlIGRlZmF1bHQgaGFwcGVuXG5cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbnB1dHMgPSBzZWxlY3RBbGwoU0VMRUNUT1IkMSwgdGhpcy4kcmVmcy5jb250ZW50KS5maWx0ZXIoaXNWaXNpYmxlKTtcblxuICAgICAgICBpZiAoaW5wdXRzICYmIGlucHV0cy5sZW5ndGggPT09IDEgJiYgaW5wdXRzWzBdLmZvY3VzKSB7XG4gICAgICAgICAgLy8gaWYgb25seSBhIHNpbmdsZSBpbnB1dCwgZm9jdXMgaXQsIGVtdWxhdGluZyBsYWJlbCBiZWhhdmlvdXJcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5wdXRzWzBdLmZvY3VzKCk7XG4gICAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldElucHV0RGVzY3JpYmVkQnk6IGZ1bmN0aW9uIHNldElucHV0RGVzY3JpYmVkQnkoYWRkLCByZW1vdmUpIHtcbiAgICAgICAgLy8gU2V0cyB0aGUgYGFyaWEtZGVzY3JpYmVkYnlgIGF0dHJpYnV0ZSBvbiB0aGUgaW5wdXQgaWYgbGFiZWwtZm9yIGlzIHNldC5cbiAgICAgICAgLy8gT3B0aW9uYWxseSBhY2NlcHRzIGEgc3RyaW5nIG9mIElEcyB0byByZW1vdmUgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIuXG4gICAgICAgIC8vIFByZXNlcnZlcyBhbnkgYXJpYS1kZXNjcmliZWRieSB2YWx1ZShzKSB1c2VyIG1heSBoYXZlIG9uIGlucHV0LlxuICAgICAgICBpZiAodGhpcy5sYWJlbEZvciAmJiBpc0Jyb3dzZXIpIHtcbiAgICAgICAgICB2YXIgaW5wdXQgPSBzZWxlY3QoXCIjXCIuY29uY2F0KHRoaXMubGFiZWxGb3IpLCB0aGlzLiRyZWZzLmNvbnRlbnQpO1xuXG4gICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgYWRiID0gJ2FyaWEtZGVzY3JpYmVkYnknO1xuICAgICAgICAgICAgdmFyIGlkcyA9IChnZXRBdHRyKGlucHV0LCBhZGIpIHx8ICcnKS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgYWRkID0gKGFkZCB8fCAnJykuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICAgIHJlbW92ZSA9IChyZW1vdmUgfHwgJycpLnNwbGl0KC9cXHMrLyk7IC8vIFVwZGF0ZSBJRCBsaXN0LCBwcmVzZXJ2aW5nIGFueSBvcmlnaW5hbCBJRHNcbiAgICAgICAgICAgIC8vIGFuZCBlbnN1cmluZyB0aGUgSUQncyBhcmUgdW5pcXVlXG5cbiAgICAgICAgICAgIGlkcyA9IGlkcy5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhYXJyYXlJbmNsdWRlcyhyZW1vdmUsIGlkKTtcbiAgICAgICAgICAgIH0pLmNvbmNhdChhZGQpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgICAgIGlkcyA9IGtleXMoaWRzLnJlZHVjZShmdW5jdGlvbiAobWVtbywgaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHt9LCBtZW1vLCBfZGVmaW5lUHJvcGVydHkoe30sIGlkLCB0cnVlKSk7XG4gICAgICAgICAgICB9LCB7fSkpLmpvaW4oJyAnKS50cmltKCk7XG5cbiAgICAgICAgICAgIGlmIChpZHMpIHtcbiAgICAgICAgICAgICAgc2V0QXR0cihpbnB1dCwgYWRiLCBpZHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTm8gSURzLCBzbyByZW1vdmUgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICByZW1vdmVBdHRyKGlucHV0LCBhZGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgdmFyIGlzRmllbGRzZXQgPSAhdGhpcy5sYWJlbEZvcjtcbiAgICAgIHZhciBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbDsgLy8gR2VuZXJhdGUgdGhlIGxhYmVsXG5cbiAgICAgIHZhciBsYWJlbCA9IHJlbmRlckxhYmVsKGgsIHRoaXMpOyAvLyBHZW5lcmF0ZSB0aGUgY29udGVudFxuXG4gICAgICB2YXIgY29udGVudCA9IGgoaXNIb3Jpem9udGFsID8gQkNvbCA6ICdkaXYnLCB7XG4gICAgICAgIHJlZjogJ2NvbnRlbnQnLFxuICAgICAgICAvLyBIaWRlIGZvY3VzIHJpbmdcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdidi1uby1mb2N1cy1yaW5nJyxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICB0YWJpbmRleDogaXNGaWVsZHNldCA/ICctMScgOiBudWxsLFxuICAgICAgICAgIHJvbGU6IGlzRmllbGRzZXQgPyAnZ3JvdXAnIDogbnVsbFxuICAgICAgICB9XG4gICAgICB9LCBbdGhpcy5ub3JtYWxpemVTbG90KCdkZWZhdWx0JykgfHwgaCgpLCByZW5kZXJJbnZhbGlkRmVlZGJhY2soaCwgdGhpcyksIHJlbmRlclZhbGlkRmVlZGJhY2soaCwgdGhpcyksIHJlbmRlckhlbHBUZXh0KGgsIHRoaXMpXSk7IC8vIENyZWF0ZSB0aGUgZm9ybS1ncm91cFxuXG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdmb3JtLWdyb3VwJyxcbiAgICAgICAgY2xhc3M6IFt0aGlzLnZhbGlkYXRlZCA/ICd3YXMtdmFsaWRhdGVkJyA6IG51bGwsIHRoaXMuc3RhdGVDbGFzc10sXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHRoaXMuc2FmZUlkKCksXG4gICAgICAgICAgZGlzYWJsZWQ6IGlzRmllbGRzZXQgPyB0aGlzLmRpc2FibGVkIDogbnVsbCxcbiAgICAgICAgICByb2xlOiBpc0ZpZWxkc2V0ID8gbnVsbCA6ICdncm91cCcsXG4gICAgICAgICAgJ2FyaWEtaW52YWxpZCc6IHRoaXMuY29tcHV0ZWRTdGF0ZSA9PT0gZmFsc2UgPyAndHJ1ZScgOiBudWxsLFxuICAgICAgICAgIC8vIE9ubHkgYXBwbHkgYXJpYS1sYWJlbGxlZGJ5IGlmIHdlIGFyZSBhIGhvcml6b250YWwgZmllbGRzZXRcbiAgICAgICAgICAvLyBhcyB0aGUgbGVnZW5kIGlzIG5vIGxvbmdlciBhIGRpcmVjdCBjaGlsZCBvZiBmaWVsZHNldFxuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBpc0ZpZWxkc2V0ICYmIGlzSG9yaXpvbnRhbCA/IHRoaXMubGFiZWxJZCA6IG51bGwsXG4gICAgICAgICAgLy8gT25seSBhcHBseSBhcmlhLWRlc2NyaWJlZGJ5IElEcyBpZiB3ZSBhcmUgYSBmaWVsZHNldFxuICAgICAgICAgIC8vIGFzIHRoZSBpbnB1dCB3aWxsIGhhdmUgdGhlIElEcyB3aGVuIG5vdCBhIGZpZWxkc2V0XG4gICAgICAgICAgJ2FyaWEtZGVzY3JpYmVkYnknOiBpc0ZpZWxkc2V0ID8gdGhpcy5kZXNjcmliZWRCeUlkcyA6IG51bGxcbiAgICAgICAgfVxuICAgICAgfTsgLy8gUmV0dXJuIGl0IHdyYXBwZWQgaW4gYSBmb3JtLWdyb3VwXG4gICAgICAvLyBOb3RlOiBGaWVsZHNldHMgZG8gbm90IHN1cHBvcnQgYWRkaW5nIGByb3dgIG9yIGBmb3JtLXJvd2AgZGlyZWN0bHlcbiAgICAgIC8vIHRvIHRoZW0gZHVlIHRvIGJyb3dzZXIgc3BlY2lmaWMgcmVuZGVyIGlzc3Vlcywgc28gd2UgbW92ZSB0aGUgYGZvcm0tcm93YFxuICAgICAgLy8gdG8gYW4gaW5uZXIgd3JhcHBlciBkaXYgd2hlbiBob3Jpem9udGFsIGFuZCB1c2luZyBhIGZpZWxkc2V0XG5cbiAgICAgIHJldHVybiBoKGlzRmllbGRzZXQgPyAnZmllbGRzZXQnIDogaXNIb3Jpem9udGFsID8gQkZvcm1Sb3cgOiAnZGl2JywgZGF0YSwgaXNIb3Jpem9udGFsICYmIGlzRmllbGRzZXQgPyBbaChCRm9ybVJvdywgW2xhYmVsLCBjb250ZW50XSldIDogW2xhYmVsLCBjb250ZW50XSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBGb3JtR3JvdXBQbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJGb3JtR3JvdXA6IEJGb3JtR3JvdXAsXG4gICAgICBCRm9ybUZpZWxkc2V0OiBCRm9ybUdyb3VwXG4gICAgfVxuICB9KTtcblxuICB2YXIgZm9ybVRleHRNaXhpbiA9IHtcbiAgICBtb2RlbDoge1xuICAgICAgcHJvcDogJ3ZhbHVlJyxcbiAgICAgIGV2ZW50OiAndXBkYXRlJ1xuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9LFxuICAgICAgYXJpYUludmFsaWQ6IHtcbiAgICAgICAgdHlwZTogW0Jvb2xlYW4sIFN0cmluZ10sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgcmVhZG9ubHk6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBwbGFpbnRleHQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBhdXRvY29tcGxldGU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgcGxhY2Vob2xkZXI6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgZm9ybWF0dGVyOiB7XG4gICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgbGF6eUZvcm1hdHRlcjoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHRyaW06IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBudW1iZXI6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBsYXp5OiB7XG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSBgdi1tb2RlbGAgb24gYmx1ci9jaGFuZ2UgZXZlbnRzXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZGVib3VuY2U6IHtcbiAgICAgICAgLy8gRGVib3VuY2UgdGltb3V0IChpbiBtcykuIE5vdCBhcHBsaWNhYmxlIHdpdGggYGxhenlgIHByb3BcbiAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgZGVmYXVsdDogMFxuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvY2FsVmFsdWU6IHRvU3RyaW5nJDEodGhpcy52YWx1ZSksXG4gICAgICAgIHZNb2RlbFZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGNvbXB1dGVkQ2xhc3M6IGZ1bmN0aW9uIGNvbXB1dGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgIC8vIFJhbmdlIGlucHV0IG5lZWRzIGNsYXNzIGBjdXN0b20tcmFuZ2VgXG4gICAgICAgICAgJ2N1c3RvbS1yYW5nZSc6IHRoaXMudHlwZSA9PT0gJ3JhbmdlJyxcbiAgICAgICAgICAvLyBgcGxhaW50ZXh0YCBub3Qgc3VwcG9ydGVkIGJ5IGB0eXBlPVwicmFuZ2VcImAgb3IgYHR5cGU9XCJjb2xvclwiYFxuICAgICAgICAgICdmb3JtLWNvbnRyb2wtcGxhaW50ZXh0JzogdGhpcy5wbGFpbnRleHQgJiYgdGhpcy50eXBlICE9PSAncmFuZ2UnICYmIHRoaXMudHlwZSAhPT0gJ2NvbG9yJyxcbiAgICAgICAgICAvLyBgZm9ybS1jb250cm9sYCBub3QgdXNlZCBieSBgdHlwZT1cInJhbmdlXCJgIG9yIGBwbGFpbnRleHRgXG4gICAgICAgICAgLy8gQWx3YXlzIHVzZWQgYnkgYHR5cGU9XCJjb2xvclwiYFxuICAgICAgICAgICdmb3JtLWNvbnRyb2wnOiAhdGhpcy5wbGFpbnRleHQgJiYgdGhpcy50eXBlICE9PSAncmFuZ2UnIHx8IHRoaXMudHlwZSA9PT0gJ2NvbG9yJ1xuICAgICAgICB9LCB0aGlzLnNpemVGb3JtQ2xhc3MsIHRoaXMuc3RhdGVDbGFzc107XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRBcmlhSW52YWxpZDogZnVuY3Rpb24gY29tcHV0ZWRBcmlhSW52YWxpZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFyaWFJbnZhbGlkIHx8IHRoaXMuYXJpYUludmFsaWQgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAvLyBgdGhpcy5hcmlhSW52YWxpZGAgaXMgYG51bGxgIG9yIGBmYWxzZWAgb3IgJ2ZhbHNlJ1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVkU3RhdGUgPT09IGZhbHNlID8gJ3RydWUnIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFyaWFJbnZhbGlkID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gVXNlciB3YW50cyBleHBsaWNpdCBgOmFyaWEtaW52YWxpZD1cInRydWVcImBcbiAgICAgICAgICByZXR1cm4gJ3RydWUnO1xuICAgICAgICB9IC8vIE1vc3QgbGlrZWx5IGEgc3RyaW5nIHZhbHVlICh3aGljaCBjb3VsZCBiZSB0aGUgc3RyaW5nICd0cnVlJylcblxuXG4gICAgICAgIHJldHVybiB0aGlzLmFyaWFJbnZhbGlkO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkRGVib3VuY2U6IGZ1bmN0aW9uIGNvbXB1dGVkRGVib3VuY2UoKSB7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGEgcG9zaXRpdmUgbnVtYmVyIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0b0ludGVnZXIodGhpcy5kZWJvdW5jZSkgfHwgMCwgMCk7XG4gICAgICB9LFxuICAgICAgaGFzRm9ybWF0dGVyOiBmdW5jdGlvbiBoYXNGb3JtYXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHRoaXMuZm9ybWF0dGVyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobmV3VmFsKSB7XG4gICAgICAgIHZhciBzdHJpbmdpZnlWYWx1ZSA9IHRvU3RyaW5nJDEobmV3VmFsKTtcblxuICAgICAgICBpZiAoc3RyaW5naWZ5VmFsdWUgIT09IHRoaXMubG9jYWxWYWx1ZSAmJiBuZXdWYWwgIT09IHRoaXMudk1vZGVsVmFsdWUpIHtcbiAgICAgICAgICAvLyBDbGVhciBhbnkgcGVuZGluZyBkZWJvdW5jZSB0aW1lb3V0LCBhcyB3ZSBhcmUgb3ZlcndyaXRpbmcgdGhlIHVzZXIgaW5wdXRcbiAgICAgICAgICB0aGlzLmNsZWFyRGVib3VuY2UoKTsgLy8gVXBkYXRlIHRoZSBsb2NhbCB2YWx1ZXNcblxuICAgICAgICAgIHRoaXMubG9jYWxWYWx1ZSA9IHN0cmluZ2lmeVZhbHVlO1xuICAgICAgICAgIHRoaXMudk1vZGVsVmFsdWUgPSBuZXdWYWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAvLyBDcmVhdGUgbm9uLXJlYWN0aXZlIHByb3BlcnR5IGFuZCBzZXQgdXAgZGVzdHJveSBoYW5kbGVyXG4gICAgICB0aGlzLiRfaW5wdXREZWJvdW5jZVRpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMuJG9uKCdob29rOmJlZm9yZURlc3Ryb3knLCB0aGlzLmNsZWFyRGVib3VuY2UpOyAvLyBQcmVzZXQgdGhlIGludGVybmFsIHN0YXRlXG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB2YXIgc3RyaW5naWZ5VmFsdWUgPSB0b1N0cmluZyQxKHZhbHVlKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgIGlmIChzdHJpbmdpZnlWYWx1ZSAhPT0gdGhpcy5sb2NhbFZhbHVlICYmIHZhbHVlICE9PSB0aGlzLnZNb2RlbFZhbHVlKSB7XG4gICAgICAgIHRoaXMubG9jYWxWYWx1ZSA9IHN0cmluZ2lmeVZhbHVlO1xuICAgICAgICB0aGlzLnZNb2RlbFZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBjbGVhckRlYm91bmNlOiBmdW5jdGlvbiBjbGVhckRlYm91bmNlKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4kX2lucHV0RGVib3VuY2VUaW1lcik7XG4gICAgICAgIHRoaXMuJF9pbnB1dERlYm91bmNlVGltZXIgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIGZvcm1hdFZhbHVlOiBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSwgZXZ0KSB7XG4gICAgICAgIHZhciBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICAgIHZhbHVlID0gdG9TdHJpbmckMSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzRm9ybWF0dGVyICYmICghdGhpcy5sYXp5Rm9ybWF0dGVyIHx8IGZvcmNlKSkge1xuICAgICAgICAgIHZhbHVlID0gdGhpcy5mb3JtYXR0ZXIodmFsdWUsIGV2dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9LFxuICAgICAgbW9kaWZ5VmFsdWU6IGZ1bmN0aW9uIG1vZGlmeVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIC8vIEVtdWxhdGUgYC50cmltYCBtb2RpZmllciBiZWhhdmlvdXJcbiAgICAgICAgaWYgKHRoaXMudHJpbSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICB9IC8vIEVtdWxhdGUgYC5udW1iZXJgIG1vZGlmaWVyIGJlaGF2aW91clxuXG5cbiAgICAgICAgaWYgKHRoaXMubnVtYmVyKSB7XG4gICAgICAgICAgdmFyIG51bWJlciA9IHRvRmxvYXQodmFsdWUpO1xuICAgICAgICAgIHZhbHVlID0gaXNOYU4obnVtYmVyKSA/IHZhbHVlIDogbnVtYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZVZhbHVlOiBmdW5jdGlvbiB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICAgIHZhciBsYXp5ID0gdGhpcy5sYXp5O1xuXG4gICAgICAgIGlmIChsYXp5ICYmICFmb3JjZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdGhpcy5tb2RpZnlWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnZNb2RlbFZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5jbGVhckRlYm91bmNlKCk7XG5cbiAgICAgICAgICB2YXIgZG9VcGRhdGUgPSBmdW5jdGlvbiBkb1VwZGF0ZSgpIHtcbiAgICAgICAgICAgIF90aGlzLnZNb2RlbFZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgICAgIF90aGlzLiRlbWl0KCd1cGRhdGUnLCB2YWx1ZSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBkZWJvdW5jZSA9IHRoaXMuY29tcHV0ZWREZWJvdW5jZTsgLy8gT25seSBkZWJvdW5jZSB0aGUgdmFsdWUgdXBkYXRlIHdoZW4gYSB2YWx1ZSBncmVhdGVyIHRoYW4gYDBgXG4gICAgICAgICAgLy8gaXMgc2V0IGFuZCB3ZSBhcmUgbm90IGluIGxhenkgbW9kZSBvciB0aGlzIGlzIGEgZm9yY2VkIHVwZGF0ZVxuXG4gICAgICAgICAgaWYgKGRlYm91bmNlID4gMCAmJiAhbGF6eSAmJiAhZm9yY2UpIHtcbiAgICAgICAgICAgIHRoaXMuJF9pbnB1dERlYm91bmNlVGltZXIgPSBzZXRUaW1lb3V0KGRvVXBkYXRlLCBkZWJvdW5jZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEltbWVkaWF0ZWx5IHVwZGF0ZSB0aGUgdi1tb2RlbFxuICAgICAgICAgICAgZG9VcGRhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNGb3JtYXR0ZXIpIHtcbiAgICAgICAgICAvLyBXaGVuIHRoZSBgdk1vZGVsVmFsdWVgIGhhc24ndCBjaGFuZ2VkIGJ1dCB0aGUgYWN0dWFsIGlucHV0IHZhbHVlXG4gICAgICAgICAgLy8gaXMgb3V0IG9mIHN5bmMsIG1ha2Ugc3VyZSB0byBjaGFuZ2UgaXQgdG8gdGhlIGdpdmVuIG9uZVxuICAgICAgICAgIC8vIFVzdWFsbHkgY2F1c2VkIGJ5IGJyb3dzZXIgYXV0b2NvbXBsZXRlIGFuZCBob3cgaXQgdHJpZ2dlcnMgdGhlXG4gICAgICAgICAgLy8gY2hhbmdlIG9yIGlucHV0IGV2ZW50LCBvciBkZXBlbmRpbmcgb24gdGhlIGZvcm1hdHRlciBmdW5jdGlvblxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ib290c3RyYXAtdnVlL2Jvb3RzdHJhcC12dWUvaXNzdWVzLzI2NTdcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYm9vdHN0cmFwLXZ1ZS9ib290c3RyYXAtdnVlL2lzc3Vlcy8zNDk4XG5cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogaGFyZCB0byB0ZXN0ICovXG4gICAgICAgICAgdmFyICRpbnB1dCA9IHRoaXMuJHJlZnMuaW5wdXQ7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiBoYXJkIHRvIHRlc3Qgb3V0IG9mIHN5bmMgdmFsdWUgKi9cblxuICAgICAgICAgIGlmICgkaW5wdXQgJiYgdmFsdWUgIT09ICRpbnB1dC52YWx1ZSkge1xuICAgICAgICAgICAgJGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25JbnB1dDogZnVuY3Rpb24gb25JbnB1dChldnQpIHtcbiAgICAgICAgLy8gYGV2dC50YXJnZXQuY29tcG9zaW5nYCBpcyBzZXQgYnkgVnVlXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvYmxvYi9kZXYvc3JjL3BsYXRmb3Jtcy93ZWIvcnVudGltZS9kaXJlY3RpdmVzL21vZGVsLmpzXG4gICAgICAgIC8vIFRPRE86IElzIHRoaXMgbmVlZGVkIG5vdyB3aXRoIHRoZSBsYXRlc3QgVnVlP1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogaGFyZCB0byB0ZXN0IGNvbXBvc2l0aW9uIGV2ZW50cyAqL1xuICAgICAgICBpZiAoZXZ0LnRhcmdldC5jb21wb3NpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSBldnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSB0aGlzLmZvcm1hdFZhbHVlKHZhbHVlLCBldnQpOyAvLyBFeGl0IHdoZW4gdGhlIGBmb3JtYXR0ZXJgIGZ1bmN0aW9uIHN0cmljdGx5IHJldHVybmVkIGBmYWxzZWBcbiAgICAgICAgLy8gb3IgcHJldmVudGVkIHRoZSBpbnB1dCBldmVudFxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlID09PSBmYWxzZSB8fCBldnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubG9jYWxWYWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKGZvcm1hdHRlZFZhbHVlKTtcbiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBmb3JtYXR0ZWRWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGV2dCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBldnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSB0aGlzLmZvcm1hdFZhbHVlKHZhbHVlLCBldnQpOyAvLyBFeGl0IHdoZW4gdGhlIGBmb3JtYXR0ZXJgIGZ1bmN0aW9uIHN0cmljdGx5IHJldHVybmVkIGBmYWxzZWBcbiAgICAgICAgLy8gb3IgcHJldmVudGVkIHRoZSBpbnB1dCBldmVudFxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlID09PSBmYWxzZSB8fCBldnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubG9jYWxWYWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKGZvcm1hdHRlZFZhbHVlLCB0cnVlKTtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZm9ybWF0dGVkVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIG9uQmx1cjogZnVuY3Rpb24gb25CbHVyKGV2dCkge1xuICAgICAgICAvLyBBcHBseSB0aGUgYGxvY2FsVmFsdWVgIG9uIGJsdXIgdG8gcHJldmVudCBjdXJzb3IganVtcHNcbiAgICAgICAgLy8gb24gbW9iaWxlIGJyb3dzZXJzIChlLmcuIGNhdXNlZCBieSBhdXRvY29tcGxldGUpXG4gICAgICAgIHZhciB2YWx1ZSA9IGV2dC50YXJnZXQudmFsdWU7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IHRoaXMuZm9ybWF0VmFsdWUodmFsdWUsIGV2dCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdXNlIHRoZSBtb2RpZmllZCB2YWx1ZSBoZXJlIHRvIGFwcGx5IHRoZVxuICAgICAgICAgIC8vIGAudHJpbWAgYW5kIGAubnVtYmVyYCBtb2RpZmllcnMgcHJvcGVybHlcbiAgICAgICAgICB0aGlzLmxvY2FsVmFsdWUgPSB0b1N0cmluZyQxKHRoaXMubW9kaWZ5VmFsdWUoZm9ybWF0dGVkVmFsdWUpKTsgLy8gV2UgcGFzcyB0aGUgZm9ybWF0dGVkIHZhbHVlIGhlcmUgc2luY2UgdGhlIGB1cGRhdGVWYWx1ZWAgbWV0aG9kXG4gICAgICAgICAgLy8gaGFuZGxlcyB0aGUgbW9kaWZpZXJzIGl0c2VsZlxuXG4gICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZShmb3JtYXR0ZWRWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgIH0gLy8gRW1pdCBuYXRpdmUgYmx1ciBldmVudFxuXG5cbiAgICAgICAgdGhpcy4kZW1pdCgnYmx1cicsIGV2dCk7XG4gICAgICB9LFxuICAgICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgICAvLyBGb3IgZXh0ZXJuYWwgaGFuZGxlciB0aGF0IG1heSB3YW50IGEgZm9jdXMgbWV0aG9kXG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgIHRoaXMuJGVsLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBibHVyOiBmdW5jdGlvbiBibHVyKCkge1xuICAgICAgICAvLyBGb3IgZXh0ZXJuYWwgaGFuZGxlciB0aGF0IG1heSB3YW50IGEgYmx1ciBtZXRob2RcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgdGhpcy4kZWwuYmx1cigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIEB2dWUvY29tcG9uZW50XG4gIHZhciBmb3JtU2VsZWN0aW9uTWl4aW4gPSB7XG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIHNlbGVjdGlvblN0YXJ0OiB7XG4gICAgICAgIC8vIEV4cG9zZSBzZWxlY3Rpb25TdGFydCBmb3IgZm9ybWF0dGVycywgZXRjXG4gICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuaW5wdXQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbClcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZWxlY3Rpb25FbmQ6IHtcbiAgICAgICAgLy8gRXhwb3NlIHNlbGVjdGlvbkVuZCBmb3IgZm9ybWF0dGVycywgZXRjXG4gICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuaW5wdXQuc2VsZWN0aW9uRW5kO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmlucHV0LnNlbGVjdGlvbkVuZCA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNlbGVjdGlvbkRpcmVjdGlvbjoge1xuICAgICAgICAvLyBFeHBvc2Ugc2VsZWN0aW9uRGlyZWN0aW9uIGZvciBmb3JtYXR0ZXJzLCBldGNcbiAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5pbnB1dC5zZWxlY3Rpb25EaXJlY3Rpb247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbClcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaW5wdXQuc2VsZWN0aW9uRGlyZWN0aW9uID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdCgpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAge1xuICAgICAgICB2YXIgX3RoaXMkJHJlZnMkaW5wdXQ7XG5cbiAgICAgICAgLy8gRm9yIGV4dGVybmFsIGhhbmRsZXIgdGhhdCBtYXkgd2FudCBhIHNlbGVjdCgpIG1ldGhvZFxuICAgICAgICAoX3RoaXMkJHJlZnMkaW5wdXQgPSB0aGlzLiRyZWZzLmlucHV0KS5zZWxlY3QuYXBwbHkoX3RoaXMkJHJlZnMkaW5wdXQsIGFyZ3VtZW50cyk7XG4gICAgICB9LFxuICAgICAgc2V0U2VsZWN0aW9uUmFuZ2U6IGZ1bmN0aW9uIHNldFNlbGVjdGlvblJhbmdlKClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB7XG4gICAgICAgIHZhciBfdGhpcyQkcmVmcyRpbnB1dDI7XG5cbiAgICAgICAgLy8gRm9yIGV4dGVybmFsIGhhbmRsZXIgdGhhdCBtYXkgd2FudCBhIHNldFNlbGVjdGlvblJhbmdlKGEsYixjKSBtZXRob2RcbiAgICAgICAgKF90aGlzJCRyZWZzJGlucHV0MiA9IHRoaXMuJHJlZnMuaW5wdXQpLnNldFNlbGVjdGlvblJhbmdlLmFwcGx5KF90aGlzJCRyZWZzJGlucHV0MiwgYXJndW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICBzZXRSYW5nZVRleHQ6IGZ1bmN0aW9uIHNldFJhbmdlVGV4dCgpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAge1xuICAgICAgICB2YXIgX3RoaXMkJHJlZnMkaW5wdXQzO1xuXG4gICAgICAgIC8vIEZvciBleHRlcm5hbCBoYW5kbGVyIHRoYXQgbWF5IHdhbnQgYSBzZXRSYW5nZVRleHQoYSxiLGMpIG1ldGhvZFxuICAgICAgICAoX3RoaXMkJHJlZnMkaW5wdXQzID0gdGhpcy4kcmVmcy5pbnB1dCkuc2V0UmFuZ2VUZXh0LmFwcGx5KF90aGlzJCRyZWZzJGlucHV0MywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQHZ1ZS9jb21wb25lbnRcbiAgdmFyIGZvcm1WYWxpZGl0eU1peGluID0ge1xuICAgIGNvbXB1dGVkOiB7XG4gICAgICB2YWxpZGl0eToge1xuICAgICAgICAvLyBFeHBvc2UgdmFsaWRpdHkgcHJvcGVydHlcbiAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5pbnB1dC52YWxpZGl0eTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZhbGlkYXRpb25NZXNzYWdlOiB7XG4gICAgICAgIC8vIEV4cG9zZSB2YWxpZGF0aW9uTWVzc2FnZSBwcm9wZXJ0eVxuICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KClcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmlucHV0LnZhbGlkYXRpb25NZXNzYWdlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd2lsbFZhbGlkYXRlOiB7XG4gICAgICAgIC8vIEV4cG9zZSB3aWxsVmFsaWRhdGUgcHJvcGVydHlcbiAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5pbnB1dC53aWxsVmFsaWRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHNldEN1c3RvbVZhbGlkaXR5OiBmdW5jdGlvbiBzZXRDdXN0b21WYWxpZGl0eSgpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAge1xuICAgICAgICB2YXIgX3RoaXMkJHJlZnMkaW5wdXQ7XG5cbiAgICAgICAgLy8gRm9yIGV4dGVybmFsIGhhbmRsZXIgdGhhdCBtYXkgd2FudCBhIHNldEN1c3RvbVZhbGlkaXR5KC4uLikgbWV0aG9kXG4gICAgICAgIHJldHVybiAoX3RoaXMkJHJlZnMkaW5wdXQgPSB0aGlzLiRyZWZzLmlucHV0KS5zZXRDdXN0b21WYWxpZGl0eS5hcHBseShfdGhpcyQkcmVmcyRpbnB1dCwgYXJndW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICBjaGVja1ZhbGlkaXR5OiBmdW5jdGlvbiBjaGVja1ZhbGlkaXR5KClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB7XG4gICAgICAgIHZhciBfdGhpcyQkcmVmcyRpbnB1dDI7XG5cbiAgICAgICAgLy8gRm9yIGV4dGVybmFsIGhhbmRsZXIgdGhhdCBtYXkgd2FudCBhIGNoZWNrVmFsaWRpdHkoLi4uKSBtZXRob2RcbiAgICAgICAgcmV0dXJuIChfdGhpcyQkcmVmcyRpbnB1dDIgPSB0aGlzLiRyZWZzLmlucHV0KS5jaGVja1ZhbGlkaXR5LmFwcGx5KF90aGlzJCRyZWZzJGlucHV0MiwgYXJndW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICByZXBvcnRWYWxpZGl0eTogZnVuY3Rpb24gcmVwb3J0VmFsaWRpdHkoKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHtcbiAgICAgICAgdmFyIF90aGlzJCRyZWZzJGlucHV0MztcblxuICAgICAgICAvLyBGb3IgZXh0ZXJuYWwgaGFuZGxlciB0aGF0IG1heSB3YW50IGEgcmVwb3J0VmFsaWRpdHkoLi4uKSBtZXRob2RcbiAgICAgICAgcmV0dXJuIChfdGhpcyQkcmVmcyRpbnB1dDMgPSB0aGlzLiRyZWZzLmlucHV0KS5yZXBvcnRWYWxpZGl0eS5hcHBseShfdGhpcyQkcmVmcyRpbnB1dDMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBUWVBFUyA9IFsndGV4dCcsICdwYXNzd29yZCcsICdlbWFpbCcsICdudW1iZXInLCAndXJsJywgJ3RlbCcsICdzZWFyY2gnLCAncmFuZ2UnLCAnY29sb3InLCAnZGF0ZScsICd0aW1lJywgJ2RhdGV0aW1lJywgJ2RhdGV0aW1lLWxvY2FsJywgJ21vbnRoJywgJ3dlZWsnXTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkZvcm1JbnB1dCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JGb3JtSW5wdXQnLFxuICAgIG1peGluczogW2lkTWl4aW4sIGZvcm1NaXhpbiwgZm9ybVNpemVNaXhpbiwgZm9ybVN0YXRlTWl4aW4sIGZvcm1UZXh0TWl4aW4sIGZvcm1TZWxlY3Rpb25NaXhpbiwgZm9ybVZhbGlkaXR5TWl4aW5dLFxuICAgIHByb3BzOiB7XG4gICAgICAvLyB2YWx1ZSBwcm9wIGRlZmluZWQgaW4gZm9ybS10ZXh0IG1peGluXG4gICAgICAvLyB2YWx1ZTogeyB9LFxuICAgICAgdHlwZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICd0ZXh0JyxcbiAgICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiB2YWxpZGF0b3IodHlwZSkge1xuICAgICAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKFRZUEVTLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG5vV2hlZWw6IHtcbiAgICAgICAgLy8gRGlzYWJsZSBtb3VzZXdoZWVsIHRvIHByZXZlbnQgd2hlZWwgZnJvbSBjaGFuZ2luZyB2YWx1ZXMgKGkuZS4gbnVtYmVyL2RhdGUpLlxuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIG1pbjoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgbWF4OiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBzdGVwOiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBsaXN0OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGxvY2FsVHlwZTogZnVuY3Rpb24gbG9jYWxUeXBlKCkge1xuICAgICAgICAvLyBXZSBvbmx5IGFsbG93IGNlcnRhaW4gdHlwZXNcbiAgICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXMoVFlQRVMsIHRoaXMudHlwZSkgPyB0aGlzLnR5cGUgOiAndGV4dCc7XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgbm9XaGVlbDogZnVuY3Rpb24gbm9XaGVlbChuZXdWYWwpIHtcbiAgICAgICAgdGhpcy5zZXRXaGVlbFN0b3BwZXIobmV3VmFsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLnNldFdoZWVsU3RvcHBlcih0aGlzLm5vV2hlZWwpO1xuICAgIH0sXG4gICAgZGVhY3RpdmF0ZWQ6IGZ1bmN0aW9uIGRlYWN0aXZhdGVkKCkge1xuICAgICAgLy8gVHVybiBvZmYgbGlzdGVuZXJzIHdoZW4ga2VlcC1hbGl2ZSBjb21wb25lbnQgZGVhY3RpdmF0ZWRcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHRoaXMuc2V0V2hlZWxTdG9wcGVyKGZhbHNlKTtcbiAgICB9LFxuICAgIGFjdGl2YXRlZDogZnVuY3Rpb24gYWN0aXZhdGVkKCkge1xuICAgICAgLy8gVHVybiBvbiBsaXN0ZW5lcnMgKGlmIG5vLXdoZWVsKSB3aGVuIGtlZXAtYWxpdmUgY29tcG9uZW50IGFjdGl2YXRlZFxuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhpcy5zZXRXaGVlbFN0b3BwZXIodGhpcy5ub1doZWVsKTtcbiAgICB9LFxuICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhpcy5zZXRXaGVlbFN0b3BwZXIoZmFsc2UpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgc2V0V2hlZWxTdG9wcGVyOiBmdW5jdGlvbiBzZXRXaGVlbFN0b3BwZXIob24pIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy4kZWw7IC8vIFdlIHVzZSBuYXRpdmUgZXZlbnRzLCBzbyB0aGF0IHdlIGRvbid0IGludGVyZmVyZSB3aXRoIHByb3BhZ2F0aW9uXG5cbiAgICAgICAgZXZlbnRPbk9mZihvbiwgaW5wdXQsICdmb2N1cycsIHRoaXMub25XaGVlbEZvY3VzKTtcbiAgICAgICAgZXZlbnRPbk9mZihvbiwgaW5wdXQsICdibHVyJywgdGhpcy5vbldoZWVsQmx1cik7XG5cbiAgICAgICAgaWYgKCFvbikge1xuICAgICAgICAgIGV2ZW50T2ZmKGRvY3VtZW50LCAnd2hlZWwnLCB0aGlzLnN0b3BXaGVlbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbldoZWVsRm9jdXM6IGZ1bmN0aW9uIG9uV2hlZWxGb2N1cygpIHtcbiAgICAgICAgZXZlbnRPbihkb2N1bWVudCwgJ3doZWVsJywgdGhpcy5zdG9wV2hlZWwpO1xuICAgICAgfSxcbiAgICAgIG9uV2hlZWxCbHVyOiBmdW5jdGlvbiBvbldoZWVsQmx1cigpIHtcbiAgICAgICAgZXZlbnRPZmYoZG9jdW1lbnQsICd3aGVlbCcsIHRoaXMuc3RvcFdoZWVsKTtcbiAgICAgIH0sXG4gICAgICBzdG9wV2hlZWw6IGZ1bmN0aW9uIHN0b3BXaGVlbChldnQpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuJGVsLmJsdXIoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBoKCdpbnB1dCcsIHtcbiAgICAgICAgcmVmOiAnaW5wdXQnLFxuICAgICAgICBjbGFzczogc2VsZi5jb21wdXRlZENsYXNzLFxuICAgICAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgICAgIG5hbWU6ICdtb2RlbCcsXG4gICAgICAgICAgcmF3TmFtZTogJ3YtbW9kZWwnLFxuICAgICAgICAgIHZhbHVlOiBzZWxmLmxvY2FsVmFsdWUsXG4gICAgICAgICAgZXhwcmVzc2lvbjogJ2xvY2FsVmFsdWUnXG4gICAgICAgIH1dLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiBzZWxmLnNhZmVJZCgpLFxuICAgICAgICAgIG5hbWU6IHNlbGYubmFtZSxcbiAgICAgICAgICBmb3JtOiBzZWxmLmZvcm0gfHwgbnVsbCxcbiAgICAgICAgICB0eXBlOiBzZWxmLmxvY2FsVHlwZSxcbiAgICAgICAgICBkaXNhYmxlZDogc2VsZi5kaXNhYmxlZCxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogc2VsZi5wbGFjZWhvbGRlcixcbiAgICAgICAgICByZXF1aXJlZDogc2VsZi5yZXF1aXJlZCxcbiAgICAgICAgICBhdXRvY29tcGxldGU6IHNlbGYuYXV0b2NvbXBsZXRlIHx8IG51bGwsXG4gICAgICAgICAgcmVhZG9ubHk6IHNlbGYucmVhZG9ubHkgfHwgc2VsZi5wbGFpbnRleHQsXG4gICAgICAgICAgbWluOiBzZWxmLm1pbixcbiAgICAgICAgICBtYXg6IHNlbGYubWF4LFxuICAgICAgICAgIHN0ZXA6IHNlbGYuc3RlcCxcbiAgICAgICAgICBsaXN0OiBzZWxmLmxvY2FsVHlwZSAhPT0gJ3Bhc3N3b3JkJyA/IHNlbGYubGlzdCA6IG51bGwsXG4gICAgICAgICAgJ2FyaWEtcmVxdWlyZWQnOiBzZWxmLnJlcXVpcmVkID8gJ3RydWUnIDogbnVsbCxcbiAgICAgICAgICAnYXJpYS1pbnZhbGlkJzogc2VsZi5jb21wdXRlZEFyaWFJbnZhbGlkXG4gICAgICAgIH0sXG4gICAgICAgIGRvbVByb3BzOiB7XG4gICAgICAgICAgdmFsdWU6IHNlbGYubG9jYWxWYWx1ZVxuICAgICAgICB9LFxuICAgICAgICBvbjogX29iamVjdFNwcmVhZDIoe30sIHNlbGYuJGxpc3RlbmVycywge1xuICAgICAgICAgIGlucHV0OiBzZWxmLm9uSW5wdXQsXG4gICAgICAgICAgY2hhbmdlOiBzZWxmLm9uQ2hhbmdlLFxuICAgICAgICAgIGJsdXI6IHNlbGYub25CbHVyXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBGb3JtSW5wdXRQbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJGb3JtSW5wdXQ6IEJGb3JtSW5wdXQsXG4gICAgICBCSW5wdXQ6IEJGb3JtSW5wdXRcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwcm9wcyR3ID0ge1xuICAgIGNoZWNrZWQ6IHtcbiAgICAgIC8vIHR5cGU6IFtTdHJpbmcsIE51bWJlciwgQm9vbGVhbiwgT2JqZWN0XSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9XG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJGb3JtUmFkaW9Hcm91cCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JGb3JtUmFkaW9Hcm91cCcsXG4gICAgbWl4aW5zOiBbaWRNaXhpbiwgZm9ybU1peGluLCBmb3JtUmFkaW9DaGVja0dyb3VwTWl4aW4sIC8vIEluY2x1ZGVzIHJlbmRlciBmdW5jdGlvblxuICAgIGZvcm1PcHRpb25zTWl4aW4sIGZvcm1TaXplTWl4aW4sIGZvcm1TdGF0ZU1peGluXSxcbiAgICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnZSYWRpb0dyb3VwOiB0aGlzXG4gICAgICB9O1xuICAgIH0sXG4gICAgcHJvcHM6IHByb3BzJHcsXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvY2FsQ2hlY2tlZDogdGhpcy5jaGVja2VkXG4gICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGlzUmFkaW9Hcm91cDogZnVuY3Rpb24gaXNSYWRpb0dyb3VwKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBGb3JtUmFkaW9QbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJGb3JtUmFkaW86IEJGb3JtUmFkaW8sXG4gICAgICBCUmFkaW86IEJGb3JtUmFkaW8sXG4gICAgICBCRm9ybVJhZGlvR3JvdXA6IEJGb3JtUmFkaW9Hcm91cCxcbiAgICAgIEJSYWRpb0dyb3VwOiBCRm9ybVJhZGlvR3JvdXBcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBvcHRpb25zTWl4aW4gPSB7XG4gICAgbWl4aW5zOiBbZm9ybU9wdGlvbnNNaXhpbl0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGxhYmVsRmllbGQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnbGFiZWwnXG4gICAgICB9LFxuICAgICAgb3B0aW9uc0ZpZWxkOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ29wdGlvbnMnXG4gICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBub3JtYWxpemVPcHRpb246IGZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbihvcHRpb24pIHtcbiAgICAgICAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgICAgICAvLyBXaGVuIHRoZSBvcHRpb24gaXMgYW4gb2JqZWN0LCBub3JtYWxpemUgaXRcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Qob3B0aW9uKSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGdldChvcHRpb24sIHRoaXMudmFsdWVGaWVsZCk7XG4gICAgICAgICAgdmFyIHRleHQgPSBnZXQob3B0aW9uLCB0aGlzLnRleHRGaWVsZCk7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXQob3B0aW9uLCB0aGlzLm9wdGlvbnNGaWVsZCk7IC8vIFdoZW4gaXQgaGFzIG9wdGlvbnMsIGNyZWF0ZSBhbiBgPG9wdGdyb3VwPmAgb2JqZWN0XG5cbiAgICAgICAgICBpZiAoaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbGFiZWw6IFN0cmluZyhnZXQob3B0aW9uLCB0aGlzLmxhYmVsRmllbGQpIHx8IHRleHQpLFxuICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gLy8gT3RoZXJ3aXNlIGNyZWF0ZSBhbiBgPG9wdGlvbj5gIG9iamVjdFxuXG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGlzVW5kZWZpbmVkKHZhbHVlKSA/IGtleSB8fCB0ZXh0IDogdmFsdWUsXG4gICAgICAgICAgICB0ZXh0OiBTdHJpbmcoaXNVbmRlZmluZWQodGV4dCkgPyBrZXkgOiB0ZXh0KSxcbiAgICAgICAgICAgIGh0bWw6IGdldChvcHRpb24sIHRoaXMuaHRtbEZpZWxkKSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBCb29sZWFuKGdldChvcHRpb24sIHRoaXMuZGlzYWJsZWRGaWVsZCkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSAvLyBPdGhlcndpc2UgY3JlYXRlIGFuIGA8b3B0aW9uPmAgb2JqZWN0IGZyb20gdGhlIGdpdmVuIHZhbHVlXG5cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBrZXkgfHwgb3B0aW9uLFxuICAgICAgICAgIHRleHQ6IFN0cmluZyhvcHRpb24pLFxuICAgICAgICAgIGRpc2FibGVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgTkFNRSRnID0gJ0JGb3JtU2VsZWN0T3B0aW9uJztcbiAgdmFyIHByb3BzJHggPSB7XG4gICAgdmFsdWU6IHtcbiAgICAgIC8vIHR5cGU6IFtTdHJpbmcsIE51bWJlciwgQm9vbGVhbiwgT2JqZWN0XSxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBkaXNhYmxlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9OyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCRm9ybVNlbGVjdE9wdGlvbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogTkFNRSRnLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IHByb3BzJHgsXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX3JlZikge1xuICAgICAgdmFyIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlLFxuICAgICAgICAgIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQ7XG4gICAgICByZXR1cm4gaCgnb3B0aW9uJywgYShkYXRhLCB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkXG4gICAgICAgIH0sXG4gICAgICAgIGRvbVByb3BzOiB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH1cbiAgICAgIH0pLCBjaGlsZHJlbik7XG4gICAgfVxuICB9KTtcblxuICB2YXIgQkZvcm1TZWxlY3RPcHRpb25Hcm91cCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JGb3JtU2VsZWN0T3B0aW9uR3JvdXAnLFxuICAgIG1peGluczogW25vcm1hbGl6ZVNsb3RNaXhpbiwgZm9ybU9wdGlvbnNNaXhpbl0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHJldHVybiBoKCdvcHRncm91cCcsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBsYWJlbDogdGhpcy5sYWJlbFxuICAgICAgICB9XG4gICAgICB9LCBbdGhpcy5ub3JtYWxpemVTbG90KCdmaXJzdCcpLCB0aGlzLmZvcm1PcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gaChCRm9ybVNlbGVjdE9wdGlvbiwge1xuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB2YWx1ZTogb3B0aW9uLnZhbHVlLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IG9wdGlvbi5kaXNhYmxlZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZG9tUHJvcHM6IGh0bWxPclRleHQob3B0aW9uLmh0bWwsIG9wdGlvbi50ZXh0KSxcbiAgICAgICAgICBrZXk6IFwib3B0aW9uX1wiLmNvbmNhdChpbmRleCwgXCJfb3B0XCIpXG4gICAgICAgIH0pO1xuICAgICAgfSksIHRoaXMubm9ybWFsaXplU2xvdCgnZGVmYXVsdCcpXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgQkZvcm1TZWxlY3QgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCRm9ybVNlbGVjdCcsXG4gICAgbWl4aW5zOiBbaWRNaXhpbiwgbm9ybWFsaXplU2xvdE1peGluLCBmb3JtTWl4aW4sIGZvcm1TaXplTWl4aW4sIGZvcm1TdGF0ZU1peGluLCBmb3JtQ3VzdG9tTWl4aW4sIG9wdGlvbnNNaXhpbl0sXG4gICAgbW9kZWw6IHtcbiAgICAgIHByb3A6ICd2YWx1ZScsXG4gICAgICBldmVudDogJ2lucHV0J1xuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIHZhbHVlOiB7Ly8gdHlwZTogW09iamVjdCwgQXJyYXksIFN0cmluZywgTnVtYmVyLCBCb29sZWFuXSxcbiAgICAgICAgLy8gZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAgbXVsdGlwbGU6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzZWxlY3RTaXplOiB7XG4gICAgICAgIC8vIEJyb3dzZXJzIGRlZmF1bHQgc2l6ZSB0byAwLCB3aGljaCBzaG93cyA0IHJvd3MgaW4gbW9zdCBicm93c2VycyBpbiBtdWx0aXBsZSBtb2RlXG4gICAgICAgIC8vIFNpemUgb2YgMSBjYW4gYm9yayBvdXQgRmlyZWZveFxuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgIH0sXG4gICAgICBhcmlhSW52YWxpZDoge1xuICAgICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbFZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGNvbXB1dGVkU2VsZWN0U2l6ZTogZnVuY3Rpb24gY29tcHV0ZWRTZWxlY3RTaXplKCkge1xuICAgICAgICAvLyBDdXN0b20gc2VsZWN0cyB3aXRoIGEgc2l6ZSBvZiB6ZXJvIGNhdXNlcyB0aGUgYXJyb3dzIHRvIGJlIGhpZGRlbixcbiAgICAgICAgLy8gc28gZG9udCByZW5kZXIgdGhlIHNpemUgYXR0cmlidXRlIGluIHRoaXMgY2FzZVxuICAgICAgICByZXR1cm4gIXRoaXMucGxhaW4gJiYgdGhpcy5zZWxlY3RTaXplID09PSAwID8gbnVsbCA6IHRoaXMuc2VsZWN0U2l6ZTtcbiAgICAgIH0sXG4gICAgICBpbnB1dENsYXNzOiBmdW5jdGlvbiBpbnB1dENsYXNzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMucGxhaW4gPyAnZm9ybS1jb250cm9sJyA6ICdjdXN0b20tc2VsZWN0JywgdGhpcy5zaXplICYmIHRoaXMucGxhaW4gPyBcImZvcm0tY29udHJvbC1cIi5jb25jYXQodGhpcy5zaXplKSA6IG51bGwsIHRoaXMuc2l6ZSAmJiAhdGhpcy5wbGFpbiA/IFwiY3VzdG9tLXNlbGVjdC1cIi5jb25jYXQodGhpcy5zaXplKSA6IG51bGwsIHRoaXMuc3RhdGVDbGFzc107XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRBcmlhSW52YWxpZDogZnVuY3Rpb24gY29tcHV0ZWRBcmlhSW52YWxpZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXJpYUludmFsaWQgPT09IHRydWUgfHwgdGhpcy5hcmlhSW52YWxpZCA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgcmV0dXJuICd0cnVlJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlQ2xhc3MgPT09ICdpcy1pbnZhbGlkJyA/ICd0cnVlJyA6IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG5ld1ZhbCkge1xuICAgICAgICB0aGlzLmxvY2FsVmFsdWUgPSBuZXdWYWw7XG4gICAgICB9LFxuICAgICAgbG9jYWxWYWx1ZTogZnVuY3Rpb24gbG9jYWxWYWx1ZSgpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB0aGlzLmxvY2FsVmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgICB0aGlzLiRyZWZzLmlucHV0LmZvY3VzKCk7XG4gICAgICB9LFxuICAgICAgYmx1cjogZnVuY3Rpb24gYmx1cigpIHtcbiAgICAgICAgdGhpcy4kcmVmcy5pbnB1dC5ibHVyKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gaCgnc2VsZWN0Jywge1xuICAgICAgICByZWY6ICdpbnB1dCcsXG4gICAgICAgIGNsYXNzOiB0aGlzLmlucHV0Q2xhc3MsXG4gICAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgICAgbmFtZTogJ21vZGVsJyxcbiAgICAgICAgICByYXdOYW1lOiAndi1tb2RlbCcsXG4gICAgICAgICAgdmFsdWU6IHRoaXMubG9jYWxWYWx1ZSxcbiAgICAgICAgICBleHByZXNzaW9uOiAnbG9jYWxWYWx1ZSdcbiAgICAgICAgfV0sXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHRoaXMuc2FmZUlkKCksXG4gICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgIGZvcm06IHRoaXMuZm9ybSB8fCBudWxsLFxuICAgICAgICAgIG11bHRpcGxlOiB0aGlzLm11bHRpcGxlIHx8IG51bGwsXG4gICAgICAgICAgc2l6ZTogdGhpcy5jb21wdXRlZFNlbGVjdFNpemUsXG4gICAgICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQsXG4gICAgICAgICAgcmVxdWlyZWQ6IHRoaXMucmVxdWlyZWQsXG4gICAgICAgICAgJ2FyaWEtcmVxdWlyZWQnOiB0aGlzLnJlcXVpcmVkID8gJ3RydWUnIDogbnVsbCxcbiAgICAgICAgICAnYXJpYS1pbnZhbGlkJzogdGhpcy5jb21wdXRlZEFyaWFJbnZhbGlkXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgY2hhbmdlOiBmdW5jdGlvbiBjaGFuZ2UoZXZ0KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZ0LnRhcmdldDtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZFZhbCA9IGZyb20odGFyZ2V0Lm9wdGlvbnMpLmZpbHRlcihmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICByZXR1cm4gby5zZWxlY3RlZDtcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICByZXR1cm4gJ192YWx1ZScgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMubG9jYWxWYWx1ZSA9IHRhcmdldC5tdWx0aXBsZSA/IHNlbGVjdGVkVmFsIDogc2VsZWN0ZWRWYWxbMF07XG5cbiAgICAgICAgICAgIF90aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLiRlbWl0KCdjaGFuZ2UnLCBfdGhpcy5sb2NhbFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgW3RoaXMubm9ybWFsaXplU2xvdCgnZmlyc3QnKSwgdGhpcy5mb3JtT3B0aW9ucy5tYXAoZnVuY3Rpb24gKG9wdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGtleSA9IFwib3B0aW9uX1wiLmNvbmNhdChpbmRleCwgXCJfb3B0XCIpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbi5vcHRpb25zO1xuICAgICAgICByZXR1cm4gaXNBcnJheShvcHRpb25zKSA/IGgoQkZvcm1TZWxlY3RPcHRpb25Hcm91cCwge1xuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBsYWJlbDogb3B0aW9uLmxhYmVsLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgIH0sXG4gICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgfSkgOiBoKEJGb3JtU2VsZWN0T3B0aW9uLCB7XG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb24udmFsdWUsXG4gICAgICAgICAgICBkaXNhYmxlZDogb3B0aW9uLmRpc2FibGVkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkb21Qcm9wczogaHRtbE9yVGV4dChvcHRpb24uaHRtbCwgb3B0aW9uLnRleHQpLFxuICAgICAgICAgIGtleToga2V5XG4gICAgICAgIH0pO1xuICAgICAgfSksIHRoaXMubm9ybWFsaXplU2xvdCgnZGVmYXVsdCcpXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgRm9ybVNlbGVjdFBsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgY29tcG9uZW50czoge1xuICAgICAgQkZvcm1TZWxlY3Q6IEJGb3JtU2VsZWN0LFxuICAgICAgQkZvcm1TZWxlY3RPcHRpb246IEJGb3JtU2VsZWN0T3B0aW9uLFxuICAgICAgQkZvcm1TZWxlY3RPcHRpb25Hcm91cDogQkZvcm1TZWxlY3RPcHRpb25Hcm91cCxcbiAgICAgIEJTZWxlY3Q6IEJGb3JtU2VsZWN0LFxuICAgICAgQlNlbGVjdE9wdGlvbjogQkZvcm1TZWxlY3RPcHRpb24sXG4gICAgICBCU2VsZWN0T3B0aW9uR3JvdXA6IEJGb3JtU2VsZWN0T3B0aW9uR3JvdXBcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBOQU1FJGggPSAnQkZvcm1TcGluYnV0dG9uJztcbiAgdmFyIFVQJDEgPSBLRVlfQ09ERVMuVVAsXG4gICAgICBET1dOJDEgPSBLRVlfQ09ERVMuRE9XTixcbiAgICAgIEhPTUUkMSA9IEtFWV9DT0RFUy5IT01FLFxuICAgICAgRU5EJDEgPSBLRVlfQ09ERVMuRU5ELFxuICAgICAgUEFHRVVQJDEgPSBLRVlfQ09ERVMuUEFHRVVQLFxuICAgICAgUEFHRURPV04kMSA9IEtFWV9DT0RFUy5QQUdFRE9XTjsgLy8gRGVmYXVsdCBmb3Igc3BpbiBidXR0b24gcmFuZ2UgYW5kIHN0ZXBcblxuICB2YXIgREVGQVVMVF9NSU4gPSAxO1xuICB2YXIgREVGQVVMVF9NQVggPSAxMDA7XG4gIHZhciBERUZBVUxUX1NURVAgPSAxOyAvLyBEZWxheSBiZWZvcmUgYXV0by1yZXBlYXQgaW4gbXNcblxuICB2YXIgREVGQVVMVF9SRVBFQVRfREVMQVkgPSA1MDA7IC8vIFJlcGVhdCBpbnRlcnZhbCBpbiBtc1xuXG4gIHZhciBERUZBVUxUX1JFUEVBVF9JTlRFUlZBTCA9IDEwMDsgLy8gUmVwZWF0IHJhdGUgaW5jcmVhc2VkIGFmdGVyIG51bWJlciBvZiByZXBlYXRzXG5cbiAgdmFyIERFRkFVTFRfUkVQRUFUX1RIUkVTSE9MRCA9IDEwOyAvLyBSZXBlYXQgc3BlZWQgbXVsdGlwbGllciAoc3RlcCBtdWx0aXBsaWVyLCBtdXN0IGJlIGFuIGludGVnZXIpXG5cbiAgdmFyIERFRkFVTFRfUkVQRUFUX01VTFRJUExJRVIgPSA0OyAvLyAtLS0gSGVscGVyIGZ1bmN0aW9ucyAtLS1cblxuICB2YXIgZGVmYXVsdE51bWJlciA9IGZ1bmN0aW9uIGRlZmF1bHROdW1iZXIodmFsdWUpIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIHZhbHVlID0gdG9GbG9hdCh2YWx1ZSk7XG4gICAgcmV0dXJuIGlzTmFOKHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0SW50ZWdlciA9IGZ1bmN0aW9uIGRlZmF1bHRJbnRlZ2VyKHZhbHVlKSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICB2YWx1ZSA9IHRvSW50ZWdlcih2YWx1ZSk7XG4gICAgcmV0dXJuIGlzTmFOKHZhbHVlKSA/IE1hdGguYWJzKGRlZmF1bHRWYWx1ZSkgOiB2YWx1ZTtcbiAgfTsgLy8gLS0tIEJGb3JtU3BpbmJ1dHRvbiAtLS1cbiAgLy8gQHZ1ZS9jb21wb25lbnRcblxuXG4gIHZhciBCRm9ybVNwaW5idXR0b24gPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6IE5BTUUkaCxcbiAgICBtaXhpbnM6IFtpZE1peGluXSxcbiAgICBpbmhlcml0QXR0cnM6IGZhbHNlLFxuICAgIHByb3BzOiB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICAvLyBTaG91bGQgdGhpcyByZWFsbHkgYmUgU3RyaW5nLCB0byBtYXRjaCBuYXRpdmUgbnVtYmVyIGlucHV0cz9cbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgbWluOiB7XG4gICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgIGRlZmF1bHQ6IERFRkFVTFRfTUlOXG4gICAgICB9LFxuICAgICAgbWF4OiB7XG4gICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgIGRlZmF1bHQ6IERFRkFVTFRfTUFYXG4gICAgICB9LFxuICAgICAgc3RlcDoge1xuICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICBkZWZhdWx0OiBERUZBVUxUX1NURVBcbiAgICAgIH0sXG4gICAgICB3cmFwOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZm9ybWF0dGVyRm46IHtcbiAgICAgICAgdHlwZTogRnVuY3Rpb24gLy8gZGVmYXVsdDogbnVsbFxuXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcgLy8gZGVmYXVsdDogbnVsbFxuXG4gICAgICB9LFxuICAgICAgcGxhY2Vob2xkZXI6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgZGlzYWJsZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICByZWFkb25seToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkOiB7XG4gICAgICAgIC8vIE9ubHkgYWZmZWN0cyB0aGUgYGFyaWEtaW52YWxpZGAgYXR0cmlidXRlXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgbmFtZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcgLy8gZGVmYXVsdDogbnVsbFxuXG4gICAgICB9LFxuICAgICAgZm9ybToge1xuICAgICAgICB0eXBlOiBTdHJpbmcgLy8gZGVmYXVsdDogbnVsbFxuXG4gICAgICB9LFxuICAgICAgc3RhdGU6IHtcbiAgICAgICAgLy8gVHJpLXN0YXRlIHByb3A6IGB0cnVlYCwgYGZhbHNlYCwgb3IgYG51bGxgXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBpbmxpbmU6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICB2ZXJ0aWNhbDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGFyaWFMYWJlbDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBhcmlhQ29udHJvbHM6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgbGFiZWxEZWNyZW1lbnQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkaCwgJ2xhYmVsRGVjcmVtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsYWJlbEluY3JlbWVudDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRoLCAnbGFiZWxJbmNyZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxvY2FsZToge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0sXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICByZXBlYXREZWxheToge1xuICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICBkZWZhdWx0OiBERUZBVUxUX1JFUEVBVF9ERUxBWVxuICAgICAgfSxcbiAgICAgIHJlcGVhdEludGVydmFsOiB7XG4gICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgIGRlZmF1bHQ6IERFRkFVTFRfUkVQRUFUX0lOVEVSVkFMXG4gICAgICB9LFxuICAgICAgcmVwZWF0VGhyZXNob2xkOiB7XG4gICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgIGRlZmF1bHQ6IERFRkFVTFRfUkVQRUFUX1RIUkVTSE9MRFxuICAgICAgfSxcbiAgICAgIHJlcGVhdFN0ZXBNdWx0aXBsaWVyOiB7XG4gICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgIGRlZmF1bHQ6IERFRkFVTFRfUkVQRUFUX01VTFRJUExJRVJcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbFZhbHVlOiBkZWZhdWx0TnVtYmVyKHRoaXMudmFsdWUpLFxuICAgICAgICBoYXNGb2N1czogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgY29tcHV0ZWRTdGVwOiBmdW5jdGlvbiBjb21wdXRlZFN0ZXAoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0TnVtYmVyKHRoaXMuc3RlcCwgREVGQVVMVF9TVEVQKTtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZE1pbjogZnVuY3Rpb24gY29tcHV0ZWRNaW4oKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0TnVtYmVyKHRoaXMubWluLCBERUZBVUxUX01JTik7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRNYXg6IGZ1bmN0aW9uIGNvbXB1dGVkTWF4KCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdE51bWJlcih0aGlzLm1heCwgREVGQVVMVF9NQVgpO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkRGVsYXk6IGZ1bmN0aW9uIGNvbXB1dGVkRGVsYXkoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0SW50ZWdlcih0aGlzLnJlcGVhdERlbGF5LCBERUZBVUxUX1JFUEVBVF9ERUxBWSkgfHwgREVGQVVMVF9SRVBFQVRfREVMQVk7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRJbnRlcnZhbDogZnVuY3Rpb24gY29tcHV0ZWRJbnRlcnZhbCgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRJbnRlZ2VyKHRoaXMucmVwZWF0SW50ZXJ2YWwsIERFRkFVTFRfUkVQRUFUX0lOVEVSVkFMKSB8fCBERUZBVUxUX1JFUEVBVF9JTlRFUlZBTDtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZFRocmVzaG9sZDogZnVuY3Rpb24gY29tcHV0ZWRUaHJlc2hvbGQoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0SW50ZWdlcih0aGlzLnJlcGVhdFRocmVzaG9sZCwgREVGQVVMVF9SRVBFQVRfVEhSRVNIT0xEKSB8fCAxO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkU3RlcE11bHRpcGxpZXI6IGZ1bmN0aW9uIGNvbXB1dGVkU3RlcE11bHRpcGxpZXIoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0SW50ZWdlcih0aGlzLnJlcGVhdFN0ZXBNdWx0aXBsaWVyLCBERUZBVUxUX1JFUEVBVF9NVUxUSVBMSUVSKSB8fCAxO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkUHJlY2lzaW9uOiBmdW5jdGlvbiBjb21wdXRlZFByZWNpc2lvbigpIHtcbiAgICAgICAgLy8gUXVpY2sgYW5kIGRpcnR5IHdheSB0byBnZXQgdGhlIG51bWJlciBvZiBkZWNpbWFsc1xuICAgICAgICB2YXIgc3RlcCA9IHRoaXMuY29tcHV0ZWRTdGVwO1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihzdGVwKSA9PT0gc3RlcCA/IDAgOiAoc3RlcC50b1N0cmluZygpLnNwbGl0KCcuJylbMV0gfHwgJycpLmxlbmd0aDtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZE11bHRpcGxpZXI6IGZ1bmN0aW9uIGNvbXB1dGVkTXVsdGlwbGllcigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLmNvbXB1dGVkUHJlY2lzaW9uIHx8IDApO1xuICAgICAgfSxcbiAgICAgIHZhbHVlQXNGaXhlZDogZnVuY3Rpb24gdmFsdWVBc0ZpeGVkKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmxvY2FsVmFsdWU7XG4gICAgICAgIHJldHVybiBpc051bGwodmFsdWUpID8gJycgOiB2YWx1ZS50b0ZpeGVkKHRoaXMuY29tcHV0ZWRQcmVjaXNpb24pO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkTG9jYWxlOiBmdW5jdGlvbiBjb21wdXRlZExvY2FsZSgpIHtcbiAgICAgICAgdmFyIGxvY2FsZXMgPSBjb25jYXQodGhpcy5sb2NhbGUpLmZpbHRlcihpZGVudGl0eSk7XG4gICAgICAgIHZhciBuZiA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGVzKTtcbiAgICAgICAgcmV0dXJuIG5mLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZTtcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0Rm9ybWF0dGVyOiBmdW5jdGlvbiBkZWZhdWx0Rm9ybWF0dGVyKCkge1xuICAgICAgICAvLyBSZXR1cm5zIGFuZCBgSW50bC5OdW1iZXJGb3JtYXRgIGZvcm1hdHRlciBtZXRob2QgcmVmZXJlbmNlXG4gICAgICAgIHZhciBwcmVjaXNpb24gPSB0aGlzLmNvbXB1dGVkUHJlY2lzaW9uO1xuICAgICAgICB2YXIgbmYgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQodGhpcy5jb21wdXRlZExvY2FsZSwge1xuICAgICAgICAgIHN0eWxlOiAnZGVjaW1hbCcsXG4gICAgICAgICAgdXNlR3JvdXBpbmc6IGZhbHNlLFxuICAgICAgICAgIG1pbmltdW1JbnRlZ2VyRGlnaXRzOiAxLFxuICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogcHJlY2lzaW9uLFxuICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogcHJlY2lzaW9uLFxuICAgICAgICAgIG5vdGF0aW9uOiAnc3RhbmRhcmQnXG4gICAgICAgIH0pOyAvLyBSZXR1cm4gdGhlIGZvcm1hdCBtZXRob2QgcmVmZXJlbmNlXG5cbiAgICAgICAgcmV0dXJuIG5mLmZvcm1hdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoX3ZhbHVlKSB7XG4gICAgICAgIF92YWx1ZSA9IHRvRmxvYXQoX3ZhbHVlKTsgLy8gV2lsbCBiZSBgTmFOYCBpZiBgdmFsdWVgIGlzIGBudWxsYFxuXG4gICAgICAgIHRoaXMubG9jYWxWYWx1ZSA9IGlzTmFOKF92YWx1ZSkgPyBudWxsIDogX3ZhbHVlO1xuICAgICAgfSxcbiAgICAgIGxvY2FsVmFsdWU6IGZ1bmN0aW9uIGxvY2FsVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgZGlzYWJsZWQ6IGZ1bmN0aW9uIGRpc2FibGVkKF9kaXNhYmxlZCkge1xuICAgICAgICBpZiAoX2Rpc2FibGVkKSB7XG4gICAgICAgICAgdGhpcy5jbGVhclJlcGVhdCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVhZG9ubHk6IGZ1bmN0aW9uIHJlYWRvbmx5KF9yZWFkb25seSkge1xuICAgICAgICBpZiAoX3JlYWRvbmx5KSB7XG4gICAgICAgICAgdGhpcy5jbGVhclJlcGVhdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgLy8gQ3JlYXRlIG5vbiByZWFjdGl2ZSBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLiRfYXV0b0RlbGF5VGltZXIgPSBudWxsO1xuICAgICAgdGhpcy4kX2F1dG9SZXBlYXRUaW1lciA9IG51bGw7XG4gICAgICB0aGlzLiRfa2V5SXNEb3duID0gZmFsc2U7XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgdGhpcy5jbGVhclJlcGVhdCgpO1xuICAgIH0sXG4gICAgZGVhY3RpdmF0ZWQ6IGZ1bmN0aW9uIGRlYWN0aXZhdGVkKClcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHtcbiAgICAgIHRoaXMuY2xlYXJSZXBlYXQoKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIC8vIC0tLSBQdWJsaWMgbWV0aG9kcyAtLS1cbiAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuJHJlZnMuc3Bpbm5lci5mb2N1cygpO1xuICAgICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBibHVyOiBmdW5jdGlvbiBibHVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy4kcmVmcy5zcGlubmVyLmJsdXIoKTtcbiAgICAgICAgICB9IGNhdGNoIChfdW51c2VkMikge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIC0tLSBQcml2YXRlIG1ldGhvZHMgLS0tXG4gICAgICBlbWl0Q2hhbmdlOiBmdW5jdGlvbiBlbWl0Q2hhbmdlKCkge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0aGlzLmxvY2FsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHN0ZXBWYWx1ZTogZnVuY3Rpb24gc3RlcFZhbHVlKGRpcmVjdGlvbikge1xuICAgICAgICAvLyBTZXRzIGEgbmV3IGluY3JlbWVudGVkIG9yIGRlY3JlbWVudGVkIHZhbHVlLCBzdXBwb3J0aW5nIG9wdGlvbmFsIHdyYXBwaW5nXG4gICAgICAgIC8vIERpcmVjdGlvbiBpcyBlaXRoZXIgKzEgb3IgLTEgKG9yIGEgbXVsdGlwbGUgdGhlcmVvZilcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5sb2NhbFZhbHVlO1xuXG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiAhaXNOdWxsKHZhbHVlKSkge1xuICAgICAgICAgIHZhciBzdGVwID0gdGhpcy5jb21wdXRlZFN0ZXAgKiBkaXJlY3Rpb247XG4gICAgICAgICAgdmFyIG1pbiA9IHRoaXMuY29tcHV0ZWRNaW47XG4gICAgICAgICAgdmFyIG1heCA9IHRoaXMuY29tcHV0ZWRNYXg7XG4gICAgICAgICAgdmFyIG11bHRpcGxpZXIgPSB0aGlzLmNvbXB1dGVkTXVsdGlwbGllcjtcbiAgICAgICAgICB2YXIgd3JhcCA9IHRoaXMud3JhcDsgLy8gV2UgZW5zdXJlIHRoYXQgdGhlIHZhbHVlIHN0ZXBzIGxpa2UgYSBuYXRpdmUgaW5wdXRcblxuICAgICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCgodmFsdWUgLSBtaW4pIC8gc3RlcCkgKiBzdGVwICsgbWluICsgc3RlcDsgLy8gV2UgZW5zdXJlIHRoYXQgcHJlY2lzaW9uIGlzIG1haW50YWluZWQgKGRlY2ltYWxzKVxuXG4gICAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogbXVsdGlwbGllcikgLyBtdWx0aXBsaWVyOyAvLyBIYW5kbGUgaWYgd3JhcHBpbmcgaXMgZW5hYmxlZFxuXG4gICAgICAgICAgdGhpcy5sb2NhbFZhbHVlID0gdmFsdWUgPiBtYXggPyB3cmFwID8gbWluIDogbWF4IDogdmFsdWUgPCBtaW4gPyB3cmFwID8gbWF4IDogbWluIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkZvY3VzQmx1cjogZnVuY3Rpb24gb25Gb2N1c0JsdXIoZXZ0KSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgIHRoaXMuaGFzRm9jdXMgPSBldnQudHlwZSA9PT0gJ2ZvY3VzJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhhc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdGVwVXA6IGZ1bmN0aW9uIHN0ZXBVcCgpIHtcbiAgICAgICAgdmFyIG11bHRpcGxpZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubG9jYWxWYWx1ZTtcblxuICAgICAgICBpZiAoaXNOdWxsKHZhbHVlKSkge1xuICAgICAgICAgIHRoaXMubG9jYWxWYWx1ZSA9IHRoaXMuY29tcHV0ZWRNaW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGVwVmFsdWUoKzEgKiBtdWx0aXBsaWVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN0ZXBEb3duOiBmdW5jdGlvbiBzdGVwRG93bigpIHtcbiAgICAgICAgdmFyIG11bHRpcGxpZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubG9jYWxWYWx1ZTtcblxuICAgICAgICBpZiAoaXNOdWxsKHZhbHVlKSkge1xuICAgICAgICAgIHRoaXMubG9jYWxWYWx1ZSA9IHRoaXMud3JhcCA/IHRoaXMuY29tcHV0ZWRNYXggOiB0aGlzLmNvbXB1dGVkTWluO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RlcFZhbHVlKC0xICogbXVsdGlwbGllcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbktleWRvd246IGZ1bmN0aW9uIG9uS2V5ZG93bihldnQpIHtcbiAgICAgICAgdmFyIGtleUNvZGUgPSBldnQua2V5Q29kZSxcbiAgICAgICAgICAgIGFsdEtleSA9IGV2dC5hbHRLZXksXG4gICAgICAgICAgICBjdHJsS2V5ID0gZXZ0LmN0cmxLZXksXG4gICAgICAgICAgICBtZXRhS2V5ID0gZXZ0Lm1ldGFLZXk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkgfHwgYWx0S2V5IHx8IGN0cmxLZXkgfHwgbWV0YUtleSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcnJheUluY2x1ZGVzKFtVUCQxLCBET1dOJDEsIEhPTUUkMSwgRU5EJDEsIFBBR0VVUCQxLCBQQUdFRE9XTiQxXSwga2V5Q29kZSkpIHtcbiAgICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vYXJpYS1wcmFjdGljZXMvI3NwaW5idXR0b25cbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblxuICAgICAgICAgIGlmICh0aGlzLiRfa2V5SXNEb3duKSB7XG4gICAgICAgICAgICAvLyBLZXlwcmVzcyBpcyBhbHJlYWR5IGluIHByb2dyZXNzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5yZXNldFRpbWVycygpO1xuXG4gICAgICAgICAgaWYgKGFycmF5SW5jbHVkZXMoW1VQJDEsIERPV04kMV0sIGtleUNvZGUpKSB7XG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHVzZSB0aGUgY3VzdG9tIGF1dG8tcmVwZWF0IGhhbmRsaW5nXG4gICAgICAgICAgICB0aGlzLiRfa2V5SXNEb3duID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IFVQJDEpIHtcbiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTdGVwUmVwZWF0KGV2dCwgdGhpcy5zdGVwVXApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBET1dOJDEpIHtcbiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTdGVwUmVwZWF0KGV2dCwgdGhpcy5zdGVwRG93bik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZXNlIHVzZSBuYXRpdmUgT1Mga2V5IHJlcGVhdGluZ1xuICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IFBBR0VVUCQxKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RlcFVwKHRoaXMuY29tcHV0ZWRTdGVwTXVsdGlwbGllcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IFBBR0VET1dOJDEpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGVwRG93bih0aGlzLmNvbXB1dGVkU3RlcE11bHRpcGxpZXIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBIT01FJDEpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2NhbFZhbHVlID0gdGhpcy5jb21wdXRlZE1pbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gRU5EJDEpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2NhbFZhbHVlID0gdGhpcy5jb21wdXRlZE1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbktleXVwOiBmdW5jdGlvbiBvbktleXVwKGV2dCkge1xuICAgICAgICAvLyBFbWl0IGEgY2hhbmdlIGV2ZW50IHdoZW4gdGhlIGtleXVwIGhhcHBlbnNcbiAgICAgICAgdmFyIGtleUNvZGUgPSBldnQua2V5Q29kZSxcbiAgICAgICAgICAgIGFsdEtleSA9IGV2dC5hbHRLZXksXG4gICAgICAgICAgICBjdHJsS2V5ID0gZXZ0LmN0cmxLZXksXG4gICAgICAgICAgICBtZXRhS2V5ID0gZXZ0Lm1ldGFLZXk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkgfHwgYWx0S2V5IHx8IGN0cmxLZXkgfHwgbWV0YUtleSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcnJheUluY2x1ZGVzKFtVUCQxLCBET1dOJDEsIEhPTUUkMSwgRU5EJDEsIFBBR0VVUCQxLCBQQUdFRE9XTiQxXSwga2V5Q29kZSkpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0VGltZXJzKCk7XG4gICAgICAgICAgdGhpcy4kX2tleUlzRG93biA9IGZhbHNlO1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFuZGxlU3RlcFJlcGVhdDogZnVuY3Rpb24gaGFuZGxlU3RlcFJlcGVhdChldnQsIHN0ZXBwZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgX3JlZiA9IGV2dCB8fCB7fSxcbiAgICAgICAgICAgIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICAgICAgICBidXR0b24gPSBfcmVmLmJ1dHRvbjtcblxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgIXRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ21vdXNlZG93bicgJiYgYnV0dG9uKSB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IHJlc3BvbmQgdG8gbGVmdCAobWFpbiA9PT0gMCkgYnV0dG9uIGNsaWNrc1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucmVzZXRUaW1lcnMoKTsgLy8gRW5hYmxlIGJvZHkgbW91c2V1cCBldmVudCBoYW5kbGVyXG5cbiAgICAgICAgICB0aGlzLnNldE1vdXNldXAodHJ1ZSk7IC8vIFN0ZXAgdGhlIGNvdW50ZXIgaW5pdGlhbGx5XG5cbiAgICAgICAgICBzdGVwcGVyKDEpO1xuICAgICAgICAgIHZhciB0aHJlc2hvbGQgPSB0aGlzLmNvbXB1dGVkVGhyZXNob2xkO1xuICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gdGhpcy5jb21wdXRlZFN0ZXBNdWx0aXBsaWVyO1xuICAgICAgICAgIHZhciBkZWxheSA9IHRoaXMuY29tcHV0ZWREZWxheTtcbiAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSB0aGlzLmNvbXB1dGVkSW50ZXJ2YWw7IC8vIEluaXRpYXRlIHRoZSBkZWxheS9yZXBlYXQgaW50ZXJ2YWxcblxuICAgICAgICAgIHRoaXMuJF9hdXRvRGVsYXlUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIF90aGlzLiRfYXV0b1JlcGVhdFRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBBZnRlciBOIGluaXRpYWwgcmVwZWF0cywgd2UgaW5jcmVhc2UgdGhlIGluY3JlbWVudGluZyBzdGVwIGFtb3VudFxuICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHRvIG1pbmltaXplIHNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50cyBvZiB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgLy8gKHZhbHVlcyBhcmUgYW5ub3VuY2VkIGV2ZXJ5IGNoYW5nZSwgd2hpY2ggY2FuIGJlIGNoYXR0eSBmb3IgU1IgdXNlcnMpXG4gICAgICAgICAgICAgIC8vIEFuZCB0byBtYWtlIGl0IGVhc2VyIHRvIHNlbGVjdCBhIHZhbHVlIHdoZW4gdGhlIHJhbmdlIGlzIGxhcmdlXG4gICAgICAgICAgICAgIHN0ZXBwZXIoY291bnQgPCB0aHJlc2hvbGQgPyAxIDogbXVsdGlwbGllcik7XG4gICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Nb3VzZXVwOiBmdW5jdGlvbiBvbk1vdXNldXAoZXZ0KSB7XG4gICAgICAgIC8vIGA8Ym9keT5gIGxpc3RlbmVyLCBvbmx5IGVuYWJsZWQgd2hlbiBtb3VzZWRvd24gc3RhcnRzXG4gICAgICAgIHZhciBfcmVmMiA9IGV2dCB8fCB7fSxcbiAgICAgICAgICAgIHR5cGUgPSBfcmVmMi50eXBlLFxuICAgICAgICAgICAgYnV0dG9uID0gX3JlZjIuYnV0dG9uO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblxuXG4gICAgICAgIGlmICh0eXBlID09PSAnbW91c2V1cCcgJiYgYnV0dG9uKSB7XG4gICAgICAgICAgLy8gd2Ugb25seSBjYXJlIGFib3V0IGxlZnQgKG1haW4gPT09IDApIG1vdXNlIGJ1dHRvbiBjbGlja1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVzZXRUaW1lcnMoKTtcbiAgICAgICAgdGhpcy5zZXRNb3VzZXVwKGZhbHNlKTsgLy8gVHJpZ2dlciB0aGUgY2hhbmdlIGV2ZW50XG5cbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgc2V0TW91c2V1cDogZnVuY3Rpb24gc2V0TW91c2V1cChvbikge1xuICAgICAgICAvLyBFbmFibGUgb3IgZGlzYWJsZWQgdGhlIGJvZHkgbW91c2V1cC90b3VjaGVuZCBoYW5kbGVyc1xuICAgICAgICAvLyBVc2UgdHJ5L2NhdGNoIHRvIGhhbmRsZSBjYXNlIHdoZW4gY2FsbGVkIHNlcnZlciBzaWRlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXZlbnRPbk9mZihvbiwgZG9jdW1lbnQuYm9keSwgJ21vdXNldXAnLCB0aGlzLm9uTW91c2V1cCwgRVZFTlRfT1BUSU9OU19QQVNTSVZFKTtcbiAgICAgICAgICBldmVudE9uT2ZmKG9uLCBkb2N1bWVudC5ib2R5LCAndG91Y2hlbmQnLCB0aGlzLm9uTW91c2V1cCwgRVZFTlRfT1BUSU9OU19QQVNTSVZFKTtcbiAgICAgICAgfSBjYXRjaCAoX3VudXNlZDMpIHt9XG4gICAgICB9LFxuICAgICAgcmVzZXRUaW1lcnM6IGZ1bmN0aW9uIHJlc2V0VGltZXJzKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4kX2F1dG9EZWxheVRpbWVyKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLiRfYXV0b1JlcGVhdFRpbWVyKTtcbiAgICAgIH0sXG4gICAgICBjbGVhclJlcGVhdDogZnVuY3Rpb24gY2xlYXJSZXBlYXQoKSB7XG4gICAgICAgIHRoaXMucmVzZXRUaW1lcnMoKTtcbiAgICAgICAgdGhpcy5zZXRNb3VzZXVwKGZhbHNlKTtcbiAgICAgICAgdGhpcy4kX2tleUlzRG93biA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXMsXG4gICAgICAgICAgX2NsYXNzO1xuXG4gICAgICB2YXIgc3BpbklkID0gdGhpcy5zYWZlSWQoKTtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMubG9jYWxWYWx1ZTtcbiAgICAgIHZhciBpc1ZlcnRpY2FsID0gdGhpcy52ZXJ0aWNhbDtcbiAgICAgIHZhciBpc0lubGluZSA9IHRoaXMuaW5saW5lICYmICFpc1ZlcnRpY2FsO1xuICAgICAgdmFyIGlzRGlzYWJsZWQgPSB0aGlzLmRpc2FibGVkO1xuICAgICAgdmFyIGlzUmVhZG9ubHkgPSB0aGlzLnJlYWRvbmx5ICYmICFpc0Rpc2FibGVkO1xuICAgICAgdmFyIGlzUmVxdWlyZWQgPSB0aGlzLnJlcXVpcmVkICYmICFpc1JlYWRvbmx5ICYmICFpc0Rpc2FibGVkO1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgICAgdmFyIGhhc1ZhbHVlID0gIWlzTnVsbCh2YWx1ZSk7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gaXNGdW5jdGlvbih0aGlzLmZvcm1hdHRlckZuKSA/IHRoaXMuZm9ybWF0dGVyRm4gOiB0aGlzLmRlZmF1bHRGb3JtYXR0ZXI7XG5cbiAgICAgIHZhciBtYWtlQnV0dG9uID0gZnVuY3Rpb24gbWFrZUJ1dHRvbihzdGVwcGVyLCBsYWJlbCwgSWNvbkNtcCwga2V5UmVmLCBzaG9ydGN1dCwgYnRuRGlzYWJsZWQpIHtcbiAgICAgICAgdmFyICRpY29uID0gaChJY29uQ21wLCB7XG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIHNjYWxlOiBfdGhpczIuaGFzRm9jdXMgPyAxLjUgOiAxLjI1XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZXZ0KVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdW50aWwgdGVzdHMgd3JpdHRlbiAqL1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFpc0Rpc2FibGVkICYmICFpc1JlYWRvbmx5KSB7XG4gICAgICAgICAgICBfdGhpczIuaGFuZGxlU3RlcFJlcGVhdChldnQsIHN0ZXBwZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gaCgnYnV0dG9uJywge1xuICAgICAgICAgIGtleToga2V5UmVmIHx8IG51bGwsXG4gICAgICAgICAgcmVmOiBrZXlSZWYsXG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICdidG4gYnRuLXNtIGJvcmRlci0wIHJvdW5kZWQtMCcsXG4gICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICdweS0wJzogIWlzVmVydGljYWxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICB0YWJpbmRleDogJy0xJyxcbiAgICAgICAgICAgIHR5cGU6ICdidXR0b24nLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGlzRGlzYWJsZWQgfHwgaXNSZWFkb25seSB8fCBidG5EaXNhYmxlZCxcbiAgICAgICAgICAgICdhcmlhLWRpc2FibGVkJzogaXNEaXNhYmxlZCB8fCBpc1JlYWRvbmx5IHx8IGJ0bkRpc2FibGVkID8gJ3RydWUnIDogbnVsbCxcbiAgICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogc3BpbklkLFxuICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiBsYWJlbCB8fCBudWxsLFxuICAgICAgICAgICAgJ2FyaWEta2V5c2hvcnRjdXRzJzogc2hvcnRjdXQgfHwgbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIG1vdXNlZG93bjogaGFuZGxlcixcbiAgICAgICAgICAgIHRvdWNoc3RhcnQ6IGhhbmRsZXJcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFtoKCdkaXYnLCB7fSwgWyRpY29uXSldKTtcbiAgICAgIH07IC8vIFRPRE86IEFkZCBidXR0b24gZGlzYWJsZWQgc3RhdGUgd2hlbiBgd3JhcGAgaXMgYGZhbHNlYCBhbmQgYXQgdmFsdWUgbWF4L21pblxuXG5cbiAgICAgIHZhciAkaW5jcmVtZW50ID0gbWFrZUJ1dHRvbih0aGlzLnN0ZXBVcCwgdGhpcy5sYWJlbEluY3JlbWVudCwgQkljb25QbHVzLCAnaW5jJywgJ0Fycm93VXAnKTtcbiAgICAgIHZhciAkZGVjcmVtZW50ID0gbWFrZUJ1dHRvbih0aGlzLnN0ZXBEb3duLCB0aGlzLmxhYmVsRGVjcmVtZW50LCBCSWNvbkRhc2gsICdkZWMnLCAnQXJyb3dEb3duJyk7XG4gICAgICB2YXIgJGhpZGRlbiA9IGgoKTtcblxuICAgICAgaWYgKHRoaXMubmFtZSAmJiAhaXNEaXNhYmxlZCkge1xuICAgICAgICAkaGlkZGVuID0gaCgnaW5wdXQnLCB7XG4gICAgICAgICAga2V5OiAnaGlkZGVuJyxcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgdHlwZTogJ2hpZGRlbicsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBmb3JtOiB0aGlzLmZvcm0gfHwgbnVsbCxcbiAgICAgICAgICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGJlIHNldCB0byAnJyBpZiB2YWx1ZSBpcyBvdXQgb2YgcmFuZ2U/XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZUFzRml4ZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgJHNwaW4gPSBoKCAvLyBXZSB1c2UgJ291dHB1dCcgZWxlbWVudCB0byBtYWtlIHRoaXMgYWNjZXB0IGEgYDxsYWJlbCBmb3I9XCJpZFwiPmAgKEV4Y2VwdCBJRSlcbiAgICAgICdvdXRwdXQnLCB7XG4gICAgICAgIHJlZjogJ3NwaW5uZXInLFxuICAgICAgICBrZXk6ICdvdXRwdXQnLFxuICAgICAgICBzdGF0aWNDbGFzczogJ2ZsZXgtZ3Jvdy0xJyxcbiAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAndy0xMDAnOiAhaXNWZXJ0aWNhbCAmJiAhaXNJbmxpbmUsXG4gICAgICAgICAgJ2QtZmxleCc6IGlzVmVydGljYWwsXG4gICAgICAgICAgJ2FsaWduLXNlbGYtY2VudGVyJzogIWlzVmVydGljYWwsXG4gICAgICAgICAgJ2FsaWduLWl0ZW1zLWNlbnRlcic6IGlzVmVydGljYWwsXG4gICAgICAgICAgJ3B5LTEnOiBpc1ZlcnRpY2FsLFxuICAgICAgICAgICdweC0xJzogIWlzVmVydGljYWwsXG4gICAgICAgICAgJ214LTEnOiBpc1ZlcnRpY2FsLFxuICAgICAgICAgICdib3JkZXItdG9wJzogaXNWZXJ0aWNhbCxcbiAgICAgICAgICAnYm9yZGVyLWJvdHRvbSc6IGlzVmVydGljYWwsXG4gICAgICAgICAgJ2JvcmRlci1sZWZ0JzogIWlzVmVydGljYWwsXG4gICAgICAgICAgJ2JvcmRlci1yaWdodCc6ICFpc1ZlcnRpY2FsXG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHNwaW5JZCxcbiAgICAgICAgICByb2xlOiAnc3BpbmJ1dHRvbicsXG4gICAgICAgICAgdGFiaW5kZXg6IGlzRGlzYWJsZWQgPyBudWxsIDogJzAnLFxuICAgICAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJyxcbiAgICAgICAgICAnYXJpYS1sYWJlbCc6IHRoaXMuYXJpYUxhYmVsIHx8IG51bGwsXG4gICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiB0aGlzLmFyaWFDb250cm9scyB8fCBudWxsLFxuICAgICAgICAgIC8vIFRPRE86IE1heSB3YW50IHRvIGNoZWNrIGlmIHRoZSB2YWx1ZSBpcyBpbiByYW5nZVxuICAgICAgICAgICdhcmlhLWludmFsaWQnOiBzdGF0ZSA9PT0gZmFsc2UgfHwgIWhhc1ZhbHVlICYmIGlzUmVxdWlyZWQgPyAndHJ1ZScgOiBudWxsLFxuICAgICAgICAgICdhcmlhLXJlcXVpcmVkJzogaXNSZXF1aXJlZCA/ICd0cnVlJyA6IG51bGwsXG4gICAgICAgICAgLy8gVGhlc2UgYXR0cnMgYXJlIHJlcXVpcmVkIGZvciByb2xlIHNwaW5idXR0b25cbiAgICAgICAgICAnYXJpYS12YWx1ZW1pbic6IHRvU3RyaW5nJDEodGhpcy5jb21wdXRlZE1pbiksXG4gICAgICAgICAgJ2FyaWEtdmFsdWVtYXgnOiB0b1N0cmluZyQxKHRoaXMuY29tcHV0ZWRNYXgpLFxuICAgICAgICAgIC8vIFRoZXNlIHNob3VsZCBiZSBgbnVsbGAgaWYgdGhlIHZhbHVlIGlzIG91dCBvZiByYW5nZVxuICAgICAgICAgIC8vIFRoZXkgbXVzdCBhbHNvIGJlIG5vbi1leGlzdGVudCBhdHRycyBpZiB0aGUgdmFsdWUgaXMgb3V0IG9mIHJhbmdlIG9yIGBudWxsYFxuICAgICAgICAgICdhcmlhLXZhbHVlbm93JzogaGFzVmFsdWUgPyB2YWx1ZSA6IG51bGwsXG4gICAgICAgICAgJ2FyaWEtdmFsdWV0ZXh0JzogaGFzVmFsdWUgPyBmb3JtYXR0ZXIodmFsdWUpIDogbnVsbFxuICAgICAgICB9XG4gICAgICB9LCBbaCgnZGl2Jywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ3ctMTAwJ1xuICAgICAgfSwgaGFzVmFsdWUgPyBmb3JtYXR0ZXIodmFsdWUpIDogdGhpcy5wbGFjZWhvbGRlciB8fCAnJyldKTtcbiAgICAgIHJldHVybiBoKCdkaXYnLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnYi1mb3JtLXNwaW5idXR0b24gZm9ybS1jb250cm9sIHAtMCcsXG4gICAgICAgIGNsYXNzOiAoX2NsYXNzID0ge1xuICAgICAgICAgIGRpc2FibGVkOiBpc0Rpc2FibGVkLFxuICAgICAgICAgIHJlYWRvbmx5OiBpc1JlYWRvbmx5LFxuICAgICAgICAgIGZvY3VzOiB0aGlzLmhhc0ZvY3VzXG4gICAgICAgIH0sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsIFwiZm9ybS1jb250cm9sLVwiLmNvbmNhdChzaXplKSwgISFzaXplKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzcywgJ2QtaW5saW5lLWZsZXgnLCBpc0lubGluZSB8fCBpc1ZlcnRpY2FsKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzcywgJ2QtZmxleCcsICFpc0lubGluZSAmJiAhaXNWZXJ0aWNhbCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsICdhbGlnbi1pdGVtcy1zdHJldGNoJywgIWlzVmVydGljYWwpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzLCAnZmxleC1jb2x1bW4nLCBpc1ZlcnRpY2FsKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzcywgJ2lzLXZhbGlkJywgc3RhdGUgPT09IHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzLCAnaXMtaW52YWxpZCcsIHN0YXRlID09PSBmYWxzZSksIF9jbGFzcyksXG4gICAgICAgIGF0dHJzOiBfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy4kYXR0cnMsIHtcbiAgICAgICAgICByb2xlOiAnZ3JvdXAnLFxuICAgICAgICAgIGxhbmc6IHRoaXMuY29tcHV0ZWRMb2NhbGUsXG4gICAgICAgICAgdGFiaW5kZXg6IGlzRGlzYWJsZWQgPyBudWxsIDogJy0xJyxcbiAgICAgICAgICAvLyBXZSB3YW50IHRvIGtlZXAgdGhlIG9yZGVyIG9mIHRoZSBidXR0b25zIHJlZ2FyZGxlc3NcbiAgICAgICAgICAvLyBvZiBsb2NhbGUgKGZsZXggd2lsbCByZS1vcmRlciBiYXNlZCBvbiBydGwvbHRyKVxuICAgICAgICAgIGRpcjogJ2x0cidcbiAgICAgICAgfSksXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAga2V5ZG93bjogdGhpcy5vbktleWRvd24sXG4gICAgICAgICAga2V5dXA6IHRoaXMub25LZXl1cCxcbiAgICAgICAgICAvLyBXZSB1c2UgY2FwdHVyZSBwaGFzZSAoYCFgIHByZWZpeCkgc2luY2UgZm9jdXMgYW5kIGJsdXIgZG8gbm90IGJ1YmJsZVxuICAgICAgICAgICchZm9jdXMnOiB0aGlzLm9uRm9jdXNCbHVyLFxuICAgICAgICAgICchYmx1cic6IHRoaXMub25Gb2N1c0JsdXJcbiAgICAgICAgfVxuICAgICAgfSwgaXNWZXJ0aWNhbCA/IFskaW5jcmVtZW50LCAkaGlkZGVuLCAkc3BpbiwgJGRlY3JlbWVudF0gOiBbJGRlY3JlbWVudCwgJGhpZGRlbiwgJHNwaW4sICRpbmNyZW1lbnRdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBGb3JtU3BpbmJ1dHRvblBsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgY29tcG9uZW50czoge1xuICAgICAgQkZvcm1TcGluYnV0dG9uOiBCRm9ybVNwaW5idXR0b24sXG4gICAgICBCU3BpbmJ1dHRvbjogQkZvcm1TcGluYnV0dG9uXG4gICAgfVxuICB9KTtcblxuICB2YXIgTkFNRSRpID0gJ0JGb3JtVGFnJztcbiAgdmFyIEJGb3JtVGFnID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiBOQU1FJGksXG4gICAgbWl4aW5zOiBbaWRNaXhpbiwgbm9ybWFsaXplU2xvdE1peGluXSxcbiAgICBwcm9wczoge1xuICAgICAgdmFyaWFudDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRpLCAndmFyaWFudCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzYWJsZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICB0aXRsZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBwaWxsOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgcmVtb3ZlTGFiZWw6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkaSwgJ3JlbW92ZUxhYmVsJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0YWc6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnc3BhbidcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIG9uRGVsZXRlOiBmdW5jdGlvbiBvbkRlbGV0ZShldnQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBldnQudHlwZSxcbiAgICAgICAgICAgIGtleUNvZGUgPSBldnQua2V5Q29kZTtcblxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ2tleWRvd24nICYmIGtleUNvZGUgPT09IEtFWV9DT0RFUy5ERUxFVEUpKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgncmVtb3ZlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHZhciB0YWdJZCA9IHRoaXMuc2FmZUlkKCk7XG4gICAgICB2YXIgdGFnTGFiZWxJZCA9IHRoaXMuc2FmZUlkKCdfdGFnbGFiZWxfJyk7XG4gICAgICB2YXIgJHJlbW92ZSA9IGgoKTtcblxuICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICRyZW1vdmUgPSBoKEJCdXR0b25DbG9zZSwge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiAnYi1mb3JtLXRhZy1yZW1vdmUgbWwtMScsXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGFyaWFMYWJlbDogdGhpcy5yZW1vdmVMYWJlbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogdGFnSWQsXG4gICAgICAgICAgICAnYXJpYS1kZXNjcmliZWRieSc6IHRhZ0xhYmVsSWQsXG4gICAgICAgICAgICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAnRGVsZXRlJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNsaWNrOiB0aGlzLm9uRGVsZXRlLFxuICAgICAgICAgICAga2V5ZG93bjogdGhpcy5vbkRlbGV0ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciAkdGFnID0gaCgnc3BhbicsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdiLWZvcm0tdGFnLWNvbnRlbnQgZmxleC1ncm93LTEgdGV4dC10cnVuY2F0ZScsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHRhZ0xhYmVsSWRcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5ub3JtYWxpemVTbG90KCdkZWZhdWx0JykgfHwgdGhpcy50aXRsZSB8fCBbaCgpXSk7XG4gICAgICByZXR1cm4gaChCQmFkZ2UsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdiLWZvcm0tdGFnIGQtaW5saW5lLWZsZXggYWxpZ24taXRlbXMtYmFzZWxpbmUgbXctMTAwJyxcbiAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZFxuICAgICAgICB9LFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiB0YWdJZCxcbiAgICAgICAgICB0aXRsZTogdGhpcy50aXRsZSB8fCBudWxsLFxuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiB0YWdMYWJlbElkXG4gICAgICAgIH0sXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgdGFnOiB0aGlzLnRhZyxcbiAgICAgICAgICB2YXJpYW50OiB0aGlzLnZhcmlhbnQsXG4gICAgICAgICAgcGlsbDogdGhpcy5waWxsXG4gICAgICAgIH1cbiAgICAgIH0sIFskdGFnLCAkcmVtb3ZlXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgTkFNRSRqID0gJ0JGb3JtVGFncyc7IC8vIFN1cHBvcnRlZCBpbnB1dCB0eXBlcyAoZm9yIGJ1aWx0IGluIGlucHV0KVxuXG4gIHZhciBUWVBFUyQxID0gWyd0ZXh0JywgJ2VtYWlsJywgJ3RlbCcsICd1cmwnLCAnbnVtYmVyJ107IC8vIFByZS1jb21waWxlZCByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG5cbiAgdmFyIFJYX1NQQUNFUyA9IC9bXFxzXFx1RkVGRlxceEEwXSsvZzsgLy8gS2V5Q29kZSBjb25zdGFudHNcblxuICB2YXIgRU5URVIkMSA9IEtFWV9DT0RFUy5FTlRFUixcbiAgICAgIEJBQ0tTUEFDRSA9IEtFWV9DT0RFUy5CQUNLU1BBQ0UsXG4gICAgICBERUxFVEUgPSBLRVlfQ09ERVMuREVMRVRFOyAvLyAtLS0gVXRpbGl0eSBtZXRob2RzIC0tLVxuICAvLyBFc2NhcGUgc3BlY2lhbCBjaGFycyBpbiBzdHJpbmcgYW5kIHJlcGxhY2VcbiAgLy8gY29udGlndW91cyBzcGFjZXMgd2l0aCBhIHdoaXRlc3BhY2UgbWF0Y2hcblxuICB2YXIgZXNjYXBlUmVnRXhwQ2hhcnMgPSBmdW5jdGlvbiBlc2NhcGVSZWdFeHBDaGFycyhzdHIpIHtcbiAgICByZXR1cm4gZXNjYXBlUmVnRXhwKHN0cikucmVwbGFjZShSWF9TUEFDRVMsICdcXFxccycpO1xuICB9OyAvLyBSZW1vdmUgbGVhZGluZy90cmFpbGluZyBzcGFjZXMgZnJvbSBhcnJheSBvZiB0YWdzIGFuZCByZW1vdmUgZHVwbGljYXRlc1xuXG5cbiAgdmFyIGNsZWFuVGFncyA9IGZ1bmN0aW9uIGNsZWFuVGFncyh0YWdzKSB7XG4gICAgcmV0dXJuIGNvbmNhdCh0YWdzKS5tYXAoZnVuY3Rpb24gKHRhZykge1xuICAgICAgcmV0dXJuIHRyaW0odG9TdHJpbmckMSh0YWcpKTtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHRhZywgaW5kZXgsIGFycikge1xuICAgICAgcmV0dXJuIHRhZy5sZW5ndGggPiAwICYmIGFyci5pbmRleE9mKHRhZykgPT09IGluZGV4O1xuICAgIH0pO1xuICB9OyAvLyBQcm9jZXNzZXMgYW4gaW5wdXQvY2hhbmdlIGV2ZW50LCBub3JtYWxpemluZyBzdHJpbmcgb3IgZXZlbnQgYXJndW1lbnRcblxuXG4gIHZhciBwcm9jZXNzRXZlbnRWYWx1ZSA9IGZ1bmN0aW9uIHByb2Nlc3NFdmVudFZhbHVlKGV2dCkge1xuICAgIHJldHVybiBpc1N0cmluZyhldnQpID8gZXZ0IDogaXNFdmVudChldnQpID8gZXZ0LnRhcmdldC52YWx1ZSB8fCAnJyA6ICcnO1xuICB9OyAvLyBSZXR1cm5zIGEgZnJlc2ggZW1wdHkgYHRhZ3NTdGF0ZWAgb2JqZWN0XG5cblxuICB2YXIgY2xlYW5UYWdzU3RhdGUgPSBmdW5jdGlvbiBjbGVhblRhZ3NTdGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWxsOiBbXSxcbiAgICAgIHZhbGlkOiBbXSxcbiAgICAgIGludmFsaWQ6IFtdLFxuICAgICAgZHVwbGljYXRlOiBbXVxuICAgIH07XG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cblxuICB2YXIgQkZvcm1UYWdzID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiBOQU1FJGosXG4gICAgbWl4aW5zOiBbaWRNaXhpbiwgbm9ybWFsaXplU2xvdE1peGluXSxcbiAgICBtb2RlbDoge1xuICAgICAgLy8gRXZlbiB0aG91Z2ggdGhpcyBpcyB0aGUgZGVmYXVsdCB0aGF0IFZ1ZSBhc3N1bWVzLCB3ZSBuZWVkXG4gICAgICAvLyB0byBhZGQgaXQgZm9yIHRoZSBkb2NzIHRvIHJlZmxlY3QgdGhhdCB0aGlzIGlzIHRoZSBtb2RlbFxuICAgICAgcHJvcDogJ3ZhbHVlJyxcbiAgICAgIGV2ZW50OiAnaW5wdXQnXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgaW5wdXRJZDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBwbGFjZWhvbGRlcjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRqLCAncGxhY2Vob2xkZXInKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgbmFtZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBmb3JtOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIGF1dG9mb2N1czoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHN0YXRlOiB7XG4gICAgICAgIC8vIFRyaS1zdGF0ZTogYHRydWVgLCBgZmFsc2VgLCBgbnVsbGBcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgaW5wdXRUeXBlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ3RleHQnLFxuICAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcih0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXMoVFlQRVMkMSwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbnB1dENsYXNzOiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgaW5wdXRBdHRyczoge1xuICAgICAgICAvLyBBZGRpdGlvbmFsIGF0dHJpYnV0ZXMgdG8gYWRkIHRvIHRoZSBpbnB1dCBlbGVtZW50XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWRkQnV0dG9uVGV4dDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRqLCAnYWRkQnV0dG9uVGV4dCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWRkQnV0dG9uVmFyaWFudDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRqLCAnYWRkQnV0dG9uVmFyaWFudCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGFnVmFyaWFudDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRqLCAndGFnVmFyaWFudCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGFnQ2xhc3M6IHtcbiAgICAgICAgdHlwZTogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICB0YWdQaWxsczoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHRhZ1JlbW92ZUxhYmVsOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJGosICd0YWdSZW1vdmVMYWJlbCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGFnUmVtb3ZlZExhYmVsOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJGosICd0YWdSZW1vdmVkTGFiZWwnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRhZ1ZhbGlkYXRvcjoge1xuICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIGR1cGxpY2F0ZVRhZ1RleHQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkaiwgJ2R1cGxpY2F0ZVRhZ1RleHQnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGludmFsaWRUYWdUZXh0OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJGosICdpbnZhbGlkVGFnVGV4dCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2VwYXJhdG9yOiB7XG4gICAgICAgIC8vIENoYXJhY3RlciAob3IgY2hhcmFjdGVycykgdGhhdCB0cmlnZ2VyIGFkZGluZyB0YWdzXG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5XSxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHJlbW92ZU9uRGVsZXRlOiB7XG4gICAgICAgIC8vIEVuYWJsZSBkZWxldGluZyBsYXN0IHRhZyBpbiBsaXN0IHdoZW4gQkFDS1NQQUNFIGlzXG4gICAgICAgIC8vIHByZXNzZWQgYW5kIGlucHV0IGlzIGVtcHR5XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgYWRkT25DaGFuZ2U6IHtcbiAgICAgICAgLy8gRW5hYmxlIGNoYW5nZSBldmVudCB0cmlnZ2VyaW5nIHRhZyBhZGRpdGlvblxuICAgICAgICAvLyBIYW5keSBpZiB1c2luZyA8c2VsZWN0PiBhcyB0aGUgaW5wdXRcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBub0FkZE9uRW50ZXI6IHtcbiAgICAgICAgLy8gRGlzYWJsZSBFTlRFUiBrZXkgZnJvbSB0cmlnZ2VyaW5nIHRhZyBhZGRpdGlvblxuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIG5vT3V0ZXJGb2N1czoge1xuICAgICAgICAvLyBEaXNhYmxlIHRoZSBmb2N1cyByaW5nIG9uIHRoZSByb290IGVsZW1lbnRcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICB2YWx1ZToge1xuICAgICAgICAvLyBUaGUgdi1tb2RlbCBwcm9wXG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYXNGb2N1czogZmFsc2UsXG4gICAgICAgIG5ld1RhZzogJycsXG4gICAgICAgIHRhZ3M6IFtdLFxuICAgICAgICAvLyBUYWdzIHRoYXQgd2VyZSByZW1vdmVkXG4gICAgICAgIHJlbW92ZWRUYWdzOiBbXSxcbiAgICAgICAgLy8gUG9wdWxhdGVkIHdoZW4gdGFncyBhcmUgcGFyc2VkXG4gICAgICAgIHRhZ3NTdGF0ZTogY2xlYW5UYWdzU3RhdGUoKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBjb21wdXRlZElucHV0SWQ6IGZ1bmN0aW9uIGNvbXB1dGVkSW5wdXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRJZCB8fCB0aGlzLnNhZmVJZCgnX19pbnB1dF9fJyk7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRJbnB1dFR5cGU6IGZ1bmN0aW9uIGNvbXB1dGVkSW5wdXRUeXBlKCkge1xuICAgICAgICAvLyBXZSBvbmx5IGFsbG93IGNlcnRhaW4gdHlwZXNcbiAgICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXMoVFlQRVMkMSwgdGhpcy5pbnB1dFR5cGUpID8gdGhpcy5pbnB1dFR5cGUgOiAndGV4dCc7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRJbnB1dEF0dHJzOiBmdW5jdGlvbiBjb21wdXRlZElucHV0QXR0cnMoKSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5pbnB1dEF0dHJzLCB7XG4gICAgICAgICAgLy8gTXVzdCBoYXZlIGF0dHJpYnV0ZXNcbiAgICAgICAgICBpZDogdGhpcy5jb21wdXRlZElucHV0SWQsXG4gICAgICAgICAgdmFsdWU6IHRoaXMubmV3VGFnLFxuICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkIHx8IG51bGwsXG4gICAgICAgICAgZm9ybTogdGhpcy5mb3JtIHx8IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRJbnB1dEhhbmRsZXJzOiBmdW5jdGlvbiBjb21wdXRlZElucHV0SGFuZGxlcnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5wdXQ6IHRoaXMub25JbnB1dElucHV0LFxuICAgICAgICAgIGNoYW5nZTogdGhpcy5vbklucHV0Q2hhbmdlLFxuICAgICAgICAgIGtleWRvd246IHRoaXMub25JbnB1dEtleWRvd25cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZFNlcGFyYXRvcjogZnVuY3Rpb24gY29tcHV0ZWRTZXBhcmF0b3IoKSB7XG4gICAgICAgIC8vIE1lcmdlIHRoZSBhcnJheSBpbnRvIGEgc3RyaW5nXG4gICAgICAgIHJldHVybiBjb25jYXQodGhpcy5zZXBhcmF0b3IpLmZpbHRlcihpc1N0cmluZykuZmlsdGVyKGlkZW50aXR5KS5qb2luKCcnKTtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZFNlcGFyYXRvclJlZ0V4cDogZnVuY3Rpb24gY29tcHV0ZWRTZXBhcmF0b3JSZWdFeHAoKSB7XG4gICAgICAgIC8vIFdlIHVzZSBhIGNvbXB1dGVkIHByb3AgaGVyZSB0byBwcmVjb21waWxlIHRoZSBSZWdFeHBcbiAgICAgICAgLy8gVGhlIFJlZ0V4cCBpcyBhIGNoYXJhY3RlciBjbGFzcyBSRSBpbiB0aGUgZm9ybSBvZiBgL1thYmNdKy9gXG4gICAgICAgIC8vIHdoZXJlIGEsIGIsIGFuZCBjIGFyZSB0aGUgdmFsaWQgc2VwYXJhdG9yIGNoYXJhY3RlcnNcbiAgICAgICAgLy8gLT4gYHRhZ3MgPSBzdHIuc3BsaXQoL1thYmNdKy8pLmZpbHRlcih0ID0+IHQpYFxuICAgICAgICB2YXIgc2VwYXJhdG9yID0gdGhpcy5jb21wdXRlZFNlcGFyYXRvcjtcbiAgICAgICAgcmV0dXJuIHNlcGFyYXRvciA/IG5ldyBSZWdFeHAoXCJbXCIuY29uY2F0KGVzY2FwZVJlZ0V4cENoYXJzKHNlcGFyYXRvciksIFwiXStcIikpIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZEpvaW5lcjogZnVuY3Rpb24gY29tcHV0ZWRKb2luZXIoKSB7XG4gICAgICAgIC8vIFdoZW4gdGFnKHMpIGFyZSBpbnZhbGlkIG9yIGR1cGxpY2F0ZSwgd2UgbGVhdmUgdGhlbVxuICAgICAgICAvLyBpbiB0aGUgaW5wdXQgc28gdGhhdCB0aGUgdXNlciBjYW4gc2VlIHRoZW1cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgdGFnIGluIHRoZSBpbnB1dCwgd2UgdXNlIHRoZVxuICAgICAgICAvLyBmaXJzdCBzZXBhcmF0b3IgY2hhcmFjdGVyIGFzIHRoZSBzZXBhcmF0b3IgaW4gdGhlIGlucHV0XG4gICAgICAgIC8vIFdlIGFwcGVuZCBhIHNwYWNlIGlmIHRoZSBmaXJzdCBzZXBhcmF0b3IgaXMgbm90IGEgc3BhY2VcbiAgICAgICAgdmFyIGpvaW5lciA9IHRoaXMuY29tcHV0ZWRTZXBhcmF0b3IuY2hhckF0KDApO1xuICAgICAgICByZXR1cm4gam9pbmVyICE9PSAnICcgPyBcIlwiLmNvbmNhdChqb2luZXIsIFwiIFwiKSA6IGpvaW5lcjtcbiAgICAgIH0sXG4gICAgICBkaXNhYmxlQWRkQnV0dG9uOiBmdW5jdGlvbiBkaXNhYmxlQWRkQnV0dG9uKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIC8vIElmICdBZGQnIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWRcbiAgICAgICAgLy8gSWYgdGhlIGlucHV0IGNvbnRhaW5zIGF0IGxlYXN0IG9uZSB0YWcgdGhhdCBjYW5cbiAgICAgICAgLy8gYmUgYWRkZWQsIHRoZW4gdGhlICdBZGQnIGJ1dHRvbiBzaG91bGQgYmUgZW5hYmxlZFxuICAgICAgICB2YXIgbmV3VGFnID0gdHJpbSh0aGlzLm5ld1RhZyk7XG4gICAgICAgIHJldHVybiBuZXdUYWcgPT09ICcnIHx8ICF0aGlzLnNwbGl0VGFncyhuZXdUYWcpLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gIWFycmF5SW5jbHVkZXMoX3RoaXMudGFncywgdCkgJiYgX3RoaXMudmFsaWRhdGVUYWcodCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGR1cGxpY2F0ZVRhZ3M6IGZ1bmN0aW9uIGR1cGxpY2F0ZVRhZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZ3NTdGF0ZS5kdXBsaWNhdGU7XG4gICAgICB9LFxuICAgICAgaGFzRHVwbGljYXRlVGFnczogZnVuY3Rpb24gaGFzRHVwbGljYXRlVGFncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHVwbGljYXRlVGFncy5sZW5ndGggPiAwO1xuICAgICAgfSxcbiAgICAgIGludmFsaWRUYWdzOiBmdW5jdGlvbiBpbnZhbGlkVGFncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnc1N0YXRlLmludmFsaWQ7XG4gICAgICB9LFxuICAgICAgaGFzSW52YWxpZFRhZ3M6IGZ1bmN0aW9uIGhhc0ludmFsaWRUYWdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnZhbGlkVGFncy5sZW5ndGggPiAwO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShuZXdWYWwpIHtcbiAgICAgICAgdGhpcy50YWdzID0gY2xlYW5UYWdzKG5ld1ZhbCk7XG4gICAgICB9LFxuICAgICAgdGFnczogZnVuY3Rpb24gdGFncyhuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGB2LW1vZGVsYCAoaWYgaXQgZGlmZmVycyBmcm9tIHRoZSB2YWx1ZSBwcm9wKVxuICAgICAgICBpZiAoIWxvb3NlRXF1YWwobmV3VmFsLCB0aGlzLnZhbHVlKSkge1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgbmV3VmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbG9vc2VFcXVhbChuZXdWYWwsIG9sZFZhbCkpIHtcbiAgICAgICAgICBuZXdWYWwgPSBjb25jYXQobmV3VmFsKS5maWx0ZXIoaWRlbnRpdHkpO1xuICAgICAgICAgIG9sZFZhbCA9IGNvbmNhdChvbGRWYWwpLmZpbHRlcihpZGVudGl0eSk7XG4gICAgICAgICAgdGhpcy5yZW1vdmVkVGFncyA9IG9sZFZhbC5maWx0ZXIoZnVuY3Rpb24gKG9sZCkge1xuICAgICAgICAgICAgcmV0dXJuICFhcnJheUluY2x1ZGVzKG5ld1ZhbCwgb2xkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRhZ3NTdGF0ZTogZnVuY3Rpb24gdGFnc1N0YXRlKG5ld1ZhbCwgb2xkVmFsKSB7XG4gICAgICAgIC8vIEVtaXQgYSB0YWctc3RhdGUgZXZlbnQgd2hlbiB0aGUgYHRhZ3NTdGF0ZWAgb2JqZWN0IGNoYW5nZXNcbiAgICAgICAgaWYgKCFsb29zZUVxdWFsKG5ld1ZhbCwgb2xkVmFsKSkge1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ3RhZy1zdGF0ZScsIG5ld1ZhbC52YWxpZCwgbmV3VmFsLmludmFsaWQsIG5ld1ZhbC5kdXBsaWNhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgLy8gV2UgZG8gdGhpcyBpbiBjcmVhdGVkIHRvIG1ha2Ugc3VyZSBhbiBpbnB1dCBldmVudCBlbWl0c1xuICAgICAgLy8gaWYgdGhlIGNsZWFuZWQgdGFncyBhcmUgbm90IGVxdWFsIHRvIHRoZSB2YWx1ZSBwcm9wXG4gICAgICB0aGlzLnRhZ3MgPSBjbGVhblRhZ3ModGhpcy52YWx1ZSk7XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgdGhpcy5oYW5kbGVBdXRvZm9jdXMoKTtcbiAgICB9LFxuICAgIGFjdGl2YXRlZDogZnVuY3Rpb24gYWN0aXZhdGVkKClcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHtcbiAgICAgIHRoaXMuaGFuZGxlQXV0b2ZvY3VzKCk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBhZGRUYWc6IGZ1bmN0aW9uIGFkZFRhZyhuZXdUYWcpIHtcbiAgICAgICAgbmV3VGFnID0gaXNTdHJpbmcobmV3VGFnKSA/IG5ld1RhZyA6IHRoaXMubmV3VGFnO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRyaW0obmV3VGFnKSA9PT0gJycpIHtcbiAgICAgICAgICAvLyBFYXJseSBleGl0XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcnNlZCA9IHRoaXMucGFyc2VUYWdzKG5ld1RhZyk7IC8vIEFkZCBhbnkgbmV3IHRhZ3MgdG8gdGhlIGB0YWdzYCBhcnJheSwgb3IgaWYgdGhlXG4gICAgICAgIC8vIGFycmF5IG9mIGBhbGxUYWdzYCBpcyBlbXB0eSwgd2UgY2xlYXIgdGhlIGlucHV0XG5cbiAgICAgICAgaWYgKHBhcnNlZC52YWxpZC5sZW5ndGggPiAwIHx8IHBhcnNlZC5hbGwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gQ2xlYXIgdGhlIHVzZXIgaW5wdXQgZWxlbWVudCAoYW5kIGxlYXZlIGluIGFueSBpbnZhbGlkL2R1cGxpY2F0ZSB0YWcocylcblxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogZnVsbCB0ZXN0aW5nIHRvIGJlIGFkZGVkIGxhdGVyICovXG4gICAgICAgICAgaWYgKG1hdGNoZXModGhpcy5nZXRJbnB1dCgpLCAnc2VsZWN0JykpIHtcbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgbmVlZGVkIHRvIHByb3Blcmx5XG4gICAgICAgICAgICAvLyB3b3JrIHdpdGggYDxzZWxlY3Q+YCBlbGVtZW50c1xuICAgICAgICAgICAgdGhpcy5uZXdUYWcgPSAnJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGludmFsaWRBbmREdXBsaWNhdGVzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwYXJzZWQuaW52YWxpZCksIF90b0NvbnN1bWFibGVBcnJheShwYXJzZWQuZHVwbGljYXRlKSk7XG4gICAgICAgICAgICB0aGlzLm5ld1RhZyA9IHBhcnNlZC5hbGwuZmlsdGVyKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXMoaW52YWxpZEFuZER1cGxpY2F0ZXMsIHRhZyk7XG4gICAgICAgICAgICB9KS5qb2luKHRoaXMuY29tcHV0ZWRKb2luZXIpLmNvbmNhdChpbnZhbGlkQW5kRHVwbGljYXRlcy5sZW5ndGggPiAwID8gdGhpcy5jb21wdXRlZEpvaW5lci5jaGFyQXQoMCkgOiAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlZC52YWxpZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gV2UgYWRkIHRoZSBuZXcgdGFncyBpbiBvbmUgYXRvbWljIG9wZXJhdGlvblxuICAgICAgICAgIC8vIHRvIHRyaWdnZXIgcmVhY3Rpdml0eSBvbmNlIChpbnN0ZWFkIG9mIG9uY2UgcGVyIHRhZylcbiAgICAgICAgICAvLyBXZSBkbyB0aGlzIGFmdGVyIHdlIHVwZGF0ZSB0aGUgbmV3IHRhZyBpbnB1dCB2YWx1ZVxuICAgICAgICAgIC8vIGBjb25jYXQoKWAgY2FuIGJlIGZhc3RlciB0aGFuIGFycmF5IHNwcmVhZCwgd2hlbiBib3RoIGFyZ3MgYXJlIGFycmF5c1xuICAgICAgICAgIHRoaXMudGFncyA9IGNvbmNhdCh0aGlzLnRhZ3MsIHBhcnNlZC52YWxpZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRhZ3NTdGF0ZSA9IHBhcnNlZDsgLy8gQXR0ZW1wdCB0byByZS1mb2N1cyB0aGUgaW5wdXQgKHNwZWNpZmljYWxseSBmb3Igd2hlbiB1c2luZyB0aGUgQWRkXG4gICAgICAgIC8vIGJ1dHRvbiwgYXMgdGhlIGJ1dHRvbiBkaXNhcHBlYXJzIGFmdGVyIHN1Y2Nlc3NmdWxseSBhZGRpbmcgYSB0YWdcblxuICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlVGFnOiBmdW5jdGlvbiByZW1vdmVUYWcodGFnKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFRPRE86XG4gICAgICAgIC8vICAgQWRkIGBvblJlbW92ZVRhZyh0YWcpYCB1c2VyIG1ldGhvZCwgd2hpY2ggaWYgcmV0dXJucyBgZmFsc2VgXG4gICAgICAgIC8vICAgd2lsbCBwcmV2ZW50IHRoZSB0YWcgZnJvbSBiZWluZyByZW1vdmVkIChpLmUuIGNvbmZpcm1hdGlvbilcbiAgICAgICAgLy8gICBPciBlbWl0IGNhbmNlbGFibGUgYEJ2RXZlbnRgXG5cblxuICAgICAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQgIT09IHRhZztcbiAgICAgICAgfSk7IC8vIFJldHVybiBmb2N1cyB0byB0aGUgaW5wdXQgKGlmIHBvc3NpYmxlKVxuXG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuZm9jdXMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgLy8gLS0tIElucHV0IGVsZW1lbnQgZXZlbnQgaGFuZGxlcnMgLS0tXG4gICAgICBvbklucHV0SW5wdXQ6IGZ1bmN0aW9uIG9uSW5wdXRJbnB1dChldnQpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGhhcmQgdG8gdGVzdCBjb21wb3NpdGlvbiBldmVudHMgKi9cbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgaXNFdmVudChldnQpICYmIGV2dC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgLy8gYGV2dC50YXJnZXQuY29tcG9zaW5nYCBpcyBzZXQgYnkgVnVlIChgdi1tb2RlbGAgZGlyZWN0aXZlKVxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvYmxvYi9kZXYvc3JjL3BsYXRmb3Jtcy93ZWIvcnVudGltZS9kaXJlY3RpdmVzL21vZGVsLmpzXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld1RhZyA9IHByb2Nlc3NFdmVudFZhbHVlKGV2dCk7XG4gICAgICAgIHZhciBzZXBhcmF0b3JSZSA9IHRoaXMuY29tcHV0ZWRTZXBhcmF0b3JSZWdFeHA7XG5cbiAgICAgICAgaWYgKHRoaXMubmV3VGFnICE9PSBuZXdUYWcpIHtcbiAgICAgICAgICB0aGlzLm5ld1RhZyA9IG5ld1RhZztcbiAgICAgICAgfSAvLyBXZSBpZ25vcmUgbGVhZGluZyB3aGl0ZXNwYWNlIGZvciB0aGUgZm9sbG93aW5nXG5cblxuICAgICAgICBuZXdUYWcgPSB0cmltTGVmdChuZXdUYWcpO1xuXG4gICAgICAgIGlmIChzZXBhcmF0b3JSZSAmJiBzZXBhcmF0b3JSZS50ZXN0KG5ld1RhZy5zbGljZSgtMSkpKSB7XG4gICAgICAgICAgLy8gQSB0cmFpbGluZyBzZXBhcmF0b3IgY2hhcmFjdGVyIHdhcyBlbnRlcmVkLCBzbyBhZGQgdGhlIHRhZyhzKVxuICAgICAgICAgIC8vIE5vdGU6IE1vcmUgdGhhbiBvbmUgdGFnIG9uIGlucHV0IGV2ZW50IGlzIHBvc3NpYmxlIHZpYSBjb3B5L3Bhc3RlXG4gICAgICAgICAgdGhpcy5hZGRUYWcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBWYWxpZGF0ZSAocGFyc2UgdGFncykgb24gaW5wdXQgZXZlbnRcbiAgICAgICAgICB0aGlzLnRhZ3NTdGF0ZSA9IG5ld1RhZyA9PT0gJycgPyBjbGVhblRhZ3NTdGF0ZSgpIDogdGhpcy5wYXJzZVRhZ3MobmV3VGFnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uSW5wdXRDaGFuZ2U6IGZ1bmN0aW9uIG9uSW5wdXRDaGFuZ2UoZXZ0KSB7XG4gICAgICAgIC8vIENoYW5nZSBpcyB0cmlnZ2VyZWQgb24gYDxpbnB1dD5gIGJsdXIsIG9yIGA8c2VsZWN0PmAgc2VsZWN0ZWRcbiAgICAgICAgLy8gVGhpcyBldmVudCBpcyBvcHQtaW5cbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkICYmIHRoaXMuYWRkT25DaGFuZ2UpIHtcbiAgICAgICAgICB2YXIgbmV3VGFnID0gcHJvY2Vzc0V2ZW50VmFsdWUoZXZ0KTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgICAgICAgaWYgKHRoaXMubmV3VGFnICE9PSBuZXdUYWcpIHtcbiAgICAgICAgICAgIHRoaXMubmV3VGFnID0gbmV3VGFnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYWRkVGFnKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbklucHV0S2V5ZG93bjogZnVuY3Rpb24gb25JbnB1dEtleWRvd24oZXZ0KSB7XG4gICAgICAgIC8vIEVhcmx5IGV4aXRcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAhaXNFdmVudChldnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleUNvZGUgPSBldnQua2V5Q29kZTtcbiAgICAgICAgdmFyIHZhbHVlID0gZXZ0LnRhcmdldC52YWx1ZSB8fCAnJztcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IHRlc3RpbmcgdG8gYmUgYWRkZWQgbGF0ZXIgKi9cblxuICAgICAgICBpZiAoIXRoaXMubm9BZGRPbkVudGVyICYmIGtleUNvZGUgPT09IEVOVEVSJDEpIHtcbiAgICAgICAgICAvLyBBdHRlbXB0IHRvIGFkZCB0aGUgdGFnIHdoZW4gdXNlciBwcmVzc2VzIGVudGVyXG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5hZGRUYWcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlbW92ZU9uRGVsZXRlICYmIChrZXlDb2RlID09PSBCQUNLU1BBQ0UgfHwga2V5Q29kZSA9PT0gREVMRVRFKSAmJiB2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3QgdGFnIGlmIHRoZSB1c2VyIHByZXNzZWQgYmFja3NwYWNlL2RlbGV0ZSBhbmQgdGhlIGlucHV0IGlzIGVtcHR5XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIC0tLSBXcmFwcGVyIGV2ZW50IGhhbmRsZXJzIC0tLVxuICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhldnQpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkICYmIGlzRXZlbnQoZXZ0KSAmJiBldnQudGFyZ2V0ID09PSBldnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5mb2N1cygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Gb2N1c2luOiBmdW5jdGlvbiBvbkZvY3VzaW4oKSB7XG4gICAgICAgIHRoaXMuaGFzRm9jdXMgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIG9uRm9jdXNvdXQ6IGZ1bmN0aW9uIG9uRm9jdXNvdXQoKSB7XG4gICAgICAgIHRoaXMuaGFzRm9jdXMgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVBdXRvZm9jdXM6IGZ1bmN0aW9uIGhhbmRsZUF1dG9mb2N1cygpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlcXVlc3RBRihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXM0LmF1dG9mb2N1cyAmJiAhX3RoaXM0LmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgIF90aGlzNC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAvLyAtLS0gUHVibGljIG1ldGhvZHMgLS0tXG4gICAgICBmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmdldElucHV0KCkuZm9jdXMoKTtcbiAgICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYmx1cjogZnVuY3Rpb24gYmx1cigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmdldElucHV0KCkuYmx1cigpO1xuICAgICAgICB9IGNhdGNoIChfdW51c2VkMikge31cbiAgICAgIH0sXG4gICAgICAvLyAtLS0gUHJpdmF0ZSBtZXRob2RzIC0tLVxuICAgICAgc3BsaXRUYWdzOiBmdW5jdGlvbiBzcGxpdFRhZ3MobmV3VGFnKSB7XG4gICAgICAgIC8vIFNwbGl0IHRoZSBpbnB1dCBpbnRvIGFuIGFycmF5IG9mIHJhdyB0YWdzXG4gICAgICAgIG5ld1RhZyA9IHRvU3RyaW5nJDEobmV3VGFnKTtcbiAgICAgICAgdmFyIHNlcGFyYXRvclJlID0gdGhpcy5jb21wdXRlZFNlcGFyYXRvclJlZ0V4cDsgLy8gU3BsaXQgdGhlIHRhZyhzKSB2aWEgdGhlIG9wdGlvbmFsIHNlcGFyYXRvclxuICAgICAgICAvLyBOb3JtYWxseSBvbmx5IGEgc2luZ2xlIHRhZyBpcyBwcm92aWRlZCwgYnV0IGNvcHkvcGFzdGVcbiAgICAgICAgLy8gY2FuIGVudGVyIG11bHRpcGxlIHRhZ3MgaW4gYSBzaW5nbGUgb3BlcmF0aW9uXG5cbiAgICAgICAgcmV0dXJuIChzZXBhcmF0b3JSZSA/IG5ld1RhZy5zcGxpdChzZXBhcmF0b3JSZSkgOiBbbmV3VGFnXSkubWFwKHRyaW0pLmZpbHRlcihpZGVudGl0eSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VUYWdzOiBmdW5jdGlvbiBwYXJzZVRhZ3MobmV3VGFnKSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIC8vIFRha2VzIGBuZXdUYWdgIHZhbHVlIGFuZCBwYXJzZXMgaXQgaW50byBgdmFsaWRUYWdzYCxcbiAgICAgICAgLy8gYGludmFsaWRUYWdzYCwgYW5kIGR1cGxpY2F0ZSB0YWdzIGFzIGFuIG9iamVjdFxuICAgICAgICAvLyBTcGxpdCB0aGUgaW5wdXQgaW50byByYXcgdGFnc1xuICAgICAgICB2YXIgdGFncyA9IHRoaXMuc3BsaXRUYWdzKG5ld1RhZyk7IC8vIEJhc2UgcmVzdWx0c1xuXG4gICAgICAgIHZhciBwYXJzZWQgPSB7XG4gICAgICAgICAgYWxsOiB0YWdzLFxuICAgICAgICAgIHZhbGlkOiBbXSxcbiAgICAgICAgICBpbnZhbGlkOiBbXSxcbiAgICAgICAgICBkdXBsaWNhdGU6IFtdXG4gICAgICAgIH07IC8vIFBhcnNlIHRoZSB1bmlxdWUgdGFnc1xuXG4gICAgICAgIHRhZ3MuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgaWYgKGFycmF5SW5jbHVkZXMoX3RoaXM1LnRhZ3MsIHRhZykgfHwgYXJyYXlJbmNsdWRlcyhwYXJzZWQudmFsaWQsIHRhZykpIHtcbiAgICAgICAgICAgIC8vIFVuaXF1ZSBkdXBsaWNhdGUgdGFnc1xuICAgICAgICAgICAgaWYgKCFhcnJheUluY2x1ZGVzKHBhcnNlZC5kdXBsaWNhdGUsIHRhZykpIHtcbiAgICAgICAgICAgICAgcGFyc2VkLmR1cGxpY2F0ZS5wdXNoKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChfdGhpczUudmFsaWRhdGVUYWcodGFnKSkge1xuICAgICAgICAgICAgLy8gV2Ugb25seSBhZGQgdW5pcXVlL3ZhbGlkIHRhZ3NcbiAgICAgICAgICAgIHBhcnNlZC52YWxpZC5wdXNoKHRhZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVuaXF1ZSBpbnZhbGlkIHRhZ3NcbiAgICAgICAgICAgIGlmICghYXJyYXlJbmNsdWRlcyhwYXJzZWQuaW52YWxpZCwgdGFnKSkge1xuICAgICAgICAgICAgICBwYXJzZWQuaW52YWxpZC5wdXNoKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH0sXG4gICAgICB2YWxpZGF0ZVRhZzogZnVuY3Rpb24gdmFsaWRhdGVUYWcodGFnKSB7XG4gICAgICAgIC8vIENhbGwgdGhlIHVzZXIgc3VwcGxpZWQgdGFnIHZhbGlkYXRvclxuICAgICAgICB2YXIgdmFsaWRhdG9yID0gdGhpcy50YWdWYWxpZGF0b3I7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbGlkYXRvcikgPyB2YWxpZGF0b3IodGFnKSA6IHRydWU7XG4gICAgICB9LFxuICAgICAgZ2V0SW5wdXQ6IGZ1bmN0aW9uIGdldElucHV0KCkge1xuICAgICAgICAvLyBSZXR1cm5zIHRoZSBpbnB1dCBlbGVtZW50IHJlZmVyZW5jZSAob3IgbnVsbCBpZiBub3QgZm91bmQpXG4gICAgICAgIHJldHVybiBzZWxlY3QoXCIjXCIuY29uY2F0KHRoaXMuY29tcHV0ZWRJbnB1dElkKSwgdGhpcy4kZWwpO1xuICAgICAgfSxcbiAgICAgIC8vIERlZmF1bHQgVXNlciBJbnRlcmZhY2UgcmVuZGVyXG4gICAgICBkZWZhdWx0UmVuZGVyOiBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyKF9yZWYpIHtcbiAgICAgICAgdmFyIHRhZ3MgPSBfcmVmLnRhZ3MsXG4gICAgICAgICAgICBhZGRUYWcgPSBfcmVmLmFkZFRhZyxcbiAgICAgICAgICAgIHJlbW92ZVRhZyA9IF9yZWYucmVtb3ZlVGFnLFxuICAgICAgICAgICAgaW5wdXRUeXBlID0gX3JlZi5pbnB1dFR5cGUsXG4gICAgICAgICAgICBpbnB1dEF0dHJzID0gX3JlZi5pbnB1dEF0dHJzLFxuICAgICAgICAgICAgaW5wdXRIYW5kbGVycyA9IF9yZWYuaW5wdXRIYW5kbGVycyxcbiAgICAgICAgICAgIGlucHV0Q2xhc3MgPSBfcmVmLmlucHV0Q2xhc3MsXG4gICAgICAgICAgICB0YWdDbGFzcyA9IF9yZWYudGFnQ2xhc3MsXG4gICAgICAgICAgICB0YWdWYXJpYW50ID0gX3JlZi50YWdWYXJpYW50LFxuICAgICAgICAgICAgdGFnUGlsbHMgPSBfcmVmLnRhZ1BpbGxzLFxuICAgICAgICAgICAgdGFnUmVtb3ZlTGFiZWwgPSBfcmVmLnRhZ1JlbW92ZUxhYmVsLFxuICAgICAgICAgICAgaW52YWxpZFRhZ1RleHQgPSBfcmVmLmludmFsaWRUYWdUZXh0LFxuICAgICAgICAgICAgZHVwbGljYXRlVGFnVGV4dCA9IF9yZWYuZHVwbGljYXRlVGFnVGV4dCxcbiAgICAgICAgICAgIGlzSW52YWxpZCA9IF9yZWYuaXNJbnZhbGlkLFxuICAgICAgICAgICAgaXNEdXBsaWNhdGUgPSBfcmVmLmlzRHVwbGljYXRlLFxuICAgICAgICAgICAgZGlzYWJsZWQgPSBfcmVmLmRpc2FibGVkLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSBfcmVmLnBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgYWRkQnV0dG9uVGV4dCA9IF9yZWYuYWRkQnV0dG9uVGV4dCxcbiAgICAgICAgICAgIGFkZEJ1dHRvblZhcmlhbnQgPSBfcmVmLmFkZEJ1dHRvblZhcmlhbnQsXG4gICAgICAgICAgICBkaXNhYmxlQWRkQnV0dG9uID0gX3JlZi5kaXNhYmxlQWRkQnV0dG9uO1xuICAgICAgICB2YXIgaCA9IHRoaXMuJGNyZWF0ZUVsZW1lbnQ7IC8vIE1ha2UgdGhlIGxpc3Qgb2YgdGFnc1xuXG4gICAgICAgIHZhciAkdGFncyA9IHRhZ3MubWFwKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICB0YWcgPSB0b1N0cmluZyQxKHRhZyk7XG4gICAgICAgICAgcmV0dXJuIGgoQkZvcm1UYWcsIHtcbiAgICAgICAgICAgIGtleTogXCJsaS10YWdfX1wiLmNvbmNhdCh0YWcpLFxuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICdtdC0xIG1yLTEnLFxuICAgICAgICAgICAgY2xhc3M6IHRhZ0NsYXNzLFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgLy8gYEJGb3JtVGFnYCB3aWxsIGF1dG8gZ2VuZXJhdGUgYW4gSURcbiAgICAgICAgICAgICAgLy8gc28gd2UgZG8gbm90IG5lZWQgdG8gc2V0IHRoZSBJRCBwcm9wXG4gICAgICAgICAgICAgIHRhZzogJ2xpJyxcbiAgICAgICAgICAgICAgdGl0bGU6IHRhZyxcbiAgICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgICAgICAgICAgICB2YXJpYW50OiB0YWdWYXJpYW50LFxuICAgICAgICAgICAgICBwaWxsOiB0YWdQaWxscyxcbiAgICAgICAgICAgICAgcmVtb3ZlTGFiZWw6IHRhZ1JlbW92ZUxhYmVsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVRhZyh0YWcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGFnKTtcbiAgICAgICAgfSk7IC8vIEZlZWRiYWNrIElEcyBpZiBuZWVkZWRcblxuICAgICAgICB2YXIgaW52YWxpZEZlZWRiYWNrSWQgPSBpbnZhbGlkVGFnVGV4dCAmJiBpc0ludmFsaWQgPyB0aGlzLnNhZmVJZCgnX19pbnZhbGlkX2ZlZWRiYWNrX18nKSA6IG51bGw7XG4gICAgICAgIHZhciBkdXBsaWNhdGVGZWVkYmFja0lkID0gZHVwbGljYXRlVGFnVGV4dCAmJiBpc0R1cGxpY2F0ZSA/IHRoaXMuc2FmZUlkKCdfX2R1cGxpY2F0ZV9mZWVkYmFja19fJykgOiBudWxsOyAvLyBDb21wdXRlIHRoZSBgYXJpYS1kZXNjcmliZWRieWAgYXR0cmlidXRlIHZhbHVlXG5cbiAgICAgICAgdmFyIGFyaWFEZXNjcmliZWRieSA9IFtpbnB1dEF0dHJzWydhcmlhLWRlc2NyaWJlZGJ5J10sIGludmFsaWRGZWVkYmFja0lkLCBkdXBsaWNhdGVGZWVkYmFja0lkXS5maWx0ZXIoaWRlbnRpdHkpLmpvaW4oJyAnKTsgLy8gSW5wdXRcblxuICAgICAgICB2YXIgJGlucHV0ID0gaCgnaW5wdXQnLCB7XG4gICAgICAgICAgcmVmOiAnaW5wdXQnLFxuICAgICAgICAgIC8vIERpcmVjdGl2ZSBuZWVkZWQgdG8gZ2V0IGBldnQudGFyZ2V0LmNvbXBvc2luZ2Agc2V0IChpZiBuZWVkZWQpXG4gICAgICAgICAgZGlyZWN0aXZlczogW3tcbiAgICAgICAgICAgIG5hbWU6ICdtb2RlbCcsXG4gICAgICAgICAgICB2YWx1ZTogaW5wdXRBdHRycy52YWx1ZVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIHN0YXRpY0NsYXNzOiAnYi1mb3JtLXRhZ3MtaW5wdXQgdy0xMDAgZmxleC1ncm93LTEgcC0wIG0tMCBiZy10cmFuc3BhcmVudCBib3JkZXItMCcsXG4gICAgICAgICAgY2xhc3M6IGlucHV0Q2xhc3MsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIG91dGxpbmU6IDAsXG4gICAgICAgICAgICBtaW5XaWR0aDogJzVyZW0nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdHRyczogX29iamVjdFNwcmVhZDIoe30sIGlucHV0QXR0cnMsIHtcbiAgICAgICAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogYXJpYURlc2NyaWJlZGJ5IHx8IG51bGwsXG4gICAgICAgICAgICB0eXBlOiBpbnB1dFR5cGUsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIgfHwgbnVsbFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGRvbVByb3BzOiB7XG4gICAgICAgICAgICB2YWx1ZTogaW5wdXRBdHRycy52YWx1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IGlucHV0SGFuZGxlcnNcbiAgICAgICAgfSk7IC8vIEFkZCBidXR0b25cblxuICAgICAgICB2YXIgJGJ1dHRvbiA9IGgoQkJ1dHRvbiwge1xuICAgICAgICAgIHJlZjogJ2J1dHRvbicsXG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICdiLWZvcm0tdGFncy1idXR0b24gcHktMCcsXG4gICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgIC8vIE9ubHkgc2hvdyB0aGUgYnV0dG9uIGlmIHRoZSB0YWcgY2FuIGJlIGFkZGVkXG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhlIGBpbnZpc2libGVgIGNsYXNzIGluc3RlYWQgb2Ygbm90IHJlbmRlcmluZ1xuICAgICAgICAgICAgLy8gdGhlIGJ1dHRvbiwgc28gdGhhdCB3ZSBtYWludGFpbiBsYXlvdXQgdG8gcHJldmVudFxuICAgICAgICAgICAgLy8gdGhlIHVzZXIgaW5wdXQgZnJvbSBqdW1waW5nIGFyb3VuZFxuICAgICAgICAgICAgaW52aXNpYmxlOiBkaXNhYmxlQWRkQnV0dG9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgZm9udFNpemU6ICc5MCUnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgdmFyaWFudDogYWRkQnV0dG9uVmFyaWFudCxcbiAgICAgICAgICAgIGRpc2FibGVkOiBkaXNhYmxlQWRkQnV0dG9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWRkVGFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBbdGhpcy5ub3JtYWxpemVTbG90KCdhZGQtYnV0dG9uLXRleHQnKSB8fCBhZGRCdXR0b25UZXh0XSk7IC8vIElEIG9mIHRoZSB0YWdzK2lucHV0IGA8dWw+YCBsaXN0XG4gICAgICAgIC8vIE5vdGUgd2UgY291bGQgY29uY2F0ZW5hdGUgaW5wdXRBdHRycy5pZCB3aXRoIGBfX1RBR19fTElTVF9fYFxuICAgICAgICAvLyBCdXQgbm90ZSB0aGF0IHRoZSBpbnB1dElEIG1heSBiZSBudWxsIHVudGlsIGFmdGVyIG1vdW50XG4gICAgICAgIC8vIGBzYWZlSWRgIHJldHVybnMgYG51bGxgLCBpZiBubyB1c2VyIHByb3ZpZGVkIElELCB1bnRpbCBhZnRlclxuICAgICAgICAvLyBtb3VudCB3aGVuIGEgdW5pcXVlIElEIGlzIGdlbmVyYXRlZFxuXG4gICAgICAgIHZhciB0YWdMaXN0SWQgPSB0aGlzLnNhZmVJZCgnX19UQUdfX0xJU1RfXycpO1xuICAgICAgICB2YXIgJGZpZWxkID0gaCgnbGknLCB7XG4gICAgICAgICAga2V5OiAnX19saS1pbnB1dF9fJyxcbiAgICAgICAgICBzdGF0aWNDbGFzczogJ2ZsZXgtZ3Jvdy0xIG10LTEnLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICByb2xlOiAnbm9uZScsXG4gICAgICAgICAgICAnYXJpYS1saXZlJzogJ29mZicsXG4gICAgICAgICAgICAnYXJpYS1jb250cm9scyc6IHRhZ0xpc3RJZFxuICAgICAgICAgIH1cbiAgICAgICAgfSwgW2goJ2RpdicsIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogJ2QtZmxleCcsXG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIHJvbGU6ICdncm91cCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFskaW5wdXQsICRidXR0b25dKV0pOyAvLyBXcmFwIGluIGFuIHVub3JkZXJlZCBsaXN0IGVsZW1lbnQgKHdlIHVzZSBhIGxpc3QgZm9yIGFjY2Vzc2liaWxpdHkpXG5cbiAgICAgICAgdmFyICR1bCA9IGgoJ3VsJywge1xuICAgICAgICAgIGtleTogJ190YWdzX2xpc3RfJyxcbiAgICAgICAgICBzdGF0aWNDbGFzczogJ2xpc3QtdW5zdHlsZWQgbXQtbjEgbWItMCBkLWZsZXggZmxleC13cmFwIGFsaWduLWl0ZW1zLWNlbnRlcicsXG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGlkOiB0YWdMaXN0SWRcbiAgICAgICAgICB9XG4gICAgICAgIH0sIC8vIGBjb25jYXQoKWAgaXMgZmFzdGVyIHRoYW4gYXJyYXkgc3ByZWFkIHdoZW4gYXJncyBhcmUga25vd24gdG8gYmUgYXJyYXlzXG4gICAgICAgIGNvbmNhdCgkdGFncywgJGZpZWxkKSk7IC8vIEFzc2VtYmxlIHRoZSBmZWVkYmFja1xuXG4gICAgICAgIHZhciAkZmVlZGJhY2sgPSBoKCk7XG5cbiAgICAgICAgaWYgKGludmFsaWRUYWdUZXh0IHx8IGR1cGxpY2F0ZVRhZ1RleHQpIHtcbiAgICAgICAgICAvLyBBZGQgYW4gYXJpYSBsaXZlIHJlZ2lvbiBmb3IgdGhlIGludmFsaWQvZHVwbGljYXRlIHRhZ1xuICAgICAgICAgIC8vIG1lc3NhZ2VzIGlmIHRoZSB1c2VyIGhhcyBub3QgZGlzYWJsZWQgdGhlIG1lc3NhZ2VzXG4gICAgICAgICAgdmFyIGpvaW5lciA9IHRoaXMuY29tcHV0ZWRKb2luZXI7IC8vIEludmFsaWQgdGFnIGZlZWRiYWNrIGlmIG5lZWRlZCAoZXJyb3IpXG5cbiAgICAgICAgICB2YXIgJGludmFsaWQgPSBoKCk7XG5cbiAgICAgICAgICBpZiAoaW52YWxpZEZlZWRiYWNrSWQpIHtcbiAgICAgICAgICAgICRpbnZhbGlkID0gaChCRm9ybUludmFsaWRGZWVkYmFjaywge1xuICAgICAgICAgICAgICBrZXk6ICdfdGFnc19pbnZhbGlkX2ZlZWRiYWNrXycsXG4gICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IGludmFsaWRGZWVkYmFja0lkLFxuICAgICAgICAgICAgICAgIGZvcmNlU2hvdzogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbdGhpcy5pbnZhbGlkVGFnVGV4dCwgJzogJywgdGhpcy5pbnZhbGlkVGFncy5qb2luKGpvaW5lcildKTtcbiAgICAgICAgICB9IC8vIER1cGxpY2F0ZSB0YWcgZmVlZGJhY2sgaWYgbmVlZGVkICh3YXJuaW5nLCBub3QgZXJyb3IpXG5cblxuICAgICAgICAgIHZhciAkZHVwbGljYXRlID0gaCgpO1xuXG4gICAgICAgICAgaWYgKGR1cGxpY2F0ZUZlZWRiYWNrSWQpIHtcbiAgICAgICAgICAgICRkdXBsaWNhdGUgPSBoKEJGb3JtVGV4dCwge1xuICAgICAgICAgICAgICBrZXk6ICdfdGFnc19kdXBsaWNhdGVfZmVlZGJhY2tfJyxcbiAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICBpZDogZHVwbGljYXRlRmVlZGJhY2tJZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbdGhpcy5kdXBsaWNhdGVUYWdUZXh0LCAnOiAnLCB0aGlzLmR1cGxpY2F0ZVRhZ3Muam9pbihqb2luZXIpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgJGZlZWRiYWNrID0gaCgnZGl2Jywge1xuICAgICAgICAgICAga2V5OiAnX3RhZ3NfZmVlZGJhY2tfJyxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICdhcmlhLWxpdmUnOiAncG9saXRlJyxcbiAgICAgICAgICAgICAgJ2FyaWEtYXRvbWljJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgWyRpbnZhbGlkLCAkZHVwbGljYXRlXSk7XG4gICAgICAgIH0gLy8gUmV0dXJuIHRoZSBjb250ZW50XG5cblxuICAgICAgICByZXR1cm4gWyR1bCwgJGZlZWRiYWNrXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAvLyBTY29wZWQgc2xvdCBwcm9wZXJ0aWVzXG4gICAgICB2YXIgc2NvcGUgPSB7XG4gICAgICAgIC8vIEFycmF5IG9mIHRhZ3MgKHNoYWxsb3cgY29weSB0byBwcmV2ZW50IG11dGF0aW9ucylcbiAgICAgICAgdGFnczogdGhpcy50YWdzLnNsaWNlKCksXG4gICAgICAgIC8vIE1ldGhvZHNcbiAgICAgICAgcmVtb3ZlVGFnOiB0aGlzLnJlbW92ZVRhZyxcbiAgICAgICAgYWRkVGFnOiB0aGlzLmFkZFRhZyxcbiAgICAgICAgLy8gV2UgZG9uJ3QgaW5jbHVkZSB0aGlzIGluIHRoZSBhdHRycywgYXMgdXNlcnMgbWF5IHdhbnQgdG8gb3ZlcnJpZGUgdGhpc1xuICAgICAgICBpbnB1dFR5cGU6IHRoaXMuY29tcHV0ZWRJbnB1dFR5cGUsXG4gICAgICAgIC8vIDxpbnB1dD4gdi1iaW5kOmlucHV0QXR0cnNcbiAgICAgICAgaW5wdXRBdHRyczogdGhpcy5jb21wdXRlZElucHV0QXR0cnMsXG4gICAgICAgIC8vIDxpbnB1dD4gdi1vbjppbnB1dEhhbmRsZXJzXG4gICAgICAgIGlucHV0SGFuZGxlcnM6IHRoaXMuY29tcHV0ZWRJbnB1dEhhbmRsZXJzLFxuICAgICAgICAvLyA8aW5wdXQ+IDppZD1cImlucHV0SWRcIlxuICAgICAgICBpbnB1dElkOiB0aGlzLmNvbXB1dGVkSW5wdXRJZCxcbiAgICAgICAgLy8gSW52YWxpZC9EdXBsaWNhdGUgc3RhdGUgaW5mb3JtYXRpb25cbiAgICAgICAgaW52YWxpZFRhZ3M6IHRoaXMuaW52YWxpZFRhZ3Muc2xpY2UoKSxcbiAgICAgICAgaXNJbnZhbGlkOiB0aGlzLmhhc0ludmFsaWRUYWdzLFxuICAgICAgICBkdXBsaWNhdGVUYWdzOiB0aGlzLmR1cGxpY2F0ZVRhZ3Muc2xpY2UoKSxcbiAgICAgICAgaXNEdXBsaWNhdGU6IHRoaXMuaGFzRHVwbGljYXRlVGFncyxcbiAgICAgICAgLy8gSWYgdGhlICdBZGQnIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWRcbiAgICAgICAgZGlzYWJsZUFkZEJ1dHRvbjogdGhpcy5kaXNhYmxlQWRkQnV0dG9uLFxuICAgICAgICAvLyBQYXNzLXRob3VnaCB2YWx1ZXNcbiAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgIHNlcGFyYXRvcjogdGhpcy5zZXBhcmF0b3IsXG4gICAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkLFxuICAgICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLnBsYWNlaG9sZGVyLFxuICAgICAgICBpbnB1dENsYXNzOiB0aGlzLmlucHV0Q2xhc3MsXG4gICAgICAgIHRhZ1JlbW92ZUxhYmVsOiB0aGlzLnRhZ1JlbW92ZUxhYmVsLFxuICAgICAgICB0YWdWYXJpYW50OiB0aGlzLnRhZ1ZhcmlhbnQsXG4gICAgICAgIHRhZ1BpbGxzOiB0aGlzLnRhZ1BpbGxzLFxuICAgICAgICB0YWdDbGFzczogdGhpcy50YWdDbGFzcyxcbiAgICAgICAgYWRkQnV0dG9uVGV4dDogdGhpcy5hZGRCdXR0b25UZXh0LFxuICAgICAgICBhZGRCdXR0b25WYXJpYW50OiB0aGlzLmFkZEJ1dHRvblZhcmlhbnQsXG4gICAgICAgIGludmFsaWRUYWdUZXh0OiB0aGlzLmludmFsaWRUYWdUZXh0LFxuICAgICAgICBkdXBsaWNhdGVUYWdUZXh0OiB0aGlzLmR1cGxpY2F0ZVRhZ1RleHRcbiAgICAgIH07IC8vIEdlbmVyYXRlIHRoZSB1c2VyIGludGVyZmFjZVxuXG4gICAgICB2YXIgJGNvbnRlbnQgPSB0aGlzLm5vcm1hbGl6ZVNsb3QoJ2RlZmF1bHQnLCBzY29wZSkgfHwgdGhpcy5kZWZhdWx0UmVuZGVyKHNjb3BlKTsgLy8gR2VuZXJhdGUgdGhlIGBhcmlhLWxpdmVgIHJlZ2lvbiBmb3IgdGhlIGN1cnJlbnQgdmFsdWUocylcblxuICAgICAgdmFyICRvdXRwdXQgPSBoKCdvdXRwdXQnLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnc3Itb25seScsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHRoaXMuc2FmZUlkKCdfc2VsZWN0ZWQtdGFnc18nKSxcbiAgICAgICAgICByb2xlOiAnc3RhdHVzJyxcbiAgICAgICAgICBmb3I6IHRoaXMuY29tcHV0ZWRJbnB1dElkLFxuICAgICAgICAgICdhcmlhLWxpdmUnOiB0aGlzLmhhc0ZvY3VzID8gJ3BvbGl0ZScgOiAnb2ZmJyxcbiAgICAgICAgICAnYXJpYS1hdG9taWMnOiAndHJ1ZScsXG4gICAgICAgICAgJ2FyaWEtcmVsZXZhbnQnOiAnYWRkaXRpb25zIHRleHQnXG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMudGFncy5qb2luKCcsICcpKTsgLy8gUmVtb3ZlZCB0YWcgbGl2ZSByZWdpb25cblxuICAgICAgdmFyICRyZW1vdmVkID0gaCgnZGl2Jywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ3NyLW9ubHknLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiB0aGlzLnNhZmVJZCgnX3JlbW92ZWQtdGFnc18nKSxcbiAgICAgICAgICByb2xlOiAnc3RhdHVzJyxcbiAgICAgICAgICAnYXJpYS1saXZlJzogdGhpcy5oYXNGb2N1cyA/ICdhc3NlcnRpdmUnIDogJ29mZicsXG4gICAgICAgICAgJ2FyaWEtYXRvbWljJzogJ3RydWUnXG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMucmVtb3ZlZFRhZ3MubGVuZ3RoID4gMCA/IFwiKFwiLmNvbmNhdCh0aGlzLnRhZ1JlbW92ZWRMYWJlbCwgXCIpIFwiKS5jb25jYXQodGhpcy5yZW1vdmVkVGFncy5qb2luKCcsICcpKSA6ICcnKTsgLy8gQWRkIGhpZGRlbiBpbnB1dHMgZm9yIGZvcm0gc3VibWlzc2lvblxuXG4gICAgICB2YXIgJGhpZGRlbiA9IGgoKTtcblxuICAgICAgaWYgKHRoaXMubmFtZSAmJiAhdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAvLyBXZSBhZGQgaGlkZGVuIGlucHV0cyBmb3IgZWFjaCB0YWcgaWYgYSBuYW1lIGlzIHByb3ZpZGVkXG4gICAgICAgIC8vIGZvciBuYXRpdmUgc3VibWlzc2lvbiBvZiBmb3Jtc1xuICAgICAgICAkaGlkZGVuID0gdGhpcy50YWdzLm1hcChmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgcmV0dXJuIGgoJ2lucHV0Jywge1xuICAgICAgICAgICAga2V5OiB0YWcsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICB0eXBlOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHRhZyxcbiAgICAgICAgICAgICAgbmFtZTogX3RoaXM2Lm5hbWUsXG4gICAgICAgICAgICAgIGZvcm06IF90aGlzNi5mb3JtIHx8IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFJldHVybiB0aGUgcmVuZGVyZWQgb3V0cHV0XG5cblxuICAgICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdiLWZvcm0tdGFncyBmb3JtLWNvbnRyb2wgaC1hdXRvJyxcbiAgICAgICAgY2xhc3M6IF9kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICAgICAgZm9jdXM6IHRoaXMuaGFzRm9jdXMgJiYgIXRoaXMubm9PdXRlckZvY3VzICYmICF0aGlzLmRpc2FibGVkLFxuICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkLFxuICAgICAgICAgICdpcy12YWxpZCc6IHRoaXMuc3RhdGUgPT09IHRydWUsXG4gICAgICAgICAgJ2lzLWludmFsaWQnOiB0aGlzLnN0YXRlID09PSBmYWxzZVxuICAgICAgICB9LCBcImZvcm0tY29udHJvbC1cIi5jb25jYXQodGhpcy5zaXplKSwgdGhpcy5zaXplKSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBpZDogdGhpcy5zYWZlSWQoKSxcbiAgICAgICAgICByb2xlOiAnZ3JvdXAnLFxuICAgICAgICAgIHRhYmluZGV4OiB0aGlzLmRpc2FibGVkIHx8IHRoaXMubm9PdXRlckZvY3VzID8gbnVsbCA6ICctMScsXG4gICAgICAgICAgJ2FyaWEtZGVzY3JpYmVkYnknOiB0aGlzLnNhZmVJZCgnX3NlbGVjdGVkXycpXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgZm9jdXNpbjogdGhpcy5vbkZvY3VzaW4sXG4gICAgICAgICAgZm9jdXNvdXQ6IHRoaXMub25Gb2N1c291dCxcbiAgICAgICAgICBjbGljazogdGhpcy5vbkNsaWNrXG4gICAgICAgIH1cbiAgICAgIH0sIGNvbmNhdCgkb3V0cHV0LCAkcmVtb3ZlZCwgJGNvbnRlbnQsICRoaWRkZW4pKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBGb3JtVGFnc1BsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgY29tcG9uZW50czoge1xuICAgICAgQkZvcm1UYWdzOiBCRm9ybVRhZ3MsXG4gICAgICBCVGFnczogQkZvcm1UYWdzLFxuICAgICAgQkZvcm1UYWc6IEJGb3JtVGFnLFxuICAgICAgQlRhZzogQkZvcm1UYWdcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBCRm9ybVRleHRhcmVhID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQkZvcm1UZXh0YXJlYScsXG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgJ2ItdmlzaWJsZSc6IFZCVmlzaWJsZVxuICAgIH0sXG4gICAgbWl4aW5zOiBbaWRNaXhpbiwgbGlzdGVuT25Sb290TWl4aW4sIGZvcm1NaXhpbiwgZm9ybVNpemVNaXhpbiwgZm9ybVN0YXRlTWl4aW4sIGZvcm1UZXh0TWl4aW4sIGZvcm1TZWxlY3Rpb25NaXhpbiwgZm9ybVZhbGlkaXR5TWl4aW5dLFxuICAgIHByb3BzOiB7XG4gICAgICByb3dzOiB7XG4gICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgIGRlZmF1bHQ6IDJcbiAgICAgIH0sXG4gICAgICBtYXhSb3dzOiB7XG4gICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICB3cmFwOiB7XG4gICAgICAgIC8vICdzb2Z0JywgJ2hhcmQnIG9yICdvZmYnLiBCcm93c2VyIGRlZmF1bHQgaXMgJ3NvZnQnXG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ3NvZnQnXG4gICAgICB9LFxuICAgICAgbm9SZXNpemU6IHtcbiAgICAgICAgLy8gRGlzYWJsZSB0aGUgcmVzaXplIGhhbmRsZSBvZiB0ZXh0YXJlYVxuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIG5vQXV0b1Nocmluazoge1xuICAgICAgICAvLyBXaGVuIGluIGF1dG8gcmVzaXplIG1vZGUsIGRpc2FibGUgc2hyaW5raW5nIHRvIGNvbnRlbnQgaGVpZ2h0XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0SW5QeDogbnVsbFxuICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBjb21wdXRlZFN0eWxlOiBmdW5jdGlvbiBjb21wdXRlZFN0eWxlKCkge1xuICAgICAgICB2YXIgc3R5bGVzID0ge1xuICAgICAgICAgIC8vIFNldHRpbmcgYG5vUmVzaXplYCB0byB0cnVlIHdpbGwgZGlzYWJsZSB0aGUgYWJpbGl0eSBmb3IgdGhlIHVzZXIgdG9cbiAgICAgICAgICAvLyBtYW51YWxseSByZXNpemUgdGhlIHRleHRhcmVhLiBXZSBhbHNvIGRpc2FibGUgd2hlbiBpbiBhdXRvIGhlaWdodCBtb2RlXG4gICAgICAgICAgcmVzaXplOiAhdGhpcy5jb21wdXRlZFJvd3MgfHwgdGhpcy5ub1Jlc2l6ZSA/ICdub25lJyA6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIXRoaXMuY29tcHV0ZWRSb3dzKSB7XG4gICAgICAgICAgLy8gQ29uZGl0aW9uYWxseSBzZXQgdGhlIGNvbXB1dGVkIENTUyBoZWlnaHQgd2hlbiBhdXRvIHJvd3MvaGVpZ2h0IGlzIGVuYWJsZWRcbiAgICAgICAgICAvLyBXZSBhdm9pZCBzZXR0aW5nIHRoZSBzdHlsZSB0byBgbnVsbGAsIHdoaWNoIGNhbiBvdmVycmlkZSB1c2VyIG1hbnVhbCByZXNpemUgaGFuZGxlXG4gICAgICAgICAgc3R5bGVzLmhlaWdodCA9IHRoaXMuaGVpZ2h0SW5QeDsgLy8gV2UgYWx3YXlzIGFkZCBhIHZlcnRpY2FsIHNjcm9sbGJhciB0byB0aGUgdGV4dGFyZWEgd2hlbiBhdXRvLWhlaWdodCBpc1xuICAgICAgICAgIC8vIGVuYWJsZWQgc28gdGhhdCB0aGUgY29tcHV0ZWQgaGVpZ2h0IGNhbGN1bGF0aW9uIHJldHVybnMgYSBzdGFibGUgdmFsdWVcblxuICAgICAgICAgIHN0eWxlcy5vdmVyZmxvd1kgPSAnc2Nyb2xsJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRNaW5Sb3dzOiBmdW5jdGlvbiBjb21wdXRlZE1pblJvd3MoKSB7XG4gICAgICAgIC8vIEVuc3VyZSByb3dzIGlzIGF0IGxlYXN0IDIgYW5kIHBvc2l0aXZlICgyIGlzIHRoZSBuYXRpdmUgdGV4dGFyZWEgdmFsdWUpXG4gICAgICAgIC8vIEEgdmFsdWUgb2YgMSBjYW4gY2F1c2UgaXNzdWVzIGluIHNvbWUgYnJvd3NlcnMsIGFuZCBtb3N0IGJyb3dzZXJzXG4gICAgICAgIC8vIG9ubHkgc3VwcG9ydCAyIGFzIHRoZSBzbWFsbGVzdCB2YWx1ZVxuICAgICAgICByZXR1cm4gTWF0aC5tYXgocGFyc2VJbnQodGhpcy5yb3dzLCAxMCkgfHwgMiwgMik7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRNYXhSb3dzOiBmdW5jdGlvbiBjb21wdXRlZE1heFJvd3MoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmNvbXB1dGVkTWluUm93cywgcGFyc2VJbnQodGhpcy5tYXhSb3dzLCAxMCkgfHwgMCk7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRSb3dzOiBmdW5jdGlvbiBjb21wdXRlZFJvd3MoKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBzZXQgdGhlIGF0dHJpYnV0ZSAncm93cycgb24gdGhlIHRleHRhcmVhXG4gICAgICAgIC8vIElmIGF1dG8taGVpZ2h0IGlzIGVuYWJsZWQsIHRoZW4gd2UgcmV0dXJuIGBudWxsYCBhcyB3ZSB1c2UgQ1NTIHRvIGNvbnRyb2wgaGVpZ2h0XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVkTWluUm93cyA9PT0gdGhpcy5jb21wdXRlZE1heFJvd3MgPyB0aGlzLmNvbXB1dGVkTWluUm93cyA6IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgbG9jYWxWYWx1ZTogZnVuY3Rpb24gbG9jYWxWYWx1ZSgpIHtcbiAgICAgICAgdGhpcy5zZXRIZWlnaHQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLnNldEhlaWdodCgpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgLy8gQ2FsbGVkIGJ5IGludGVyc2VjdGlvbiBvYnNlcnZlciBkaXJlY3RpdmVcbiAgICAgIHZpc2libGVDYWxsYmFjazogZnVuY3Rpb24gdmlzaWJsZUNhbGxiYWNrKHZpc2libGUpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAge1xuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIGAkbmV4dFRpY2soKWAgaGVyZSBqdXN0IHRvIG1ha2Ugc3VyZSBhbnlcbiAgICAgICAgICAvLyB0cmFuc2l0aW9ucyBvciBwb3J0YWxsaW5nIGhhdmUgY29tcGxldGVkXG4gICAgICAgICAgdGhpcy4kbmV4dFRpY2sodGhpcy5zZXRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0SGVpZ2h0OiBmdW5jdGlvbiBzZXRIZWlnaHQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlcXVlc3RBRihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5oZWlnaHRJblB4ID0gX3RoaXMuY29tcHV0ZUhlaWdodCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlSGVpZ2h0OiBmdW5jdGlvbiBjb21wdXRlSGVpZ2h0KClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBjYW4ndCB0ZXN0IGdldENvbXB1dGVkU3R5bGUgaW4gSlNET00gKi9cbiAgICAgIHtcbiAgICAgICAgaWYgKHRoaXMuJGlzU2VydmVyIHx8ICFpc051bGwodGhpcy5jb21wdXRlZFJvd3MpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWwgPSB0aGlzLiRlbDsgLy8gRWxlbWVudCBtdXN0IGJlIHZpc2libGUgKG5vdCBoaWRkZW4pIGFuZCBpbiBkb2N1bWVudFxuICAgICAgICAvLyBNdXN0IGJlIGNoZWNrZWQgYWZ0ZXIgYWJvdmUgY2hlY2tzXG5cbiAgICAgICAgaWYgKCFpc1Zpc2libGUoZWwpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gLy8gR2V0IGN1cnJlbnQgY29tcHV0ZWQgc3R5bGVzXG5cblxuICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENTKGVsKTsgLy8gSGVpZ2h0IG9mIG9uZSBsaW5lIG9mIHRleHQgaW4gcHhcblxuICAgICAgICB2YXIgbGluZUhlaWdodCA9IHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5saW5lSGVpZ2h0KTsgLy8gQ2FsY3VsYXRlIGhlaWdodCBvZiBib3JkZXIgYW5kIHBhZGRpbmdcblxuICAgICAgICB2YXIgYm9yZGVyID0gKHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCkgfHwgMCkgKyAocGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoKSB8fCAwKTtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSAocGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3ApIHx8IDApICsgKHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tKSB8fCAwKTsgLy8gQ2FsY3VsYXRlIG9mZnNldFxuXG4gICAgICAgIHZhciBvZmZzZXQgPSBib3JkZXIgKyBwYWRkaW5nOyAvLyBNaW5pbXVtIGhlaWdodCBmb3IgbWluIHJvd3MgKHdoaWNoIG11c3QgYmUgMiByb3dzIG9yIGdyZWF0ZXIgZm9yIGNyb3NzLWJyb3dzZXIgc3VwcG9ydClcblxuICAgICAgICB2YXIgbWluSGVpZ2h0ID0gbGluZUhlaWdodCAqIHRoaXMuY29tcHV0ZWRNaW5Sb3dzICsgb2Zmc2V0OyAvLyBHZXQgdGhlIGN1cnJlbnQgc3R5bGUgaGVpZ2h0ICh3aXRoIGBweGAgdW5pdHMpXG5cbiAgICAgICAgdmFyIG9sZEhlaWdodCA9IGVsLnN0eWxlLmhlaWdodCB8fCBjb21wdXRlZFN0eWxlLmhlaWdodDsgLy8gUHJvYmUgc2Nyb2xsSGVpZ2h0IGJ5IHRlbXBvcmFyaWx5IGNoYW5naW5nIHRoZSBoZWlnaHQgdG8gYGF1dG9gXG5cbiAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gZWwuc2Nyb2xsSGVpZ2h0OyAvLyBQbGFjZSB0aGUgb3JpZ2luYWwgb2xkIGhlaWdodCBiYWNrIG9uIHRoZSBlbGVtZW50LCBqdXN0IGluIGNhc2UgYGNvbXB1dGVkUHJvcGBcbiAgICAgICAgLy8gcmV0dXJucyB0aGUgc2FtZSB2YWx1ZSBhcyBiZWZvcmVcblxuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBvbGRIZWlnaHQ7IC8vIENhbGN1bGF0ZSBjb250ZW50IGhlaWdodCBpbiAncm93cycgKHNjcm9sbEhlaWdodCBpbmNsdWRlcyBwYWRkaW5nIGJ1dCBub3QgYm9yZGVyKVxuXG4gICAgICAgIHZhciBjb250ZW50Um93cyA9IE1hdGgubWF4KChzY3JvbGxIZWlnaHQgLSBwYWRkaW5nKSAvIGxpbmVIZWlnaHQsIDIpOyAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheSAobGltaXRlZCB3aXRoaW4gbWluL21heCByb3dzKVxuXG4gICAgICAgIHZhciByb3dzID0gTWF0aC5taW4oTWF0aC5tYXgoY29udGVudFJvd3MsIHRoaXMuY29tcHV0ZWRNaW5Sb3dzKSwgdGhpcy5jb21wdXRlZE1heFJvd3MpOyAvLyBDYWxjdWxhdGUgdGhlIHJlcXVpcmVkIGhlaWdodCBvZiB0aGUgdGV4dGFyZWEgaW5jbHVkaW5nIGJvcmRlciBhbmQgcGFkZGluZyAoaW4gcGl4ZWxzKVxuXG4gICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLm1heChNYXRoLmNlaWwocm93cyAqIGxpbmVIZWlnaHQgKyBvZmZzZXQpLCBtaW5IZWlnaHQpOyAvLyBDb21wdXRlZCBoZWlnaHQgcmVtYWlucyB0aGUgbGFyZ2VyIG9mIGBvbGRIZWlnaHRgIGFuZCBuZXcgYGhlaWdodGAsXG4gICAgICAgIC8vIHdoZW4gaGVpZ2h0IGlzIGluIGBzdGlja3lgIG1vZGUgKHByb3AgYG5vLWF1dG8tc2hyaW5rYCBpcyB0cnVlKVxuXG4gICAgICAgIGlmICh0aGlzLm5vQXV0b1NocmluayAmJiAocGFyc2VGbG9hdChvbGRIZWlnaHQpIHx8IDApID4gaGVpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIG9sZEhlaWdodDtcbiAgICAgICAgfSAvLyBSZXR1cm4gdGhlIG5ldyBjb21wdXRlZCBDU1MgaGVpZ2h0IGluIHB4IHVuaXRzXG5cblxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgLy8gVXNpbmcgc2VsZiBpbnN0ZWFkIG9mIHRoaXMgaGVscHMgcmVkdWNlIGNvZGUgc2l6ZSBkdXJpbmcgbWluaWZpY2F0aW9uXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gaCgndGV4dGFyZWEnLCB7XG4gICAgICAgIHJlZjogJ2lucHV0JyxcbiAgICAgICAgY2xhc3M6IHNlbGYuY29tcHV0ZWRDbGFzcyxcbiAgICAgICAgc3R5bGU6IHNlbGYuY29tcHV0ZWRTdHlsZSxcbiAgICAgICAgZGlyZWN0aXZlczogW3tcbiAgICAgICAgICBuYW1lOiAnbW9kZWwnLFxuICAgICAgICAgIHZhbHVlOiBzZWxmLmxvY2FsVmFsdWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6ICdiLXZpc2libGUnLFxuICAgICAgICAgIHZhbHVlOiB0aGlzLnZpc2libGVDYWxsYmFjayxcbiAgICAgICAgICAvLyBJZiB0ZXh0YXJlYSBpcyB3aXRoaW4gNjQwcHggb2Ygdmlld3BvcnQsIGNvbnNpZGVyIGl0IHZpc2libGVcbiAgICAgICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgICAgICc2NDAnOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBpZDogc2VsZi5zYWZlSWQoKSxcbiAgICAgICAgICBuYW1lOiBzZWxmLm5hbWUsXG4gICAgICAgICAgZm9ybTogc2VsZi5mb3JtIHx8IG51bGwsXG4gICAgICAgICAgZGlzYWJsZWQ6IHNlbGYuZGlzYWJsZWQsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6IHNlbGYucGxhY2Vob2xkZXIsXG4gICAgICAgICAgcmVxdWlyZWQ6IHNlbGYucmVxdWlyZWQsXG4gICAgICAgICAgYXV0b2NvbXBsZXRlOiBzZWxmLmF1dG9jb21wbGV0ZSB8fCBudWxsLFxuICAgICAgICAgIHJlYWRvbmx5OiBzZWxmLnJlYWRvbmx5IHx8IHNlbGYucGxhaW50ZXh0LFxuICAgICAgICAgIHJvd3M6IHNlbGYuY29tcHV0ZWRSb3dzLFxuICAgICAgICAgIHdyYXA6IHNlbGYud3JhcCB8fCBudWxsLFxuICAgICAgICAgICdhcmlhLXJlcXVpcmVkJzogc2VsZi5yZXF1aXJlZCA/ICd0cnVlJyA6IG51bGwsXG4gICAgICAgICAgJ2FyaWEtaW52YWxpZCc6IHNlbGYuY29tcHV0ZWRBcmlhSW52YWxpZFxuICAgICAgICB9LFxuICAgICAgICBkb21Qcm9wczoge1xuICAgICAgICAgIHZhbHVlOiBzZWxmLmxvY2FsVmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAgb246IF9vYmplY3RTcHJlYWQyKHt9LCBzZWxmLiRsaXN0ZW5lcnMsIHtcbiAgICAgICAgICBpbnB1dDogc2VsZi5vbklucHV0LFxuICAgICAgICAgIGNoYW5nZTogc2VsZi5vbkNoYW5nZSxcbiAgICAgICAgICBibHVyOiBzZWxmLm9uQmx1clxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgRm9ybVRleHRhcmVhUGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBCRm9ybVRleHRhcmVhOiBCRm9ybVRleHRhcmVhLFxuICAgICAgQlRleHRhcmVhOiBCRm9ybVRleHRhcmVhXG4gICAgfVxuICB9KTtcblxuICB2YXIgSW1hZ2VQbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJJbWc6IEJJbWcsXG4gICAgICBCSW1nTGF6eTogQkltZ0xhenlcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwcm9wcyR5ID0ge1xuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2RpdidcbiAgICB9XG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJJbnB1dEdyb3VwVGV4dCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JJbnB1dEdyb3VwVGV4dCcsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczogcHJvcHMkeSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICAgICAgcmV0dXJuIGgocHJvcHMudGFnLCBhKGRhdGEsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdpbnB1dC1ncm91cC10ZXh0J1xuICAgICAgfSksIGNoaWxkcmVuKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBjb21tb25Qcm9wcyA9IHtcbiAgICBpZDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGl2J1xuICAgIH0sXG4gICAgaXNUZXh0OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJJbnB1dEdyb3VwQWRkb24gPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCSW5wdXRHcm91cEFkZG9uJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBfb2JqZWN0U3ByZWFkMih7fSwgY29tbW9uUHJvcHMsIHtcbiAgICAgIGFwcGVuZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfVxuICAgIH0pLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gICAgICByZXR1cm4gaChwcm9wcy50YWcsIGEoZGF0YSwge1xuICAgICAgICBjbGFzczoge1xuICAgICAgICAgICdpbnB1dC1ncm91cC1hcHBlbmQnOiBwcm9wcy5hcHBlbmQsXG4gICAgICAgICAgJ2lucHV0LWdyb3VwLXByZXBlbmQnOiAhcHJvcHMuYXBwZW5kXG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHByb3BzLmlkXG4gICAgICAgIH1cbiAgICAgIH0pLCBwcm9wcy5pc1RleHQgPyBbaChCSW5wdXRHcm91cFRleHQsIGNoaWxkcmVuKV0gOiBjaGlsZHJlbik7XG4gICAgfVxuICB9KTtcblxuICB2YXIgQklucHV0R3JvdXBQcmVwZW5kID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQklucHV0R3JvdXBQcmVwZW5kJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBjb21tb25Qcm9wcyxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICAgICAgLy8gcGFzcyBhbGwgb3VyIHByb3BzL2F0dHJzIGRvd24gdG8gY2hpbGQsIGFuZCBzZXRgYXBwZW5kYCB0byBmYWxzZVxuICAgICAgcmV0dXJuIGgoQklucHV0R3JvdXBBZGRvbiwgYShkYXRhLCB7XG4gICAgICAgIHByb3BzOiBfb2JqZWN0U3ByZWFkMih7fSwgcHJvcHMsIHtcbiAgICAgICAgICBhcHBlbmQ6IGZhbHNlXG4gICAgICAgIH0pXG4gICAgICB9KSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIEJJbnB1dEdyb3VwQXBwZW5kID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQklucHV0R3JvdXBBcHBlbmQnLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IGNvbW1vblByb3BzLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gICAgICAvLyBwYXNzIGFsbCBvdXIgcHJvcHMvYXR0cnMgZG93biB0byBjaGlsZCwgYW5kIHNldGBhcHBlbmRgIHRvIHRydWVcbiAgICAgIHJldHVybiBoKEJJbnB1dEdyb3VwQWRkb24sIGEoZGF0YSwge1xuICAgICAgICBwcm9wczogX29iamVjdFNwcmVhZDIoe30sIHByb3BzLCB7XG4gICAgICAgICAgYXBwZW5kOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9KSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIE5BTUUkayA9ICdCSW5wdXRHcm91cCc7XG4gIHZhciBwcm9wcyR6ID0ge1xuICAgIGlkOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuICAgIHNpemU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkaywgJ3NpemUnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByZXBlbmQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG4gICAgcHJlcGVuZEh0bWw6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG4gICAgYXBwZW5kOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuICAgIGFwcGVuZEh0bWw6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGl2J1xuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQklucHV0R3JvdXAgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6IE5BTUUkayxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBwcm9wcyR6LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBzbG90cyA9IF9yZWYuc2xvdHMsXG4gICAgICAgICAgc2NvcGVkU2xvdHMgPSBfcmVmLnNjb3BlZFNsb3RzO1xuICAgICAgdmFyICRzbG90cyA9IHNsb3RzKCk7XG4gICAgICB2YXIgJHNjb3BlZFNsb3RzID0gc2NvcGVkU2xvdHMgfHwge307XG4gICAgICB2YXIgY2hpbGROb2RlcyA9IFtdOyAvLyBQcmVwZW5kIHByb3Avc2xvdFxuXG4gICAgICBpZiAocHJvcHMucHJlcGVuZCB8fCBwcm9wcy5wcmVwZW5kSHRtbCB8fCBoYXNOb3JtYWxpemVkU2xvdCgncHJlcGVuZCcsICRzY29wZWRTbG90cywgJHNsb3RzKSkge1xuICAgICAgICBjaGlsZE5vZGVzLnB1c2goaChCSW5wdXRHcm91cFByZXBlbmQsIFsvLyBQcm9wXG4gICAgICAgIHByb3BzLnByZXBlbmQgfHwgcHJvcHMucHJlcGVuZEh0bWwgPyBoKEJJbnB1dEdyb3VwVGV4dCwge1xuICAgICAgICAgIGRvbVByb3BzOiBodG1sT3JUZXh0KHByb3BzLnByZXBlbmRIdG1sLCBwcm9wcy5wcmVwZW5kKVxuICAgICAgICB9KSA6IGgoKSwgLy8gU2xvdFxuICAgICAgICBub3JtYWxpemVTbG90KCdwcmVwZW5kJywge30sICRzY29wZWRTbG90cywgJHNsb3RzKSB8fCBoKCldKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZE5vZGVzLnB1c2goaCgpKTtcbiAgICAgIH0gLy8gRGVmYXVsdCBzbG90XG5cblxuICAgICAgaWYgKGhhc05vcm1hbGl6ZWRTbG90KCdkZWZhdWx0JywgJHNjb3BlZFNsb3RzLCAkc2xvdHMpKSB7XG4gICAgICAgIGNoaWxkTm9kZXMucHVzaC5hcHBseShjaGlsZE5vZGVzLCBfdG9Db25zdW1hYmxlQXJyYXkobm9ybWFsaXplU2xvdCgnZGVmYXVsdCcsIHt9LCAkc2NvcGVkU2xvdHMsICRzbG90cykpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkTm9kZXMucHVzaChoKCkpO1xuICAgICAgfSAvLyBBcHBlbmQgcHJvcFxuXG5cbiAgICAgIGlmIChwcm9wcy5hcHBlbmQgfHwgcHJvcHMuYXBwZW5kSHRtbCB8fCBoYXNOb3JtYWxpemVkU2xvdCgnYXBwZW5kJywgJHNjb3BlZFNsb3RzLCAkc2xvdHMpKSB7XG4gICAgICAgIGNoaWxkTm9kZXMucHVzaChoKEJJbnB1dEdyb3VwQXBwZW5kLCBbLy8gcHJvcFxuICAgICAgICBwcm9wcy5hcHBlbmQgfHwgcHJvcHMuYXBwZW5kSHRtbCA/IGgoQklucHV0R3JvdXBUZXh0LCB7XG4gICAgICAgICAgZG9tUHJvcHM6IGh0bWxPclRleHQocHJvcHMuYXBwZW5kSHRtbCwgcHJvcHMuYXBwZW5kKVxuICAgICAgICB9KSA6IGgoKSwgLy8gU2xvdFxuICAgICAgICBub3JtYWxpemVTbG90KCdhcHBlbmQnLCB7fSwgJHNjb3BlZFNsb3RzLCAkc2xvdHMpIHx8IGgoKV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkTm9kZXMucHVzaChoKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaChwcm9wcy50YWcsIGEoZGF0YSwge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2lucHV0LWdyb3VwJyxcbiAgICAgICAgY2xhc3M6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJpbnB1dC1ncm91cC1cIi5jb25jYXQocHJvcHMuc2l6ZSksIHByb3BzLnNpemUpLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiBwcm9wcy5pZCB8fCBudWxsLFxuICAgICAgICAgIHJvbGU6ICdncm91cCdcbiAgICAgICAgfVxuICAgICAgfSksIGNoaWxkTm9kZXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIElucHV0R3JvdXBQbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJJbnB1dEdyb3VwOiBCSW5wdXRHcm91cCxcbiAgICAgIEJJbnB1dEdyb3VwQWRkb246IEJJbnB1dEdyb3VwQWRkb24sXG4gICAgICBCSW5wdXRHcm91cFByZXBlbmQ6IEJJbnB1dEdyb3VwUHJlcGVuZCxcbiAgICAgIEJJbnB1dEdyb3VwQXBwZW5kOiBCSW5wdXRHcm91cEFwcGVuZCxcbiAgICAgIEJJbnB1dEdyb3VwVGV4dDogQklucHV0R3JvdXBUZXh0XG4gICAgfVxuICB9KTtcblxuICB2YXIgcHJvcHMkQSA9IHtcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdkaXYnXG4gICAgfSxcbiAgICBmbHVpZDoge1xuICAgICAgLy8gU3RyaW5nIGJyZWFrcG9pbnQgbmFtZSBuZXcgaW4gQm9vdHN0cmFwIHY0LjQueFxuICAgICAgdHlwZTogW0Jvb2xlYW4sIFN0cmluZ10sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkNvbnRhaW5lciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JDb250YWluZXInLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IHByb3BzJEEsXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX3JlZikge1xuICAgICAgdmFyIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgICAgIHJldHVybiBoKHByb3BzLnRhZywgYShkYXRhLCB7XG4gICAgICAgIGNsYXNzOiBfZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgIGNvbnRhaW5lcjogIShwcm9wcy5mbHVpZCB8fCBwcm9wcy5mbHVpZCA9PT0gJycpLFxuICAgICAgICAgICdjb250YWluZXItZmx1aWQnOiBwcm9wcy5mbHVpZCA9PT0gdHJ1ZSB8fCBwcm9wcy5mbHVpZCA9PT0gJydcbiAgICAgICAgfSwgXCJjb250YWluZXItXCIuY29uY2F0KHByb3BzLmZsdWlkKSwgcHJvcHMuZmx1aWQgJiYgcHJvcHMuZmx1aWQgIT09IHRydWUpXG4gICAgICB9KSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIE5BTUUkbCA9ICdCSnVtYm90cm9uJztcbiAgdmFyIHByb3BzJEIgPSB7XG4gICAgZmx1aWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgY29udGFpbmVyRmx1aWQ6IHtcbiAgICAgIHR5cGU6IFtCb29sZWFuLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGhlYWRlcjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgaGVhZGVySHRtbDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgaGVhZGVyVGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnaDEnXG4gICAgfSxcbiAgICBoZWFkZXJMZXZlbDoge1xuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6ICczJ1xuICAgIH0sXG4gICAgbGVhZDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgbGVhZEh0bWw6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGxlYWRUYWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdwJ1xuICAgIH0sXG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGl2J1xuICAgIH0sXG4gICAgYmdWYXJpYW50OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJGwsICdiZ1ZhcmlhbnQnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGJvcmRlclZhcmlhbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkbCwgJ2JvcmRlclZhcmlhbnQnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRleHRWYXJpYW50OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJGwsICd0ZXh0VmFyaWFudCcpO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkp1bWJvdHJvbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogTkFNRSRsLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IHByb3BzJEIsXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX3JlZikge1xuICAgICAgdmFyIF9jbGFzczI7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBzbG90cyA9IF9yZWYuc2xvdHMsXG4gICAgICAgICAgc2NvcGVkU2xvdHMgPSBfcmVmLnNjb3BlZFNsb3RzO1xuICAgICAgLy8gVGhlIG9yZGVyIG9mIHRoZSBjb25kaXRpb25hbHMgbWF0dGVyLlxuICAgICAgLy8gV2UgYXJlIGJ1aWxkaW5nIHRoZSBjb21wb25lbnQgbWFya3VwIGluIG9yZGVyLlxuICAgICAgdmFyIGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgIHZhciAkc2xvdHMgPSBzbG90cygpO1xuICAgICAgdmFyICRzY29wZWRTbG90cyA9IHNjb3BlZFNsb3RzIHx8IHt9OyAvLyBIZWFkZXJcblxuICAgICAgaWYgKHByb3BzLmhlYWRlciB8fCBoYXNOb3JtYWxpemVkU2xvdCgnaGVhZGVyJywgJHNjb3BlZFNsb3RzLCAkc2xvdHMpIHx8IHByb3BzLmhlYWRlckh0bWwpIHtcbiAgICAgICAgY2hpbGROb2Rlcy5wdXNoKGgocHJvcHMuaGVhZGVyVGFnLCB7XG4gICAgICAgICAgY2xhc3M6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJkaXNwbGF5LVwiLmNvbmNhdChwcm9wcy5oZWFkZXJMZXZlbCksIHByb3BzLmhlYWRlckxldmVsKVxuICAgICAgICB9LCBub3JtYWxpemVTbG90KCdoZWFkZXInLCB7fSwgJHNjb3BlZFNsb3RzLCAkc2xvdHMpIHx8IHByb3BzLmhlYWRlckh0bWwgfHwgc3RyaXBUYWdzKHByb3BzLmhlYWRlcikpKTtcbiAgICAgIH0gLy8gTGVhZFxuXG5cbiAgICAgIGlmIChwcm9wcy5sZWFkIHx8IGhhc05vcm1hbGl6ZWRTbG90KCdsZWFkJywgJHNjb3BlZFNsb3RzLCAkc2xvdHMpIHx8IHByb3BzLmxlYWRIdG1sKSB7XG4gICAgICAgIGNoaWxkTm9kZXMucHVzaChoKHByb3BzLmxlYWRUYWcsIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogJ2xlYWQnXG4gICAgICAgIH0sIG5vcm1hbGl6ZVNsb3QoJ2xlYWQnLCB7fSwgJHNjb3BlZFNsb3RzLCAkc2xvdHMpIHx8IHByb3BzLmxlYWRIdG1sIHx8IHN0cmlwVGFncyhwcm9wcy5sZWFkKSkpO1xuICAgICAgfSAvLyBEZWZhdWx0IHNsb3RcblxuXG4gICAgICBpZiAoaGFzTm9ybWFsaXplZFNsb3QoJ2RlZmF1bHQnLCAkc2NvcGVkU2xvdHMsICRzbG90cykpIHtcbiAgICAgICAgY2hpbGROb2Rlcy5wdXNoKG5vcm1hbGl6ZVNsb3QoJ2RlZmF1bHQnLCB7fSwgJHNjb3BlZFNsb3RzLCAkc2xvdHMpKTtcbiAgICAgIH0gLy8gSWYgZmx1aWQsIHdyYXAgY29udGVudCBpbiBhIGNvbnRhaW5lci9jb250YWluZXItZmx1aWRcblxuXG4gICAgICBpZiAocHJvcHMuZmx1aWQpIHtcbiAgICAgICAgLy8gQ2hpbGRyZW4gYmVjb21lIGEgY2hpbGQgb2YgYSBjb250YWluZXJcbiAgICAgICAgY2hpbGROb2RlcyA9IFtoKEJDb250YWluZXIsIHtcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZmx1aWQ6IHByb3BzLmNvbnRhaW5lckZsdWlkXG4gICAgICAgICAgfVxuICAgICAgICB9LCBjaGlsZE5vZGVzKV07XG4gICAgICB9IC8vIFJldHVybiB0aGUganVtYm90cm9uXG5cblxuICAgICAgcmV0dXJuIGgocHJvcHMudGFnLCBhKGRhdGEsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdqdW1ib3Ryb24nLFxuICAgICAgICBjbGFzczogKF9jbGFzczIgPSB7XG4gICAgICAgICAgJ2p1bWJvdHJvbi1mbHVpZCc6IHByb3BzLmZsdWlkXG4gICAgICAgIH0sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MyLCBcInRleHQtXCIuY29uY2F0KHByb3BzLnRleHRWYXJpYW50KSwgcHJvcHMudGV4dFZhcmlhbnQpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzMiwgXCJiZy1cIi5jb25jYXQocHJvcHMuYmdWYXJpYW50KSwgcHJvcHMuYmdWYXJpYW50KSwgX2RlZmluZVByb3BlcnR5KF9jbGFzczIsIFwiYm9yZGVyLVwiLmNvbmNhdChwcm9wcy5ib3JkZXJWYXJpYW50KSwgcHJvcHMuYm9yZGVyVmFyaWFudCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MyLCBcImJvcmRlclwiLCBwcm9wcy5ib3JkZXJWYXJpYW50KSwgX2NsYXNzMilcbiAgICAgIH0pLCBjaGlsZE5vZGVzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBKdW1ib3Ryb25QbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJKdW1ib3Ryb246IEJKdW1ib3Ryb25cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBDT01NT05fQUxJR05NRU5UID0gWydzdGFydCcsICdlbmQnLCAnY2VudGVyJ107IC8vIEdlbmVyYXRlcyBhIHByb3Agb2JqZWN0IHdpdGggYSB0eXBlIG9mIGBbU3RyaW5nLCBOdW1iZXJdYFxuXG4gIHZhciBzdHJOdW0kMSA9IGZ1bmN0aW9uIHN0ck51bSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9O1xuICB9OyAvLyBDb21wdXRlIGEgYHJvdy1jb2xzLXticmVha3BvaW50fS17Y29sc31gIGNsYXNzIG5hbWVcbiAgLy8gTWVtb2l6ZWQgZnVuY3Rpb24gZm9yIGJldHRlciBwZXJmb3JtYW5jZSBvbiBnZW5lcmF0aW5nIGNsYXNzIG5hbWVzXG5cblxuICB2YXIgY29tcHV0ZVJvd0NvbHNDbGFzcyA9IG1lbW9pemUoZnVuY3Rpb24gKGJyZWFrcG9pbnQsIGNvbHMpIHtcbiAgICBjb2xzID0gdHJpbSh0b1N0cmluZyQxKGNvbHMpKTtcbiAgICByZXR1cm4gY29scyA/IGxvd2VyQ2FzZShbJ3Jvdy1jb2xzJywgYnJlYWtwb2ludCwgY29sc10uZmlsdGVyKGlkZW50aXR5KS5qb2luKCctJykpIDogbnVsbDtcbiAgfSk7IC8vIEdldCB0aGUgYnJlYWtwb2ludCBuYW1lIGZyb20gdGhlIGByb3dDb2xzYCBwcm9wIG5hbWVcbiAgLy8gTWVtb2l6ZWQgZnVuY3Rpb24gZm9yIGJldHRlciBwZXJmb3JtYW5jZSBvbiBleHRyYWN0aW5nIGJyZWFrcG9pbnQgbmFtZXNcblxuICB2YXIgY29tcHV0ZVJvd0NvbHNCcmVha3BvaW50ID0gbWVtb2l6ZShmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiBsb3dlckNhc2UocHJvcC5yZXBsYWNlKCdjb2xzJywgJycpKTtcbiAgfSk7IC8vIENhY2hlZCBjb3B5IG9mIHRoZSBgcm93LWNvbHNgIGJyZWFrcG9pbnQgcHJvcCBuYW1lc1xuICAvLyBXaWxsIGJlIHBvcHVsYXRlZCB3aGVuIHRoZSBwcm9wcyBhcmUgZ2VuZXJhdGVkXG5cbiAgdmFyIHJvd0NvbHNQcm9wTGlzdCA9IFtdOyAvLyBMYXp5IGV2YWxlZCBwcm9wcyBmYWN0b3J5IGZvciA8Yi1yb3c+IChjYWxsZWQgb25seSBvbmNlLFxuICAvLyB0aGUgZmlyc3QgdGltZSB0aGUgY29tcG9uZW50IGlzIHVzZWQpXG5cbiAgdmFyIGdlbmVyYXRlUHJvcHMkMiA9IGZ1bmN0aW9uIGdlbmVyYXRlUHJvcHMoKSB7XG4gICAgLy8gR3JhYiB0aGUgYnJlYWtwb2ludHMgZnJvbSB0aGUgY2FjaGVkIGNvbmZpZyAoaW5jbHVkaW5nIHRoZSAnJyAoeHMpIGJyZWFrcG9pbnQpXG4gICAgdmFyIGJyZWFrcG9pbnRzID0gZ2V0QnJlYWtwb2ludHNVcENhY2hlZCgpOyAvLyBTdXBwb3J0cyBjbGFzc2VzIGxpa2U6IGByb3ctY29scy0yYCwgYHJvdy1jb2xzLW1kLTRgLCBgcm93LWNvbHMteGwtNmBcblxuICAgIHZhciByb3dDb2xzUHJvcHMgPSBicmVha3BvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHByb3BzLCBicmVha3BvaW50KSB7XG4gICAgICBwcm9wc1tzdWZmaXhQcm9wTmFtZShicmVha3BvaW50LCAnY29scycpXSA9IHN0ck51bSQxKCk7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfSwgY3JlYXRlKG51bGwpKTsgLy8gQ2FjaGUgdGhlIHJvdy1jb2xzIHByb3AgbmFtZXNcblxuICAgIHJvd0NvbHNQcm9wTGlzdCA9IGtleXMocm93Q29sc1Byb3BzKTsgLy8gUmV0dXJuIHRoZSBnZW5lcmF0ZWQgcHJvcHNcblxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICB0YWc6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnZGl2J1xuICAgICAgfSxcbiAgICAgIG5vR3V0dGVyczoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGFsaWduVjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHN0cikge1xuICAgICAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKENPTU1PTl9BTElHTk1FTlQuY29uY2F0KFsnYmFzZWxpbmUnLCAnc3RyZXRjaCddKSwgc3RyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFsaWduSDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHN0cikge1xuICAgICAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKENPTU1PTl9BTElHTk1FTlQuY29uY2F0KFsnYmV0d2VlbicsICdhcm91bmQnXSksIHN0cik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhbGlnbkNvbnRlbnQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcihzdHIpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXlJbmNsdWRlcyhDT01NT05fQUxJR05NRU5ULmNvbmNhdChbJ2JldHdlZW4nLCAnYXJvdW5kJywgJ3N0cmV0Y2gnXSksIHN0cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCByb3dDb2xzUHJvcHMpO1xuICB9OyAvLyBXZSBkbyBub3QgdXNlIGBWdWUuZXh0ZW5kKClgIGhlcmUgYXMgdGhhdCB3b3VsZCBldmFsdWF0ZSB0aGUgcHJvcHNcbiAgLy8gaW1tZWRpYXRlbHksIHdoaWNoIHdlIGRvIG5vdCB3YW50IHRvIGhhcHBlblxuICAvLyBAdnVlL2NvbXBvbmVudFxuXG5cbiAgdmFyIEJSb3cgPSB7XG4gICAgbmFtZTogJ0JSb3cnLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG5cbiAgICBnZXQgcHJvcHMoKSB7XG4gICAgICAvLyBBbGxvdyBwcm9wcyB0byBiZSBsYXp5IGV2YWxlZCBvbiBmaXJzdCBhY2Nlc3MgYW5kXG4gICAgICAvLyB0aGVuIHRoZXkgYmVjb21lIGEgbm9uLWdldHRlciBhZnRlcndhcmRzXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9GdW5jdGlvbnMvZ2V0I1NtYXJ0X3NlbGYtb3ZlcndyaXRpbmdfbGF6eV9nZXR0ZXJzXG4gICAgICBkZWxldGUgdGhpcy5wcm9wcztcbiAgICAgIHRoaXMucHJvcHMgPSBnZW5lcmF0ZVByb3BzJDIoKTtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzO1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgX2NsYXNzTGlzdCRwdXNoO1xuXG4gICAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICAgICAgdmFyIGNsYXNzTGlzdCA9IFtdOyAvLyBMb29wIHRocm91Z2ggcm93LWNvbHMgYnJlYWtwb2ludCBwcm9wcyBhbmQgZ2VuZXJhdGUgdGhlIGNsYXNzZXNcblxuICAgICAgcm93Q29sc1Byb3BMaXN0LmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgdmFyIGMgPSBjb21wdXRlUm93Q29sc0NsYXNzKGNvbXB1dGVSb3dDb2xzQnJlYWtwb2ludChwcm9wKSwgcHJvcHNbcHJvcF0pOyAvLyBJZiBhIGNsYXNzIGlzIHJldHVybmVkLCBwdXNoIGl0IG9udG8gdGhlIGFycmF5XG5cbiAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICBjbGFzc0xpc3QucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjbGFzc0xpc3QucHVzaCgoX2NsYXNzTGlzdCRwdXNoID0ge1xuICAgICAgICAnbm8tZ3V0dGVycyc6IHByb3BzLm5vR3V0dGVyc1xuICAgICAgfSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc0xpc3QkcHVzaCwgXCJhbGlnbi1pdGVtcy1cIi5jb25jYXQocHJvcHMuYWxpZ25WKSwgcHJvcHMuYWxpZ25WKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc0xpc3QkcHVzaCwgXCJqdXN0aWZ5LWNvbnRlbnQtXCIuY29uY2F0KHByb3BzLmFsaWduSCksIHByb3BzLmFsaWduSCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NMaXN0JHB1c2gsIFwiYWxpZ24tY29udGVudC1cIi5jb25jYXQocHJvcHMuYWxpZ25Db250ZW50KSwgcHJvcHMuYWxpZ25Db250ZW50KSwgX2NsYXNzTGlzdCRwdXNoKSk7XG4gICAgICByZXR1cm4gaChwcm9wcy50YWcsIGEoZGF0YSwge1xuICAgICAgICBzdGF0aWNDbGFzczogJ3JvdycsXG4gICAgICAgIGNsYXNzOiBjbGFzc0xpc3RcbiAgICAgIH0pLCBjaGlsZHJlbik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBMYXlvdXRQbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJDb250YWluZXI6IEJDb250YWluZXIsXG4gICAgICBCUm93OiBCUm93LFxuICAgICAgQkNvbDogQkNvbCxcbiAgICAgIEJGb3JtUm93OiBCRm9ybVJvd1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIExpbmtQbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJMaW5rOiBCTGlua1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHByb3BzJEMgPSB7XG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGl2J1xuICAgIH0sXG4gICAgZmx1c2g6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgaG9yaXpvbnRhbDoge1xuICAgICAgdHlwZTogW0Jvb2xlYW4sIFN0cmluZ10sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkxpc3RHcm91cCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JMaXN0R3JvdXAnLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IHByb3BzJEMsXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX3JlZikge1xuICAgICAgdmFyIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgICAgIHZhciBob3Jpem9udGFsID0gcHJvcHMuaG9yaXpvbnRhbCA9PT0gJycgPyB0cnVlIDogcHJvcHMuaG9yaXpvbnRhbDtcbiAgICAgIGhvcml6b250YWwgPSBwcm9wcy5mbHVzaCA/IGZhbHNlIDogaG9yaXpvbnRhbDtcbiAgICAgIHZhciBjb21wb25lbnREYXRhID0ge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2xpc3QtZ3JvdXAnLFxuICAgICAgICBjbGFzczogX2RlZmluZVByb3BlcnR5KHtcbiAgICAgICAgICAnbGlzdC1ncm91cC1mbHVzaCc6IHByb3BzLmZsdXNoLFxuICAgICAgICAgICdsaXN0LWdyb3VwLWhvcml6b250YWwnOiBob3Jpem9udGFsID09PSB0cnVlXG4gICAgICAgIH0sIFwibGlzdC1ncm91cC1ob3Jpem9udGFsLVwiLmNvbmNhdChob3Jpem9udGFsKSwgaXNTdHJpbmcoaG9yaXpvbnRhbCkpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGgocHJvcHMudGFnLCBhKGRhdGEsIGNvbXBvbmVudERhdGEpLCBjaGlsZHJlbik7XG4gICAgfVxuICB9KTtcblxuICB2YXIgTkFNRSRtID0gJ0JMaXN0R3JvdXBJdGVtJztcbiAgdmFyIGFjdGlvblRhZ3MgPSBbJ2EnLCAncm91dGVyLWxpbmsnLCAnYnV0dG9uJywgJ2ItbGluayddO1xuICB2YXIgbGlua1Byb3BzJDIgPSBwcm9wc0ZhY3RvcnkoKTtcbiAgZGVsZXRlIGxpbmtQcm9wcyQyLmhyZWYuZGVmYXVsdDtcbiAgZGVsZXRlIGxpbmtQcm9wcyQyLnRvLmRlZmF1bHQ7XG4gIHZhciBwcm9wcyREID0gX29iamVjdFNwcmVhZDIoe1xuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2RpdidcbiAgICB9LFxuICAgIGFjdGlvbjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGJ1dHRvbjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIHZhcmlhbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkbSwgJ3ZhcmlhbnQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIGxpbmtQcm9wcyQyKTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQkxpc3RHcm91cEl0ZW0gPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6IE5BTUUkbSxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBwcm9wcyRELFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBfY2xhc3M7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gICAgICB2YXIgdGFnID0gcHJvcHMuYnV0dG9uID8gJ2J1dHRvbicgOiAhcHJvcHMuaHJlZiAmJiAhcHJvcHMudG8gPyBwcm9wcy50YWcgOiBCTGluaztcbiAgICAgIHZhciBpc0FjdGlvbiA9IEJvb2xlYW4ocHJvcHMuaHJlZiB8fCBwcm9wcy50byB8fCBwcm9wcy5hY3Rpb24gfHwgcHJvcHMuYnV0dG9uIHx8IGFycmF5SW5jbHVkZXMoYWN0aW9uVGFncywgcHJvcHMudGFnKSk7XG4gICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgIHZhciBpdGVtUHJvcHMgPSB7fTtcblxuICAgICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgICAgaWYgKCFkYXRhLmF0dHJzIHx8ICFkYXRhLmF0dHJzLnR5cGUpIHtcbiAgICAgICAgICAvLyBBZGQgYSB0eXBlIGZvciBidXR0b24gaXMgb25lIG5vdCBwcm92aWRlZCBpbiBwYXNzZWQgYXR0cmlidXRlc1xuICAgICAgICAgIGF0dHJzLnR5cGUgPSAnYnV0dG9uJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICAgIC8vIFNldCBkaXNhYmxlZCBhdHRyaWJ1dGUgaWYgYnV0dG9uIGFuZCBkaXNhYmxlZFxuICAgICAgICAgIGF0dHJzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbVByb3BzID0gcGx1Y2tQcm9wcyhsaW5rUHJvcHMkMiwgcHJvcHMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29tcG9uZW50RGF0YSA9IHtcbiAgICAgICAgYXR0cnM6IGF0dHJzLFxuICAgICAgICBwcm9wczogaXRlbVByb3BzLFxuICAgICAgICBzdGF0aWNDbGFzczogJ2xpc3QtZ3JvdXAtaXRlbScsXG4gICAgICAgIGNsYXNzOiAoX2NsYXNzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsIFwibGlzdC1ncm91cC1pdGVtLVwiLmNvbmNhdChwcm9wcy52YXJpYW50KSwgcHJvcHMudmFyaWFudCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsICdsaXN0LWdyb3VwLWl0ZW0tYWN0aW9uJywgaXNBY3Rpb24pLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzLCBcImFjdGl2ZVwiLCBwcm9wcy5hY3RpdmUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzLCBcImRpc2FibGVkXCIsIHByb3BzLmRpc2FibGVkKSwgX2NsYXNzKVxuICAgICAgfTtcbiAgICAgIHJldHVybiBoKHRhZywgYShkYXRhLCBjb21wb25lbnREYXRhKSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIExpc3RHcm91cFBsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgY29tcG9uZW50czoge1xuICAgICAgQkxpc3RHcm91cDogQkxpc3RHcm91cCxcbiAgICAgIEJMaXN0R3JvdXBJdGVtOiBCTGlzdEdyb3VwSXRlbVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHByb3BzJEUgPSB7XG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGl2J1xuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQk1lZGlhQm9keSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JNZWRpYUJvZHknLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IHByb3BzJEUsXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX3JlZikge1xuICAgICAgdmFyIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgICAgIHJldHVybiBoKHByb3BzLnRhZywgYShkYXRhLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnbWVkaWEtYm9keSdcbiAgICAgIH0pLCBjaGlsZHJlbik7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcHJvcHMkRiA9IHtcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdkaXYnXG4gICAgfSxcbiAgICB2ZXJ0aWNhbEFsaWduOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAndG9wJ1xuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQk1lZGlhQXNpZGUgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCTWVkaWFBc2lkZScsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczogcHJvcHMkRixcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICAgICAgdmFyIGFsaWduID0gcHJvcHMudmVydGljYWxBbGlnbiA9PT0gJ3RvcCcgPyAnc3RhcnQnIDogcHJvcHMudmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScgPyAnZW5kJyA6IHByb3BzLnZlcnRpY2FsQWxpZ247XG4gICAgICByZXR1cm4gaChwcm9wcy50YWcsIGEoZGF0YSwge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2QtZmxleCcsXG4gICAgICAgIGNsYXNzOiBfZGVmaW5lUHJvcGVydHkoe30sIFwiYWxpZ24tc2VsZi1cIi5jb25jYXQoYWxpZ24pLCBhbGlnbilcbiAgICAgIH0pLCBjaGlsZHJlbik7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcHJvcHMkRyA9IHtcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdkaXYnXG4gICAgfSxcbiAgICByaWdodEFsaWduOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHZlcnRpY2FsQWxpZ246IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICd0b3AnXG4gICAgfSxcbiAgICBub0JvZHk6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQk1lZGlhID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQk1lZGlhJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBwcm9wcyRHLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBzbG90cyA9IF9yZWYuc2xvdHMsXG4gICAgICAgICAgc2NvcGVkU2xvdHMgPSBfcmVmLnNjb3BlZFNsb3RzLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgICAgIHZhciBjaGlsZE5vZGVzID0gcHJvcHMubm9Cb2R5ID8gY2hpbGRyZW4gOiBbXTtcblxuICAgICAgaWYgKCFwcm9wcy5ub0JvZHkpIHtcbiAgICAgICAgdmFyICRzbG90cyA9IHNsb3RzKCk7XG4gICAgICAgIHZhciAkc2NvcGVkU2xvdHMgPSBzY29wZWRTbG90cyB8fCB7fTtcbiAgICAgICAgdmFyICRhc2lkZSA9IG5vcm1hbGl6ZVNsb3QoJ2FzaWRlJywge30sICRzY29wZWRTbG90cywgJHNsb3RzKTtcbiAgICAgICAgdmFyICRkZWZhdWx0ID0gbm9ybWFsaXplU2xvdCgnZGVmYXVsdCcsIHt9LCAkc2NvcGVkU2xvdHMsICRzbG90cyk7XG5cbiAgICAgICAgaWYgKCRhc2lkZSAmJiAhcHJvcHMucmlnaHRBbGlnbikge1xuICAgICAgICAgIGNoaWxkTm9kZXMucHVzaChoKEJNZWRpYUFzaWRlLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ21yLTMnLFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgdmVydGljYWxBbGlnbjogcHJvcHMudmVydGljYWxBbGlnblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sICRhc2lkZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGROb2Rlcy5wdXNoKGgoQk1lZGlhQm9keSwgJGRlZmF1bHQpKTtcblxuICAgICAgICBpZiAoJGFzaWRlICYmIHByb3BzLnJpZ2h0QWxpZ24pIHtcbiAgICAgICAgICBjaGlsZE5vZGVzLnB1c2goaChCTWVkaWFBc2lkZSwge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICdtbC0zJyxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246IHByb3BzLnZlcnRpY2FsQWxpZ25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAkYXNpZGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaChwcm9wcy50YWcsIGEoZGF0YSwge1xuICAgICAgICBzdGF0aWNDbGFzczogJ21lZGlhJ1xuICAgICAgfSksIGNoaWxkTm9kZXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIE1lZGlhUGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBCTWVkaWE6IEJNZWRpYSxcbiAgICAgIEJNZWRpYUFzaWRlOiBCTWVkaWFBc2lkZSxcbiAgICAgIEJNZWRpYUJvZHk6IEJNZWRpYUJvZHlcbiAgICB9XG4gIH0pO1xuXG4gIC8vXG4gIC8vIFNpbmdsZSByb290IG5vZGUgcG9ydGFsaW5nIG9mIGNvbnRlbnQsIHdoaWNoIHJldGFpbnMgcGFyZW50L2NoaWxkIGhpZXJhcmNoeVxuICAvLyBVbmxpa2UgUG9ydGFsLVZ1ZSB3aGVyZSBwb3J0YWxlZCBjb250ZW50IGlzIG5vIGxvbmdlciBhIGRlc2NlbmRlbnQgb2YgaXRzXG4gIC8vIGludGVuZGVkIHBhcmVudCBjb21wb25lbnRzXG4gIC8vXG4gIC8vIFByaXZhdGUgY29tcG9uZW50cyBmb3IgdXNlIGJ5IFRvb2x0aXBzLCBQb3BvdmVycyBhbmQgTW9kYWxzXG4gIC8vXG4gIC8vIEJhc2VkIG9uIHZ1ZS1zaW1wbGUtcG9ydGFsXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MaW51c0JvcmcvdnVlLXNpbXBsZS1wb3J0YWxcbiAgLy8gVHJhbnNwb3J0ZXIgdGFyZ2V0IHVzZWQgYnkgQlRyYW5zcG9ydGVyU2luZ2xlXG4gIC8vIFN1cHBvcnRzIG9ubHkgYSBzaW5nbGUgcm9vdCBlbGVtZW50XG4gIC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJUcmFuc3BvcnRlclRhcmdldFNpbmdsZSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgLy8gQXMgYW4gYWJzdHJhY3QgY29tcG9uZW50LCBpdCBkb2Vzbid0IGFwcGVhciBpbiB0aGUgJHBhcmVudCBjaGFpbiBvZlxuICAgIC8vIGNvbXBvbmVudHMsIHdoaWNoIG1lYW5zIHRoZSBuZXh0IHBhcmVudCBvZiBhbnkgY29tcG9uZW50IHJlbmRlcmVkIGluc2lkZVxuICAgIC8vIG9mIHRoaXMgb25lIHdpbGwgYmUgdGhlIHBhcmVudCBmcm9tIHdoaWNoIGlzIHdhcyBwb3J0YWwnZFxuICAgIGFic3RyYWN0OiB0cnVlLFxuICAgIG5hbWU6ICdCVHJhbnNwb3J0ZXJUYXJnZXRTaW5nbGUnLFxuICAgIHByb3BzOiB7XG4gICAgICBub2Rlczoge1xuICAgICAgICAvLyBFdmVuIHRob3VnaCB3ZSBvbmx5IHN1cHBvcnQgYSBzaW5nbGUgcm9vdCBlbGVtZW50LFxuICAgICAgICAvLyBWTm9kZXMgYXJlIGFsd2F5cyBwYXNzZWQgYXMgYW4gYXJyYXlcbiAgICAgICAgdHlwZTogW0FycmF5LCBGdW5jdGlvbl0gLy8gZGVmYXVsdDogdW5kZWZpbmVkXG5cbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEodm0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZWROb2Rlczogdm0ubm9kZXNcbiAgICAgIH07XG4gICAgfSxcbiAgICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCgpIHtcbiAgICAgIHJlbW92ZU5vZGUodGhpcy4kZWwpO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgdmFyIG5vZGVzID0gaXNGdW5jdGlvbih0aGlzLnVwZGF0ZWROb2RlcykgPyB0aGlzLnVwZGF0ZWROb2Rlcyh7fSkgOiB0aGlzLnVwZGF0ZWROb2RlcztcbiAgICAgIG5vZGVzID0gY29uY2F0KG5vZGVzKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXG4gICAgICBpZiAobm9kZXMgJiYgbm9kZXMubGVuZ3RoID4gMCAmJiAhbm9kZXNbMF0udGV4dCkge1xuICAgICAgICByZXR1cm4gbm9kZXNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIFRoaXMgY29tcG9uZW50IGhhcyBubyByb290IGVsZW1lbnQsIHNvIG9ubHkgYSBzaW5nbGUgVk5vZGUgaXMgYWxsb3dlZFxuICAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCVHJhbnNwb3J0ZXJTaW5nbGUgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCVHJhbnNwb3J0ZXJTaW5nbGUnLFxuICAgIG1peGluczogW25vcm1hbGl6ZVNsb3RNaXhpbl0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgIC8vIFN0cmluZzogQ1NTIHNlbGVjdG9yLFxuICAgICAgICAvLyBIVE1MRWxlbWVudDogRWxlbWVudCByZWZlcmVuY2VcbiAgICAgICAgLy8gTWFpbmx5IG5lZWRlZCBmb3IgdG9vbHRpcHMvcG9wb3ZlcnMgaW5zaWRlIG1vZGFsc1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBIVE1MRWxlbWVudF0sXG4gICAgICAgIGRlZmF1bHQ6ICdib2R5J1xuICAgICAgfSxcbiAgICAgIHRhZzoge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBzZXQgdG8gbWF0Y2ggdGhlIHJvb3QgZWxlbWVudCB0eXBlXG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ2RpdidcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICBkaXNhYmxlZDoge1xuICAgICAgICBpbW1lZGlhdGU6IHRydWUsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoZGlzYWJsZWQpIHtcbiAgICAgICAgICBkaXNhYmxlZCA/IHRoaXMudW5tb3VudFRhcmdldCgpIDogdGhpcy4kbmV4dFRpY2sodGhpcy5tb3VudFRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgICB0aGlzLl9idl9kZWZhdWx0Rm4gPSBudWxsO1xuICAgICAgdGhpcy5fYnZfdGFyZ2V0ID0gbnVsbDtcbiAgICB9LFxuICAgIGJlZm9yZU1vdW50OiBmdW5jdGlvbiBiZWZvcmVNb3VudCgpIHtcbiAgICAgIHRoaXMubW91bnRUYXJnZXQoKTtcbiAgICB9LFxuICAgIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQoKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBjaGlsZHJlbiBoYXZlIGNvbXBsZXRlZCB1cGRhdGluZ1xuICAgICAgLy8gYmVmb3JlIHJlbmRlcmluZyBpbiB0aGUgdGFyZ2V0XG4gICAgICAvLyBgdnVlLXNpbXBsZS1wb3J0YWxgIGhhcyB0aGUgdGhpcyBpbiBhIGAkbmV4dFRpY2soKWAsXG4gICAgICAvLyB3aGlsZSBgcG9ydGFsLXZ1ZWAgZG9lc24ndFxuICAgICAgLy8gSnVzdCB0cnlpbmcgdG8gc2VlIGlmIHRoZSBgJG5leHRUaWNrKClgIGRlbGF5IGlzIHJlcXVpcmVkIG9yIG5vdFxuICAgICAgLy8gU2luY2UgYWxsIHNsb3RzIGluIFZ1ZSAyLjYueCBhcmUgYWx3YXlzIGZ1bmN0aW9uc1xuICAgICAgdGhpcy51cGRhdGVUYXJnZXQoKTtcbiAgICB9LFxuICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgICB0aGlzLnVubW91bnRUYXJnZXQoKTtcbiAgICAgIHRoaXMuX2J2X2RlZmF1bHRGbiA9IG51bGw7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAvLyBHZXQgdGhlIGVsZW1lbnQgd2hpY2ggdGhlIHRhcmdldCBzaG91bGQgYmUgYXBwZW5kZWQgdG9cbiAgICAgIGdldENvbnRhaW5lcjogZnVuY3Rpb24gZ2V0Q29udGFpbmVyKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICAgIHJldHVybiBpc1N0cmluZyhjb250YWluZXIpID8gc2VsZWN0KGNvbnRhaW5lcikgOiBjb250YWluZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBNb3VudCB0aGUgdGFyZ2V0XG4gICAgICBtb3VudFRhcmdldDogZnVuY3Rpb24gbW91bnRUYXJnZXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYnZfdGFyZ2V0KSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XG5cbiAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICB0aGlzLl9idl90YXJnZXQgPSBuZXcgQlRyYW5zcG9ydGVyVGFyZ2V0U2luZ2xlKHtcbiAgICAgICAgICAgICAgZWw6IGVsLFxuICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgIHByb3BzRGF0YToge1xuICAgICAgICAgICAgICAgIC8vIEluaXRpYWwgbm9kZXMgdG8gYmUgcmVuZGVyZWRcbiAgICAgICAgICAgICAgICBub2RlczogY29uY2F0KHRoaXMubm9ybWFsaXplU2xvdCgnZGVmYXVsdCcpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBVcGRhdGUgdGhlIGNvbnRlbnQgb2YgdGhlIHRhcmdldFxuICAgICAgdXBkYXRlVGFyZ2V0OiBmdW5jdGlvbiB1cGRhdGVUYXJnZXQoKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIgJiYgdGhpcy5fYnZfdGFyZ2V0KSB7XG4gICAgICAgICAgdmFyIGRlZmF1bHRGbiA9IHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQ7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGFwcGxpY2FibGUgaW4gVnVlIDIuNS54ICovXG4gICAgICAgICAgICBpZiAoZGVmYXVsdEZuICYmIHRoaXMuX2J2X2RlZmF1bHRGbiAhPT0gZGVmYXVsdEZuKSB7XG4gICAgICAgICAgICAgIC8vIFdlIG9ubHkgdXBkYXRlIHRoZSB0YXJnZXQgY29tcG9uZW50IGlmIHRoZSBzY29wZWQgc2xvdFxuICAgICAgICAgICAgICAvLyBmdW5jdGlvbiBpcyBhIGZyZXNoIG9uZS4gVGhlIG5ldyBzbG90IHN5bnRheCAoc2luY2UgVnVlIDIuNilcbiAgICAgICAgICAgICAgLy8gY2FuIGNhY2hlIHVuY2hhbmdlZCBzbG90IGZ1bmN0aW9ucyBhbmQgd2Ugd2FudCB0byByZXNwZWN0IHRoYXQgaGVyZVxuICAgICAgICAgICAgICB0aGlzLl9idl90YXJnZXQudXBkYXRlZE5vZGVzID0gZGVmYXVsdEZuO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZGVmYXVsdEZuKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBiZSBiYWNrIGNvbXBhdGlibGUgd2l0aCBub24tc2NvcGVkIGRlZmF1bHQgc2xvdCAoaS5lLiAyLjUueClcbiAgICAgICAgICAgICAgdGhpcy5fYnZfdGFyZ2V0LnVwZGF0ZWROb2RlcyA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBVcGRhdGUgdGhlIHNjb3BlZCBzbG90IGZ1bmN0aW9uIGNhY2hlXG5cblxuICAgICAgICAgIHRoaXMuX2J2X2RlZmF1bHRGbiA9IGRlZmF1bHRGbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFVubW91bnQgdGhlIHRhcmdldFxuICAgICAgdW5tb3VudFRhcmdldDogZnVuY3Rpb24gdW5tb3VudFRhcmdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2J2X3RhcmdldCkge1xuICAgICAgICAgIHRoaXMuX2J2X3RhcmdldC4kZGVzdHJveSgpO1xuXG4gICAgICAgICAgdGhpcy5fYnZfdGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gY29uY2F0KHRoaXMubm9ybWFsaXplU2xvdCgnZGVmYXVsdCcpKS5maWx0ZXIoaWRlbnRpdHkpO1xuXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwICYmICFub2Rlc1swXS50ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGVzWzBdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoKCk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgUFJPUCQxID0gJyRfYnZfZG9jdW1lbnRIYW5kbGVyc18nOyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBsaXN0ZW5PbkRvY3VtZW50TWl4aW4gPSB7XG4gICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBpZiAoIWlzQnJvd3Nlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIERlY2xhcmUgbm9uLXJlYWN0aXZlIHByb3BlcnR5XG4gICAgICAvLyBPYmplY3Qgb2YgYXJyYXlzLCBrZXllZCBieSBldmVudCBuYW1lLFxuICAgICAgLy8gd2hlcmUgdmFsdWUgaXMgYW4gYXJyYXkgb2YgaGFuZGxlcnNcbiAgICAgIC8vIFByb3Agd2lsbCBiZSBkZWZpbmVkIG9uIGNsaWVudCBvbmx5XG5cblxuICAgICAgdGhpc1tQUk9QJDFdID0ge307IC8vIFNldCB1cCBvdXIgYmVmb3JlRGVzdHJveSBoYW5kbGVyIChjbGllbnQgb25seSlcblxuICAgICAgdGhpcy4kb25jZSgnaG9vazpiZWZvcmVEZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlbXMgPSBfdGhpc1tQUk9QJDFdIHx8IHt9OyAvLyBJbW1lZGlhdGVseSBkZWxldGUgdGhpc1tQUk9QXSB0byBwcmV2ZW50IHRoZVxuICAgICAgICAvLyBsaXN0ZW5Pbi9PZmYgbWV0aG9kcyBmcm9tIHJ1bm5pbmcgKHdoaWNoIG1heSBvY2N1clxuICAgICAgICAvLyBkdWUgdG8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lL3RyYW5zaXRpb24gZGVsYXlzKVxuXG4gICAgICAgIGRlbGV0ZSBfdGhpc1tQUk9QJDFdOyAvLyBSZW1vdmUgYWxsIHJlZ2lzdGVyZWQgZXZlbnQgaGFuZGxlcnNcblxuICAgICAgICBrZXlzKGl0ZW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChldnROYW1lKSB7XG4gICAgICAgICAgdmFyIGhhbmRsZXJzID0gaXRlbXNbZXZ0TmFtZV0gfHwgW107XG4gICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50T2ZmKGRvY3VtZW50LCBldnROYW1lLCBoYW5kbGVyLCBFVkVOVF9PUFRJT05TX05PX0NBUFRVUkUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgbGlzdGVuRG9jdW1lbnQ6IGZ1bmN0aW9uIGxpc3RlbkRvY3VtZW50KG9uLCBldnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIG9uID8gdGhpcy5saXN0ZW5PbkRvY3VtZW50KGV2dE5hbWUsIGhhbmRsZXIpIDogdGhpcy5saXN0ZW5PZmZEb2N1bWVudChldnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBsaXN0ZW5PbkRvY3VtZW50OiBmdW5jdGlvbiBsaXN0ZW5PbkRvY3VtZW50KGV2dE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXNbUFJPUCQxXSAmJiBpc1N0cmluZyhldnROYW1lKSAmJiBpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgICAgdGhpc1tQUk9QJDFdW2V2dE5hbWVdID0gdGhpc1tQUk9QJDFdW2V2dE5hbWVdIHx8IFtdO1xuXG4gICAgICAgICAgaWYgKCFhcnJheUluY2x1ZGVzKHRoaXNbUFJPUCQxXVtldnROYW1lXSwgaGFuZGxlcikpIHtcbiAgICAgICAgICAgIHRoaXNbUFJPUCQxXVtldnROYW1lXS5wdXNoKGhhbmRsZXIpO1xuICAgICAgICAgICAgZXZlbnRPbihkb2N1bWVudCwgZXZ0TmFtZSwgaGFuZGxlciwgRVZFTlRfT1BUSU9OU19OT19DQVBUVVJFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsaXN0ZW5PZmZEb2N1bWVudDogZnVuY3Rpb24gbGlzdGVuT2ZmRG9jdW1lbnQoZXZ0TmFtZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAodGhpc1tQUk9QJDFdICYmIGlzU3RyaW5nKGV2dE5hbWUpICYmIGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgICAgICBldmVudE9mZihkb2N1bWVudCwgZXZ0TmFtZSwgaGFuZGxlciwgRVZFTlRfT1BUSU9OU19OT19DQVBUVVJFKTtcbiAgICAgICAgICB0aGlzW1BST1AkMV1bZXZ0TmFtZV0gPSAodGhpc1tQUk9QJDFdW2V2dE5hbWVdIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoICE9PSBoYW5kbGVyO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBQUk9QJDIgPSAnJF9idl93aW5kb3dIYW5kbGVyc18nOyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBsaXN0ZW5PbldpbmRvd01peGluID0ge1xuICAgIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlKCkge1xuICAgICAgLy8gRGVjbGFyZSBub24tcmVhY3RpdmUgcHJvcGVydHlcbiAgICAgIC8vIE9iamVjdCBvZiBhcnJheXMsIGtleWVkIGJ5IGV2ZW50IG5hbWUsXG4gICAgICAvLyB3aGVyZSB2YWx1ZSBpcyBhbiBhcnJheSBvZiBoYW5kbGVyc1xuICAgICAgdGhpc1tQUk9QJDJdID0ge307XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzW1BST1AkMl07IC8vIEltbWVkaWF0ZWx5IGRlbGV0ZSB0aGlzW1BST1BdIHRvIHByZXZlbnQgdGhlXG4gICAgICAgIC8vIGxpc3Rlbk9uL09mZiBtZXRob2RzIGZyb20gcnVubmluZyAod2hpY2ggbWF5IG9jY3VyXG4gICAgICAgIC8vIGR1ZSB0byByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZGVsYXlzKVxuXG4gICAgICAgIGRlbGV0ZSB0aGlzW1BST1AkMl07IC8vIFJlbW92ZSBhbGwgcmVnaXN0ZXJlZCBldmVudCBoYW5kbGVyc1xuXG4gICAgICAgIGtleXMoaXRlbXMpLmZvckVhY2goZnVuY3Rpb24gKGV2dE5hbWUpIHtcbiAgICAgICAgICB2YXIgaGFuZGxlcnMgPSBpdGVtc1tldnROYW1lXSB8fCBbXTtcbiAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRPZmYod2luZG93LCBldnROYW1lLCBoYW5kbGVyLCBFVkVOVF9PUFRJT05TX05PX0NBUFRVUkUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGxpc3RlbldpbmRvdzogZnVuY3Rpb24gbGlzdGVuV2luZG93KG9uLCBldnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIG9uID8gdGhpcy5saXN0ZW5PbldpbmRvdyhldnROYW1lLCBoYW5kbGVyKSA6IHRoaXMubGlzdGVuT2ZmV2luZG93KGV2dE5hbWUsIGhhbmRsZXIpO1xuICAgICAgfSxcbiAgICAgIGxpc3Rlbk9uV2luZG93OiBmdW5jdGlvbiBsaXN0ZW5PbldpbmRvdyhldnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIgJiYgdGhpc1tQUk9QJDJdICYmIGlzU3RyaW5nKGV2dE5hbWUpICYmIGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgICAgICB0aGlzW1BST1AkMl1bZXZ0TmFtZV0gPSB0aGlzW1BST1AkMl1bZXZ0TmFtZV0gfHwgW107XG5cbiAgICAgICAgICBpZiAoIWFycmF5SW5jbHVkZXModGhpc1tQUk9QJDJdW2V2dE5hbWVdLCBoYW5kbGVyKSkge1xuICAgICAgICAgICAgdGhpc1tQUk9QJDJdW2V2dE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgICAgICAgICBldmVudE9uKHdpbmRvdywgZXZ0TmFtZSwgaGFuZGxlciwgRVZFTlRfT1BUSU9OU19OT19DQVBUVVJFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsaXN0ZW5PZmZXaW5kb3c6IGZ1bmN0aW9uIGxpc3Rlbk9mZldpbmRvdyhldnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIgJiYgdGhpc1tQUk9QJDJdICYmIGlzU3RyaW5nKGV2dE5hbWUpICYmIGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgICAgICBldmVudE9mZih3aW5kb3csIGV2dE5hbWUsIGhhbmRsZXIsIEVWRU5UX09QVElPTlNfTk9fQ0FQVFVSRSk7XG4gICAgICAgICAgdGhpc1tQUk9QJDJdW2V2dE5hbWVdID0gKHRoaXNbUFJPUCQyXVtldnROYW1lXSB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCAhPT0gaGFuZGxlcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBUaGlzIG1ldGhvZCByZXR1cm5zIGEgY29tcG9uZW50J3Mgc2NvcGVkIHN0eWxlIGF0dHJpYnV0ZSBuYW1lOiBgZGF0YS12LXh4eHh4eHhgXG4gIC8vIFRoZSBgX3Njb3BlSWRgIG9wdGlvbnMgcHJvcGVydHkgaXMgYWRkZWQgYnkgdnVlLWxvYWRlciB3aGVuIHVzaW5nIHNjb3BlZCBzdHlsZXNcbiAgLy8gYW5kIHdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgbm8gc2NvcGVkIHN0eWxlcyBhcmUgaW4gdXNlXG4gIHZhciBnZXRTY29wZUlkID0gZnVuY3Rpb24gZ2V0U2NvcGVJZCh2bSkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgcmV0dXJuIHZtID8gdm0uJG9wdGlvbnMuX3Njb3BlSWQgfHwgZGVmYXVsdFZhbHVlIDogZGVmYXVsdFZhbHVlO1xuICB9O1xuXG4gIHZhciBzY29wZWRTdHlsZUF0dHJzTWl4aW4gPSB7XG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIHNjb3BlZFN0eWxlQXR0cnM6IGZ1bmN0aW9uIHNjb3BlZFN0eWxlQXR0cnMoKSB7XG4gICAgICAgIHZhciBzY29wZUlkID0gZ2V0U2NvcGVJZCh0aGlzLiRwYXJlbnQpO1xuICAgICAgICByZXR1cm4gc2NvcGVJZCA/IF9kZWZpbmVQcm9wZXJ0eSh7fSwgc2NvcGVJZCwgJycpIDoge307XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIE1vZGFsTWFuYWdlciBoZWxwZXJcbiAgICogSGFuZGxlcyBjb250cm9sbGluZyBtb2RhbCBzdGFja2luZyB6SW5kZXhlcyBhbmQgYm9keSBhZGp1c3RtZW50cy9jbGFzc2VzXG4gICAqL1xuICAvLyBEZWZhdWx0IG1vZGFsIGJhY2tkcm9wIHotaW5kZXhcblxuICB2YXIgREVGQVVMVF9aSU5ERVggPSAxMDQwOyAvLyBTZWxlY3RvcnMgZm9yIHBhZGRpbmcvbWFyZ2luIGFkanVzdG1lbnRzXG5cbiAgdmFyIFNlbGVjdG9yJDEgPSB7XG4gICAgRklYRURfQ09OVEVOVDogJy5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3AnLFxuICAgIFNUSUNLWV9DT05URU5UOiAnLnN0aWNreS10b3AnLFxuICAgIE5BVkJBUl9UT0dHTEVSOiAnLm5hdmJhci10b2dnbGVyJ1xuICB9OyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBNb2RhbE1hbmFnZXIgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RhbHM6IFtdLFxuICAgICAgICBiYXNlWkluZGV4OiBudWxsLFxuICAgICAgICBzY3JvbGxiYXJXaWR0aDogbnVsbCxcbiAgICAgICAgaXNCb2R5T3ZlcmZsb3dpbmc6IGZhbHNlXG4gICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIG1vZGFsQ291bnQ6IGZ1bmN0aW9uIG1vZGFsQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGFscy5sZW5ndGg7XG4gICAgICB9LFxuICAgICAgbW9kYWxzQXJlT3BlbjogZnVuY3Rpb24gbW9kYWxzQXJlT3BlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kYWxDb3VudCA+IDA7XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgbW9kYWxDb3VudDogZnVuY3Rpb24gbW9kYWxDb3VudChuZXdDb3VudCwgb2xkQ291bnQpIHtcbiAgICAgICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICAgIHRoaXMuZ2V0U2Nyb2xsYmFyV2lkdGgoKTtcblxuICAgICAgICAgIGlmIChuZXdDb3VudCA+IDAgJiYgb2xkQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFRyYW5zaXRpb25pbmcgdG8gbW9kYWwocykgb3BlblxuICAgICAgICAgICAgdGhpcy5jaGVja1Njcm9sbGJhcigpO1xuICAgICAgICAgICAgdGhpcy5zZXRTY3JvbGxiYXIoKTtcbiAgICAgICAgICAgIGFkZENsYXNzKGRvY3VtZW50LmJvZHksICdtb2RhbC1vcGVuJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXdDb3VudCA9PT0gMCAmJiBvbGRDb3VudCA+IDApIHtcbiAgICAgICAgICAgIC8vIFRyYW5zaXRpb25pbmcgdG8gbW9kYWwocykgY2xvc2VkXG4gICAgICAgICAgICB0aGlzLnJlc2V0U2Nyb2xsYmFyKCk7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbW9kYWwtb3BlbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldEF0dHIoZG9jdW1lbnQuYm9keSwgJ2RhdGEtbW9kYWwtb3Blbi1jb3VudCcsIFN0cmluZyhuZXdDb3VudCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbW9kYWxzOiBmdW5jdGlvbiBtb2RhbHMobmV3VmFsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5jaGVja1Njcm9sbGJhcigpO1xuICAgICAgICByZXF1ZXN0QUYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnVwZGF0ZU1vZGFscyhuZXdWYWwgfHwgW10pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIC8vIFB1YmxpYyBtZXRob2RzXG4gICAgICByZWdpc3Rlck1vZGFsOiBmdW5jdGlvbiByZWdpc3Rlck1vZGFsKG1vZGFsKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBtb2RhbCBpZiBub3QgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICAgIGlmIChtb2RhbCAmJiB0aGlzLm1vZGFscy5pbmRleE9mKG1vZGFsKSA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBBZGQgbW9kYWwgdG8gbW9kYWxzIGFycmF5XG4gICAgICAgICAgdGhpcy5tb2RhbHMucHVzaChtb2RhbCk7XG4gICAgICAgICAgbW9kYWwuJG9uY2UoJ2hvb2s6YmVmb3JlRGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi51bnJlZ2lzdGVyTW9kYWwobW9kYWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdW5yZWdpc3Rlck1vZGFsOiBmdW5jdGlvbiB1bnJlZ2lzdGVyTW9kYWwobW9kYWwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5tb2RhbHMuaW5kZXhPZihtb2RhbCk7XG5cbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgbW9kYWwgZnJvbSBtb2RhbHMgYXJyYXlcbiAgICAgICAgICB0aGlzLm1vZGFscy5zcGxpY2UoaW5kZXgsIDEpOyAvLyBSZXNldCB0aGUgbW9kYWwncyBkYXRhXG5cbiAgICAgICAgICBpZiAoIShtb2RhbC5faXNCZWluZ0Rlc3Ryb3llZCB8fCBtb2RhbC5faXNEZXN0cm95ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0TW9kYWwobW9kYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldEJhc2VaSW5kZXg6IGZ1bmN0aW9uIGdldEJhc2VaSW5kZXgoKSB7XG4gICAgICAgIGlmIChpc051bGwodGhpcy5iYXNlWkluZGV4KSAmJiBpc0Jyb3dzZXIpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgYGRpdi5tb2RhbC1iYWNrZHJvcGAgdG8gZ2V0IGNvbXB1dGVkIHotaW5kZXhcbiAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgZGl2LmNsYXNzTmFtZSA9ICdtb2RhbC1iYWNrZHJvcCBkLW5vbmUnO1xuICAgICAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgICB0aGlzLmJhc2VaSW5kZXggPSB0b0ludGVnZXIoZ2V0Q1MoZGl2KS56SW5kZXggfHwgREVGQVVMVF9aSU5ERVgpO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VaSW5kZXggfHwgREVGQVVMVF9aSU5ERVg7XG4gICAgICB9LFxuICAgICAgZ2V0U2Nyb2xsYmFyV2lkdGg6IGZ1bmN0aW9uIGdldFNjcm9sbGJhcldpZHRoKCkge1xuICAgICAgICBpZiAoaXNOdWxsKHRoaXMuc2Nyb2xsYmFyV2lkdGgpICYmIGlzQnJvd3Nlcikge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBgZGl2Lm1lYXN1cmUtc2Nyb2xsYmFyYCB0byBnZXQgY29tcHV0ZWQgei1pbmRleFxuICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBkaXYuY2xhc3NOYW1lID0gJ21vZGFsLXNjcm9sbGJhci1tZWFzdXJlJztcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgICAgdGhpcy5zY3JvbGxiYXJXaWR0aCA9IGdldEJDUihkaXYpLndpZHRoIC0gZGl2LmNsaWVudFdpZHRoO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbGJhcldpZHRoIHx8IDA7XG4gICAgICB9LFxuICAgICAgLy8gUHJpdmF0ZSBtZXRob2RzXG4gICAgICB1cGRhdGVNb2RhbHM6IGZ1bmN0aW9uIHVwZGF0ZU1vZGFscyhtb2RhbHMpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGJhc2VaSW5kZXggPSB0aGlzLmdldEJhc2VaSW5kZXgoKTtcbiAgICAgICAgdmFyIHNjcm9sbGJhcldpZHRoID0gdGhpcy5nZXRTY3JvbGxiYXJXaWR0aCgpO1xuICAgICAgICBtb2RhbHMuZm9yRWFjaChmdW5jdGlvbiAobW9kYWwsIGluZGV4KSB7XG4gICAgICAgICAgLy8gV2UgdXBkYXRlIGRhdGEgdmFsdWVzIG9uIGVhY2ggbW9kYWxcbiAgICAgICAgICBtb2RhbC56SW5kZXggPSBiYXNlWkluZGV4ICsgaW5kZXg7XG4gICAgICAgICAgbW9kYWwuc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxiYXJXaWR0aDtcbiAgICAgICAgICBtb2RhbC5pc1RvcCA9IGluZGV4ID09PSBfdGhpczMubW9kYWxzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgbW9kYWwuaXNCb2R5T3ZlcmZsb3dpbmcgPSBfdGhpczMuaXNCb2R5T3ZlcmZsb3dpbmc7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHJlc2V0TW9kYWw6IGZ1bmN0aW9uIHJlc2V0TW9kYWwobW9kYWwpIHtcbiAgICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgICAgbW9kYWwuekluZGV4ID0gdGhpcy5nZXRCYXNlWkluZGV4KCk7XG4gICAgICAgICAgbW9kYWwuaXNUb3AgPSB0cnVlO1xuICAgICAgICAgIG1vZGFsLmlzQm9keU92ZXJmbG93aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjaGVja1Njcm9sbGJhcjogZnVuY3Rpb24gY2hlY2tTY3JvbGxiYXIoKSB7XG4gICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgYm9keSBlbGVtZW50IGlzIG92ZXJmbG93aW5nXG4gICAgICAgIHZhciBfZ2V0QkNSID0gZ2V0QkNSKGRvY3VtZW50LmJvZHkpLFxuICAgICAgICAgICAgbGVmdCA9IF9nZXRCQ1IubGVmdCxcbiAgICAgICAgICAgIHJpZ2h0ID0gX2dldEJDUi5yaWdodDtcblxuICAgICAgICB0aGlzLmlzQm9keU92ZXJmbG93aW5nID0gbGVmdCArIHJpZ2h0IDwgd2luZG93LmlubmVyV2lkdGg7XG4gICAgICB9LFxuICAgICAgc2V0U2Nyb2xsYmFyOiBmdW5jdGlvbiBzZXRTY3JvbGxiYXIoKSB7XG4gICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTsgLy8gU3RvcmFnZSBwbGFjZSB0byBjYWNoZSBjaGFuZ2VzIHRvIG1hcmdpbnMgYW5kIHBhZGRpbmdcbiAgICAgICAgLy8gTm90ZTogVGhpcyBhc3N1bWVzIHRoZSBmb2xsb3dpbmcgZWxlbWVudCB0eXBlcyBhcmUgbm90IGFkZGVkIHRvIHRoZVxuICAgICAgICAvLyBkb2N1bWVudCBhZnRlciB0aGUgbW9kYWwgaGFzIG9wZW5lZC5cblxuICAgICAgICBib2R5Ll9wYWRkaW5nQ2hhbmdlZEZvck1vZGFsID0gYm9keS5fcGFkZGluZ0NoYW5nZWRGb3JNb2RhbCB8fCBbXTtcbiAgICAgICAgYm9keS5fbWFyZ2luQ2hhbmdlZEZvck1vZGFsID0gYm9keS5fbWFyZ2luQ2hhbmdlZEZvck1vZGFsIHx8IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLmlzQm9keU92ZXJmbG93aW5nKSB7XG4gICAgICAgICAgdmFyIHNjcm9sbGJhcldpZHRoID0gdGhpcy5zY3JvbGxiYXJXaWR0aDsgLy8gQWRqdXN0IGZpeGVkIGNvbnRlbnQgcGFkZGluZ1xuXG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byB0ZXN0IGluIEpTRE9NICovXG5cbiAgICAgICAgICBzZWxlY3RBbGwoU2VsZWN0b3IkMS5GSVhFRF9DT05URU5UKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGFjdHVhbFBhZGRpbmcgPSBlbC5zdHlsZS5wYWRkaW5nUmlnaHQ7XG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlZFBhZGRpbmcgPSBnZXRDUyhlbCkucGFkZGluZ1JpZ2h0IHx8IDA7XG4gICAgICAgICAgICBzZXRBdHRyKGVsLCAnZGF0YS1wYWRkaW5nLXJpZ2h0JywgYWN0dWFsUGFkZGluZyk7XG4gICAgICAgICAgICBlbC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIlwiLmNvbmNhdCh0b0Zsb2F0KGNhbGN1bGF0ZWRQYWRkaW5nKSArIHNjcm9sbGJhcldpZHRoLCBcInB4XCIpO1xuXG4gICAgICAgICAgICBib2R5Ll9wYWRkaW5nQ2hhbmdlZEZvck1vZGFsLnB1c2goZWwpO1xuICAgICAgICAgIH0pOyAvLyBBZGp1c3Qgc3RpY2t5IGNvbnRlbnQgbWFyZ2luXG5cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIHRlc3QgaW4gSlNET00gKi9cblxuICAgICAgICAgIHNlbGVjdEFsbChTZWxlY3RvciQxLlNUSUNLWV9DT05URU5UKS5mb3JFYWNoKGZ1bmN0aW9uIChlbClcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBhY3R1YWxNYXJnaW4gPSBlbC5zdHlsZS5tYXJnaW5SaWdodDtcbiAgICAgICAgICAgIHZhciBjYWxjdWxhdGVkTWFyZ2luID0gZ2V0Q1MoZWwpLm1hcmdpblJpZ2h0IHx8IDA7XG4gICAgICAgICAgICBzZXRBdHRyKGVsLCAnZGF0YS1tYXJnaW4tcmlnaHQnLCBhY3R1YWxNYXJnaW4pO1xuICAgICAgICAgICAgZWwuc3R5bGUubWFyZ2luUmlnaHQgPSBcIlwiLmNvbmNhdCh0b0Zsb2F0KGNhbGN1bGF0ZWRNYXJnaW4pIC0gc2Nyb2xsYmFyV2lkdGgsIFwicHhcIik7XG5cbiAgICAgICAgICAgIGJvZHkuX21hcmdpbkNoYW5nZWRGb3JNb2RhbC5wdXNoKGVsKTtcbiAgICAgICAgICB9KTsgLy8gQWRqdXN0IDxiLW5hdmJhci10b2dnbGVyPiBtYXJnaW5cblxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gdGVzdCBpbiBKU0RPTSAqL1xuXG4gICAgICAgICAgc2VsZWN0QWxsKFNlbGVjdG9yJDEuTkFWQkFSX1RPR0dMRVIpLmZvckVhY2goZnVuY3Rpb24gKGVsKVxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGFjdHVhbE1hcmdpbiA9IGVsLnN0eWxlLm1hcmdpblJpZ2h0O1xuICAgICAgICAgICAgdmFyIGNhbGN1bGF0ZWRNYXJnaW4gPSBnZXRDUyhlbCkubWFyZ2luUmlnaHQgfHwgMDtcbiAgICAgICAgICAgIHNldEF0dHIoZWwsICdkYXRhLW1hcmdpbi1yaWdodCcsIGFjdHVhbE1hcmdpbik7XG4gICAgICAgICAgICBlbC5zdHlsZS5tYXJnaW5SaWdodCA9IFwiXCIuY29uY2F0KHRvRmxvYXQoY2FsY3VsYXRlZE1hcmdpbikgKyBzY3JvbGxiYXJXaWR0aCwgXCJweFwiKTtcblxuICAgICAgICAgICAgYm9keS5fbWFyZ2luQ2hhbmdlZEZvck1vZGFsLnB1c2goZWwpO1xuICAgICAgICAgIH0pOyAvLyBBZGp1c3QgYm9keSBwYWRkaW5nXG5cbiAgICAgICAgICB2YXIgYWN0dWFsUGFkZGluZyA9IGJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0O1xuICAgICAgICAgIHZhciBjYWxjdWxhdGVkUGFkZGluZyA9IGdldENTKGJvZHkpLnBhZGRpbmdSaWdodDtcbiAgICAgICAgICBzZXRBdHRyKGJvZHksICdkYXRhLXBhZGRpbmctcmlnaHQnLCBhY3R1YWxQYWRkaW5nKTtcbiAgICAgICAgICBib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IFwiXCIuY29uY2F0KHRvRmxvYXQoY2FsY3VsYXRlZFBhZGRpbmcpICsgc2Nyb2xsYmFyV2lkdGgsIFwicHhcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXNldFNjcm9sbGJhcjogZnVuY3Rpb24gcmVzZXRTY3JvbGxiYXIoKSB7XG4gICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcblxuICAgICAgICBpZiAoYm9keS5fcGFkZGluZ0NoYW5nZWRGb3JNb2RhbCkge1xuICAgICAgICAgIC8vIFJlc3RvcmUgZml4ZWQgY29udGVudCBwYWRkaW5nXG4gICAgICAgICAgYm9keS5fcGFkZGluZ0NoYW5nZWRGb3JNb2RhbC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byB0ZXN0IGluIEpTRE9NICovXG4gICAgICAgICAgICBpZiAoaGFzQXR0cihlbCwgJ2RhdGEtcGFkZGluZy1yaWdodCcpKSB7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLnBhZGRpbmdSaWdodCA9IGdldEF0dHIoZWwsICdkYXRhLXBhZGRpbmctcmlnaHQnKSB8fCAnJztcbiAgICAgICAgICAgICAgcmVtb3ZlQXR0cihlbCwgJ2RhdGEtcGFkZGluZy1yaWdodCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvZHkuX21hcmdpbkNoYW5nZWRGb3JNb2RhbCkge1xuICAgICAgICAgIC8vIFJlc3RvcmUgc3RpY2t5IGNvbnRlbnQgYW5kIG5hdmJhci10b2dnbGVyIG1hcmdpblxuICAgICAgICAgIGJvZHkuX21hcmdpbkNoYW5nZWRGb3JNb2RhbC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byB0ZXN0IGluIEpTRE9NICovXG4gICAgICAgICAgICBpZiAoaGFzQXR0cihlbCwgJ2RhdGEtbWFyZ2luLXJpZ2h0JykpIHtcbiAgICAgICAgICAgICAgZWwuc3R5bGUubWFyZ2luUmlnaHQgPSBnZXRBdHRyKGVsLCAnZGF0YS1tYXJnaW4tcmlnaHQnKSB8fCAnJztcbiAgICAgICAgICAgICAgcmVtb3ZlQXR0cihlbCwgJ2RhdGEtbWFyZ2luLXJpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBib2R5Ll9wYWRkaW5nQ2hhbmdlZEZvck1vZGFsID0gbnVsbDtcbiAgICAgICAgYm9keS5fbWFyZ2luQ2hhbmdlZEZvck1vZGFsID0gbnVsbDsgLy8gUmVzdG9yZSBib2R5IHBhZGRpbmdcblxuICAgICAgICBpZiAoaGFzQXR0cihib2R5LCAnZGF0YS1wYWRkaW5nLXJpZ2h0JykpIHtcbiAgICAgICAgICBib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IGdldEF0dHIoYm9keSwgJ2RhdGEtcGFkZGluZy1yaWdodCcpIHx8ICcnO1xuICAgICAgICAgIHJlbW92ZUF0dHIoYm9keSwgJ2RhdGEtcGFkZGluZy1yaWdodCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTsgLy8gQ3JlYXRlIGFuZCBleHBvcnQgb3VyIG1vZGFsIG1hbmFnZXIgaW5zdGFuY2VcblxuICB2YXIgbW9kYWxNYW5hZ2VyID0gbmV3IE1vZGFsTWFuYWdlcigpO1xuXG4gIHZhciBCdk1vZGFsRXZlbnQgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQnZFdmVudCkge1xuICAgIF9pbmhlcml0cyhCdk1vZGFsRXZlbnQsIF9CdkV2ZW50KTtcblxuICAgIGZ1bmN0aW9uIEJ2TW9kYWxFdmVudCh0eXBlKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIHZhciBldmVudEluaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnZNb2RhbEV2ZW50KTtcblxuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQnZNb2RhbEV2ZW50KS5jYWxsKHRoaXMsIHR5cGUsIGV2ZW50SW5pdCkpOyAvLyBGcmVlemUgb3VyIG5ldyBwcm9wcyBhcyByZWFkb25seSwgYnV0IGxlYXZlIHRoZW0gZW51bWVyYWJsZVxuXG4gICAgICBkZWZpbmVQcm9wZXJ0aWVzKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCB7XG4gICAgICAgIHRyaWdnZXI6IHJlYWRvbmx5RGVzY3JpcHRvcigpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQnZNb2RhbEV2ZW50LCBudWxsLCBbe1xuICAgICAga2V5OiBcIkRlZmF1bHRzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHt9LCBfZ2V0KF9nZXRQcm90b3R5cGVPZihCdk1vZGFsRXZlbnQpLCBcIkRlZmF1bHRzXCIsIHRoaXMpLCB7XG4gICAgICAgICAgdHJpZ2dlcjogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQnZNb2RhbEV2ZW50O1xuICB9KEJ2RXZlbnQpOyAvLyBOYW1lZCBleHBvcnRzXG5cbiAgdmFyIE5BTUUkbiA9ICdCTW9kYWwnOyAvLyBPYnNlcnZlRG9tIGNvbmZpZyB0byBkZXRlY3QgY2hhbmdlcyBpbiBtb2RhbCBjb250ZW50XG4gIC8vIHNvIHRoYXQgd2UgY2FuIGFkanVzdCB0aGUgbW9kYWwgcGFkZGluZyBpZiBuZWVkZWRcblxuICB2YXIgT0JTRVJWRVJfQ09ORklHID0ge1xuICAgIHN1YnRyZWU6IHRydWUsXG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVGaWx0ZXI6IFsnc3R5bGUnLCAnY2xhc3MnXVxuICB9OyAvLyBRdWVyeSBzZWxlY3RvciB0byBmaW5kIGFsbCB0YWJiYWJsZSBlbGVtZW50c1xuICAvLyAoaW5jbHVkZXMgdGFiaW5kZXg9XCItMVwiLCB3aGljaCB3ZSBmaWx0ZXIgb3V0IGFmdGVyKVxuXG4gIHZhciBUQUJBQkxFX1NFTEVDVE9SID0gWydidXR0b24nLCAnW2hyZWZdOm5vdCguZGlzYWJsZWQpJywgJ2lucHV0JywgJ3NlbGVjdCcsICd0ZXh0YXJlYScsICdbdGFiaW5kZXhdJywgJ1tjb250ZW50ZWRpdGFibGVdJ10ubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHMsIFwiOm5vdCg6ZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKVwiKTtcbiAgfSkuam9pbignLCAnKTsgLy8gLS0tIFV0aWxpdHkgbWV0aG9kcyAtLS1cbiAgLy8gQXR0ZW1wdCB0byBmb2N1cyBhbiBlbGVtZW50LCBhbmQgcmV0dXJuIHRydWUgaWYgc3VjY2Vzc2Z1bFxuXG4gIHZhciBhdHRlbXB0Rm9jdXMgPSBmdW5jdGlvbiBhdHRlbXB0Rm9jdXMoZWwpIHtcbiAgICBpZiAoZWwgJiYgaXNWaXNpYmxlKGVsKSAmJiBlbC5mb2N1cykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWwuZm9jdXMoKTtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHt9XG4gICAgfSAvLyBJZiB0aGUgZWxlbWVudCBoYXMgZm9jdXMsIHRoZW4gcmV0dXJuIHRydWVcblxuXG4gICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsO1xuICB9OyAvLyAtLS0gUHJvcHMgLS0tXG5cblxuICB2YXIgcHJvcHMkSCA9IHtcbiAgICBzaXplOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJG4sICdzaXplJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjZW50ZXJlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBzY3JvbGxhYmxlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGJ1dHRvblNpemU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfSxcbiAgICBub1N0YWNraW5nOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIG5vRmFkZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBub0Nsb3NlT25CYWNrZHJvcDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBub0Nsb3NlT25Fc2M6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgbm9FbmZvcmNlRm9jdXM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgaWdub3JlRW5mb3JjZUZvY3VzU2VsZWN0b3I6IHtcbiAgICAgIHR5cGU6IFtBcnJheSwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfSxcbiAgICB0aXRsZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJydcbiAgICB9LFxuICAgIHRpdGxlSHRtbDoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcbiAgICB0aXRsZVRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRuLCAndGl0bGVUYWcnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRpdGxlQ2xhc3M6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgdGl0bGVTck9ubHk6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgYXJpYUxhYmVsOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBoZWFkZXJCZ1ZhcmlhbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkbiwgJ2hlYWRlckJnVmFyaWFudCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGVhZGVyQm9yZGVyVmFyaWFudDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRuLCAnaGVhZGVyQm9yZGVyVmFyaWFudCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGVhZGVyVGV4dFZhcmlhbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkbiwgJ2hlYWRlclRleHRWYXJpYW50Jyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBoZWFkZXJDbG9zZVZhcmlhbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkbiwgJ2hlYWRlckNsb3NlVmFyaWFudCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGVhZGVyQ2xhc3M6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgYm9keUJnVmFyaWFudDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRuLCAnYm9keUJnVmFyaWFudCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYm9keVRleHRWYXJpYW50OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJG4sICdib2R5VGV4dFZhcmlhbnQnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vZGFsQ2xhc3M6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgZGlhbG9nQ2xhc3M6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgY29udGVudENsYXNzOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGJvZHlDbGFzczoge1xuICAgICAgdHlwZTogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBmb290ZXJCZ1ZhcmlhbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkbiwgJ2Zvb3RlckJnVmFyaWFudCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZm9vdGVyQm9yZGVyVmFyaWFudDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRuLCAnZm9vdGVyQm9yZGVyVmFyaWFudCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZm9vdGVyVGV4dFZhcmlhbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkbiwgJ2Zvb3RlclRleHRWYXJpYW50Jyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBmb290ZXJDbGFzczoge1xuICAgICAgdHlwZTogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBoaWRlSGVhZGVyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGhpZGVGb290ZXI6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgaGlkZUhlYWRlckNsb3NlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGhpZGVCYWNrZHJvcDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBva09ubHk6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgb2tEaXNhYmxlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBjYW5jZWxEaXNhYmxlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICB2aXNpYmxlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHJldHVybkZvY3VzOiB7XG4gICAgICAvLyBIVE1MIEVsZW1lbnQsIENTUyBzZWxlY3RvciBzdHJpbmcgb3IgVnVlIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgICAgdHlwZTogW0hUTUxFbGVtZW50LCBTdHJpbmcsIE9iamVjdF0sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBoZWFkZXJDbG9zZUNvbnRlbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkbiwgJ2hlYWRlckNsb3NlQ29udGVudCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGVhZGVyQ2xvc2VMYWJlbDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRuLCAnaGVhZGVyQ2xvc2VMYWJlbCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FuY2VsVGl0bGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkbiwgJ2NhbmNlbFRpdGxlJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYW5jZWxUaXRsZUh0bWw6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG4gICAgb2tUaXRsZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRuLCAnb2tUaXRsZScpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb2tUaXRsZUh0bWw6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG4gICAgY2FuY2VsVmFyaWFudDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRuLCAnY2FuY2VsVmFyaWFudCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb2tWYXJpYW50OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJG4sICdva1ZhcmlhbnQnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxhenk6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgYnVzeToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBzdGF0aWM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgYXV0b0ZvY3VzQnV0dG9uOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiB2YWxpZGF0b3IodmFsKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBpc1VuZGVmaW5lZE9yTnVsbCh2YWwpIHx8IGFycmF5SW5jbHVkZXMoWydvaycsICdjYW5jZWwnLCAnY2xvc2UnXSwgdmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJNb2RhbCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogTkFNRSRuLFxuICAgIG1peGluczogW2lkTWl4aW4sIGxpc3Rlbk9uRG9jdW1lbnRNaXhpbiwgbGlzdGVuT25Sb290TWl4aW4sIGxpc3Rlbk9uV2luZG93TWl4aW4sIG5vcm1hbGl6ZVNsb3RNaXhpbiwgc2NvcGVkU3R5bGVBdHRyc01peGluXSxcbiAgICBpbmhlcml0QXR0cnM6IGZhbHNlLFxuICAgIG1vZGVsOiB7XG4gICAgICBwcm9wOiAndmlzaWJsZScsXG4gICAgICBldmVudDogJ2NoYW5nZSdcbiAgICB9LFxuICAgIHByb3BzOiBwcm9wcyRILFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0hpZGRlbjogdHJ1ZSxcbiAgICAgICAgLy8gSWYgbW9kYWwgc2hvdWxkIG5vdCBiZSBpbiBkb2N1bWVudFxuICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAvLyBDb250cm9scyBtb2RhbCB2aXNpYmxlIHN0YXRlXG4gICAgICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2UsXG4gICAgICAgIC8vIFVzZWQgZm9yIHN0eWxlIGNvbnRyb2xcbiAgICAgICAgaXNTaG93OiBmYWxzZSxcbiAgICAgICAgLy8gVXNlZCBmb3Igc3R5bGUgY29udHJvbFxuICAgICAgICBpc0Jsb2NrOiBmYWxzZSxcbiAgICAgICAgLy8gVXNlZCBmb3Igc3R5bGUgY29udHJvbFxuICAgICAgICBpc09wZW5pbmc6IGZhbHNlLFxuICAgICAgICAvLyBUbyBzaWduYWwgdGhhdCB0aGUgbW9kYWwgaXMgaW4gdGhlIHByb2Nlc3Mgb2Ygb3BlbmluZ1xuICAgICAgICBpc0Nsb3Npbmc6IGZhbHNlLFxuICAgICAgICAvLyBUbyBzaWduYWwgdGhhdCB0aGUgbW9kYWwgaXMgaW4gdGhlIHByb2Nlc3Mgb2YgY2xvc2luZ1xuICAgICAgICBpZ25vcmVCYWNrZHJvcENsaWNrOiBmYWxzZSxcbiAgICAgICAgLy8gVXNlZCB0byBzaWduaWZ5IGlmIGNsaWNrIG91dCBsaXN0ZW5lciBzaG91bGQgaWdub3JlIHRoZSBjbGlja1xuICAgICAgICBpc01vZGFsT3ZlcmZsb3dpbmc6IGZhbHNlLFxuICAgICAgICByZXR1cm5fZm9jdXM6IHRoaXMucmV0dXJuRm9jdXMgfHwgbnVsbCxcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBpdGVtcyBhcmUgY29udHJvbGxlZCBieSB0aGUgbW9kYWxNYW5hZ2VyIGluc3RhbmNlXG4gICAgICAgIHNjcm9sbGJhcldpZHRoOiAwLFxuICAgICAgICB6SW5kZXg6IG1vZGFsTWFuYWdlci5nZXRCYXNlWkluZGV4KCksXG4gICAgICAgIGlzVG9wOiB0cnVlLFxuICAgICAgICBpc0JvZHlPdmVyZmxvd2luZzogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgbW9kYWxDbGFzc2VzOiBmdW5jdGlvbiBtb2RhbENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgIGZhZGU6ICF0aGlzLm5vRmFkZSxcbiAgICAgICAgICBzaG93OiB0aGlzLmlzU2hvd1xuICAgICAgICB9LCB0aGlzLm1vZGFsQ2xhc3NdO1xuICAgICAgfSxcbiAgICAgIG1vZGFsU3R5bGVzOiBmdW5jdGlvbiBtb2RhbFN0eWxlcygpIHtcbiAgICAgICAgdmFyIHNiV2lkdGggPSBcIlwiLmNvbmNhdCh0aGlzLnNjcm9sbGJhcldpZHRoLCBcInB4XCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0OiAhdGhpcy5pc0JvZHlPdmVyZmxvd2luZyAmJiB0aGlzLmlzTW9kYWxPdmVyZmxvd2luZyA/IHNiV2lkdGggOiAnJyxcbiAgICAgICAgICBwYWRkaW5nUmlnaHQ6IHRoaXMuaXNCb2R5T3ZlcmZsb3dpbmcgJiYgIXRoaXMuaXNNb2RhbE92ZXJmbG93aW5nID8gc2JXaWR0aCA6ICcnLFxuICAgICAgICAgIC8vIE5lZWRlZCB0byBmaXggaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL2Jvb3RzdHJhcC12dWUvYm9vdHN0cmFwLXZ1ZS9pc3N1ZXMvMzQ1N1xuICAgICAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlIGFyZSB1c2luZyB2LXNob3csIHdlIG11c3QgZW5zdXJlICdub25lJyBpcyByZXN0b3JlZCBpbiB0aGUgc3R5bGVzXG4gICAgICAgICAgZGlzcGxheTogdGhpcy5pc0Jsb2NrID8gJ2Jsb2NrJyA6ICdub25lJ1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGRpYWxvZ0NsYXNzZXM6IGZ1bmN0aW9uIGRpYWxvZ0NsYXNzZXMoKSB7XG4gICAgICAgIHZhciBfcmVmO1xuXG4gICAgICAgIHJldHVybiBbKF9yZWYgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9yZWYsIFwibW9kYWwtXCIuY29uY2F0KHRoaXMuc2l6ZSksIHRoaXMuc2l6ZSksIF9kZWZpbmVQcm9wZXJ0eShfcmVmLCAnbW9kYWwtZGlhbG9nLWNlbnRlcmVkJywgdGhpcy5jZW50ZXJlZCksIF9kZWZpbmVQcm9wZXJ0eShfcmVmLCAnbW9kYWwtZGlhbG9nLXNjcm9sbGFibGUnLCB0aGlzLnNjcm9sbGFibGUpLCBfcmVmKSwgdGhpcy5kaWFsb2dDbGFzc107XG4gICAgICB9LFxuICAgICAgaGVhZGVyQ2xhc3NlczogZnVuY3Rpb24gaGVhZGVyQ2xhc3NlcygpIHtcbiAgICAgICAgdmFyIF9yZWYyO1xuXG4gICAgICAgIHJldHVybiBbKF9yZWYyID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfcmVmMiwgXCJiZy1cIi5jb25jYXQodGhpcy5oZWFkZXJCZ1ZhcmlhbnQpLCB0aGlzLmhlYWRlckJnVmFyaWFudCksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMiwgXCJ0ZXh0LVwiLmNvbmNhdCh0aGlzLmhlYWRlclRleHRWYXJpYW50KSwgdGhpcy5oZWFkZXJUZXh0VmFyaWFudCksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMiwgXCJib3JkZXItXCIuY29uY2F0KHRoaXMuaGVhZGVyQm9yZGVyVmFyaWFudCksIHRoaXMuaGVhZGVyQm9yZGVyVmFyaWFudCksIF9yZWYyKSwgdGhpcy5oZWFkZXJDbGFzc107XG4gICAgICB9LFxuICAgICAgdGl0bGVDbGFzc2VzOiBmdW5jdGlvbiB0aXRsZUNsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICdzci1vbmx5JzogdGhpcy50aXRsZVNyT25seVxuICAgICAgICB9LCB0aGlzLnRpdGxlQ2xhc3NdO1xuICAgICAgfSxcbiAgICAgIGJvZHlDbGFzc2VzOiBmdW5jdGlvbiBib2R5Q2xhc3NlcygpIHtcbiAgICAgICAgdmFyIF9yZWYzO1xuXG4gICAgICAgIHJldHVybiBbKF9yZWYzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfcmVmMywgXCJiZy1cIi5jb25jYXQodGhpcy5ib2R5QmdWYXJpYW50KSwgdGhpcy5ib2R5QmdWYXJpYW50KSwgX2RlZmluZVByb3BlcnR5KF9yZWYzLCBcInRleHQtXCIuY29uY2F0KHRoaXMuYm9keVRleHRWYXJpYW50KSwgdGhpcy5ib2R5VGV4dFZhcmlhbnQpLCBfcmVmMyksIHRoaXMuYm9keUNsYXNzXTtcbiAgICAgIH0sXG4gICAgICBmb290ZXJDbGFzc2VzOiBmdW5jdGlvbiBmb290ZXJDbGFzc2VzKCkge1xuICAgICAgICB2YXIgX3JlZjQ7XG5cbiAgICAgICAgcmV0dXJuIFsoX3JlZjQgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9yZWY0LCBcImJnLVwiLmNvbmNhdCh0aGlzLmZvb3RlckJnVmFyaWFudCksIHRoaXMuZm9vdGVyQmdWYXJpYW50KSwgX2RlZmluZVByb3BlcnR5KF9yZWY0LCBcInRleHQtXCIuY29uY2F0KHRoaXMuZm9vdGVyVGV4dFZhcmlhbnQpLCB0aGlzLmZvb3RlclRleHRWYXJpYW50KSwgX2RlZmluZVByb3BlcnR5KF9yZWY0LCBcImJvcmRlci1cIi5jb25jYXQodGhpcy5mb290ZXJCb3JkZXJWYXJpYW50KSwgdGhpcy5mb290ZXJCb3JkZXJWYXJpYW50KSwgX3JlZjQpLCB0aGlzLmZvb3RlckNsYXNzXTtcbiAgICAgIH0sXG4gICAgICBtb2RhbE91dGVyU3R5bGU6IGZ1bmN0aW9uIG1vZGFsT3V0ZXJTdHlsZSgpIHtcbiAgICAgICAgLy8gU3R5bGVzIG5lZWRlZCBmb3IgcHJvcGVyIHN0YWNraW5nIG9mIG1vZGFsc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIHpJbmRleDogdGhpcy56SW5kZXhcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBzbG90U2NvcGU6IGZ1bmN0aW9uIHNsb3RTY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvazogdGhpcy5vbk9rLFxuICAgICAgICAgIGNhbmNlbDogdGhpcy5vbkNhbmNlbCxcbiAgICAgICAgICBjbG9zZTogdGhpcy5vbkNsb3NlLFxuICAgICAgICAgIGhpZGU6IHRoaXMuaGlkZSxcbiAgICAgICAgICB2aXNpYmxlOiB0aGlzLmlzVmlzaWJsZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVJZ25vcmVFbmZvcmNlRm9jdXNTZWxlY3RvcjogZnVuY3Rpb24gY29tcHV0ZUlnbm9yZUVuZm9yY2VGb2N1c1NlbGVjdG9yKCkge1xuICAgICAgICAvLyBOb3JtYWxpemUgdG8gYW4gc2luZ2xlIHNlbGVjdG9yIHdpdGggc2VsZWN0b3JzIHNlcGFyYXRlZCBieSBgLGBcbiAgICAgICAgcmV0dXJuIGNvbmNhdCh0aGlzLmlnbm9yZUVuZm9yY2VGb2N1c1NlbGVjdG9yKS5maWx0ZXIoaWRlbnRpdHkpLmpvaW4oJywnKS50cmltKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgdmlzaWJsZTogZnVuY3Rpb24gdmlzaWJsZShuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICBpZiAobmV3VmFsICE9PSBvbGRWYWwpIHtcbiAgICAgICAgICB0aGlzW25ld1ZhbCA/ICdzaG93JyA6ICdoaWRlJ10oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgIC8vIERlZmluZSBub24tcmVhY3RpdmUgcHJvcGVydGllc1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsO1xuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgIC8vIFNldCBpbml0aWFsIHotaW5kZXggYXMgcXVlcmllZCBmcm9tIHRoZSBET01cbiAgICAgIHRoaXMuekluZGV4ID0gbW9kYWxNYW5hZ2VyLmdldEJhc2VaSW5kZXgoKTsgLy8gTGlzdGVuIGZvciBldmVudHMgZnJvbSBvdGhlcnMgdG8gZWl0aGVyIG9wZW4gb3IgY2xvc2Ugb3Vyc2VsdmVzXG4gICAgICAvLyBhbmQgbGlzdGVuIHRvIGFsbCBtb2RhbHMgdG8gZW5hYmxlL2Rpc2FibGUgZW5mb3JjZSBmb2N1c1xuXG4gICAgICB0aGlzLmxpc3Rlbk9uUm9vdCgnYnY6OnNob3c6Om1vZGFsJywgdGhpcy5zaG93SGFuZGxlcik7XG4gICAgICB0aGlzLmxpc3Rlbk9uUm9vdCgnYnY6OmhpZGU6Om1vZGFsJywgdGhpcy5oaWRlSGFuZGxlcik7XG4gICAgICB0aGlzLmxpc3Rlbk9uUm9vdCgnYnY6OnRvZ2dsZTo6bW9kYWwnLCB0aGlzLnRvZ2dsZUhhbmRsZXIpOyAvLyBMaXN0ZW4gZm9yIGBidjptb2RhbDo6c2hvdyBldmVudHNgLCBhbmQgY2xvc2Ugb3Vyc2VsdmVzIGlmIHRoZVxuICAgICAgLy8gb3BlbmluZyBtb2RhbCBub3QgdXNcblxuICAgICAgdGhpcy5saXN0ZW5PblJvb3QoJ2J2Ojptb2RhbDo6c2hvdycsIHRoaXMubW9kYWxMaXN0ZW5lcik7IC8vIEluaXRpYWxseSBzaG93IG1vZGFsP1xuXG4gICAgICBpZiAodGhpcy52aXNpYmxlID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKHRoaXMuc2hvdyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgLy8gRW5zdXJlIGV2ZXJ5dGhpbmcgaXMgYmFjayB0byBub3JtYWxcbiAgICAgIGlmICh0aGlzLl9vYnNlcnZlcikge1xuICAgICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1Nob3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIC8vIFByaXZhdGUgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgdi1tb2RlbFxuICAgICAgdXBkYXRlTW9kZWw6IGZ1bmN0aW9uIHVwZGF0ZU1vZGVsKHZhbCkge1xuICAgICAgICBpZiAodmFsICE9PSB0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gUHJpdmF0ZSBtZXRob2QgdG8gY3JlYXRlIGEgQnZNb2RhbEV2ZW50IG9iamVjdFxuICAgICAgYnVpbGRFdmVudDogZnVuY3Rpb24gYnVpbGRFdmVudCh0eXBlKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdk1vZGFsRXZlbnQodHlwZSwgX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIC8vIERlZmF1bHQgb3B0aW9uc1xuICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICAgIHRhcmdldDogdGhpcy4kcmVmcy5tb2RhbCB8fCB0aGlzLiRlbCB8fCBudWxsLFxuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG51bGwsXG4gICAgICAgICAgdHJpZ2dlcjogbnVsbFxuICAgICAgICB9LCBvcHRpb25zLCB7XG4gICAgICAgICAgLy8gT3B0aW9ucyB0aGF0IGNhbid0IGJlIG92ZXJyaWRkZW5cbiAgICAgICAgICB2dWVUYXJnZXQ6IHRoaXMsXG4gICAgICAgICAgY29tcG9uZW50SWQ6IHRoaXMuc2FmZUlkKClcbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIC8vIFB1YmxpYyBtZXRob2QgdG8gc2hvdyBtb2RhbFxuICAgICAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlIHx8IHRoaXMuaXNPcGVuaW5nKSB7XG4gICAgICAgICAgLy8gSWYgYWxyZWFkeSBvcGVuLCBvciBpbiB0aGUgcHJvY2VzcyBvZiBvcGVuaW5nLCBkbyBub3RoaW5nXG5cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5cbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zaW5nKSB7XG4gICAgICAgICAgLy8gSWYgd2UgYXJlIGluIHRoZSBwcm9jZXNzIG9mIGNsb3NpbmcsIHdhaXQgdW50aWwgaGlkZGVuIGJlZm9yZSByZS1vcGVuaW5nXG5cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHRoaXMuJG9uY2UoJ2hpZGRlbicsIHRoaXMuc2hvdyk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNPcGVuaW5nID0gdHJ1ZTsgLy8gU2V0IHRoZSBlbGVtZW50IHRvIHJldHVybiBmb2N1cyB0byB3aGVuIGNsb3NlZFxuXG4gICAgICAgIHRoaXMucmV0dXJuX2ZvY3VzID0gdGhpcy5yZXR1cm5fZm9jdXMgfHwgdGhpcy5nZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgICAgIHZhciBzaG93RXZ0ID0gdGhpcy5idWlsZEV2ZW50KCdzaG93Jywge1xuICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KHNob3dFdnQpOyAvLyBEb24ndCBzaG93IGlmIGNhbmNlbGVkXG5cbiAgICAgICAgaWYgKHNob3dFdnQuZGVmYXVsdFByZXZlbnRlZCB8fCB0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgIHRoaXMuaXNPcGVuaW5nID0gZmFsc2U7IC8vIEVuc3VyZSB0aGUgdi1tb2RlbCByZWZsZWN0cyB0aGUgY3VycmVudCBzdGF0ZVxuXG4gICAgICAgICAgdGhpcy51cGRhdGVNb2RlbChmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFNob3cgdGhlIG1vZGFsXG5cblxuICAgICAgICB0aGlzLmRvU2hvdygpO1xuICAgICAgfSxcbiAgICAgIC8vIFB1YmxpYyBtZXRob2QgdG8gaGlkZSBtb2RhbFxuICAgICAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgICAgdmFyIHRyaWdnZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuXG4gICAgICAgIGlmICghdGhpcy5pc1Zpc2libGUgfHwgdGhpcy5pc0Nsb3NpbmcpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNDbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgdmFyIGhpZGVFdnQgPSB0aGlzLmJ1aWxkRXZlbnQoJ2hpZGUnLCB7XG4gICAgICAgICAgY2FuY2VsYWJsZTogdHJpZ2dlciAhPT0gJ0ZPUkNFJyxcbiAgICAgICAgICB0cmlnZ2VyOiB0cmlnZ2VyIHx8IG51bGxcbiAgICAgICAgfSk7IC8vIFdlIGVtaXQgc3BlY2lmaWMgZXZlbnQgZm9yIG9uZSBvZiB0aGUgdGhyZWUgYnVpbHQtaW4gYnV0dG9uc1xuXG4gICAgICAgIGlmICh0cmlnZ2VyID09PSAnb2snKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgnb2snLCBoaWRlRXZ0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyID09PSAnY2FuY2VsJykge1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ2NhbmNlbCcsIGhpZGVFdnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgPT09ICdoZWFkZXJjbG9zZScpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdjbG9zZScsIGhpZGVFdnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoaGlkZUV2dCk7IC8vIEhpZGUgaWYgbm90IGNhbmNlbGVkXG5cbiAgICAgICAgaWYgKGhpZGVFdnQuZGVmYXVsdFByZXZlbnRlZCB8fCAhdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICB0aGlzLmlzQ2xvc2luZyA9IGZhbHNlOyAvLyBFbnN1cmUgdi1tb2RlbCByZWZsZWN0cyBjdXJyZW50IHN0YXRlXG5cbiAgICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsKHRydWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9wIG9ic2VydmluZyBmb3IgY29udGVudCBjaGFuZ2VzXG5cblxuICAgICAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XG4gICAgICAgIH0gLy8gVHJpZ2dlciB0aGUgaGlkZSB0cmFuc2l0aW9uXG5cblxuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlOyAvLyBVcGRhdGUgdGhlIHYtbW9kZWxcblxuICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsKGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICAvLyBQdWJsaWMgbWV0aG9kIHRvIHRvZ2dsZSBtb2RhbCB2aXNpYmlsaXR5XG4gICAgICB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZSh0cmlnZ2VyRWwpIHtcbiAgICAgICAgaWYgKHRyaWdnZXJFbCkge1xuICAgICAgICAgIHRoaXMucmV0dXJuX2ZvY3VzID0gdHJpZ2dlckVsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgdGhpcy5oaWRlKCd0b2dnbGUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFByaXZhdGUgbWV0aG9kIHRvIGdldCB0aGUgY3VycmVudCBkb2N1bWVudCBhY3RpdmUgZWxlbWVudFxuICAgICAgZ2V0QWN0aXZlRWxlbWVudDogZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudCgpIHtcbiAgICAgICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDsgLy8gTm90ZTogT24gSUUgMTEsIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBtYXkgYmUgbnVsbC5cbiAgICAgICAgICAvLyBTbyB3ZSB0ZXN0IGl0IGZvciB0cnV0aGluZXNzIGZpcnN0LlxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ib290c3RyYXAtdnVlL2Jvb3RzdHJhcC12dWUvaXNzdWVzLzMyMDZcbiAgICAgICAgICAvLyBSZXR1cm5pbmcgZm9jdXMgdG8gZG9jdW1lbnQuYm9keSBtYXkgY2F1c2UgdW53YW50ZWQgc2Nyb2xscywgc28gd2VcbiAgICAgICAgICAvLyBleGNsdWRlIHNldHRpbmcgZm9jdXMgb24gYm9keVxuXG4gICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBhY3RpdmVFbGVtZW50LmZvY3VzKSB7XG4gICAgICAgICAgICAvLyBQcmVzZXQgdGhlIGZhbGxiYWNrIHJldHVybiBmb2N1cyB2YWx1ZSBpZiBpdCBpcyBub3Qgc2V0XG4gICAgICAgICAgICAvLyBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgc2hvdWxkIGJlIHRoZSB0cmlnZ2VyIGVsZW1lbnQgdGhhdCB3YXMgY2xpY2tlZCBvclxuICAgICAgICAgICAgLy8gaW4gdGhlIGNhc2Ugb2YgdXNpbmcgdGhlIHYtbW9kZWwsIHdoaWNoIGV2ZXIgZWxlbWVudCBoYXMgY3VycmVudCBmb2N1c1xuICAgICAgICAgICAgLy8gV2lsbCBiZSBvdmVycmlkZGVuIGJ5IHNvbWUgY29tbWFuZHMgc3VjaCBhcyB0b2dnbGUsIGV0Yy5cbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIC8vIFByaXZhdGUgbWV0aG9kIHRvIGdldCBhIGxpc3Qgb2YgYWxsIHRhYmFibGUgZWxlbWVudHMgd2l0aGluIG1vZGFsIGNvbnRlbnRcbiAgICAgIGdldFRhYmFibGVzOiBmdW5jdGlvbiBnZXRUYWJhYmxlcygpIHtcbiAgICAgICAgLy8gRmluZCBhbGwgdGFiYWJsZSBlbGVtZW50cyBpbiB0aGUgbW9kYWwgY29udGVudFxuICAgICAgICAvLyBBc3N1bWVzIHVzZXJzIGhhdmUgbm90IHVzZWQgdGFiaW5kZXggPiAwIG9uIGVsZW1lbnRzIVxuICAgICAgICByZXR1cm4gc2VsZWN0QWxsKFRBQkFCTEVfU0VMRUNUT1IsIHRoaXMuJHJlZnMuY29udGVudCkuZmlsdGVyKGlzVmlzaWJsZSkuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuIGkudGFiSW5kZXggPiAtMSAmJiAhaS5kaXNhYmxlZDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgLy8gUHJpdmF0ZSBtZXRob2QgdG8gZmluaXNoIHNob3dpbmcgbW9kYWxcbiAgICAgIGRvU2hvdzogZnVuY3Rpb24gZG9TaG93KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBjb21tZW50aW5nIG91dCBmb3Igbm93IHVudGlsIHdlIGNhbiB0ZXN0IHN0YWNraW5nICovXG4gICAgICAgIGlmIChtb2RhbE1hbmFnZXIubW9kYWxzQXJlT3BlbiAmJiB0aGlzLm5vU3RhY2tpbmcpIHtcbiAgICAgICAgICAvLyBJZiBhbm90aGVyIG1vZGFsKHMpIGlzIGFscmVhZHkgb3Blbiwgd2FpdCBmb3IgaXQodGhlbSkgdG8gY2xvc2VcbiAgICAgICAgICB0aGlzLmxpc3Rlbk9uUm9vdE9uY2UoJ2J2Ojptb2RhbDo6aGlkZGVuJywgdGhpcy5kb1Nob3cpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZGFsTWFuYWdlci5yZWdpc3Rlck1vZGFsKHRoaXMpOyAvLyBQbGFjZSBtb2RhbCBpbiBET01cblxuICAgICAgICB0aGlzLmlzSGlkZGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSBkbyB0aGlzIGluIGAkbmV4dFRpY2soKWAgdG8gZW5zdXJlIHRoZSBtb2RhbCBpcyBpbiBET00gZmlyc3RcbiAgICAgICAgICAvLyBiZWZvcmUgd2Ugc2hvdyBpdFxuICAgICAgICAgIF90aGlzLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgX3RoaXMuaXNPcGVuaW5nID0gZmFsc2U7IC8vIFVwZGF0ZSB0aGUgdi1tb2RlbFxuXG4gICAgICAgICAgX3RoaXMudXBkYXRlTW9kZWwodHJ1ZSk7XG5cbiAgICAgICAgICBfdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gSW4gYSBuZXh0VGljayBpbiBjYXNlIG1vZGFsIGNvbnRlbnQgaXMgbGF6eVxuICAgICAgICAgICAgLy8gT2JzZXJ2ZSBjaGFuZ2VzIGluIG1vZGFsIGNvbnRlbnQgYW5kIGFkanVzdCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIF90aGlzLl9vYnNlcnZlciA9IG9ic2VydmVEb20oX3RoaXMuJHJlZnMuY29udGVudCwgX3RoaXMuY2hlY2tNb2RhbE92ZXJmbG93LmJpbmQoX3RoaXMpLCBPQlNFUlZFUl9DT05GSUcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAvLyBUcmFuc2l0aW9uIGhhbmRsZXJzXG4gICAgICBvbkJlZm9yZUVudGVyOiBmdW5jdGlvbiBvbkJlZm9yZUVudGVyKCkge1xuICAgICAgICB0aGlzLmlzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0UmVzaXplRXZlbnQodHJ1ZSk7XG4gICAgICB9LFxuICAgICAgb25FbnRlcjogZnVuY3Rpb24gb25FbnRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5pc0Jsb2NrID0gdHJ1ZTsgLy8gV2UgYWRkIHRoZSBgc2hvd2AgY2xhc3MgMSBmcmFtZSBsYXRlclxuICAgICAgICAvLyBgcmVxdWVzdEFGKClgIHJ1bnMgdGhlIGNhbGxiYWNrIGJlZm9yZSB0aGUgbmV4dCByZXBhaW50LCBzbyB3ZSBuZWVkXG4gICAgICAgIC8vIHR3byBjYWxscyB0byBndWFyYW50ZWUgdGhlIG5leHQgZnJhbWUgaGFzIGJlZW4gcmVuZGVyZWRcblxuICAgICAgICByZXF1ZXN0QUYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlcXVlc3RBRihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuaXNTaG93ID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25BZnRlckVudGVyOiBmdW5jdGlvbiBvbkFmdGVyRW50ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuY2hlY2tNb2RhbE92ZXJmbG93KCk7XG4gICAgICAgIHRoaXMuaXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7IC8vIFdlIHVzZSBgcmVxdWVzdEFGKClgIHRvIGFsbG93IHRyYW5zaXRpb24gaG9va3MgdG8gY29tcGxldGVcbiAgICAgICAgLy8gYmVmb3JlIHBhc3NpbmcgY29udHJvbCBvdmVyIHRvIHRoZSBvdGhlciBoYW5kbGVyc1xuICAgICAgICAvLyBUaGlzIHdpbGwgYWxsb3cgdXNlcnMgdG8gbm90IGhhdmUgdG8gdXNlIGAkbmV4dFRpY2soKWAgb3IgYHJlcXVlc3RBRigpYFxuICAgICAgICAvLyB3aGVuIHRyeWluZyB0byBwcmUtZm9jdXMgYW4gZWxlbWVudFxuXG4gICAgICAgIHJlcXVlc3RBRihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMzLmVtaXRFdmVudChfdGhpczMuYnVpbGRFdmVudCgnc2hvd24nKSk7XG5cbiAgICAgICAgICBfdGhpczMuc2V0RW5mb3JjZUZvY3VzKHRydWUpO1xuXG4gICAgICAgICAgX3RoaXMzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBEZWxheWVkIGluIGEgYCRuZXh0VGljaygpYCB0byBhbGxvdyB1c2VycyB0aW1lIHRvIHByZS1mb2N1c1xuICAgICAgICAgICAgLy8gYW4gZWxlbWVudCBpZiB0aGUgd2lzaFxuICAgICAgICAgICAgX3RoaXMzLmZvY3VzRmlyc3QoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25CZWZvcmVMZWF2ZTogZnVuY3Rpb24gb25CZWZvcmVMZWF2ZSgpIHtcbiAgICAgICAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldFJlc2l6ZUV2ZW50KGZhbHNlKTtcbiAgICAgICAgdGhpcy5zZXRFbmZvcmNlRm9jdXMoZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIG9uTGVhdmU6IGZ1bmN0aW9uIG9uTGVhdmUoKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgJ3Nob3cnIGNsYXNzXG4gICAgICAgIHRoaXMuaXNTaG93ID0gZmFsc2U7XG4gICAgICB9LFxuICAgICAgb25BZnRlckxlYXZlOiBmdW5jdGlvbiBvbkFmdGVyTGVhdmUoKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuaXNCbG9jayA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzTW9kYWxPdmVyZmxvd2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNC5pc0Nsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICBtb2RhbE1hbmFnZXIudW5yZWdpc3Rlck1vZGFsKF90aGlzNCk7XG5cbiAgICAgICAgICBfdGhpczQucmV0dXJuRm9jdXNUbygpOyAvLyBUT0RPOiBOZWVkIHRvIGZpbmQgYSB3YXkgdG8gcGFzcyB0aGUgYHRyaWdnZXJgIHByb3BlcnR5XG4gICAgICAgICAgLy8gICAgICAgdG8gdGhlIGBoaWRkZW5gIGV2ZW50LCBub3QganVzdCBvbmx5IHRoZSBgaGlkZWAgZXZlbnRcblxuXG4gICAgICAgICAgX3RoaXM0LmVtaXRFdmVudChfdGhpczQuYnVpbGRFdmVudCgnaGlkZGVuJykpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAvLyBFdmVudCBlbWl0dGVyXG4gICAgICBlbWl0RXZlbnQ6IGZ1bmN0aW9uIGVtaXRFdmVudChidk1vZGFsRXZ0KSB7XG4gICAgICAgIHZhciB0eXBlID0gYnZNb2RhbEV2dC50eXBlOyAvLyBXZSBlbWl0IG9uIHJvb3QgZmlyc3QgaW5jYXNlIGEgZ2xvYmFsIGxpc3RlbmVyIHdhbnRzIHRvIGNhbmNlbFxuICAgICAgICAvLyB0aGUgZXZlbnQgZmlyc3QgYmVmb3JlIHRoZSBpbnN0YW5jZSBlbWl0cyBpdHMgZXZlbnRcblxuICAgICAgICB0aGlzLmVtaXRPblJvb3QoXCJidjo6bW9kYWw6OlwiLmNvbmNhdCh0eXBlKSwgYnZNb2RhbEV2dCwgYnZNb2RhbEV2dC5jb21wb25lbnRJZCk7XG4gICAgICAgIHRoaXMuJGVtaXQodHlwZSwgYnZNb2RhbEV2dCk7XG4gICAgICB9LFxuICAgICAgLy8gVUkgZXZlbnQgaGFuZGxlcnNcbiAgICAgIG9uRGlhbG9nTW91c2Vkb3duOiBmdW5jdGlvbiBvbkRpYWxvZ01vdXNlZG93bigpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgLy8gV2F0Y2ggdG8gc2VlIGlmIHRoZSBtYXRjaGluZyBtb3VzZXVwIGV2ZW50IG9jY3VycyBvdXRzaWRlIHRoZSBkaWFsb2dcbiAgICAgICAgLy8gQW5kIGlmIGl0IGRvZXMsIGNhbmNlbCB0aGUgY2xpY2tPdXQgaGFuZGxlclxuICAgICAgICB2YXIgbW9kYWwgPSB0aGlzLiRyZWZzLm1vZGFsO1xuXG4gICAgICAgIHZhciBvbmNlTW9kYWxNb3VzZXVwID0gZnVuY3Rpb24gb25jZU1vZGFsTW91c2V1cChldnQpIHtcbiAgICAgICAgICBldmVudE9mZihtb2RhbCwgJ21vdXNldXAnLCBvbmNlTW9kYWxNb3VzZXVwLCBFVkVOVF9PUFRJT05TX05PX0NBUFRVUkUpO1xuXG4gICAgICAgICAgaWYgKGV2dC50YXJnZXQgPT09IG1vZGFsKSB7XG4gICAgICAgICAgICBfdGhpczUuaWdub3JlQmFja2Ryb3BDbGljayA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGV2ZW50T24obW9kYWwsICdtb3VzZXVwJywgb25jZU1vZGFsTW91c2V1cCwgRVZFTlRfT1BUSU9OU19OT19DQVBUVVJFKTtcbiAgICAgIH0sXG4gICAgICBvbkNsaWNrT3V0OiBmdW5jdGlvbiBvbkNsaWNrT3V0KGV2dCkge1xuICAgICAgICBpZiAodGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgICAgLy8gQ2xpY2sgd2FzIGluaXRpYXRlZCBpbnNpZGUgdGhlIG1vZGFsIGNvbnRlbnQsIGJ1dCBmaW5pc2hlZCBvdXRzaWRlLlxuICAgICAgICAgIC8vIFNldCBieSB0aGUgYWJvdmUgb25EaWFsb2dNb3VzZWRvd24gaGFuZGxlclxuICAgICAgICAgIHRoaXMuaWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBEbyBub3RoaW5nIGlmIG5vdCB2aXNpYmxlLCBiYWNrZHJvcCBjbGljayBkaXNhYmxlZCwgb3IgZWxlbWVudFxuICAgICAgICAvLyB0aGF0IGdlbmVyYXRlZCBjbGljayBldmVudCBpcyBubyBsb25nZXIgaW4gZG9jdW1lbnQgYm9keVxuXG5cbiAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSB8fCB0aGlzLm5vQ2xvc2VPbkJhY2tkcm9wIHx8ICFjb250YWlucyhkb2N1bWVudC5ib2R5LCBldnQudGFyZ2V0KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBJZiBiYWNrZHJvcCBjbGlja2VkLCBoaWRlIG1vZGFsXG5cblxuICAgICAgICBpZiAoIWNvbnRhaW5zKHRoaXMuJHJlZnMuY29udGVudCwgZXZ0LnRhcmdldCkpIHtcbiAgICAgICAgICB0aGlzLmhpZGUoJ2JhY2tkcm9wJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbk9rOiBmdW5jdGlvbiBvbk9rKCkge1xuICAgICAgICB0aGlzLmhpZGUoJ29rJyk7XG4gICAgICB9LFxuICAgICAgb25DYW5jZWw6IGZ1bmN0aW9uIG9uQ2FuY2VsKCkge1xuICAgICAgICB0aGlzLmhpZGUoJ2NhbmNlbCcpO1xuICAgICAgfSxcbiAgICAgIG9uQ2xvc2U6IGZ1bmN0aW9uIG9uQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuaGlkZSgnaGVhZGVyY2xvc2UnKTtcbiAgICAgIH0sXG4gICAgICBvbkVzYzogZnVuY3Rpb24gb25Fc2MoZXZ0KSB7XG4gICAgICAgIC8vIElmIEVTQyBwcmVzc2VkLCBoaWRlIG1vZGFsXG4gICAgICAgIGlmIChldnQua2V5Q29kZSA9PT0gS0VZX0NPREVTLkVTQyAmJiB0aGlzLmlzVmlzaWJsZSAmJiAhdGhpcy5ub0Nsb3NlT25Fc2MpIHtcbiAgICAgICAgICB0aGlzLmhpZGUoJ2VzYycpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gRG9jdW1lbnQgZm9jdXNpbiBsaXN0ZW5lclxuICAgICAgZm9jdXNIYW5kbGVyOiBmdW5jdGlvbiBmb2N1c0hhbmRsZXIoZXZ0KSB7XG4gICAgICAgIC8vIElmIGZvY3VzIGxlYXZlcyBtb2RhbCBjb250ZW50LCBicmluZyBpdCBiYWNrXG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy4kcmVmcy5jb250ZW50O1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZXZ0LnRhcmdldDtcblxuICAgICAgICBpZiAodGhpcy5ub0VuZm9yY2VGb2N1cyB8fCAhdGhpcy5pc1RvcCB8fCAhdGhpcy5pc1Zpc2libGUgfHwgIWNvbnRlbnQgfHwgZG9jdW1lbnQgPT09IHRhcmdldCB8fCBjb250YWlucyhjb250ZW50LCB0YXJnZXQpIHx8IHRoaXMuY29tcHV0ZUlnbm9yZUVuZm9yY2VGb2N1c1NlbGVjdG9yICYmIGNsb3Nlc3QodGhpcy5jb21wdXRlSWdub3JlRW5mb3JjZUZvY3VzU2VsZWN0b3IsIHRhcmdldCwgdHJ1ZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGFiYWJsZXMgPSB0aGlzLmdldFRhYmFibGVzKCk7XG4gICAgICAgIHZhciBfdGhpcyQkcmVmcyA9IHRoaXMuJHJlZnMsXG4gICAgICAgICAgICBib3R0b21UcmFwID0gX3RoaXMkJHJlZnMuYm90dG9tVHJhcCxcbiAgICAgICAgICAgIHRvcFRyYXAgPSBfdGhpcyQkcmVmcy50b3BUcmFwO1xuXG4gICAgICAgIGlmIChib3R0b21UcmFwICYmIHRhcmdldCA9PT0gYm90dG9tVHJhcCkge1xuICAgICAgICAgIC8vIElmIHVzZXIgcHJlc3NlZCBUQUIgb3V0IG9mIG1vZGFsIGludG8gb3VyIGJvdHRvbSB0cmFiIHRyYXAgZWxlbWVudFxuICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IHRhYmFibGUgZWxlbWVudCBpbiB0aGUgbW9kYWwgY29udGVudCBhbmQgZm9jdXMgaXRcbiAgICAgICAgICBpZiAoYXR0ZW1wdEZvY3VzKHRhYmFibGVzWzBdKSkge1xuICAgICAgICAgICAgLy8gRm9jdXMgd2FzIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodG9wVHJhcCAmJiB0YXJnZXQgPT09IHRvcFRyYXApIHtcbiAgICAgICAgICAvLyBJZiB1c2VyIHByZXNzZWQgQ1RSTC1UQUIgb3V0IG9mIG1vZGFsIGFuZCBpbnRvIG91ciB0b3AgdGFiIHRyYXAgZWxlbWVudFxuICAgICAgICAgIC8vIEZpbmQgdGhlIGxhc3QgdGFiYWJsZSBlbGVtZW50IGluIHRoZSBtb2RhbCBjb250ZW50IGFuZCBmb2N1cyBpdFxuICAgICAgICAgIGlmIChhdHRlbXB0Rm9jdXModGFiYWJsZXNbdGFiYWJsZXMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAvLyBGb2N1cyB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBPdGhlcndpc2UgZm9jdXMgdGhlIG1vZGFsIGNvbnRlbnQgY29udGFpbmVyXG5cblxuICAgICAgICBjb250ZW50LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIC8vIFR1cm4gb24vb2ZmIGZvY3VzaW4gbGlzdGVuZXJcbiAgICAgIHNldEVuZm9yY2VGb2N1czogZnVuY3Rpb24gc2V0RW5mb3JjZUZvY3VzKG9uKSB7XG4gICAgICAgIHRoaXMubGlzdGVuRG9jdW1lbnQob24sICdmb2N1c2luJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xuICAgICAgfSxcbiAgICAgIC8vIFJlc2l6ZSBsaXN0ZW5lclxuICAgICAgc2V0UmVzaXplRXZlbnQ6IGZ1bmN0aW9uIHNldFJlc2l6ZUV2ZW50KG9uKSB7XG4gICAgICAgIHRoaXMubGlzdGVuV2luZG93KG9uLCAncmVzaXplJywgdGhpcy5jaGVja01vZGFsT3ZlcmZsb3cpO1xuICAgICAgICB0aGlzLmxpc3RlbldpbmRvdyhvbiwgJ29yaWVudGF0aW9uY2hhbmdlJywgdGhpcy5jaGVja01vZGFsT3ZlcmZsb3cpO1xuICAgICAgfSxcbiAgICAgIC8vIFJvb3QgbGlzdGVuZXIgaGFuZGxlcnNcbiAgICAgIHNob3dIYW5kbGVyOiBmdW5jdGlvbiBzaG93SGFuZGxlcihpZCwgdHJpZ2dlckVsKSB7XG4gICAgICAgIGlmIChpZCA9PT0gdGhpcy5zYWZlSWQoKSkge1xuICAgICAgICAgIHRoaXMucmV0dXJuX2ZvY3VzID0gdHJpZ2dlckVsIHx8IHRoaXMuZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGlkZUhhbmRsZXI6IGZ1bmN0aW9uIGhpZGVIYW5kbGVyKGlkKSB7XG4gICAgICAgIGlmIChpZCA9PT0gdGhpcy5zYWZlSWQoKSkge1xuICAgICAgICAgIHRoaXMuaGlkZSgnZXZlbnQnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZUhhbmRsZXI6IGZ1bmN0aW9uIHRvZ2dsZUhhbmRsZXIoaWQsIHRyaWdnZXJFbCkge1xuICAgICAgICBpZiAoaWQgPT09IHRoaXMuc2FmZUlkKCkpIHtcbiAgICAgICAgICB0aGlzLnRvZ2dsZSh0cmlnZ2VyRWwpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbW9kYWxMaXN0ZW5lcjogZnVuY3Rpb24gbW9kYWxMaXN0ZW5lcihidkV2dCkge1xuICAgICAgICAvLyBJZiBhbm90aGVyIG1vZGFsIG9wZW5zLCBjbG9zZSB0aGlzIG9uZSBpZiBzdGFja2luZyBub3QgcGVybWl0dGVkXG4gICAgICAgIGlmICh0aGlzLm5vU3RhY2tpbmcgJiYgYnZFdnQudnVlVGFyZ2V0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBGb2N1cyBjb250cm9sIGhhbmRsZXJzXG4gICAgICBmb2N1c0ZpcnN0OiBmdW5jdGlvbiBmb2N1c0ZpcnN0KCkge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICAvLyBEb24ndCB0cnkgYW5kIGZvY3VzIGlmIHdlIGFyZSBTU1JcbiAgICAgICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICAgIHJlcXVlc3RBRihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbW9kYWwgPSBfdGhpczYuJHJlZnMubW9kYWw7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IF90aGlzNi4kcmVmcy5jb250ZW50O1xuXG4gICAgICAgICAgICB2YXIgYWN0aXZlRWxlbWVudCA9IF90aGlzNi5nZXRBY3RpdmVFbGVtZW50KCk7IC8vIElmIHRoZSBtb2RhbCBjb250YWlucyB0aGUgYWN0aXZlRWxlbWVudCwgd2UgZG9uJ3QgZG8gYW55dGhpbmdcblxuXG4gICAgICAgICAgICBpZiAobW9kYWwgJiYgY29udGVudCAmJiAhKGFjdGl2ZUVsZW1lbnQgJiYgY29udGFpbnMoY29udGVudCwgYWN0aXZlRWxlbWVudCkpKSB7XG4gICAgICAgICAgICAgIHZhciBvayA9IF90aGlzNi4kcmVmc1snb2stYnV0dG9uJ107XG4gICAgICAgICAgICAgIHZhciBjYW5jZWwgPSBfdGhpczYuJHJlZnNbJ2NhbmNlbC1idXR0b24nXTtcbiAgICAgICAgICAgICAgdmFyIGNsb3NlID0gX3RoaXM2LiRyZWZzWydjbG9zZS1idXR0b24nXTsgLy8gRm9jdXMgdGhlIGFwcHJvcHJpYXRlIGJ1dHRvbiBvciBtb2RhbCBjb250ZW50IHdyYXBwZXJcblxuICAgICAgICAgICAgICB2YXIgYXV0b0ZvY3VzID0gX3RoaXM2LmF1dG9Gb2N1c0J1dHRvbjtcbiAgICAgICAgICAgICAgdmFyIGVsID0gYXV0b0ZvY3VzID09PSAnb2snICYmIG9rID8gb2suJGVsIHx8IG9rIDogYXV0b0ZvY3VzID09PSAnY2FuY2VsJyAmJiBjYW5jZWwgPyBjYW5jZWwuJGVsIHx8IGNhbmNlbCA6IGF1dG9Gb2N1cyA9PT0gJ2Nsb3NlJyAmJiBjbG9zZSA/IGNsb3NlLiRlbCB8fCBjbG9zZSA6IGNvbnRlbnQ7IC8vIEZvY3VzIHRoZSBlbGVtZW50XG5cbiAgICAgICAgICAgICAgYXR0ZW1wdEZvY3VzKGVsKTtcblxuICAgICAgICAgICAgICBpZiAoZWwgPT09IGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdG9wIG9mIG1vZGFsIGlzIHNob3dpbmcgKGlmIGxvbmdlciB0aGFuIHRoZSB2aWV3cG9ydClcbiAgICAgICAgICAgICAgICBfdGhpczYuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIG1vZGFsLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJldHVybkZvY3VzVG86IGZ1bmN0aW9uIHJldHVybkZvY3VzVG8oKSB7XG4gICAgICAgIC8vIFByZWZlciBgcmV0dXJuRm9jdXNgIHByb3Agb3ZlciBldmVudCBzcGVjaWZpZWRcbiAgICAgICAgLy8gYHJldHVybl9mb2N1c2AgdmFsdWVcbiAgICAgICAgdmFyIGVsID0gdGhpcy5yZXR1cm5Gb2N1cyB8fCB0aGlzLnJldHVybl9mb2N1cyB8fCBudWxsO1xuICAgICAgICB0aGlzLnJldHVybl9mb2N1cyA9IG51bGw7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBJcyBlbCBhIHN0cmluZyBDU1Mgc2VsZWN0b3I/XG4gICAgICAgICAgZWwgPSBpc1N0cmluZyhlbCkgPyBzZWxlY3QoZWwpIDogZWw7XG5cbiAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIC8vIFBvc3NpYmx5IGNvdWxkIGJlIGEgY29tcG9uZW50IHJlZmVyZW5jZVxuICAgICAgICAgICAgZWwgPSBlbC4kZWwgfHwgZWw7XG4gICAgICAgICAgICBhdHRlbXB0Rm9jdXMoZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgY2hlY2tNb2RhbE92ZXJmbG93OiBmdW5jdGlvbiBjaGVja01vZGFsT3ZlcmZsb3coKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgIHZhciBtb2RhbCA9IHRoaXMuJHJlZnMubW9kYWw7XG4gICAgICAgICAgdGhpcy5pc01vZGFsT3ZlcmZsb3dpbmcgPSBtb2RhbC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWFrZU1vZGFsOiBmdW5jdGlvbiBtYWtlTW9kYWwoaCkge1xuICAgICAgICAvLyBNb2RhbCBoZWFkZXJcbiAgICAgICAgdmFyIGhlYWRlciA9IGgoKTtcblxuICAgICAgICBpZiAoIXRoaXMuaGlkZUhlYWRlcikge1xuICAgICAgICAgIHZhciBtb2RhbEhlYWRlciA9IHRoaXMubm9ybWFsaXplU2xvdCgnbW9kYWwtaGVhZGVyJywgdGhpcy5zbG90U2NvcGUpO1xuXG4gICAgICAgICAgaWYgKCFtb2RhbEhlYWRlcikge1xuICAgICAgICAgICAgdmFyIGNsb3NlQnV0dG9uID0gaCgpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGlkZUhlYWRlckNsb3NlKSB7XG4gICAgICAgICAgICAgIGNsb3NlQnV0dG9uID0gaChCQnV0dG9uQ2xvc2UsIHtcbiAgICAgICAgICAgICAgICByZWY6ICdjbG9zZS1idXR0b24nLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLmhlYWRlckNsb3NlQ29udGVudCxcbiAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmlzVHJhbnNpdGlvbmluZyxcbiAgICAgICAgICAgICAgICAgIGFyaWFMYWJlbDogdGhpcy5oZWFkZXJDbG9zZUxhYmVsLFxuICAgICAgICAgICAgICAgICAgdGV4dFZhcmlhbnQ6IHRoaXMuaGVhZGVyQ2xvc2VWYXJpYW50IHx8IHRoaXMuaGVhZGVyVGV4dFZhcmlhbnRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICBjbGljazogdGhpcy5vbkNsb3NlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBbdGhpcy5ub3JtYWxpemVTbG90KCdtb2RhbC1oZWFkZXItY2xvc2UnKV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZG9tUHJvcHMgPSAhdGhpcy5oYXNOb3JtYWxpemVkU2xvdCgnbW9kYWwtdGl0bGUnKSAmJiB0aGlzLnRpdGxlSHRtbCA/IHtcbiAgICAgICAgICAgICAgaW5uZXJIVE1MOiB0aGlzLnRpdGxlSHRtbFxuICAgICAgICAgICAgfSA6IHt9O1xuICAgICAgICAgICAgbW9kYWxIZWFkZXIgPSBbaCh0aGlzLnRpdGxlVGFnLCB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAnbW9kYWwtdGl0bGUnLFxuICAgICAgICAgICAgICBjbGFzczogdGhpcy50aXRsZUNsYXNzZXMsXG4gICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuc2FmZUlkKCdfX0JWX21vZGFsX3RpdGxlXycpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRvbVByb3BzOiBkb21Qcm9wc1xuICAgICAgICAgICAgfSwgW3RoaXMubm9ybWFsaXplU2xvdCgnbW9kYWwtdGl0bGUnLCB0aGlzLnNsb3RTY29wZSkgfHwgc3RyaXBUYWdzKHRoaXMudGl0bGUpXSksIGNsb3NlQnV0dG9uXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoZWFkZXIgPSBoKCdoZWFkZXInLCB7XG4gICAgICAgICAgICByZWY6ICdoZWFkZXInLFxuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICdtb2RhbC1oZWFkZXInLFxuICAgICAgICAgICAgY2xhc3M6IHRoaXMuaGVhZGVyQ2xhc3NlcyxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGlkOiB0aGlzLnNhZmVJZCgnX19CVl9tb2RhbF9oZWFkZXJfJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBbbW9kYWxIZWFkZXJdKTtcbiAgICAgICAgfSAvLyBNb2RhbCBib2R5XG5cblxuICAgICAgICB2YXIgYm9keSA9IGgoJ2RpdicsIHtcbiAgICAgICAgICByZWY6ICdib2R5JyxcbiAgICAgICAgICBzdGF0aWNDbGFzczogJ21vZGFsLWJvZHknLFxuICAgICAgICAgIGNsYXNzOiB0aGlzLmJvZHlDbGFzc2VzLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5zYWZlSWQoJ19fQlZfbW9kYWxfYm9keV8nKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5ub3JtYWxpemVTbG90KCdkZWZhdWx0JywgdGhpcy5zbG90U2NvcGUpKTsgLy8gTW9kYWwgZm9vdGVyXG5cbiAgICAgICAgdmFyIGZvb3RlciA9IGgoKTtcblxuICAgICAgICBpZiAoIXRoaXMuaGlkZUZvb3Rlcikge1xuICAgICAgICAgIHZhciBtb2RhbEZvb3RlciA9IHRoaXMubm9ybWFsaXplU2xvdCgnbW9kYWwtZm9vdGVyJywgdGhpcy5zbG90U2NvcGUpO1xuXG4gICAgICAgICAgaWYgKCFtb2RhbEZvb3Rlcikge1xuICAgICAgICAgICAgdmFyIGNhbmNlbEJ1dHRvbiA9IGgoKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLm9rT25seSkge1xuICAgICAgICAgICAgICB2YXIgY2FuY2VsSHRtbCA9IHRoaXMuY2FuY2VsVGl0bGVIdG1sID8ge1xuICAgICAgICAgICAgICAgIGlubmVySFRNTDogdGhpcy5jYW5jZWxUaXRsZUh0bWxcbiAgICAgICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgICAgICAgIGNhbmNlbEJ1dHRvbiA9IGgoQkJ1dHRvbiwge1xuICAgICAgICAgICAgICAgIHJlZjogJ2NhbmNlbC1idXR0b24nLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICB2YXJpYW50OiB0aGlzLmNhbmNlbFZhcmlhbnQsXG4gICAgICAgICAgICAgICAgICBzaXplOiB0aGlzLmJ1dHRvblNpemUsXG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5jYW5jZWxEaXNhYmxlZCB8fCB0aGlzLmJ1c3kgfHwgdGhpcy5pc1RyYW5zaXRpb25pbmdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICBjbGljazogdGhpcy5vbkNhbmNlbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgW3RoaXMubm9ybWFsaXplU2xvdCgnbW9kYWwtY2FuY2VsJykgfHwgKGNhbmNlbEh0bWwgPyBoKCdzcGFuJywge1xuICAgICAgICAgICAgICAgIGRvbVByb3BzOiBjYW5jZWxIdG1sXG4gICAgICAgICAgICAgIH0pIDogc3RyaXBUYWdzKHRoaXMuY2FuY2VsVGl0bGUpKV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb2tIdG1sID0gdGhpcy5va1RpdGxlSHRtbCA/IHtcbiAgICAgICAgICAgICAgaW5uZXJIVE1MOiB0aGlzLm9rVGl0bGVIdG1sXG4gICAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgICAgIHZhciBva0J1dHRvbiA9IGgoQkJ1dHRvbiwge1xuICAgICAgICAgICAgICByZWY6ICdvay1idXR0b24nLFxuICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIHZhcmlhbnQ6IHRoaXMub2tWYXJpYW50LFxuICAgICAgICAgICAgICAgIHNpemU6IHRoaXMuYnV0dG9uU2l6ZSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5va0Rpc2FibGVkIHx8IHRoaXMuYnVzeSB8fCB0aGlzLmlzVHJhbnNpdGlvbmluZ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIGNsaWNrOiB0aGlzLm9uT2tcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW3RoaXMubm9ybWFsaXplU2xvdCgnbW9kYWwtb2snKSB8fCAob2tIdG1sID8gaCgnc3BhbicsIHtcbiAgICAgICAgICAgICAgZG9tUHJvcHM6IG9rSHRtbFxuICAgICAgICAgICAgfSkgOiBzdHJpcFRhZ3ModGhpcy5va1RpdGxlKSldKTtcbiAgICAgICAgICAgIG1vZGFsRm9vdGVyID0gW2NhbmNlbEJ1dHRvbiwgb2tCdXR0b25dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvb3RlciA9IGgoJ2Zvb3RlcicsIHtcbiAgICAgICAgICAgIHJlZjogJ2Zvb3RlcicsXG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ21vZGFsLWZvb3RlcicsXG4gICAgICAgICAgICBjbGFzczogdGhpcy5mb290ZXJDbGFzc2VzLFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgaWQ6IHRoaXMuc2FmZUlkKCdfX0JWX21vZGFsX2Zvb3Rlcl8nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIFttb2RhbEZvb3Rlcl0pO1xuICAgICAgICB9IC8vIEFzc2VtYmxlIG1vZGFsIGNvbnRlbnRcblxuXG4gICAgICAgIHZhciBtb2RhbENvbnRlbnQgPSBoKCdkaXYnLCB7XG4gICAgICAgICAgcmVmOiAnY29udGVudCcsXG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICdtb2RhbC1jb250ZW50JyxcbiAgICAgICAgICBjbGFzczogdGhpcy5jb250ZW50Q2xhc3MsXG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIHJvbGU6ICdkb2N1bWVudCcsXG4gICAgICAgICAgICBpZDogdGhpcy5zYWZlSWQoJ19fQlZfbW9kYWxfY29udGVudF8nKSxcbiAgICAgICAgICAgIHRhYmluZGV4OiAnLTEnXG4gICAgICAgICAgfVxuICAgICAgICB9LCBbaGVhZGVyLCBib2R5LCBmb290ZXJdKTsgLy8gVGFiIHRyYXAgdG8gcHJldmVudCBwYWdlIGZyb20gc2Nyb2xsaW5nIHRvIG5leHQgZWxlbWVudCBpblxuICAgICAgICAvLyB0YWIgaW5kZXggZHVyaW5nIGVuZm9yY2UgZm9jdXMgdGFiIGN5Y2xlXG5cbiAgICAgICAgdmFyIHRhYlRyYXBUb3AgPSBoKCk7XG4gICAgICAgIHZhciB0YWJUcmFwQm90dG9tID0gaCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSAmJiAhdGhpcy5ub0VuZm9yY2VGb2N1cykge1xuICAgICAgICAgIHRhYlRyYXBUb3AgPSBoKCdzcGFuJywge1xuICAgICAgICAgICAgcmVmOiAndG9wVHJhcCcsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICB0YWJpbmRleDogJzAnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGFiVHJhcEJvdHRvbSA9IGgoJ3NwYW4nLCB7XG4gICAgICAgICAgICByZWY6ICdib3R0b21UcmFwJyxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIHRhYmluZGV4OiAnMCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBNb2RhbCBkaWFsb2cgd3JhcHBlclxuXG5cbiAgICAgICAgdmFyIG1vZGFsRGlhbG9nID0gaCgnZGl2Jywge1xuICAgICAgICAgIHJlZjogJ2RpYWxvZycsXG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICdtb2RhbC1kaWFsb2cnLFxuICAgICAgICAgIGNsYXNzOiB0aGlzLmRpYWxvZ0NsYXNzZXMsXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIG1vdXNlZG93bjogdGhpcy5vbkRpYWxvZ01vdXNlZG93blxuICAgICAgICAgIH1cbiAgICAgICAgfSwgW3RhYlRyYXBUb3AsIG1vZGFsQ29udGVudCwgdGFiVHJhcEJvdHRvbV0pOyAvLyBNb2RhbFxuXG4gICAgICAgIHZhciBtb2RhbCA9IGgoJ2RpdicsIHtcbiAgICAgICAgICByZWY6ICdtb2RhbCcsXG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICdtb2RhbCcsXG4gICAgICAgICAgY2xhc3M6IHRoaXMubW9kYWxDbGFzc2VzLFxuICAgICAgICAgIHN0eWxlOiB0aGlzLm1vZGFsU3R5bGVzLFxuICAgICAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgICAgICBuYW1lOiAnc2hvdycsXG4gICAgICAgICAgICByYXdOYW1lOiAndi1zaG93JyxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmlzVmlzaWJsZSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246ICdpc1Zpc2libGUnXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLnNhZmVJZCgpLFxuICAgICAgICAgICAgcm9sZTogJ2RpYWxvZycsXG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiB0aGlzLmlzVmlzaWJsZSA/IG51bGwgOiAndHJ1ZScsXG4gICAgICAgICAgICAnYXJpYS1tb2RhbCc6IHRoaXMuaXNWaXNpYmxlID8gJ3RydWUnIDogbnVsbCxcbiAgICAgICAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5hcmlhTGFiZWwsXG4gICAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogdGhpcy5oaWRlSGVhZGVyIHx8IHRoaXMuYXJpYUxhYmVsIHx8ICEodGhpcy5oYXNOb3JtYWxpemVkU2xvdCgnbW9kYWwtdGl0bGUnKSB8fCB0aGlzLnRpdGxlSHRtbCB8fCB0aGlzLnRpdGxlKSA/IG51bGwgOiB0aGlzLnNhZmVJZCgnX19CVl9tb2RhbF90aXRsZV8nKSxcbiAgICAgICAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogdGhpcy5zYWZlSWQoJ19fQlZfbW9kYWxfYm9keV8nKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGtleWRvd246IHRoaXMub25Fc2MsXG4gICAgICAgICAgICBjbGljazogdGhpcy5vbkNsaWNrT3V0XG4gICAgICAgICAgfVxuICAgICAgICB9LCBbbW9kYWxEaWFsb2ddKTsgLy8gV3JhcCBtb2RhbCBpbiB0cmFuc2l0aW9uXG4gICAgICAgIC8vIFNhZGx5LCB3ZSBjYW4ndCB1c2UgQlZUcmFuc2l0aW9uIGhlcmUgZHVlIHRvIHRoZSBkaWZmZXJlbmNlcyBpblxuICAgICAgICAvLyB0cmFuc2l0aW9uIGR1cmF0aW9ucyBmb3IgLm1vZGFsIGFuZCAubW9kYWwtZGlhbG9nLiBOb3QgdW50aWxcbiAgICAgICAgLy8gaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9pc3N1ZXMvOTk4NiBpcyByZXNvbHZlZFxuXG4gICAgICAgIG1vZGFsID0gaCgndHJhbnNpdGlvbicsIHtcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZW50ZXJDbGFzczogJycsXG4gICAgICAgICAgICBlbnRlclRvQ2xhc3M6ICcnLFxuICAgICAgICAgICAgZW50ZXJBY3RpdmVDbGFzczogJycsXG4gICAgICAgICAgICBsZWF2ZUNsYXNzOiAnJyxcbiAgICAgICAgICAgIGxlYXZlQWN0aXZlQ2xhc3M6ICcnLFxuICAgICAgICAgICAgbGVhdmVUb0NsYXNzOiAnJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGJlZm9yZUVudGVyOiB0aGlzLm9uQmVmb3JlRW50ZXIsXG4gICAgICAgICAgICBlbnRlcjogdGhpcy5vbkVudGVyLFxuICAgICAgICAgICAgYWZ0ZXJFbnRlcjogdGhpcy5vbkFmdGVyRW50ZXIsXG4gICAgICAgICAgICBiZWZvcmVMZWF2ZTogdGhpcy5vbkJlZm9yZUxlYXZlLFxuICAgICAgICAgICAgbGVhdmU6IHRoaXMub25MZWF2ZSxcbiAgICAgICAgICAgIGFmdGVyTGVhdmU6IHRoaXMub25BZnRlckxlYXZlXG4gICAgICAgICAgfVxuICAgICAgICB9LCBbbW9kYWxdKTsgLy8gTW9kYWwgYmFja2Ryb3BcblxuICAgICAgICB2YXIgYmFja2Ryb3AgPSBoKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmhpZGVCYWNrZHJvcCAmJiB0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgIGJhY2tkcm9wID0gaCgnZGl2Jywge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICdtb2RhbC1iYWNrZHJvcCcsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICBpZDogdGhpcy5zYWZlSWQoJ19fQlZfbW9kYWxfYmFja2Ryb3BfJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBbdGhpcy5ub3JtYWxpemVTbG90KCdtb2RhbC1iYWNrZHJvcCcpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBiYWNrZHJvcCA9IGgoQlZUcmFuc2l0aW9uLCB7XG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIG5vRmFkZTogdGhpcy5ub0ZhZGVcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFtiYWNrZHJvcF0pOyAvLyBJZiB0aGUgcGFyZW50IGhhcyBhIHNjb3BlZCBzdHlsZSBhdHRyaWJ1dGUsIGFuZCB0aGUgbW9kYWxcbiAgICAgICAgLy8gaXMgcG9ydGFsbGVkLCBhZGQgdGhlIHNjb3BlZCBhdHRyaWJ1dGUgdG8gdGhlIG1vZGFsIHdyYXBwZXJcblxuICAgICAgICB2YXIgc2NvcGVkU3R5bGVBdHRycyA9ICF0aGlzLnN0YXRpYyA/IHRoaXMuc2NvcGVkU3R5bGVBdHRycyA6IHt9OyAvLyBBc3NlbWJsZSBtb2RhbCBhbmQgYmFja2Ryb3AgaW4gYW4gb3V0ZXIgPGRpdj5cblxuICAgICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICAgIGtleTogXCJtb2RhbC1vdXRlci1cIi5jb25jYXQodGhpcy5fdWlkKSxcbiAgICAgICAgICBzdHlsZTogdGhpcy5tb2RhbE91dGVyU3R5bGUsXG4gICAgICAgICAgYXR0cnM6IF9vYmplY3RTcHJlYWQyKHt9LCBzY29wZWRTdHlsZUF0dHJzLCB7fSwgdGhpcy4kYXR0cnMsIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLnNhZmVJZCgnX19CVl9tb2RhbF9vdXRlcl8nKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sIFttb2RhbCwgYmFja2Ryb3BdKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRpYykge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXp5ICYmIHRoaXMuaXNIaWRkZW4gPyBoKCkgOiB0aGlzLm1ha2VNb2RhbChoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSGlkZGVuID8gaCgpIDogaChCVHJhbnNwb3J0ZXJTaW5nbGUsIFt0aGlzLm1ha2VNb2RhbChoKV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIEVWRU5UX1NIT1cgPSAnYnY6OnNob3c6Om1vZGFsJzsgLy8gUHJvcCBuYW1lIHdlIHVzZSB0byBzdG9yZSBpbmZvIG9uIHJvb3QgZWxlbWVudFxuXG4gIHZhciBQUk9QRVJUWSA9ICdfX2J2X21vZGFsX2RpcmVjdGl2ZV9fJztcblxuICB2YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KF9yZWYpIHtcbiAgICB2YXIgX3JlZiRtb2RpZmllcnMgPSBfcmVmLm1vZGlmaWVycyxcbiAgICAgICAgbW9kaWZpZXJzID0gX3JlZiRtb2RpZmllcnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRtb2RpZmllcnMsXG4gICAgICAgIGFyZyA9IF9yZWYuYXJnLFxuICAgICAgICB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gICAgLy8gVHJ5IHZhbHVlLCB0aGVuIGFyZywgb3RoZXJ3aXNlIHBpY2sgbGFzdCBtb2RpZmllclxuICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZSA6IGlzU3RyaW5nKGFyZykgPyBhcmcgOiBrZXlzKG1vZGlmaWVycykucmV2ZXJzZSgpWzBdO1xuICB9O1xuXG4gIHZhciBnZXRUcmlnZ2VyRWxlbWVudCA9IGZ1bmN0aW9uIGdldFRyaWdnZXJFbGVtZW50KGVsKSB7XG4gICAgLy8gSWYgcm9vdCBlbGVtZW50IGlzIGEgZHJvcGRvd24taXRlbSBvciBuYXYtaXRlbSwgd2VcbiAgICAvLyBuZWVkIHRvIHRhcmdldCB0aGUgaW5uZXIgbGluayBvciBidXR0b24gaW5zdGVhZFxuICAgIHJldHVybiBlbCAmJiBtYXRjaGVzKGVsLCAnLmRyb3Bkb3duLW1lbnUgPiBsaSwgbGkubmF2LWl0ZW0nKSA/IHNlbGVjdCgnYSwgYnV0dG9uJywgZWwpIHx8IGVsIDogZWw7XG4gIH07XG5cbiAgdmFyIHNldFJvbGUgPSBmdW5jdGlvbiBzZXRSb2xlKHRyaWdnZXIpIHtcbiAgICAvLyBFbnN1cmUgYWNjZXNzaWJpbGl0eSBvbiBub24gYnV0dG9uIGVsZW1lbnRzXG4gICAgaWYgKHRyaWdnZXIgJiYgdHJpZ2dlci50YWdOYW1lICE9PSAnQlVUVE9OJykge1xuICAgICAgLy8gT25seSBzZXQgYSByb2xlIGlmIHRoZSB0cmlnZ2VyIGVsZW1lbnQgZG9lc24ndCBoYXZlIG9uZVxuICAgICAgaWYgKCFoYXNBdHRyKHRyaWdnZXIsICdyb2xlJykpIHtcbiAgICAgICAgc2V0QXR0cih0cmlnZ2VyLCAncm9sZScsICdidXR0b24nKTtcbiAgICAgIH0gLy8gQWRkIGEgdGFiaW5kZXggaXMgbm90IGEgYnV0dG9uIG9yIGxpbmssIGFuZCB0YWJpbmRleCBpcyBub3QgcHJvdmlkZWRcblxuXG4gICAgICBpZiAodHJpZ2dlci50YWdOYW1lICE9PSAnQScgJiYgIWhhc0F0dHIodHJpZ2dlciwgJ3RhYmluZGV4JykpIHtcbiAgICAgICAgc2V0QXR0cih0cmlnZ2VyLCAndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgYmluZCQxID0gZnVuY3Rpb24gYmluZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGJpbmRpbmcpO1xuICAgIHZhciB0cmlnZ2VyID0gZ2V0VHJpZ2dlckVsZW1lbnQoZWwpO1xuXG4gICAgaWYgKHRhcmdldCAmJiB0cmlnZ2VyKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZXZ0KSB7XG4gICAgICAgIC8vIGBjdXJyZW50VGFyZ2V0YCBpcyB0aGUgZWxlbWVudCB3aXRoIHRoZSBsaXN0ZW5lciBvbiBpdFxuICAgICAgICB2YXIgY3VycmVudFRhcmdldCA9IGV2dC5jdXJyZW50VGFyZ2V0O1xuXG4gICAgICAgIGlmICghaXNEaXNhYmxlZChjdXJyZW50VGFyZ2V0KSkge1xuICAgICAgICAgIHZhciB0eXBlID0gZXZ0LnR5cGU7XG4gICAgICAgICAgdmFyIGtleSA9IGV2dC5rZXlDb2RlOyAvLyBPcGVuIG1vZGFsIG9ubHkgaWYgdHJpZ2dlciBpcyBub3QgZGlzYWJsZWRcblxuICAgICAgICAgIGlmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdrZXlkb3duJyAmJiAoa2V5ID09PSBLRVlfQ09ERVMuRU5URVIgfHwga2V5ID09PSBLRVlfQ09ERVMuU1BBQ0UpKSB7XG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0LiRyb290LiRlbWl0KEVWRU5UX1NIT1csIHRhcmdldCwgY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBlbFtQUk9QRVJUWV0gPSB7XG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICB0cmlnZ2VyOiB0cmlnZ2VyXG4gICAgICB9OyAvLyBJZiBlbGVtZW50IGlzIG5vdCBhIGJ1dHRvbiwgd2UgYWRkIGByb2xlPVwiYnV0dG9uXCJgIGZvciBhY2Nlc3NpYmlsaXR5XG5cbiAgICAgIHNldFJvbGUodHJpZ2dlcik7IC8vIExpc3RlbiBmb3IgY2xpY2sgZXZlbnRzXG5cbiAgICAgIGV2ZW50T24odHJpZ2dlciwgJ2NsaWNrJywgaGFuZGxlciwgRVZFTlRfT1BUSU9OU19QQVNTSVZFKTtcblxuICAgICAgaWYgKHRyaWdnZXIudGFnTmFtZSAhPT0gJ0JVVFRPTicgJiYgZ2V0QXR0cih0cmlnZ2VyLCAncm9sZScpID09PSAnYnV0dG9uJykge1xuICAgICAgICAvLyBJZiB0cmlnZ2VyIGlzbid0IGEgYnV0dG9uIGJ1dCBoYXMgcm9sZSBidXR0b24sXG4gICAgICAgIC8vIHdlIGFsc28gbGlzdGVuIGZvciBga2V5ZG93bi5zcGFjZWAgJiYgYGtleWRvd24uZW50ZXJgXG4gICAgICAgIGV2ZW50T24odHJpZ2dlciwgJ2tleWRvd24nLCBoYW5kbGVyLCBFVkVOVF9PUFRJT05TX1BBU1NJVkUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgdW5iaW5kJDEgPSBmdW5jdGlvbiB1bmJpbmQoZWwpIHtcbiAgICB2YXIgb2xkUHJvcCA9IGVsW1BST1BFUlRZXSB8fCB7fTtcbiAgICB2YXIgdHJpZ2dlciA9IG9sZFByb3AudHJpZ2dlcjtcbiAgICB2YXIgaGFuZGxlciA9IG9sZFByb3AuaGFuZGxlcjtcblxuICAgIGlmICh0cmlnZ2VyICYmIGhhbmRsZXIpIHtcbiAgICAgIGV2ZW50T2ZmKHRyaWdnZXIsICdjbGljaycsIGhhbmRsZXIsIEVWRU5UX09QVElPTlNfUEFTU0lWRSk7XG4gICAgICBldmVudE9mZih0cmlnZ2VyLCAna2V5ZG93bicsIGhhbmRsZXIsIEVWRU5UX09QVElPTlNfUEFTU0lWRSk7XG4gICAgICBldmVudE9mZihlbCwgJ2NsaWNrJywgaGFuZGxlciwgRVZFTlRfT1BUSU9OU19QQVNTSVZFKTtcbiAgICAgIGV2ZW50T2ZmKGVsLCAna2V5ZG93bicsIGhhbmRsZXIsIEVWRU5UX09QVElPTlNfUEFTU0lWRSk7XG4gICAgfVxuXG4gICAgZGVsZXRlIGVsW1BST1BFUlRZXTtcbiAgfTtcblxuICB2YXIgY29tcG9uZW50VXBkYXRlZCQxID0gZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICB2YXIgb2xkUHJvcCA9IGVsW1BST1BFUlRZXSB8fCB7fTtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGJpbmRpbmcpO1xuICAgIHZhciB0cmlnZ2VyID0gZ2V0VHJpZ2dlckVsZW1lbnQoZWwpO1xuXG4gICAgaWYgKHRhcmdldCAhPT0gb2xkUHJvcC50YXJnZXQgfHwgdHJpZ2dlciAhPT0gb2xkUHJvcC50cmlnZ2VyKSB7XG4gICAgICAvLyBXZSBiaW5kIGFuZCByZWJpbmQgaWYgdGhlIHRhcmdldCBvciB0cmlnZ2VyIGNoYW5nZXNcbiAgICAgIHVuYmluZCQxKGVsKTtcbiAgICAgIGJpbmQkMShlbCwgYmluZGluZywgdm5vZGUpO1xuICAgIH0gLy8gSWYgdHJpZ2dlciBlbGVtZW50IGlzIG5vdCBhIGJ1dHRvbiwgZW5zdXJlIGByb2xlPVwiYnV0dG9uXCJgXG4gICAgLy8gaXMgc3RpbGwgc2V0IGZvciBhY2Nlc3NpYmlsaXR5XG5cblxuICAgIHNldFJvbGUodHJpZ2dlcik7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZWQgPSBmdW5jdGlvbiB1cGRhdGVkKCkge307XG4gIC8qXG4gICAqIEV4cG9ydCBvdXIgZGlyZWN0aXZlXG4gICAqL1xuXG5cbiAgdmFyIFZCTW9kYWwgPSB7XG4gICAgaW5zZXJ0ZWQ6IGNvbXBvbmVudFVwZGF0ZWQkMSxcbiAgICB1cGRhdGVkOiB1cGRhdGVkLFxuICAgIGNvbXBvbmVudFVwZGF0ZWQ6IGNvbXBvbmVudFVwZGF0ZWQkMSxcbiAgICB1bmJpbmQ6IHVuYmluZCQxXG4gIH07XG5cbiAgdmFyIFBST1BfTkFNRSQyID0gJyRidk1vZGFsJztcbiAgdmFyIFBST1BfTkFNRV9QUklWID0gJ19idl9fbW9kYWwnOyAvLyBCYXNlIG1vZGFsIHByb3BzIHRoYXQgYXJlIGFsbG93ZWRcbiAgLy8gU29tZSBtYXkgYmUgaWdub3JlZCBvciBvdmVycmlkZGVuIG9uIHNvbWUgbWVzc2FnZSBib3hlc1xuICAvLyBQcm9wIElEIGlzIGFsbG93ZWQsIGJ1dCByZWFsbHkgb25seSBzaG91bGQgYmUgdXNlZCBmb3IgdGVzdGluZ1xuICAvLyBXZSBuZWVkIHRvIGFkZCBpdCBpbiBleHBsaWNpdGx5IGFzIGl0IGNvbWVzIGZyb20gdGhlIGBpZE1peGluYFxuXG4gIHZhciBCQVNFX1BST1BTID0gWydpZCddLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoa2V5cyhvbWl0KHByb3BzJEgsIFsnYnVzeScsICdsYXp5JywgJ25vU3RhY2tpbmcnLCBcInN0YXRpY1wiLCAndmlzaWJsZSddKSkpKTsgLy8gRmFsbGJhY2sgZXZlbnQgcmVzb2x2ZXIgKHJldHVybnMgdW5kZWZpbmVkKVxuXG4gIHZhciBkZWZhdWx0UmVzb2x2ZXIgPSBmdW5jdGlvbiBkZWZhdWx0UmVzb2x2ZXIoKSB7fTsgLy8gTWFwIHByb3AgbmFtZXMgdG8gbW9kYWwgc2xvdCBuYW1lc1xuXG5cbiAgdmFyIHByb3BzVG9TbG90cyA9IHtcbiAgICBtc2dCb3hDb250ZW50OiAnZGVmYXVsdCcsXG4gICAgdGl0bGU6ICdtb2RhbC10aXRsZScsXG4gICAgb2tUaXRsZTogJ21vZGFsLW9rJyxcbiAgICBjYW5jZWxUaXRsZTogJ21vZGFsLWNhbmNlbCdcbiAgfTsgLy8gLS0tIFV0aWxpdHkgbWV0aG9kcyAtLS1cbiAgLy8gTWV0aG9kIHRvIGZpbHRlciBvbmx5IHJlY29nbml6ZWQgcHJvcHMgdGhhdCBhcmUgbm90IHVuZGVmaW5lZFxuXG4gIHZhciBmaWx0ZXJPcHRpb25zID0gZnVuY3Rpb24gZmlsdGVyT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIEJBU0VfUFJPUFMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBrZXkpIHtcbiAgICAgIGlmICghaXNVbmRlZmluZWQob3B0aW9uc1trZXldKSkge1xuICAgICAgICBtZW1vW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIHt9KTtcbiAgfTsgLy8gTWV0aG9kIHRvIGluc3RhbGwgYCRidk1vZGFsYCBWTSBpbmplY3Rpb25cblxuXG4gIHZhciBwbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4oVnVlKSB7XG4gICAgLy8gQ3JlYXRlIGEgcHJpdmF0ZSBzdWItY29tcG9uZW50IHRoYXQgZXh0ZW5kcyBCTW9kYWxcbiAgICAvLyB3aGljaCBzZWxmLWRlc3RydWN0cyBhZnRlciBoaWRkZW5cbiAgICAvLyBAdnVlL2NvbXBvbmVudFxuICAgIHZhciBCTXNnQm94ID0gVnVlLmV4dGVuZCh7XG4gICAgICBuYW1lOiAnQk1zZ0JveCcsXG4gICAgICBleHRlbmRzOiBCTW9kYWwsXG4gICAgICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCgpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIG5vdCBpbiBkb2N1bWVudCBhbnkgbW9yZVxuICAgICAgICBpZiAodGhpcy4kZWwgJiYgdGhpcy4kZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRoaXMuJGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy4kZWwpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAvLyBTZWxmIGRlc3RydWN0IGhhbmRsZXJcbiAgICAgICAgdmFyIGhhbmRsZURlc3Ryb3kgPSBmdW5jdGlvbiBoYW5kbGVEZXN0cm95KCkge1xuICAgICAgICAgIHZhciBzZWxmID0gX3RoaXM7XG5cbiAgICAgICAgICBfdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gSW4gYSBgc2V0VGltZW91dCgpYCB0byByZWxlYXNlIGNvbnRyb2wgYmFjayB0byBhcHBsaWNhdGlvblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWxmLiRkZXN0cm95KCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTsgLy8gU2VsZiBkZXN0cnVjdCBpZiBwYXJlbnQgZGVzdHJveWVkXG5cblxuICAgICAgICB0aGlzLiRwYXJlbnQuJG9uY2UoJ2hvb2s6ZGVzdHJveWVkJywgaGFuZGxlRGVzdHJveSk7IC8vIFNlbGYgZGVzdHJ1Y3QgYWZ0ZXIgaGlkZGVuXG5cbiAgICAgICAgdGhpcy4kb25jZSgnaGlkZGVuJywgaGFuZGxlRGVzdHJveSk7IC8vIFNlbGYgZGVzdHJ1Y3Qgb24gcm91dGUgY2hhbmdlXG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cbiAgICAgICAgaWYgKHRoaXMuJHJvdXRlciAmJiB0aGlzLiRyb3V0ZSkge1xuICAgICAgICAgIC8vIERlc3Ryb3kgb3Vyc2VsdmVzIGlmIHJvdXRlIGNoYW5nZXNcblxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgdGhpcy4kb25jZSgnaG9vazpiZWZvcmVEZXN0cm95JywgdGhpcy4kd2F0Y2goJyRyb3V0ZXInLCBoYW5kbGVEZXN0cm95KSk7XG4gICAgICAgIH0gLy8gU2hvdyB0aGUgYEJNc2dCb3hgXG5cblxuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTWV0aG9kIHRvIGdlbmVyYXRlIHRoZSBvbi1kZW1hbmQgbW9kYWwgbWVzc2FnZSBib3hcbiAgICAvLyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIHJlc29sdmVcblxuICAgIHZhciBhc3luY01zZ0JveCA9IGZ1bmN0aW9uIGFzeW5jTXNnQm94KCRwYXJlbnQsIHByb3BzKSB7XG4gICAgICB2YXIgcmVzb2x2ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGRlZmF1bHRSZXNvbHZlcjtcblxuICAgICAgaWYgKHdhcm5Ob3RDbGllbnQoUFJPUF9OQU1FJDIpIHx8IHdhcm5Ob1Byb21pc2VTdXBwb3J0KFBST1BfTkFNRSQyKSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBgQk1zZ0JveGAgY29tcG9uZW50XG5cblxuICAgICAgdmFyIG1zZ0JveCA9IG5ldyBCTXNnQm94KHtcbiAgICAgICAgLy8gV2Ugc2V0IHBhcmVudCBhcyB0aGUgbG9jYWwgVk0gc28gdGhlc2UgbW9kYWxzIGNhbiBlbWl0IGV2ZW50cyBvblxuICAgICAgICAvLyB0aGUgYXBwIGAkcm9vdGAsIGFzIG5lZWRlZCBieSB0aGluZ3MgbGlrZSB0b29sdGlwcyBhbmQgcG9wb3ZlcnNcbiAgICAgICAgLy8gQW5kIGl0IGhlbHBzIHRvIGVuc3VyZSBgQk1zZ0JveGAgaXMgZGVzdHJveWVkIHdoZW4gcGFyZW50IGlzIGRlc3Ryb3llZFxuICAgICAgICBwYXJlbnQ6ICRwYXJlbnQsXG4gICAgICAgIC8vIFByZXNldCB0aGUgcHJvcCB2YWx1ZXNcbiAgICAgICAgcHJvcHNEYXRhOiBfb2JqZWN0U3ByZWFkMih7fSwgZmlsdGVyT3B0aW9ucyhnZXRDb21wb25lbnRDb25maWcoJ0JNb2RhbCcpIHx8IHt9KSwge1xuICAgICAgICAgIC8vIERlZmF1bHRzIHRoYXQgdXNlciBjYW4gb3ZlcnJpZGVcbiAgICAgICAgICBoaWRlSGVhZGVyQ2xvc2U6IHRydWUsXG4gICAgICAgICAgaGlkZUhlYWRlcjogIShwcm9wcy50aXRsZSB8fCBwcm9wcy50aXRsZUh0bWwpXG4gICAgICAgIH0sIG9taXQocHJvcHMsIGtleXMocHJvcHNUb1Nsb3RzKSksIHtcbiAgICAgICAgICAvLyBQcm9wcyB0aGF0IGNhbid0IGJlIG92ZXJyaWRkZW5cbiAgICAgICAgICBsYXp5OiBmYWxzZSxcbiAgICAgICAgICBidXN5OiBmYWxzZSxcbiAgICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICBub1N0YWNraW5nOiBmYWxzZSxcbiAgICAgICAgICBub0VuZm9yY2VGb2N1czogZmFsc2VcbiAgICAgICAgfSlcbiAgICAgIH0pOyAvLyBDb252ZXJ0IGNlcnRhaW4gcHJvcHMgdG8gc2NvcGVkIHNsb3RzXG5cbiAgICAgIGtleXMocHJvcHNUb1Nsb3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQocHJvcHNbcHJvcF0pKSB7XG4gICAgICAgICAgLy8gQ2FuIGJlIGEgc3RyaW5nLCBvciBhcnJheSBvZiBWTm9kZXMuXG4gICAgICAgICAgLy8gQWx0ZXJuYXRpdmVseSwgdXNlciBjYW4gdXNlIEhUTUwgdmVyc2lvbiBvZiBwcm9wIHRvIHBhc3MgYW4gSFRNTCBzdHJpbmcuXG4gICAgICAgICAgbXNnQm94LiRzbG90c1twcm9wc1RvU2xvdHNbcHJvcF1dID0gY29uY2F0KHByb3BzW3Byb3BdKTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIFJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGhpZGRlbiwgb3IgcmVqZWN0cyBvbiBkZXN0cm95ZWRcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgIG1zZ0JveC4kb25jZSgnaG9vazpkZXN0cm95ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0Jvb3RzdHJhcFZ1ZSBNc2dCb3ggZGVzdHJveWVkIGJlZm9yZSByZXNvbHZlJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1zZ0JveC4kb24oJ2hpZGUnLCBmdW5jdGlvbiAoYnZNb2RhbEV2dCkge1xuICAgICAgICAgIGlmICghYnZNb2RhbEV2dC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzb2x2ZXIoYnZNb2RhbEV2dCk7IC8vIElmIHJlc29sdmVyIGRpZG4ndCBjYW5jZWwgaGlkZSwgd2UgcmVzb2x2ZVxuXG4gICAgICAgICAgICBpZiAoIWJ2TW9kYWxFdnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBDcmVhdGUgYSBtb3VudCBwb2ludCAoYSBESVYpIGFuZCBtb3VudCB0aGUgbXNnQm8gd2hpY2ggd2lsbCB0cmlnZ2VyIGl0IHRvIHNob3dcblxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgbXNnQm94LiRtb3VudChkaXYpO1xuICAgICAgfSk7XG4gICAgfTsgLy8gUHJpdmF0ZSB1dGlsaXR5IG1ldGhvZCB0byBvcGVuIGEgdXNlciBkZWZpbmVkIG1lc3NhZ2UgYm94IGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAgICAvLyBOb3QgdG8gYmUgdXNlZCBkaXJlY3RseSBieSBjb25zdW1lcnMsIGFzIHRoaXMgbWV0aG9kIG1heSBjaGFuZ2UgY2FsbGluZyBzeW50YXhcblxuXG4gICAgdmFyIG1ha2VNc2dCb3ggPSBmdW5jdGlvbiBtYWtlTXNnQm94KCRwYXJlbnQsIGNvbnRlbnQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciByZXNvbHZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoIWNvbnRlbnQgfHwgd2Fybk5vUHJvbWlzZVN1cHBvcnQoUFJPUF9OQU1FJDIpIHx8IHdhcm5Ob3RDbGllbnQoUFJPUF9OQU1FJDIpIHx8ICFpc0Z1bmN0aW9uKHJlc29sdmVyKSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhc3luY01zZ0JveCgkcGFyZW50LCBfb2JqZWN0U3ByZWFkMih7fSwgZmlsdGVyT3B0aW9ucyhvcHRpb25zKSwge1xuICAgICAgICBtc2dCb3hDb250ZW50OiBjb250ZW50XG4gICAgICB9KSwgcmVzb2x2ZXIpO1xuICAgIH07IC8vIEJ2TW9kYWwgaW5zdGFuY2UgY2xhc3NcblxuXG4gICAgdmFyIEJ2TW9kYWwgPVxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBCdk1vZGFsKHZtKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdk1vZGFsKTtcblxuICAgICAgICAvLyBBc3NpZ24gdGhlIG5ldyBwcm9wZXJ0aWVzIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgYXNzaWduKHRoaXMsIHtcbiAgICAgICAgICBfdm06IHZtLFxuICAgICAgICAgIF9yb290OiB2bS4kcm9vdFxuICAgICAgICB9KTsgLy8gU2V0IHRoZXNlIHByb3BlcnRpZXMgYXMgcmVhZC1vbmx5IGFuZCBub24tZW51bWVyYWJsZVxuXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgIF92bTogcmVhZG9ubHlEZXNjcmlwdG9yKCksXG4gICAgICAgICAgX3Jvb3Q6IHJlYWRvbmx5RGVzY3JpcHRvcigpXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyAtLS0gSW5zdGFuY2UgbWV0aG9kcyAtLS1cbiAgICAgIC8vIFNob3cgbW9kYWwgd2l0aCB0aGUgc3BlY2lmaWVkIElEIGFyZ3MgYXJlIGZvciBmdXR1cmUgdXNlXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEJ2TW9kYWwsIFt7XG4gICAgICAgIGtleTogXCJzaG93XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KGlkKSB7XG4gICAgICAgICAgaWYgKGlkICYmIHRoaXMuX3Jvb3QpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyRfcm9vdDtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKF90aGlzJF9yb290ID0gdGhpcy5fcm9vdCkuJGVtaXQuYXBwbHkoX3RoaXMkX3Jvb3QsIFsnYnY6OnNob3c6Om1vZGFsJywgaWRdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEhpZGUgbW9kYWwgd2l0aCB0aGUgc3BlY2lmaWVkIElEIGFyZ3MgYXJlIGZvciBmdXR1cmUgdXNlXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImhpZGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoaWQpIHtcbiAgICAgICAgICBpZiAoaWQgJiYgdGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgdmFyIF90aGlzJF9yb290MjtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKF90aGlzJF9yb290MiA9IHRoaXMuX3Jvb3QpLiRlbWl0LmFwcGx5KF90aGlzJF9yb290MiwgWydidjo6aGlkZTo6bW9kYWwnLCBpZF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVGhlIGZvbGxvd2luZyBtZXRob2RzIHJlcXVpcmUgUHJvbWlzZSBzdXBwb3J0IVxuICAgICAgICAvLyBJRSAxMSBhbmQgb3RoZXJzIGRvIG5vdCBzdXBwb3J0IFByb21pc2UgbmF0aXZlbHksIHNvIHVzZXJzXG4gICAgICAgIC8vIHNob3VsZCBoYXZlIGEgUG9seWZpbGwgbG9hZGVkICh3aGljaCB0aGV5IG5lZWQgYW55d2F5cyBmb3IgSUUgMTEgc3VwcG9ydClcbiAgICAgICAgLy8gT3BlbiBhIG1lc3NhZ2UgYm94IHdpdGggT0sgYnV0dG9uIG9ubHkgYW5kIHJldHVybnMgYSBwcm9taXNlXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcIm1zZ0JveE9rXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtc2dCb3hPayhtZXNzYWdlKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgLy8gUGljayB0aGUgbW9kYWwgcHJvcHMgd2Ugc3VwcG9ydCBmcm9tIG9wdGlvbnNcbiAgICAgICAgICB2YXIgcHJvcHMgPSBfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgLy8gQWRkIGluIG92ZXJyaWRlcyBhbmQgb3VyIGNvbnRlbnQgcHJvcFxuICAgICAgICAgICAgb2tPbmx5OiB0cnVlLFxuICAgICAgICAgICAgb2tEaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBoaWRlRm9vdGVyOiBmYWxzZSxcbiAgICAgICAgICAgIG1zZ0JveENvbnRlbnQ6IG1lc3NhZ2VcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBtYWtlTXNnQm94KHRoaXMuX3ZtLCBtZXNzYWdlLCBwcm9wcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQWx3YXlzIHJlc29sdmUgdG8gdHJ1ZSBmb3IgT0tcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIE9wZW4gYSBtZXNzYWdlIGJveCBtb2RhbCB3aXRoIE9LIGFuZCBDQU5DRUwgYnV0dG9uc1xuICAgICAgICAvLyBhbmQgcmV0dXJucyBhIHByb21pc2VcblxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwibXNnQm94Q29uZmlybVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbXNnQm94Q29uZmlybShtZXNzYWdlKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgLy8gU2V0IHRoZSBtb2RhbCBwcm9wcyB3ZSBzdXBwb3J0IGZyb20gb3B0aW9uc1xuICAgICAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICAvLyBBZGQgaW4gb3ZlcnJpZGVzIGFuZCBvdXIgY29udGVudCBwcm9wXG4gICAgICAgICAgICBva09ubHk6IGZhbHNlLFxuICAgICAgICAgICAgb2tEaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBjYW5jZWxEaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBoaWRlRm9vdGVyOiBmYWxzZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIG1ha2VNc2dCb3godGhpcy5fdm0sIG1lc3NhZ2UsIHByb3BzLCBmdW5jdGlvbiAoYnZNb2RhbEV2dCkge1xuICAgICAgICAgICAgdmFyIHRyaWdnZXIgPSBidk1vZGFsRXZ0LnRyaWdnZXI7XG4gICAgICAgICAgICByZXR1cm4gdHJpZ2dlciA9PT0gJ29rJyA/IHRydWUgOiB0cmlnZ2VyID09PSAnY2FuY2VsJyA/IGZhbHNlIDogbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gQnZNb2RhbDtcbiAgICB9KCk7IC8vIEFkZCBvdXIgaW5zdGFuY2UgbWl4aW5cblxuXG4gICAgVnVlLm1peGluKHtcbiAgICAgIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlKCkge1xuICAgICAgICAvLyBCZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIGAkcm9vdGAgZm9yIGAkZW1pdHNgLCBhbmQgVk0gZm9yIHBhcmVudGluZyxcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBjcmVhdGUgYSBmcmVzaCBpbnN0YW5jZSBvZiBgQnZNb2RhbGAgZm9yIGVhY2ggVk1cbiAgICAgICAgdGhpc1tQUk9QX05BTUVfUFJJVl0gPSBuZXcgQnZNb2RhbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gRGVmaW5lIG91ciByZWFkLW9ubHkgYCRidk1vZGFsYCBpbnN0YW5jZSBwcm9wZXJ0eVxuICAgIC8vIFBsYWNlZCBpbiBhbiBpZiBqdXN0IGluIGNhc2UgaW4gSE1SIG1vZGVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5cbiAgICBpZiAoIVZ1ZS5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoUFJPUF9OQU1FJDIpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCBQUk9QX05BTUUkMiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGlmICghdGhpcyB8fCAhdGhpc1tQUk9QX05BTUVfUFJJVl0pIHtcbiAgICAgICAgICAgIHdhcm4oXCJcXFwiXCIuY29uY2F0KFBST1BfTkFNRSQyLCBcIlxcXCIgbXVzdCBiZSBhY2Nlc3NlZCBmcm9tIGEgVnVlIGluc3RhbmNlIFxcXCJ0aGlzXFxcIiBjb250ZXh0LlwiKSwgJ0JNb2RhbCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzW1BST1BfTkFNRV9QUklWXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBCVk1vZGFsUGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBwbHVnaW5zOiB7XG4gICAgICBwbHVnaW46IHBsdWdpblxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIE1vZGFsUGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBCTW9kYWw6IEJNb2RhbFxuICAgIH0sXG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgVkJNb2RhbDogVkJNb2RhbFxuICAgIH0sXG4gICAgLy8gJGJ2TW9kYWwgaW5qZWN0aW9uXG4gICAgcGx1Z2luczoge1xuICAgICAgQlZNb2RhbFBsdWdpbjogQlZNb2RhbFBsdWdpblxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHByb3BzJEkgPSB7XG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAndWwnXG4gICAgfSxcbiAgICBmaWxsOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGp1c3RpZmllZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBhbGlnbjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgdGFiczoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBwaWxsczoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBzbWFsbDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBjYXJkSGVhZGVyOiB7XG4gICAgICAvLyBTZXQgdG8gdHJ1ZSBpZiBwbGFjaW5nIGluIGEgY2FyZCBoZWFkZXJcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfTsgLy8gLS0gVXRpbHMgLS1cblxuICB2YXIgY29tcHV0ZUp1c3RpZnlDb250ZW50ID0gZnVuY3Rpb24gY29tcHV0ZUp1c3RpZnlDb250ZW50KHZhbHVlKSB7XG4gICAgLy8gTm9ybWFsaXplIHZhbHVlXG4gICAgdmFsdWUgPSB2YWx1ZSA9PT0gJ2xlZnQnID8gJ3N0YXJ0JyA6IHZhbHVlID09PSAncmlnaHQnID8gJ2VuZCcgOiB2YWx1ZTtcbiAgICByZXR1cm4gXCJqdXN0aWZ5LWNvbnRlbnQtXCIuY29uY2F0KHZhbHVlKTtcbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuXG4gIHZhciBCTmF2ID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQk5hdicsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczogcHJvcHMkSSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgX2NsYXNzO1xuXG4gICAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICAgICAgcmV0dXJuIGgocHJvcHMudGFnLCBhKGRhdGEsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICduYXYnLFxuICAgICAgICBjbGFzczogKF9jbGFzcyA9IHtcbiAgICAgICAgICAnbmF2LXRhYnMnOiBwcm9wcy50YWJzLFxuICAgICAgICAgICduYXYtcGlsbHMnOiBwcm9wcy5waWxscyAmJiAhcHJvcHMudGFicyxcbiAgICAgICAgICAnY2FyZC1oZWFkZXItdGFicyc6ICFwcm9wcy52ZXJ0aWNhbCAmJiBwcm9wcy5jYXJkSGVhZGVyICYmIHByb3BzLnRhYnMsXG4gICAgICAgICAgJ2NhcmQtaGVhZGVyLXBpbGxzJzogIXByb3BzLnZlcnRpY2FsICYmIHByb3BzLmNhcmRIZWFkZXIgJiYgcHJvcHMucGlsbHMgJiYgIXByb3BzLnRhYnMsXG4gICAgICAgICAgJ2ZsZXgtY29sdW1uJzogcHJvcHMudmVydGljYWwsXG4gICAgICAgICAgJ25hdi1maWxsJzogIXByb3BzLnZlcnRpY2FsICYmIHByb3BzLmZpbGwsXG4gICAgICAgICAgJ25hdi1qdXN0aWZpZWQnOiAhcHJvcHMudmVydGljYWwgJiYgcHJvcHMuanVzdGlmaWVkXG4gICAgICAgIH0sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsIGNvbXB1dGVKdXN0aWZ5Q29udGVudChwcm9wcy5hbGlnbiksICFwcm9wcy52ZXJ0aWNhbCAmJiBwcm9wcy5hbGlnbiksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsIFwic21hbGxcIiwgcHJvcHMuc21hbGwpLCBfY2xhc3MpXG4gICAgICB9KSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHByb3BzJEogPSBwcm9wc0ZhY3RvcnkoKTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQk5hdkl0ZW0gPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCTmF2SXRlbScsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczogX29iamVjdFNwcmVhZDIoe30sIHByb3BzJEosIHtcbiAgICAgIGxpbmtBdHRyczoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge31cbiAgICAgIH0sXG4gICAgICBsaW5rQ2xhc3Nlczoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3QsIEFycmF5XSxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfVxuICAgIH0pLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBsaXN0ZW5lcnMgPSBfcmVmLmxpc3RlbmVycyxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gICAgICAvLyBXZSB0cmFuc2ZlciB0aGUgbGlzdGVuZXJzIHRvIHRoZSBsaW5rXG4gICAgICBkZWxldGUgZGF0YS5vbjtcbiAgICAgIHJldHVybiBoKCdsaScsIGEoZGF0YSwge1xuICAgICAgICBzdGF0aWNDbGFzczogJ25hdi1pdGVtJ1xuICAgICAgfSksIFtoKEJMaW5rLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnbmF2LWxpbmsnLFxuICAgICAgICBjbGFzczogcHJvcHMubGlua0NsYXNzZXMsXG4gICAgICAgIGF0dHJzOiBwcm9wcy5saW5rQXR0cnMsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgb246IGxpc3RlbmVyc1xuICAgICAgfSwgY2hpbGRyZW4pXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcHJvcHMkSyA9IHt9OyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCTmF2VGV4dCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JOYXZUZXh0JyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBwcm9wcyRLLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgICAgIHJldHVybiBoKCdsaScsIGEoZGF0YSwge1xuICAgICAgICBzdGF0aWNDbGFzczogJ25hdmJhci10ZXh0J1xuICAgICAgfSksIGNoaWxkcmVuKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwcm9wcyRMID0gX29iamVjdFNwcmVhZDIoe30sIG9taXQocHJvcHMkbywgWydpbmxpbmUnXSksIHtcbiAgICBmb3JtQ2xhc3M6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH1cbiAgfSk7IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJOYXZGb3JtID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQk5hdkZvcm0nLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IHByb3BzJEwsXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX3JlZikge1xuICAgICAgdmFyIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgICAgICBfcmVmJGxpc3RlbmVycyA9IF9yZWYubGlzdGVuZXJzLFxuICAgICAgICAgIGxpc3RlbmVycyA9IF9yZWYkbGlzdGVuZXJzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkbGlzdGVuZXJzO1xuICAgICAgdmFyIGF0dHJzID0gZGF0YS5hdHRyczsgLy8gVGhlIGZvbGxvd2luZyBkYXRhIHByb3BlcnRpZXMgYXJlIGNsZWFyZWQgb3V0XG4gICAgICAvLyBhcyB0aGV5IHdpbGwgYmUgcGFzc2VkIHRvIEJGb3JtIGRpcmVjdGx5XG5cbiAgICAgIGRhdGEuYXR0cnMgPSB7fTtcbiAgICAgIGRhdGEub24gPSB7fTtcbiAgICAgIHZhciAkZm9ybSA9IGgoQkZvcm0sIHtcbiAgICAgICAgY2xhc3M6IHByb3BzLmZvcm1DbGFzcyxcbiAgICAgICAgcHJvcHM6IF9vYmplY3RTcHJlYWQyKHt9LCBwcm9wcywge1xuICAgICAgICAgIGlubGluZTogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgICAgYXR0cnM6IGF0dHJzLFxuICAgICAgICBvbjogbGlzdGVuZXJzXG4gICAgICB9LCBjaGlsZHJlbik7XG4gICAgICByZXR1cm4gaCgnbGknLCBhKGRhdGEsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdmb3JtLWlubGluZSdcbiAgICAgIH0pLCBbJGZvcm1dKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwcm9wcyRNID0gcGx1Y2tQcm9wcyhbJ3RleHQnLCAnaHRtbCcsICdtZW51Q2xhc3MnLCAndG9nZ2xlQ2xhc3MnLCAnbm9DYXJldCcsICdyb2xlJywgJ2xhenknXSwgcHJvcHMkaik7IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJOYXZJdGVtRHJvcGRvd24gPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCTmF2SXRlbURyb3Bkb3duJyxcbiAgICBtaXhpbnM6IFtpZE1peGluLCBkcm9wZG93bk1peGluLCBub3JtYWxpemVTbG90TWl4aW5dLFxuICAgIHByb3BzOiBwcm9wcyRNLFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBpc05hdjogZnVuY3Rpb24gaXNOYXYoKSB7XG4gICAgICAgIC8vIFNpZ25hbCB0byBkcm9wZG93biBtaXhpbiB0aGF0IHdlIGFyZSBpbiBhIG5hdmJhclxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBkcm9wZG93bkNsYXNzZXM6IGZ1bmN0aW9uIGRyb3Bkb3duQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmRpcmVjdGlvbkNsYXNzLCB7XG4gICAgICAgICAgc2hvdzogdGhpcy52aXNpYmxlXG4gICAgICAgIH1dO1xuICAgICAgfSxcbiAgICAgIG1lbnVDbGFzc2VzOiBmdW5jdGlvbiBtZW51Q2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLm1lbnVDbGFzcywge1xuICAgICAgICAgICdkcm9wZG93bi1tZW51LXJpZ2h0JzogdGhpcy5yaWdodCxcbiAgICAgICAgICBzaG93OiB0aGlzLnZpc2libGVcbiAgICAgICAgfV07XG4gICAgICB9LFxuICAgICAgdG9nZ2xlQ2xhc3NlczogZnVuY3Rpb24gdG9nZ2xlQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnRvZ2dsZUNsYXNzLCB7XG4gICAgICAgICAgJ2Ryb3Bkb3duLXRvZ2dsZS1uby1jYXJldCc6IHRoaXMubm9DYXJldFxuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHZhciBidXR0b24gPSBoKEJMaW5rLCB7XG4gICAgICAgIHJlZjogJ3RvZ2dsZScsXG4gICAgICAgIHN0YXRpY0NsYXNzOiAnbmF2LWxpbmsgZHJvcGRvd24tdG9nZ2xlJyxcbiAgICAgICAgY2xhc3M6IHRoaXMudG9nZ2xlQ2xhc3NlcyxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBocmVmOiAnIycsXG4gICAgICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWRcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBpZDogdGhpcy5zYWZlSWQoJ19CVl9idXR0b25fJyksXG4gICAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiAndHJ1ZScsXG4gICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiB0aGlzLnZpc2libGUgPyAndHJ1ZScgOiAnZmFsc2UnXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgbW91c2Vkb3duOiB0aGlzLm9uTW91c2Vkb3duLFxuICAgICAgICAgIGNsaWNrOiB0aGlzLnRvZ2dsZSxcbiAgICAgICAgICBrZXlkb3duOiB0aGlzLnRvZ2dsZSAvLyBIYW5kbGUgRU5URVIsIFNQQUNFIGFuZCBET1dOXG5cbiAgICAgICAgfVxuICAgICAgfSwgW3RoaXMuJHNsb3RzWydidXR0b24tY29udGVudCddIHx8IHRoaXMuJHNsb3RzLnRleHQgfHwgaCgnc3BhbicsIHtcbiAgICAgICAgZG9tUHJvcHM6IGh0bWxPclRleHQodGhpcy5odG1sLCB0aGlzLnRleHQpXG4gICAgICB9KV0pO1xuICAgICAgdmFyIG1lbnUgPSBoKCd1bCcsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdkcm9wZG93bi1tZW51JyxcbiAgICAgICAgY2xhc3M6IHRoaXMubWVudUNsYXNzZXMsXG4gICAgICAgIHJlZjogJ21lbnUnLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHRhYmluZGV4OiAnLTEnLFxuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiB0aGlzLnNhZmVJZCgnX0JWX2J1dHRvbl8nKVxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGtleWRvd246IHRoaXMub25LZXlkb3duIC8vIEhhbmRsZSBVUCwgRE9XTiBhbmQgRVNDXG5cbiAgICAgICAgfVxuICAgICAgfSwgIXRoaXMubGF6eSB8fCB0aGlzLnZpc2libGUgPyB0aGlzLm5vcm1hbGl6ZVNsb3QoJ2RlZmF1bHQnLCB7XG4gICAgICAgIGhpZGU6IHRoaXMuaGlkZVxuICAgICAgfSkgOiBbaCgpXSk7XG4gICAgICByZXR1cm4gaCgnbGknLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnbmF2LWl0ZW0gYi1uYXYtZHJvcGRvd24gZHJvcGRvd24nLFxuICAgICAgICBjbGFzczogdGhpcy5kcm9wZG93bkNsYXNzZXMsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHRoaXMuc2FmZUlkKClcbiAgICAgICAgfVxuICAgICAgfSwgW2J1dHRvbiwgbWVudV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIE5hdlBsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgY29tcG9uZW50czoge1xuICAgICAgQk5hdjogQk5hdixcbiAgICAgIEJOYXZJdGVtOiBCTmF2SXRlbSxcbiAgICAgIEJOYXZUZXh0OiBCTmF2VGV4dCxcbiAgICAgIEJOYXZGb3JtOiBCTmF2Rm9ybSxcbiAgICAgIEJOYXZJdGVtRHJvcGRvd246IEJOYXZJdGVtRHJvcGRvd24sXG4gICAgICBCTmF2SXRlbURkOiBCTmF2SXRlbURyb3Bkb3duLFxuICAgICAgQk5hdkRyb3Bkb3duOiBCTmF2SXRlbURyb3Bkb3duLFxuICAgICAgQk5hdkRkOiBCTmF2SXRlbURyb3Bkb3duXG4gICAgfSxcbiAgICBwbHVnaW5zOiB7XG4gICAgICBEcm9wZG93blBsdWdpbjogRHJvcGRvd25QbHVnaW5cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBOQU1FJG8gPSAnQk5hdmJhcic7XG4gIHZhciBwcm9wcyROID0ge1xuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ25hdidcbiAgICB9LFxuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdsaWdodCdcbiAgICB9LFxuICAgIHZhcmlhbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkbywgJ3ZhcmlhbnQnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvZ2dsZWFibGU6IHtcbiAgICAgIHR5cGU6IFtCb29sZWFuLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGZpeGVkOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuICAgIHN0aWNreToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBwcmludDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9OyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCTmF2YmFyID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiBOQU1FJG8sXG4gICAgbWl4aW5zOiBbbm9ybWFsaXplU2xvdE1peGluXSxcbiAgICBwcm9wczogcHJvcHMkTixcbiAgICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnZOYXZiYXI6IHRoaXNcbiAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgYnJlYWtwb2ludENsYXNzOiBmdW5jdGlvbiBicmVha3BvaW50Q2xhc3MoKSB7XG4gICAgICAgIHZhciBicmVha3BvaW50ID0gbnVsbDtcbiAgICAgICAgdmFyIHhzID0gZ2V0QnJlYWtwb2ludHMoKVswXTtcbiAgICAgICAgdmFyIHRvZ2dsZWFibGUgPSB0aGlzLnRvZ2dsZWFibGU7XG5cbiAgICAgICAgaWYgKHRvZ2dsZWFibGUgJiYgaXNTdHJpbmcodG9nZ2xlYWJsZSkgJiYgdG9nZ2xlYWJsZSAhPT0geHMpIHtcbiAgICAgICAgICBicmVha3BvaW50ID0gXCJuYXZiYXItZXhwYW5kLVwiLmNvbmNhdCh0b2dnbGVhYmxlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2dnbGVhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrcG9pbnQgPSAnbmF2YmFyLWV4cGFuZCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnJlYWtwb2ludDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICByZXR1cm4gaCh0aGlzLnRhZywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ25hdmJhcicsXG4gICAgICAgIGNsYXNzOiBbKF9yZWYgPSB7XG4gICAgICAgICAgJ2QtcHJpbnQnOiB0aGlzLnByaW50LFxuICAgICAgICAgICdzdGlja3ktdG9wJzogdGhpcy5zdGlja3lcbiAgICAgICAgfSwgX2RlZmluZVByb3BlcnR5KF9yZWYsIFwibmF2YmFyLVwiLmNvbmNhdCh0aGlzLnR5cGUpLCB0aGlzLnR5cGUpLCBfZGVmaW5lUHJvcGVydHkoX3JlZiwgXCJiZy1cIi5jb25jYXQodGhpcy52YXJpYW50KSwgdGhpcy52YXJpYW50KSwgX2RlZmluZVByb3BlcnR5KF9yZWYsIFwiZml4ZWQtXCIuY29uY2F0KHRoaXMuZml4ZWQpLCB0aGlzLmZpeGVkKSwgX3JlZiksIHRoaXMuYnJlYWtwb2ludENsYXNzXSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICByb2xlOiB0aGlzLnRhZyA9PT0gJ25hdicgPyBudWxsIDogJ25hdmlnYXRpb24nXG4gICAgICAgIH1cbiAgICAgIH0sIFt0aGlzLm5vcm1hbGl6ZVNsb3QoJ2RlZmF1bHQnKV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHByb3BzJE8gPSBwbHVja1Byb3BzKFsndGFnJywgJ2ZpbGwnLCAnanVzdGlmaWVkJywgJ2FsaWduJywgJ3NtYWxsJ10sIHByb3BzJEkpOyAvLyAtLSBVdGlscyAtLVxuXG4gIHZhciBjb21wdXRlSnVzdGlmeUNvbnRlbnQkMSA9IGZ1bmN0aW9uIGNvbXB1dGVKdXN0aWZ5Q29udGVudCh2YWx1ZSkge1xuICAgIC8vIE5vcm1hbGl6ZSB2YWx1ZVxuICAgIHZhbHVlID0gdmFsdWUgPT09ICdsZWZ0JyA/ICdzdGFydCcgOiB2YWx1ZSA9PT0gJ3JpZ2h0JyA/ICdlbmQnIDogdmFsdWU7XG4gICAgcmV0dXJuIFwianVzdGlmeS1jb250ZW50LVwiLmNvbmNhdCh2YWx1ZSk7XG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cblxuICB2YXIgQk5hdmJhck5hdiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JOYXZiYXJOYXYnLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IHByb3BzJE8sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX3JlZikge1xuICAgICAgdmFyIF9jbGFzcztcblxuICAgICAgdmFyIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgICAgIHJldHVybiBoKHByb3BzLnRhZywgYShkYXRhLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnbmF2YmFyLW5hdicsXG4gICAgICAgIGNsYXNzOiAoX2NsYXNzID0ge1xuICAgICAgICAgICduYXYtZmlsbCc6IHByb3BzLmZpbGwsXG4gICAgICAgICAgJ25hdi1qdXN0aWZpZWQnOiBwcm9wcy5qdXN0aWZpZWRcbiAgICAgICAgfSwgX2RlZmluZVByb3BlcnR5KF9jbGFzcywgY29tcHV0ZUp1c3RpZnlDb250ZW50JDEocHJvcHMuYWxpZ24pLCBwcm9wcy5hbGlnbiksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsIFwic21hbGxcIiwgcHJvcHMuc21hbGwpLCBfY2xhc3MpXG4gICAgICB9KSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGxpbmtQcm9wcyQzID0gcHJvcHNGYWN0b3J5KCk7XG4gIGxpbmtQcm9wcyQzLmhyZWYuZGVmYXVsdCA9IHVuZGVmaW5lZDtcbiAgbGlua1Byb3BzJDMudG8uZGVmYXVsdCA9IHVuZGVmaW5lZDtcbiAgdmFyIHByb3BzJFAgPSBfb2JqZWN0U3ByZWFkMih7fSwgbGlua1Byb3BzJDMsIHtcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdkaXYnXG4gICAgfVxuICB9KTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQk5hdmJhckJyYW5kID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQk5hdmJhckJyYW5kJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiBwcm9wcyRQLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gICAgICB2YXIgaXNMaW5rID0gcHJvcHMudG8gfHwgcHJvcHMuaHJlZjtcbiAgICAgIHZhciB0YWcgPSBpc0xpbmsgPyBCTGluayA6IHByb3BzLnRhZztcbiAgICAgIHJldHVybiBoKHRhZywgYShkYXRhLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnbmF2YmFyLWJyYW5kJyxcbiAgICAgICAgcHJvcHM6IGlzTGluayA/IHBsdWNrUHJvcHMobGlua1Byb3BzJDMsIHByb3BzKSA6IHt9XG4gICAgICB9KSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIE5BTUUkcCA9ICdCTmF2YmFyVG9nZ2xlJzsgLy8gVE9ETzogU3dpdGNoIHRvIHVzaW5nIFZCVG9nZ2xlIGRpcmVjdGl2ZSwgd2lsbCByZWR1Y2UgY29kZSBmb290cHJpbnRcbiAgLy8gRXZlbnRzIHdlIGVtaXQgb24gJHJvb3RcblxuICB2YXIgRVZFTlRfVE9HR0xFJDIgPSAnYnY6OnRvZ2dsZTo6Y29sbGFwc2UnOyAvLyBFdmVudHMgd2UgbGlzdGVuIHRvIG9uICRyb290XG5cbiAgdmFyIEVWRU5UX1NUQVRFJDIgPSAnYnY6OmNvbGxhcHNlOjpzdGF0ZSc7IC8vIFRoaXMgcHJpdmF0ZSBldmVudCBpcyBOT1QgdG8gYmUgZG9jdW1lbnRlZCBhcyBwZW9wbGUgc2hvdWxkIG5vdCBiZSB1c2luZyBpdC5cblxuICB2YXIgRVZFTlRfU1RBVEVfU1lOQyQyID0gJ2J2Ojpjb2xsYXBzZTo6c3luYzo6c3RhdGUnOyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCTmF2YmFyVG9nZ2xlID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiBOQU1FJHAsXG4gICAgbWl4aW5zOiBbbGlzdGVuT25Sb290TWl4aW4sIG5vcm1hbGl6ZVNsb3RNaXhpbl0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJHAsICdsYWJlbCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGFyZ2V0OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2dnbGVTdGF0ZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgdGhpcy5saXN0ZW5PblJvb3QoRVZFTlRfU1RBVEUkMiwgdGhpcy5oYW5kbGVTdGF0ZUV2dCk7XG4gICAgICB0aGlzLmxpc3Rlbk9uUm9vdChFVkVOVF9TVEFURV9TWU5DJDIsIHRoaXMuaGFuZGxlU3RhdGVFdnQpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhldnQpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldnQpO1xuXG4gICAgICAgIGlmICghZXZ0LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICB0aGlzLiRyb290LiRlbWl0KEVWRU5UX1RPR0dMRSQyLCB0aGlzLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYW5kbGVTdGF0ZUV2dDogZnVuY3Rpb24gaGFuZGxlU3RhdGVFdnQoaWQsIHN0YXRlKSB7XG4gICAgICAgIGlmIChpZCA9PT0gdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICB0aGlzLnRvZ2dsZVN0YXRlID0gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHJldHVybiBoKCdidXR0b24nLCB7XG4gICAgICAgIGNsYXNzOiBbJ25hdmJhci10b2dnbGVyJ10sXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgdHlwZTogJ2J1dHRvbicsXG4gICAgICAgICAgJ2FyaWEtbGFiZWwnOiB0aGlzLmxhYmVsLFxuICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogdGhpcy50YXJnZXQsXG4gICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiB0aGlzLnRvZ2dsZVN0YXRlID8gJ3RydWUnIDogJ2ZhbHNlJ1xuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGNsaWNrOiB0aGlzLm9uQ2xpY2tcbiAgICAgICAgfVxuICAgICAgfSwgW3RoaXMubm9ybWFsaXplU2xvdCgnZGVmYXVsdCcpIHx8IGgoJ3NwYW4nLCB7XG4gICAgICAgIGNsYXNzOiBbJ25hdmJhci10b2dnbGVyLWljb24nXVxuICAgICAgfSldKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBOYXZiYXJQbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJOYXZiYXI6IEJOYXZiYXIsXG4gICAgICBCTmF2YmFyTmF2OiBCTmF2YmFyTmF2LFxuICAgICAgQk5hdmJhckJyYW5kOiBCTmF2YmFyQnJhbmQsXG4gICAgICBCTmF2YmFyVG9nZ2xlOiBCTmF2YmFyVG9nZ2xlLFxuICAgICAgQk5hdlRvZ2dsZTogQk5hdmJhclRvZ2dsZVxuICAgIH0sXG4gICAgcGx1Z2luczoge1xuICAgICAgTmF2UGx1Z2luOiBOYXZQbHVnaW4sXG4gICAgICBDb2xsYXBzZVBsdWdpbjogQ29sbGFwc2VQbHVnaW4sXG4gICAgICBEcm9wZG93blBsdWdpbjogRHJvcGRvd25QbHVnaW5cbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgdmFyIHJhbmdlID0gZnVuY3Rpb24gcmFuZ2UobGVuZ3RoKSB7XG4gICAgcmV0dXJuIEFycmF5LmFwcGx5KG51bGwsIHtcbiAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gZm9yIGA8Yi1wYWdpbmF0aW9uPmAgYW5kIGA8Yi1wYWdpbmF0aW9uLW5hdj5gXG4gIC8vIC0tLSBDb25zdGFudHMgLS0tXG4gIC8vIFRocmVzaG9sZCBvZiBsaW1pdCBzaXplIHdoZW4gd2Ugc3RhcnQvc3RvcCBzaG93aW5nIGVsbGlwc2lzXG5cbiAgdmFyIEVMTElQU0lTX1RIUkVTSE9MRCA9IDM7IC8vIERlZmF1bHQgIyBvZiBidXR0b25zIGxpbWl0XG5cbiAgdmFyIERFRkFVTFRfTElNSVQgPSA1OyAvLyAtLS0gSGVscGVyIG1ldGhvZHMgLS0tXG4gIC8vIE1ha2UgYW4gYXJyYXkgb2YgTiB0byBOK1hcblxuICB2YXIgbWFrZVBhZ2VBcnJheSA9IGZ1bmN0aW9uIG1ha2VQYWdlQXJyYXkoc3RhcnROdW1iZXIsIG51bWJlck9mUGFnZXMpIHtcbiAgICByZXR1cm4gcmFuZ2UobnVtYmVyT2ZQYWdlcykubWFwKGZ1bmN0aW9uICh2YWwsIGkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG51bWJlcjogc3RhcnROdW1iZXIgKyBpLFxuICAgICAgICBjbGFzc2VzOiBudWxsXG4gICAgICB9O1xuICAgIH0pO1xuICB9OyAvLyBTYW5pdGl6ZSB0aGUgcHJvdmlkZWQgbGltaXQgdmFsdWUgKGNvbnZlcnRpbmcgdG8gYSBudW1iZXIpXG5cblxuICB2YXIgc2FuaXRpemVMaW1pdCA9IGZ1bmN0aW9uIHNhbml0aXplTGltaXQodmFsKSB7XG4gICAgdmFyIGxpbWl0ID0gdG9JbnRlZ2VyKHZhbCkgfHwgMTtcbiAgICByZXR1cm4gbGltaXQgPCAxID8gREVGQVVMVF9MSU1JVCA6IGxpbWl0O1xuICB9OyAvLyBTYW5pdGl6ZSB0aGUgcHJvdmlkZWQgY3VycmVudCBwYWdlIG51bWJlciAoY29udmVydGluZyB0byBhIG51bWJlcilcblxuXG4gIHZhciBzYW5pdGl6ZUN1cnJlbnRQYWdlID0gZnVuY3Rpb24gc2FuaXRpemVDdXJyZW50UGFnZSh2YWwsIG51bWJlck9mUGFnZXMpIHtcbiAgICB2YXIgcGFnZSA9IHRvSW50ZWdlcih2YWwpIHx8IDE7XG4gICAgcmV0dXJuIHBhZ2UgPiBudW1iZXJPZlBhZ2VzID8gbnVtYmVyT2ZQYWdlcyA6IHBhZ2UgPCAxID8gMSA6IHBhZ2U7XG4gIH07IC8vIExpbmtzIGRvbid0IG5vcm1hbGx5IHJlc3BvbmQgdG8gU1BBQ0UsIHNvIHdlIGFkZCB0aGF0XG4gIC8vIGZ1bmN0aW9uYWxpdHkgdmlhIHRoaXMgaGFuZGxlclxuXG5cbiAgdmFyIG9uU3BhY2VLZXkgPSBmdW5jdGlvbiBvblNwYWNlS2V5KGV2dCkge1xuICAgIGlmIChldnQua2V5Q29kZSA9PT0gS0VZX0NPREVTLlNQQUNFKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTsgLy8gU3RvcCBwYWdlIGZyb20gc2Nyb2xsaW5nXG5cbiAgICAgIGV2dC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gVHJpZ2dlciB0aGUgY2xpY2sgZXZlbnQgb24gdGhlIGxpbmtcblxuICAgICAgZXZ0LmN1cnJlbnRUYXJnZXQuY2xpY2soKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07IC8vIC0tLSBQcm9wcyAtLS1cblxuXG4gIHZhciBwcm9wcyRRID0ge1xuICAgIGRpc2FibGVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHZhbHVlKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHtcbiAgICAgICAgdmFyIG51bWJlciA9IHRvSW50ZWdlcih2YWx1ZSk7XG5cbiAgICAgICAgaWYgKCFpc051bGwodmFsdWUpICYmIChpc05hTihudW1iZXIpIHx8IG51bWJlciA8IDEpKSB7XG4gICAgICAgICAgd2FybignXCJ2LW1vZGVsXCIgdmFsdWUgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gXCIwXCInLCAnQlBhZ2luYXRpb24nKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpbWl0OiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogREVGQVVMVF9MSU1JVCxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHZhbHVlKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHtcbiAgICAgICAgdmFyIG51bWJlciA9IHRvSW50ZWdlcih2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGlzTmFOKG51bWJlcikgfHwgbnVtYmVyIDwgMSkge1xuICAgICAgICAgIHdhcm4oJ1Byb3AgXCJsaW1pdFwiIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIFwiMFwiJywgJ0JQYWdpbmF0aW9uJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBhbGlnbjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2xlZnQnXG4gICAgfSxcbiAgICBwaWxsczoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBoaWRlR290b0VuZEJ1dHRvbnM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgYXJpYUxhYmVsOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnUGFnaW5hdGlvbidcbiAgICB9LFxuICAgIGxhYmVsRmlyc3RQYWdlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnR28gdG8gZmlyc3QgcGFnZSdcbiAgICB9LFxuICAgIGZpcnN0VGV4dDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogXCJcXHhBQlwiIC8vICfCqydcblxuICAgIH0sXG4gICAgZmlyc3ROdW1iZXI6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgZmlyc3RDbGFzczoge1xuICAgICAgdHlwZTogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBsYWJlbFByZXZQYWdlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnR28gdG8gcHJldmlvdXMgcGFnZSdcbiAgICB9LFxuICAgIHByZXZUZXh0OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBcIlxcdTIwMzlcIiAvLyAn4oC5J1xuXG4gICAgfSxcbiAgICBwcmV2Q2xhc3M6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgbGFiZWxOZXh0UGFnZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ0dvIHRvIG5leHQgcGFnZSdcbiAgICB9LFxuICAgIG5leHRUZXh0OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBcIlxcdTIwM0FcIiAvLyAn4oC6J1xuXG4gICAgfSxcbiAgICBuZXh0Q2xhc3M6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgbGFiZWxMYXN0UGFnZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ0dvIHRvIGxhc3QgcGFnZSdcbiAgICB9LFxuICAgIGxhc3RUZXh0OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBcIlxceEJCXCIgLy8gJ8K7J1xuXG4gICAgfSxcbiAgICBsYXN0TnVtYmVyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGxhc3RDbGFzczoge1xuICAgICAgdHlwZTogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBsYWJlbFBhZ2U6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEZ1bmN0aW9uXSxcbiAgICAgIGRlZmF1bHQ6ICdHbyB0byBwYWdlJ1xuICAgIH0sXG4gICAgcGFnZUNsYXNzOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGhpZGVFbGxpcHNpczoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBlbGxpcHNpc1RleHQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwiXFx1MjAyNlwiIC8vICfigKYnXG5cbiAgICB9LFxuICAgIGVsbGlwc2lzQ2xhc3M6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgcGFnaW5hdGlvbk1peGluID0ge1xuICAgIG1peGluczogW25vcm1hbGl6ZVNsb3RNaXhpbl0sXG4gICAgbW9kZWw6IHtcbiAgICAgIHByb3A6ICd2YWx1ZScsXG4gICAgICBldmVudDogJ2lucHV0J1xuICAgIH0sXG4gICAgcHJvcHM6IHByb3BzJFEsXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHZhciBjdXJyID0gdG9JbnRlZ2VyKHRoaXMudmFsdWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gLTEgc2lnbmlmaWVzIG5vIHBhZ2UgaW5pdGlhbGx5IHNlbGVjdGVkXG4gICAgICAgIGN1cnJlbnRQYWdlOiBjdXJyID4gMCA/IGN1cnIgOiAtMSxcbiAgICAgICAgbG9jYWxOdW1iZXJPZlBhZ2VzOiAxLFxuICAgICAgICBsb2NhbExpbWl0OiBERUZBVUxUX0xJTUlUXG4gICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGJ0blNpemU6IGZ1bmN0aW9uIGJ0blNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPyBcInBhZ2luYXRpb24tXCIuY29uY2F0KHRoaXMuc2l6ZSkgOiAnJztcbiAgICAgIH0sXG4gICAgICBhbGlnbm1lbnQ6IGZ1bmN0aW9uIGFsaWdubWVudCgpIHtcbiAgICAgICAgdmFyIGFsaWduID0gdGhpcy5hbGlnbjtcblxuICAgICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgcmV0dXJuICdqdXN0aWZ5LWNvbnRlbnQtY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcgfHwgYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICByZXR1cm4gJ2p1c3RpZnktY29udGVudC1lbmQnO1xuICAgICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZmlsbCcpIHtcbiAgICAgICAgICAvLyBUaGUgcGFnZS1pdGVtcyB3aWxsIGFsc28gaGF2ZSAnZmxleC1maWxsJyBhZGRlZFxuICAgICAgICAgIC8vIFdlIGFkZCB0ZXh0IGNlbnRlcmluZyB0byBtYWtlIHRoZSBidXR0b24gYXBwZWFyYW5jZSBiZXR0ZXIgaW4gZmlsbCBtb2RlXG4gICAgICAgICAgcmV0dXJuICd0ZXh0LWNlbnRlcic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9LFxuICAgICAgc3R5bGVDbGFzczogZnVuY3Rpb24gc3R5bGVDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlsbHMgPyAnYi1wYWdpbmF0aW9uLXBpbGxzJyA6ICcnO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkQ3VycmVudFBhZ2U6IGZ1bmN0aW9uIGNvbXB1dGVkQ3VycmVudFBhZ2UoKSB7XG4gICAgICAgIHJldHVybiBzYW5pdGl6ZUN1cnJlbnRQYWdlKHRoaXMuY3VycmVudFBhZ2UsIHRoaXMubG9jYWxOdW1iZXJPZlBhZ2VzKTtcbiAgICAgIH0sXG4gICAgICBwYWdpbmF0aW9uUGFyYW1zOiBmdW5jdGlvbiBwYWdpbmF0aW9uUGFyYW1zKCkge1xuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIHNob3cgdGhlIHRoZSBlbGxpcHNpc1xuICAgICAgICB2YXIgbGltaXQgPSB0aGlzLmxvY2FsTGltaXQ7XG4gICAgICAgIHZhciBudW1iZXJPZlBhZ2VzID0gdGhpcy5sb2NhbE51bWJlck9mUGFnZXM7XG4gICAgICAgIHZhciBjdXJyZW50UGFnZSA9IHRoaXMuY29tcHV0ZWRDdXJyZW50UGFnZTtcbiAgICAgICAgdmFyIGhpZGVFbGxpcHNpcyA9IHRoaXMuaGlkZUVsbGlwc2lzO1xuICAgICAgICB2YXIgZmlyc3ROdW1iZXIgPSB0aGlzLmZpcnN0TnVtYmVyO1xuICAgICAgICB2YXIgbGFzdE51bWJlciA9IHRoaXMubGFzdE51bWJlcjtcbiAgICAgICAgdmFyIHNob3dGaXJzdERvdHMgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNob3dMYXN0RG90cyA9IGZhbHNlO1xuICAgICAgICB2YXIgbnVtYmVyT2ZMaW5rcyA9IGxpbWl0O1xuICAgICAgICB2YXIgc3RhcnROdW1iZXIgPSAxO1xuXG4gICAgICAgIGlmIChudW1iZXJPZlBhZ2VzIDw9IGxpbWl0KSB7XG4gICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBMZXNzIHBhZ2VzIGF2YWlsYWJsZSB0aGFuIHRoZSBsaW1pdCBvZiBkaXNwbGF5ZWQgcGFnZXNcbiAgICAgICAgICBudW1iZXJPZkxpbmtzID0gbnVtYmVyT2ZQYWdlcztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UGFnZSA8IGxpbWl0IC0gMSAmJiBsaW1pdCA+IEVMTElQU0lTX1RIUkVTSE9MRCkge1xuICAgICAgICAgIGlmICghaGlkZUVsbGlwc2lzIHx8IGxhc3ROdW1iZXIpIHtcbiAgICAgICAgICAgIHNob3dMYXN0RG90cyA9IHRydWU7XG4gICAgICAgICAgICBudW1iZXJPZkxpbmtzID0gbGltaXQgLSAoZmlyc3ROdW1iZXIgPyAwIDogMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbnVtYmVyT2ZMaW5rcyA9IE1hdGgubWluKG51bWJlck9mTGlua3MsIGxpbWl0KTtcbiAgICAgICAgfSBlbHNlIGlmIChudW1iZXJPZlBhZ2VzIC0gY3VycmVudFBhZ2UgKyAyIDwgbGltaXQgJiYgbGltaXQgPiBFTExJUFNJU19USFJFU0hPTEQpIHtcbiAgICAgICAgICBpZiAoIWhpZGVFbGxpcHNpcyB8fCBmaXJzdE51bWJlcikge1xuICAgICAgICAgICAgc2hvd0ZpcnN0RG90cyA9IHRydWU7XG4gICAgICAgICAgICBudW1iZXJPZkxpbmtzID0gbGltaXQgLSAobGFzdE51bWJlciA/IDAgOiAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGFydE51bWJlciA9IG51bWJlck9mUGFnZXMgLSBudW1iZXJPZkxpbmtzICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXZSBhcmUgc29tZXdoZXJlIGluIHRoZSBtaWRkbGUgb2YgdGhlIHBhZ2UgbGlzdFxuICAgICAgICAgIGlmIChsaW1pdCA+IEVMTElQU0lTX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgbnVtYmVyT2ZMaW5rcyA9IGxpbWl0IC0gMjtcbiAgICAgICAgICAgIHNob3dGaXJzdERvdHMgPSAhISghaGlkZUVsbGlwc2lzIHx8IGZpcnN0TnVtYmVyKTtcbiAgICAgICAgICAgIHNob3dMYXN0RG90cyA9ICEhKCFoaWRlRWxsaXBzaXMgfHwgbGFzdE51bWJlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhcnROdW1iZXIgPSBjdXJyZW50UGFnZSAtIE1hdGguZmxvb3IobnVtYmVyT2ZMaW5rcyAvIDIpO1xuICAgICAgICB9IC8vIFNhbml0eSBjaGVja3NcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblxuXG4gICAgICAgIGlmIChzdGFydE51bWJlciA8IDEpIHtcbiAgICAgICAgICBzdGFydE51bWJlciA9IDE7XG4gICAgICAgICAgc2hvd0ZpcnN0RG90cyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0TnVtYmVyID4gbnVtYmVyT2ZQYWdlcyAtIG51bWJlck9mTGlua3MpIHtcbiAgICAgICAgICBzdGFydE51bWJlciA9IG51bWJlck9mUGFnZXMgLSBudW1iZXJPZkxpbmtzICsgMTtcbiAgICAgICAgICBzaG93TGFzdERvdHMgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG93Rmlyc3REb3RzICYmIGZpcnN0TnVtYmVyICYmIHN0YXJ0TnVtYmVyIDwgNCkge1xuICAgICAgICAgIG51bWJlck9mTGlua3MgPSBudW1iZXJPZkxpbmtzICsgMjtcbiAgICAgICAgICBzdGFydE51bWJlciA9IDE7XG4gICAgICAgICAgc2hvd0ZpcnN0RG90cyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3RQYWdlTnVtYmVyID0gc3RhcnROdW1iZXIgKyBudW1iZXJPZkxpbmtzIC0gMTtcblxuICAgICAgICBpZiAoc2hvd0xhc3REb3RzICYmIGxhc3ROdW1iZXIgJiYgbGFzdFBhZ2VOdW1iZXIgPiBudW1iZXJPZlBhZ2VzIC0gMykge1xuICAgICAgICAgIG51bWJlck9mTGlua3MgPSBudW1iZXJPZkxpbmtzICsgKGxhc3RQYWdlTnVtYmVyID09PSBudW1iZXJPZlBhZ2VzIC0gMiA/IDIgOiAzKTtcbiAgICAgICAgICBzaG93TGFzdERvdHMgPSBmYWxzZTtcbiAgICAgICAgfSAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBsb3dlciBsaW1pdHMgKHdoZXJlIGVsbGlwc2lzIGFyZSBuZXZlciBzaG93bilcblxuXG4gICAgICAgIGlmIChsaW1pdCA8PSBFTExJUFNJU19USFJFU0hPTEQpIHtcbiAgICAgICAgICBpZiAoZmlyc3ROdW1iZXIgJiYgc3RhcnROdW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgIG51bWJlck9mTGlua3MgPSBNYXRoLm1pbihudW1iZXJPZkxpbmtzICsgMSwgbnVtYmVyT2ZQYWdlcywgbGltaXQgKyAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3ROdW1iZXIgJiYgbnVtYmVyT2ZQYWdlcyA9PT0gc3RhcnROdW1iZXIgKyBudW1iZXJPZkxpbmtzIC0gMSkge1xuICAgICAgICAgICAgc3RhcnROdW1iZXIgPSBNYXRoLm1heChzdGFydE51bWJlciAtIDEsIDEpO1xuICAgICAgICAgICAgbnVtYmVyT2ZMaW5rcyA9IE1hdGgubWluKG51bWJlck9mUGFnZXMgLSBzdGFydE51bWJlciArIDEsIG51bWJlck9mUGFnZXMsIGxpbWl0ICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbnVtYmVyT2ZMaW5rcyA9IE1hdGgubWluKG51bWJlck9mTGlua3MsIG51bWJlck9mUGFnZXMgLSBzdGFydE51bWJlciArIDEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNob3dGaXJzdERvdHM6IHNob3dGaXJzdERvdHMsXG4gICAgICAgICAgc2hvd0xhc3REb3RzOiBzaG93TGFzdERvdHMsXG4gICAgICAgICAgbnVtYmVyT2ZMaW5rczogbnVtYmVyT2ZMaW5rcyxcbiAgICAgICAgICBzdGFydE51bWJlcjogc3RhcnROdW1iZXJcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBwYWdlTGlzdDogZnVuY3Rpb24gcGFnZUxpc3QoKSB7XG4gICAgICAgIC8vIEdlbmVyYXRlcyB0aGUgcGFnZUxpc3QgYXJyYXlcbiAgICAgICAgdmFyIF90aGlzJHBhZ2luYXRpb25QYXJhbSA9IHRoaXMucGFnaW5hdGlvblBhcmFtcyxcbiAgICAgICAgICAgIG51bWJlck9mTGlua3MgPSBfdGhpcyRwYWdpbmF0aW9uUGFyYW0ubnVtYmVyT2ZMaW5rcyxcbiAgICAgICAgICAgIHN0YXJ0TnVtYmVyID0gX3RoaXMkcGFnaW5hdGlvblBhcmFtLnN0YXJ0TnVtYmVyO1xuICAgICAgICB2YXIgY3VycmVudFBhZ2UgPSB0aGlzLmNvbXB1dGVkQ3VycmVudFBhZ2U7IC8vIEdlbmVyYXRlIGxpc3Qgb2YgcGFnZSBudW1iZXJzXG5cbiAgICAgICAgdmFyIHBhZ2VzID0gbWFrZVBhZ2VBcnJheShzdGFydE51bWJlciwgbnVtYmVyT2ZMaW5rcyk7IC8vIFdlIGxpbWl0IHRvIGEgdG90YWwgb2YgMyBwYWdlIGJ1dHRvbnMgb24gWFMgc2NyZWVuc1xuICAgICAgICAvLyBTbyBhZGQgY2xhc3NlcyB0byBwYWdlIGxpbmtzIHRvIGhpZGUgdGhlbSBmb3IgWFMgYnJlYWtwb2ludFxuICAgICAgICAvLyBOb3RlOiBFbGxpcHNpcyB3aWxsIGFsc28gYmUgaGlkZGVuIG9uIFhTIHNjcmVlbnNcbiAgICAgICAgLy8gVE9ETzogTWFrZSB0aGlzIHZpc3VhbCBsaW1pdCBjb25maWd1cmFibGUgYmFzZWQgb24gYnJlYWtwb2ludChzKVxuXG4gICAgICAgIGlmIChwYWdlcy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgdmFyIGlkeCA9IGN1cnJlbnRQYWdlIC0gc3RhcnROdW1iZXI7IC8vIFRIZSBmb2xsb3dpbmcgaXMgYSBib290c3RyYXAtdnVlIGN1c3RvbSB1dGlsaXR5IGNsYXNzXG5cbiAgICAgICAgICB2YXIgY2xhc3NlcyA9ICdidi1kLXhzLWRvd24tbm9uZSc7XG5cbiAgICAgICAgICBpZiAoaWR4ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBLZWVwIGxlZnRtb3N0IDMgYnV0dG9ucyB2aXNpYmxlIHdoZW4gY3VycmVudCBwYWdlIGlzIGZpcnN0IHBhZ2VcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAzOyBpIDwgcGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcGFnZXNbaV0uY2xhc3NlcyA9IGNsYXNzZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpZHggPT09IHBhZ2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIC8vIEtlZXAgcmlnaHRtb3N0IDMgYnV0dG9ucyB2aXNpYmxlIHdoZW4gY3VycmVudCBwYWdlIGlzIGxhc3QgcGFnZVxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHBhZ2VzLmxlbmd0aCAtIDM7IF9pKyspIHtcbiAgICAgICAgICAgICAgcGFnZXNbX2ldLmNsYXNzZXMgPSBjbGFzc2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBIaWRlIGFsbCBleGNlcHQgY3VycmVudCBwYWdlLCBjdXJyZW50IHBhZ2UgLSAxIGFuZCBjdXJyZW50IHBhZ2UgKyAxXG4gICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBpZHggLSAxOyBfaTIrKykge1xuICAgICAgICAgICAgICAvLyBoaWRlIHNvbWUgbGVmdCBidXR0b24ocylcbiAgICAgICAgICAgICAgcGFnZXNbX2kyXS5jbGFzc2VzID0gY2xhc3NlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gcGFnZXMubGVuZ3RoIC0gMTsgX2kzID4gaWR4ICsgMTsgX2kzLS0pIHtcbiAgICAgICAgICAgICAgLy8gaGlkZSBzb21lIHJpZ2h0IGJ1dHRvbihzKVxuICAgICAgICAgICAgICBwYWdlc1tfaTNdLmNsYXNzZXMgPSBjbGFzc2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYWdlcztcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRQYWdlID0gc2FuaXRpemVDdXJyZW50UGFnZShuZXdWYWx1ZSwgdGhpcy5sb2NhbE51bWJlck9mUGFnZXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3VycmVudFBhZ2U6IGZ1bmN0aW9uIGN1cnJlbnRQYWdlKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAobmV3VmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgLy8gRW1pdCBudWxsIGlmIG5vIHBhZ2Ugc2VsZWN0ZWRcbiAgICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIG5ld1ZhbHVlID4gMCA/IG5ld1ZhbHVlIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsaW1pdDogZnVuY3Rpb24gbGltaXQobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsTGltaXQgPSBzYW5pdGl6ZUxpbWl0KG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIFNldCBvdXIgZGVmYXVsdCB2YWx1ZXMgaW4gZGF0YVxuICAgICAgdGhpcy5sb2NhbExpbWl0ID0gc2FuaXRpemVMaW1pdCh0aGlzLmxpbWl0KTtcbiAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrXG4gICAgICAgIF90aGlzLmN1cnJlbnRQYWdlID0gX3RoaXMuY3VycmVudFBhZ2UgPiBfdGhpcy5sb2NhbE51bWJlck9mUGFnZXMgPyBfdGhpcy5sb2NhbE51bWJlck9mUGFnZXMgOiBfdGhpcy5jdXJyZW50UGFnZTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgaGFuZGxlS2V5TmF2OiBmdW5jdGlvbiBoYW5kbGVLZXlOYXYoZXZ0KSB7XG4gICAgICAgIHZhciBrZXlDb2RlID0gZXZ0LmtleUNvZGUsXG4gICAgICAgICAgICBzaGlmdEtleSA9IGV2dC5zaGlmdEtleTtcblxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS0VZX0NPREVTLkxFRlQgfHwga2V5Q29kZSA9PT0gS0VZX0NPREVTLlVQKSB7XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgc2hpZnRLZXkgPyB0aGlzLmZvY3VzRmlyc3QoKSA6IHRoaXMuZm9jdXNQcmV2KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gS0VZX0NPREVTLlJJR0hUIHx8IGtleUNvZGUgPT09IEtFWV9DT0RFUy5ET1dOKSB7XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgc2hpZnRLZXkgPyB0aGlzLmZvY3VzTGFzdCgpIDogdGhpcy5mb2N1c05leHQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldEJ1dHRvbnM6IGZ1bmN0aW9uIGdldEJ1dHRvbnMoKSB7XG4gICAgICAgIC8vIFJldHVybiBvbmx5IGJ1dHRvbnMgdGhhdCBhcmUgdmlzaWJsZVxuICAgICAgICByZXR1cm4gc2VsZWN0QWxsKCdhLnBhZ2UtbGluaycsIHRoaXMuJGVsKS5maWx0ZXIoZnVuY3Rpb24gKGJ0bikge1xuICAgICAgICAgIHJldHVybiBpc1Zpc2libGUoYnRuKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2V0QnRuRm9jdXM6IGZ1bmN0aW9uIHNldEJ0bkZvY3VzKGJ0bikge1xuICAgICAgICBidG4uZm9jdXMoKTtcbiAgICAgIH0sXG4gICAgICBmb2N1c0N1cnJlbnQ6IGZ1bmN0aW9uIGZvY3VzQ3VycmVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBpbiBgJG5leHRUaWNrKClgIHRvIGVuc3VyZSBidXR0b25zIGhhdmUgZmluaXNoZWQgcmVuZGVyaW5nXG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYnRuID0gX3RoaXMyLmdldEJ1dHRvbnMoKS5maW5kKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRvSW50ZWdlcihnZXRBdHRyKGVsLCAnYXJpYS1wb3NpbnNldCcpKSA9PT0gX3RoaXMyLmNvbXB1dGVkQ3VycmVudFBhZ2U7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoYnRuICYmIGJ0bi5mb2N1cykge1xuICAgICAgICAgICAgX3RoaXMyLnNldEJ0bkZvY3VzKGJ0bik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIGlmIGN1cnJlbnQgcGFnZSBpcyBub3QgaW4gYnV0dG9uIGxpc3RcbiAgICAgICAgICAgIF90aGlzMi5mb2N1c0ZpcnN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmb2N1c0ZpcnN0OiBmdW5jdGlvbiBmb2N1c0ZpcnN0KCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAvLyBXZSBkbyB0aGlzIGluIGAkbmV4dFRpY2soKWAgdG8gZW5zdXJlIGJ1dHRvbnMgaGF2ZSBmaW5pc2hlZCByZW5kZXJpbmdcbiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBidG4gPSBfdGhpczMuZ2V0QnV0dG9ucygpLmZpbmQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gIWlzRGlzYWJsZWQoZWwpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGJ0biAmJiBidG4uZm9jdXMgJiYgYnRuICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICBfdGhpczMuc2V0QnRuRm9jdXMoYnRuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZvY3VzTGFzdDogZnVuY3Rpb24gZm9jdXNMYXN0KCkge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICAvLyBXZSBkbyB0aGlzIGluIGAkbmV4dFRpY2soKWAgdG8gZW5zdXJlIGJ1dHRvbnMgaGF2ZSBmaW5pc2hlZCByZW5kZXJpbmdcbiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBidG4gPSBfdGhpczQuZ2V0QnV0dG9ucygpLnJldmVyc2UoKS5maW5kKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuICFpc0Rpc2FibGVkKGVsKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChidG4gJiYgYnRuLmZvY3VzICYmIGJ0biAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgX3RoaXM0LnNldEJ0bkZvY3VzKGJ0bik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmb2N1c1ByZXY6IGZ1bmN0aW9uIGZvY3VzUHJldigpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBpbiBgJG5leHRUaWNrKClgIHRvIGVuc3VyZSBidXR0b25zIGhhdmUgZmluaXNoZWQgcmVuZGVyaW5nXG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYnV0dG9ucyA9IF90aGlzNS5nZXRCdXR0b25zKCk7XG5cbiAgICAgICAgICB2YXIgaWR4ID0gYnV0dG9ucy5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKGlkeCA+IDAgJiYgIWlzRGlzYWJsZWQoYnV0dG9uc1tpZHggLSAxXSkgJiYgYnV0dG9uc1tpZHggLSAxXS5mb2N1cykge1xuICAgICAgICAgICAgX3RoaXM1LnNldEJ0bkZvY3VzKGJ1dHRvbnNbaWR4IC0gMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZm9jdXNOZXh0OiBmdW5jdGlvbiBmb2N1c05leHQoKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgaW4gYCRuZXh0VGljaygpYCB0byBlbnN1cmUgYnV0dG9ucyBoYXZlIGZpbmlzaGVkIHJlbmRlcmluZ1xuICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGJ1dHRvbnMgPSBfdGhpczYuZ2V0QnV0dG9ucygpO1xuXG4gICAgICAgICAgdmFyIGlkeCA9IGJ1dHRvbnMuaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcbiAgICAgICAgICB2YXIgY250ID0gYnV0dG9ucy5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgaWYgKGlkeCA8IGNudCAmJiAhaXNEaXNhYmxlZChidXR0b25zW2lkeCArIDFdKSAmJiBidXR0b25zW2lkeCArIDFdLmZvY3VzKSB7XG4gICAgICAgICAgICBfdGhpczYuc2V0QnRuRm9jdXMoYnV0dG9uc1tpZHggKyAxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICB2YXIgYnV0dG9ucyA9IFtdO1xuICAgICAgdmFyIG51bWJlck9mUGFnZXMgPSB0aGlzLmxvY2FsTnVtYmVyT2ZQYWdlcztcbiAgICAgIHZhciBwYWdlTnVtYmVycyA9IHRoaXMucGFnZUxpc3QubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwLm51bWJlcjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGRpc2FibGVkID0gdGhpcy5kaXNhYmxlZDtcbiAgICAgIHZhciBfdGhpcyRwYWdpbmF0aW9uUGFyYW0yID0gdGhpcy5wYWdpbmF0aW9uUGFyYW1zLFxuICAgICAgICAgIHNob3dGaXJzdERvdHMgPSBfdGhpcyRwYWdpbmF0aW9uUGFyYW0yLnNob3dGaXJzdERvdHMsXG4gICAgICAgICAgc2hvd0xhc3REb3RzID0gX3RoaXMkcGFnaW5hdGlvblBhcmFtMi5zaG93TGFzdERvdHM7XG4gICAgICB2YXIgY3VycmVudFBhZ2UgPSB0aGlzLmNvbXB1dGVkQ3VycmVudFBhZ2U7XG4gICAgICB2YXIgZmlsbCA9IHRoaXMuYWxpZ24gPT09ICdmaWxsJzsgLy8gSGVscGVyIGZ1bmN0aW9uIGFuZCBmbGFnXG5cbiAgICAgIHZhciBpc0FjdGl2ZVBhZ2UgPSBmdW5jdGlvbiBpc0FjdGl2ZVBhZ2UocGFnZU51bSkge1xuICAgICAgICByZXR1cm4gcGFnZU51bSA9PT0gY3VycmVudFBhZ2U7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbm9DdXJyZW50UGFnZSA9IHRoaXMuY3VycmVudFBhZ2UgPCAxOyAvLyBGYWN0b3J5IGZ1bmN0aW9uIGZvciBwcmV2L25leHQvZmlyc3QvbGFzdCBidXR0b25zXG5cbiAgICAgIHZhciBtYWtlRW5kQnRuID0gZnVuY3Rpb24gbWFrZUVuZEJ0bihsaW5rVG8sIGFyaWFMYWJlbCwgYnRuU2xvdCwgYnRuVGV4dCwgYnRuQ2xhc3MsIHBhZ2VUZXN0LCBrZXkpIHtcbiAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSBkaXNhYmxlZCB8fCBpc0FjdGl2ZVBhZ2UocGFnZVRlc3QpIHx8IG5vQ3VycmVudFBhZ2UgfHwgbGlua1RvIDwgMSB8fCBsaW5rVG8gPiBudW1iZXJPZlBhZ2VzO1xuICAgICAgICB2YXIgcGFnZU51bSA9IGxpbmtUbyA8IDEgPyAxIDogbGlua1RvID4gbnVtYmVyT2ZQYWdlcyA/IG51bWJlck9mUGFnZXMgOiBsaW5rVG87XG4gICAgICAgIHZhciBzY29wZSA9IHtcbiAgICAgICAgICBkaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICAgICAgICBwYWdlOiBwYWdlTnVtLFxuICAgICAgICAgIGluZGV4OiBwYWdlTnVtIC0gMVxuICAgICAgICB9O1xuICAgICAgICB2YXIgYnRuQ29udGVudCA9IF90aGlzNy5ub3JtYWxpemVTbG90KGJ0blNsb3QsIHNjb3BlKSB8fCB0b1N0cmluZyQxKGJ0blRleHQpIHx8IGgoKTtcbiAgICAgICAgdmFyIGlubmVyID0gaChpc0Rpc2FibGVkID8gJ3NwYW4nIDogQkxpbmssIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogJ3BhZ2UtbGluaycsXG4gICAgICAgICAgcHJvcHM6IGlzRGlzYWJsZWQgPyB7fSA6IF90aGlzNy5saW5rUHJvcHMobGlua1RvKSxcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgcm9sZTogJ21lbnVpdGVtJyxcbiAgICAgICAgICAgIHRhYmluZGV4OiBpc0Rpc2FibGVkID8gbnVsbCA6ICctMScsXG4gICAgICAgICAgICAnYXJpYS1sYWJlbCc6IGFyaWFMYWJlbCxcbiAgICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogX3RoaXM3LmFyaWFDb250cm9scyB8fCBudWxsLFxuICAgICAgICAgICAgJ2FyaWEtZGlzYWJsZWQnOiBpc0Rpc2FibGVkID8gJ3RydWUnIDogbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IGlzRGlzYWJsZWQgPyB7fSA6IHtcbiAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljayhldnQpIHtcbiAgICAgICAgICAgICAgX3RoaXM3Lm9uQ2xpY2sobGlua1RvLCBldnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleWRvd246IG9uU3BhY2VLZXlcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFtidG5Db250ZW50XSk7XG4gICAgICAgIHJldHVybiBoKCdsaScsIHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICBzdGF0aWNDbGFzczogJ3BhZ2UtaXRlbScsXG4gICAgICAgICAgY2xhc3M6IFt7XG4gICAgICAgICAgICBkaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICAgICAgICAgICdmbGV4LWZpbGwnOiBmaWxsXG4gICAgICAgICAgfSwgYnRuQ2xhc3NdLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJyxcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IGlzRGlzYWJsZWQgPyAndHJ1ZScgOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9LCBbaW5uZXJdKTtcbiAgICAgIH07IC8vIEVsbGlwc2lzIGZhY3RvcnlcblxuXG4gICAgICB2YXIgbWFrZUVsbGlwc2lzID0gZnVuY3Rpb24gbWFrZUVsbGlwc2lzKGlzTGFzdCkge1xuICAgICAgICByZXR1cm4gaCgnbGknLCB7XG4gICAgICAgICAga2V5OiBcImVsbGlwc2lzLVwiLmNvbmNhdChpc0xhc3QgPyAnbGFzdCcgOiAnZmlyc3QnKSxcbiAgICAgICAgICBzdGF0aWNDbGFzczogJ3BhZ2UtaXRlbScsXG4gICAgICAgICAgY2xhc3M6IFsnZGlzYWJsZWQnLCAnYnYtZC14cy1kb3duLW5vbmUnLCBmaWxsID8gJ2ZsZXgtZmlsbCcgOiAnJywgX3RoaXM3LmVsbGlwc2lzQ2xhc3NdLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICByb2xlOiAnc2VwYXJhdG9yJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgW2goJ3NwYW4nLCB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICdwYWdlLWxpbmsnXG4gICAgICAgIH0sIFtfdGhpczcubm9ybWFsaXplU2xvdCgnZWxsaXBzaXMtdGV4dCcpIHx8IHRvU3RyaW5nJDEoX3RoaXM3LmVsbGlwc2lzVGV4dCkgfHwgaCgpXSldKTtcbiAgICAgIH07IC8vIFBhZ2UgYnV0dG9uIGZhY3RvcnlcblxuXG4gICAgICB2YXIgbWFrZVBhZ2VCdXR0b24gPSBmdW5jdGlvbiBtYWtlUGFnZUJ1dHRvbihwYWdlLCBpZHgpIHtcbiAgICAgICAgdmFyIGFjdGl2ZSA9IGlzQWN0aXZlUGFnZShwYWdlLm51bWJlcikgJiYgIW5vQ3VycmVudFBhZ2U7IC8vIEFjdGl2ZSBwYWdlIHdpbGwgaGF2ZSB0YWJpbmRleCBvZiAwLCBvciBpZiBubyBjdXJyZW50IHBhZ2UgYW5kIGZpcnN0IHBhZ2UgYnV0dG9uXG5cbiAgICAgICAgdmFyIHRhYkluZGV4ID0gZGlzYWJsZWQgPyBudWxsIDogYWN0aXZlIHx8IG5vQ3VycmVudFBhZ2UgJiYgaWR4ID09PSAwID8gJzAnIDogJy0xJztcbiAgICAgICAgdmFyIGF0dHJzID0ge1xuICAgICAgICAgIHJvbGU6ICdtZW51aXRlbXJhZGlvJyxcbiAgICAgICAgICAnYXJpYS1kaXNhYmxlZCc6IGRpc2FibGVkID8gJ3RydWUnIDogbnVsbCxcbiAgICAgICAgICAnYXJpYS1jb250cm9scyc6IF90aGlzNy5hcmlhQ29udHJvbHMgfHwgbnVsbCxcbiAgICAgICAgICAnYXJpYS1sYWJlbCc6IGlzRnVuY3Rpb24oX3RoaXM3LmxhYmVsUGFnZSkgPyBfdGhpczcubGFiZWxQYWdlKHBhZ2UubnVtYmVyKSA6IFwiXCIuY29uY2F0KF90aGlzNy5sYWJlbFBhZ2UsIFwiIFwiKS5jb25jYXQocGFnZS5udW1iZXIpLFxuICAgICAgICAgICdhcmlhLWNoZWNrZWQnOiBhY3RpdmUgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgICAgICdhcmlhLXBvc2luc2V0JzogcGFnZS5udW1iZXIsXG4gICAgICAgICAgJ2FyaWEtc2V0c2l6ZSc6IG51bWJlck9mUGFnZXMsXG4gICAgICAgICAgLy8gQVJJQSBcInJvdmluZyB0YWJpbmRleFwiIG1ldGhvZFxuICAgICAgICAgIHRhYmluZGV4OiB0YWJJbmRleFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYnRuQ29udGVudCA9IHRvU3RyaW5nJDEoX3RoaXM3Lm1ha2VQYWdlKHBhZ2UubnVtYmVyKSk7XG4gICAgICAgIHZhciBzY29wZSA9IHtcbiAgICAgICAgICBwYWdlOiBwYWdlLm51bWJlcixcbiAgICAgICAgICBpbmRleDogcGFnZS5udW1iZXIgLSAxLFxuICAgICAgICAgIGNvbnRlbnQ6IGJ0bkNvbnRlbnQsXG4gICAgICAgICAgYWN0aXZlOiBhY3RpdmUsXG4gICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkXG4gICAgICAgIH07XG4gICAgICAgIHZhciBpbm5lciA9IGgoZGlzYWJsZWQgPyAnc3BhbicgOiBCTGluaywge1xuICAgICAgICAgIHByb3BzOiBkaXNhYmxlZCA/IHt9IDogX3RoaXM3LmxpbmtQcm9wcyhwYWdlLm51bWJlciksXG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICdwYWdlLWxpbmsnLFxuICAgICAgICAgIGF0dHJzOiBhdHRycyxcbiAgICAgICAgICBvbjogZGlzYWJsZWQgPyB7fSA6IHtcbiAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljayhldnQpIHtcbiAgICAgICAgICAgICAgX3RoaXM3Lm9uQ2xpY2socGFnZS5udW1iZXIsIGV2dCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5ZG93bjogb25TcGFjZUtleVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgW190aGlzNy5ub3JtYWxpemVTbG90KCdwYWdlJywgc2NvcGUpIHx8IGJ0bkNvbnRlbnRdKTtcbiAgICAgICAgcmV0dXJuIGgoJ2xpJywge1xuICAgICAgICAgIGtleTogXCJwYWdlLVwiLmNvbmNhdChwYWdlLm51bWJlciksXG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICdwYWdlLWl0ZW0nLFxuICAgICAgICAgIGNsYXNzOiBbe1xuICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgICAgICAgICAgYWN0aXZlOiBhY3RpdmUsXG4gICAgICAgICAgICAnZmxleC1maWxsJzogZmlsbFxuICAgICAgICAgIH0sIHBhZ2UuY2xhc3NlcywgX3RoaXM3LnBhZ2VDbGFzc10sXG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nXG4gICAgICAgICAgfVxuICAgICAgICB9LCBbaW5uZXJdKTtcbiAgICAgIH07IC8vIEdvdG8gZmlyc3QgcGFnZSBidXR0b25cbiAgICAgIC8vIERvbid0IHJlbmRlciBidXR0b24gd2hlbiBgaGlkZUdvdG9FbmRCdXR0b25zYCBvciBgZmlyc3ROdW1iZXJgIGlzIHNldFxuXG5cbiAgICAgIHZhciAkZmlyc3RQYWdlQnRuID0gaCgpO1xuXG4gICAgICBpZiAoIXRoaXMuZmlyc3ROdW1iZXIgJiYgIXRoaXMuaGlkZUdvdG9FbmRCdXR0b25zKSB7XG4gICAgICAgICRmaXJzdFBhZ2VCdG4gPSBtYWtlRW5kQnRuKDEsIHRoaXMubGFiZWxGaXJzdFBhZ2UsICdmaXJzdC10ZXh0JywgdGhpcy5maXJzdFRleHQsIHRoaXMuZmlyc3RDbGFzcywgMSwgJ3BhZ2luYXRpb24tZ290by1maXJzdCcpO1xuICAgICAgfVxuXG4gICAgICBidXR0b25zLnB1c2goJGZpcnN0UGFnZUJ0bik7IC8vIEdvdG8gcHJldmlvdXMgcGFnZSBidXR0b25cblxuICAgICAgYnV0dG9ucy5wdXNoKG1ha2VFbmRCdG4oY3VycmVudFBhZ2UgLSAxLCB0aGlzLmxhYmVsUHJldlBhZ2UsICdwcmV2LXRleHQnLCB0aGlzLnByZXZUZXh0LCB0aGlzLnByZXZDbGFzcywgMSwgJ3BhZ2luYXRpb24tZ290by1wcmV2JykpOyAvLyBTaG93IGZpcnN0ICgxKSBidXR0b24/XG5cbiAgICAgIGJ1dHRvbnMucHVzaCh0aGlzLmZpcnN0TnVtYmVyICYmIHBhZ2VOdW1iZXJzWzBdICE9PSAxID8gbWFrZVBhZ2VCdXR0b24oe1xuICAgICAgICBudW1iZXI6IDFcbiAgICAgIH0sIDApIDogaCgpKTsgLy8gRmlyc3QgZWxsaXBzaXNcblxuICAgICAgYnV0dG9ucy5wdXNoKHNob3dGaXJzdERvdHMgPyBtYWtlRWxsaXBzaXMoZmFsc2UpIDogaCgpKTsgLy8gSW5kaXZpZHVhbCBwYWdlIGxpbmtzXG5cbiAgICAgIHRoaXMucGFnZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAocGFnZSwgaWR4KSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBzaG93Rmlyc3REb3RzICYmIF90aGlzNy5maXJzdE51bWJlciAmJiBwYWdlTnVtYmVyc1swXSAhPT0gMSA/IDEgOiAwO1xuICAgICAgICBidXR0b25zLnB1c2gobWFrZVBhZ2VCdXR0b24ocGFnZSwgaWR4ICsgb2Zmc2V0KSk7XG4gICAgICB9KTsgLy8gTGFzdCBlbGxpcHNpc1xuXG4gICAgICBidXR0b25zLnB1c2goc2hvd0xhc3REb3RzID8gbWFrZUVsbGlwc2lzKHRydWUpIDogaCgpKTsgLy8gU2hvdyBsYXN0IHBhZ2UgYnV0dG9uP1xuXG4gICAgICBidXR0b25zLnB1c2godGhpcy5sYXN0TnVtYmVyICYmIHBhZ2VOdW1iZXJzW3BhZ2VOdW1iZXJzLmxlbmd0aCAtIDFdICE9PSBudW1iZXJPZlBhZ2VzID8gbWFrZVBhZ2VCdXR0b24oe1xuICAgICAgICBudW1iZXI6IG51bWJlck9mUGFnZXNcbiAgICAgIH0sIC0xKSA6IGgoKSk7IC8vIEdvdG8gbmV4dCBwYWdlIGJ1dHRvblxuXG4gICAgICBidXR0b25zLnB1c2gobWFrZUVuZEJ0bihjdXJyZW50UGFnZSArIDEsIHRoaXMubGFiZWxOZXh0UGFnZSwgJ25leHQtdGV4dCcsIHRoaXMubmV4dFRleHQsIHRoaXMubmV4dENsYXNzLCBudW1iZXJPZlBhZ2VzLCAncGFnaW5hdGlvbi1nb3RvLW5leHQnKSk7IC8vIEdvdG8gbGFzdCBwYWdlIGJ1dHRvblxuICAgICAgLy8gRG9uJ3QgcmVuZGVyIGJ1dHRvbiB3aGVuIGBoaWRlR290b0VuZEJ1dHRvbnNgIG9yIGBsYXN0TnVtYmVyYCBpcyBzZXRcblxuICAgICAgdmFyICRsYXN0UGFnZUJ0biA9IGgoKTtcblxuICAgICAgaWYgKCF0aGlzLmxhc3ROdW1iZXIgJiYgIXRoaXMuaGlkZUdvdG9FbmRCdXR0b25zKSB7XG4gICAgICAgICRsYXN0UGFnZUJ0biA9IG1ha2VFbmRCdG4obnVtYmVyT2ZQYWdlcywgdGhpcy5sYWJlbExhc3RQYWdlLCAnbGFzdC10ZXh0JywgdGhpcy5sYXN0VGV4dCwgdGhpcy5sYXN0Q2xhc3MsIG51bWJlck9mUGFnZXMsICdwYWdpbmF0aW9uLWdvdG8tbGFzdCcpO1xuICAgICAgfVxuXG4gICAgICBidXR0b25zLnB1c2goJGxhc3RQYWdlQnRuKTsgLy8gQXNzZW1ibGUgdGhlIHBhZ2luYXRpb24gYnV0dG9uc1xuXG4gICAgICB2YXIgJHBhZ2luYXRpb24gPSBoKCd1bCcsIHtcbiAgICAgICAgcmVmOiAndWwnLFxuICAgICAgICBzdGF0aWNDbGFzczogJ3BhZ2luYXRpb24nLFxuICAgICAgICBjbGFzczogWydiLXBhZ2luYXRpb24nLCB0aGlzLmJ0blNpemUsIHRoaXMuYWxpZ25tZW50LCB0aGlzLnN0eWxlQ2xhc3NdLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHJvbGU6ICdtZW51YmFyJyxcbiAgICAgICAgICAnYXJpYS1kaXNhYmxlZCc6IGRpc2FibGVkID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgICAnYXJpYS1sYWJlbCc6IHRoaXMuYXJpYUxhYmVsIHx8IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBrZXlkb3duOiB0aGlzLmhhbmRsZUtleU5hdlxuICAgICAgICB9XG4gICAgICB9LCBidXR0b25zKTsgLy8gSWYgd2UgYXJlIGA8Yi1wYWdpbmF0aW9uLW5hdj5gLCB3cmFwIGluIGA8bmF2PmAgd3JhcHBlclxuXG4gICAgICBpZiAodGhpcy5pc05hdikge1xuICAgICAgICByZXR1cm4gaCgnbmF2Jywge1xuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAnYXJpYS1kaXNhYmxlZCc6IGRpc2FibGVkID8gJ3RydWUnIDogbnVsbCxcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IGRpc2FibGVkID8gJ3RydWUnIDogJ2ZhbHNlJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgWyRwYWdpbmF0aW9uXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkcGFnaW5hdGlvbjtcbiAgICB9XG4gIH07XG5cbiAgdmFyIE5BTUUkcSA9ICdCUGFnaW5hdGlvbic7XG4gIHZhciBERUZBVUxUX1BFUl9QQUdFID0gMjA7XG4gIHZhciBERUZBVUxUX1RPVEFMX1JPV1MgPSAwO1xuICB2YXIgcHJvcHMkUiA9IHtcbiAgICBzaXplOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJHEsICdzaXplJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwZXJQYWdlOiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogREVGQVVMVF9QRVJfUEFHRVxuICAgIH0sXG4gICAgdG90YWxSb3dzOiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogREVGQVVMVF9UT1RBTF9ST1dTXG4gICAgfSxcbiAgICBhcmlhQ29udHJvbHM6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9XG4gIH07IC8vIC0tLSBIZWxwZXIgZnVuY3Rpb25zIC0tLVxuICAvLyBTYW5pdGl6ZSB0aGUgcHJvdmlkZWQgcGVyIHBhZ2UgbnVtYmVyIChjb252ZXJ0aW5nIHRvIGEgbnVtYmVyKVxuXG4gIHZhciBzYW5pdGl6ZVBlclBhZ2UgPSBmdW5jdGlvbiBzYW5pdGl6ZVBlclBhZ2UodmFsKSB7XG4gICAgdmFyIHBlclBhZ2UgPSB0b0ludGVnZXIodmFsKSB8fCBERUZBVUxUX1BFUl9QQUdFO1xuICAgIHJldHVybiBwZXJQYWdlIDwgMSA/IDEgOiBwZXJQYWdlO1xuICB9OyAvLyBTYW5pdGl6ZSB0aGUgcHJvdmlkZWQgdG90YWwgcm93cyBudW1iZXIgKGNvbnZlcnRpbmcgdG8gYSBudW1iZXIpXG5cblxuICB2YXIgc2FuaXRpemVUb3RhbFJvd3MgPSBmdW5jdGlvbiBzYW5pdGl6ZVRvdGFsUm93cyh2YWwpIHtcbiAgICB2YXIgdG90YWxSb3dzID0gdG9JbnRlZ2VyKHZhbCkgfHwgREVGQVVMVF9UT1RBTF9ST1dTO1xuICAgIHJldHVybiB0b3RhbFJvd3MgPCAwID8gMCA6IHRvdGFsUm93cztcbiAgfTsgLy8gVGhlIHJlbmRlciBmdW5jdGlvbiBpcyBicm91Z2h0IGluIHZpYSB0aGUgYHBhZ2luYXRpb25NaXhpbmBcbiAgLy8gQHZ1ZS9jb21wb25lbnRcblxuXG4gIHZhciBCUGFnaW5hdGlvbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogTkFNRSRxLFxuICAgIG1peGluczogW3BhZ2luYXRpb25NaXhpbl0sXG4gICAgcHJvcHM6IHByb3BzJFIsXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIG51bWJlck9mUGFnZXM6IGZ1bmN0aW9uIG51bWJlck9mUGFnZXMoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBNYXRoLmNlaWwoc2FuaXRpemVUb3RhbFJvd3ModGhpcy50b3RhbFJvd3MpIC8gc2FuaXRpemVQZXJQYWdlKHRoaXMucGVyUGFnZSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0IDwgMSA/IDEgOiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgcGFnZVNpemVOdW1iZXJPZlBhZ2VzOiBmdW5jdGlvbiBwYWdlU2l6ZU51bWJlck9mUGFnZXMoKSB7XG4gICAgICAgIC8vIFVzZWQgZm9yIHdhdGNoaW5nIGNoYW5nZXMgdG8gYHBlclBhZ2VgIGFuZCBgbnVtYmVyT2ZQYWdlc2BcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwZXJQYWdlOiBzYW5pdGl6ZVBlclBhZ2UodGhpcy5wZXJQYWdlKSxcbiAgICAgICAgICB0b3RhbFJvd3M6IHNhbml0aXplVG90YWxSb3dzKHRoaXMudG90YWxSb3dzKSxcbiAgICAgICAgICBudW1iZXJPZlBhZ2VzOiB0aGlzLm51bWJlck9mUGFnZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICBwYWdlU2l6ZU51bWJlck9mUGFnZXM6IGZ1bmN0aW9uIHBhZ2VTaXplTnVtYmVyT2ZQYWdlcyhuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkT3JOdWxsKG9sZFZhbCkpIHtcbiAgICAgICAgICBpZiAobmV3VmFsLnBlclBhZ2UgIT09IG9sZFZhbC5wZXJQYWdlICYmIG5ld1ZhbC50b3RhbFJvd3MgPT09IG9sZFZhbC50b3RhbFJvd3MpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwYWdlIHNpemUgY2hhbmdlcywgcmVzZXQgdG8gcGFnZSAxXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYWdlID0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5ld1ZhbC5udW1iZXJPZlBhZ2VzICE9PSBvbGRWYWwubnVtYmVyT2ZQYWdlcyAmJiB0aGlzLmN1cnJlbnRQYWdlID4gbmV3VmFsLm51bWJlck9mUGFnZXMpIHtcbiAgICAgICAgICAgIC8vIElmIGBudW1iZXJPZlBhZ2VzYCBjaGFuZ2VzIGFuZCBpcyBsZXNzIHRoYW5cbiAgICAgICAgICAgIC8vIHRoZSBgY3VycmVudFBhZ2VgIG51bWJlciwgcmVzZXQgdG8gcGFnZSAxXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYWdlID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvY2FsTnVtYmVyT2ZQYWdlcyA9IG5ld1ZhbC5udW1iZXJPZlBhZ2VzO1xuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIFNldCB0aGUgaW5pdGlhbCBwYWdlIGNvdW50XG4gICAgICB0aGlzLmxvY2FsTnVtYmVyT2ZQYWdlcyA9IHRoaXMubnVtYmVyT2ZQYWdlczsgLy8gU2V0IHRoZSBpbml0aWFsIHBhZ2UgdmFsdWVcblxuICAgICAgdmFyIGN1cnJlbnRQYWdlID0gdG9JbnRlZ2VyKHRoaXMudmFsdWUpIHx8IDA7XG5cbiAgICAgIGlmIChjdXJyZW50UGFnZSA+IDApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IGN1cnJlbnRQYWdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIElmIHRoaXMgdmFsdWUgcGFyc2VzIHRvIE5hTiBvciBhIHZhbHVlIGxlc3MgdGhhbiAxXG4gICAgICAgICAgLy8gVHJpZ2dlciBhbiBpbml0aWFsIGVtaXQgb2YgJ251bGwnIGlmIG5vIHBhZ2Ugc3BlY2lmaWVkXG4gICAgICAgICAgX3RoaXMuY3VycmVudFBhZ2UgPSAwO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAvLyBTZXQgdGhlIGluaXRpYWwgcGFnZSBjb3VudFxuICAgICAgdGhpcy5sb2NhbE51bWJlck9mUGFnZXMgPSB0aGlzLm51bWJlck9mUGFnZXM7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAvLyBUaGVzZSBtZXRob2RzIGFyZSB1c2VkIGJ5IHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2sobnVtLCBldnQpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgLy8gSGFuZGxlIGVkZ2UgY2FzZXMgd2hlcmUgbnVtYmVyIG9mIHBhZ2VzIGhhcyBjaGFuZ2VkIChpLmUuIGlmIHBlclBhZ2UgY2hhbmdlcylcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgbm9ybWFsbHkgbm90IGhhcHBlbiwgYnV0IGp1c3QgaW4gY2FzZS5cbiAgICAgICAgaWYgKG51bSA+IHRoaXMubnVtYmVyT2ZQYWdlcykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgbnVtID0gdGhpcy5udW1iZXJPZlBhZ2VzO1xuICAgICAgICB9IGVsc2UgaWYgKG51bSA8IDEpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIG51bSA9IDE7XG4gICAgICAgIH0gLy8gVXBkYXRlIHRoZSB2LW1vZGVsXG5cblxuICAgICAgICB0aGlzLmN1cnJlbnRQYWdlID0gbnVtOyAvLyBFbWl0IGV2ZW50IHRyaWdnZXJlZCBieSB1c2VyIGludGVyYWN0aW9uXG5cbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5jdXJyZW50UGFnZSk7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBLZWVwIHRoZSBjdXJyZW50IGJ1dHRvbiBmb2N1c2VkIGlmIHBvc3NpYmxlXG4gICAgICAgICAgdmFyIHRhcmdldCA9IGV2dC50YXJnZXQ7XG5cbiAgICAgICAgICBpZiAoaXNWaXNpYmxlKHRhcmdldCkgJiYgX3RoaXMyLiRlbC5jb250YWlucyh0YXJnZXQpICYmIHRhcmdldC5mb2N1cykge1xuICAgICAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzMi5mb2N1c0N1cnJlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG1ha2VQYWdlOiBmdW5jdGlvbiBtYWtlUGFnZShwYWdlTnVtKSB7XG4gICAgICAgIHJldHVybiBwYWdlTnVtO1xuICAgICAgfSxcbiAgICAgIGxpbmtQcm9wczogZnVuY3Rpb24gbGlua1Byb3BzKCkge1xuICAgICAgICAvLyBBbHdheXMgJyMnIGZvciBwYWdpbmF0aW9uIGNvbXBvbmVudFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhyZWY6ICcjJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIFBhZ2luYXRpb25QbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJQYWdpbmF0aW9uOiBCUGFnaW5hdGlvblxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIE5BTUUkciA9ICdCUGFnaW5hdGlvbk5hdic7IC8vIFNhbml0aXplIHRoZSBwcm92aWRlZCBudW1iZXIgb2YgcGFnZXMgKGNvbnZlcnRpbmcgdG8gYSBudW1iZXIpXG5cbiAgdmFyIHNhbml0aXplTnVtYmVyT2ZQYWdlcyA9IGZ1bmN0aW9uIHNhbml0aXplTnVtYmVyT2ZQYWdlcyh2YWx1ZSkge1xuICAgIHZhciBudW1iZXJPZlBhZ2VzID0gdG9JbnRlZ2VyKHZhbHVlKSB8fCAxO1xuICAgIHJldHVybiBudW1iZXJPZlBhZ2VzIDwgMSA/IDEgOiBudW1iZXJPZlBhZ2VzO1xuICB9O1xuICB2YXIgcHJvcHMkUyA9IHtcbiAgICBzaXplOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJHIsICdzaXplJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBudW1iZXJPZlBhZ2VzOiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHZhbHVlKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHtcbiAgICAgICAgdmFyIG51bSA9IHRvSW50ZWdlcih2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGlzTmFOKG51bSkgfHwgbnVtIDwgMSkge1xuICAgICAgICAgIHdhcm4oJ1Byb3AgXCJudW1iZXItb2YtcGFnZXNcIiBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiBcIjBcIicsIE5BTUUkcik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBiYXNlVXJsOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnLydcbiAgICB9LFxuICAgIHVzZVJvdXRlcjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBsaW5rR2VuOiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIHBhZ2VHZW46IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgcGFnZXM6IHtcbiAgICAgIC8vIE9wdGlvbmFsIGFycmF5IG9mIHBhZ2UgbGlua3NcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgbm9QYWdlRGV0ZWN0OiB7XG4gICAgICAvLyBEaXNhYmxlIGF1dG8gcGFnZSBudW1iZXIgZGV0ZWN0aW9uIGlmIHRydWVcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgLy8gcm91dGVyLWxpbmsgc3BlY2lmaWMgcHJvcHNcbiAgICBhY3RpdmVDbGFzczoge1xuICAgICAgdHlwZTogU3RyaW5nIC8vIGRlZmF1bHQ6IHVuZGVmaW5lZFxuXG4gICAgfSxcbiAgICBleGFjdDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiB7XG4gICAgICB0eXBlOiBTdHJpbmcgLy8gZGVmYXVsdDogdW5kZWZpbmVkXG5cbiAgICB9LFxuICAgIC8vIG51eHQtbGluayBzcGVjaWZpYyBwcm9wKHMpXG4gICAgbm9QcmVmZXRjaDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9OyAvLyBUaGUgcmVuZGVyIGZ1bmN0aW9uIGlzIGJyb3VnaHQgaW4gdmlhIHRoZSBwYWdpbmF0aW9uIG1peGluXG4gIC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJQYWdpbmF0aW9uTmF2ID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiBOQU1FJHIsXG4gICAgbWl4aW5zOiBbcGFnaW5hdGlvbk1peGluXSxcbiAgICBwcm9wczogcHJvcHMkUyxcbiAgICBjb21wdXRlZDoge1xuICAgICAgLy8gVXNlZCBieSByZW5kZXIgZnVuY3Rpb24gdG8gdHJpZ2dlciB3cmFwcGluZyBpbiAnPG5hdj4nIGVsZW1lbnRcbiAgICAgIGlzTmF2OiBmdW5jdGlvbiBpc05hdigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRWYWx1ZTogZnVuY3Rpb24gY29tcHV0ZWRWYWx1ZSgpIHtcbiAgICAgICAgLy8gUmV0dXJucyB0aGUgdmFsdWUgcHJvcCBhcyBhIG51bWJlciBvciBgbnVsbGAgaWYgdW5kZWZpbmVkIG9yIDwgMVxuICAgICAgICB2YXIgdmFsID0gdG9JbnRlZ2VyKHRoaXMudmFsdWUpO1xuICAgICAgICByZXR1cm4gaXNOYU4odmFsKSB8fCB2YWwgPCAxID8gbnVsbCA6IHZhbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICBudW1iZXJPZlBhZ2VzOiBmdW5jdGlvbiBudW1iZXJPZlBhZ2VzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5zZXROdW1iZXJPZlBhZ2VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHBhZ2VzOiBmdW5jdGlvbiBwYWdlcygpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5zZXROdW1iZXJPZlBhZ2VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgIHRoaXMuc2V0TnVtYmVyT2ZQYWdlcygpO1xuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy4kcm91dGVyKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgYWRkIHRoZSB3YXRjaGVyIGlmIHZ1ZSByb3V0ZXIgaXMgZGV0ZWN0ZWRcbiAgICAgICAgdGhpcy4kd2F0Y2goJyRyb3V0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBRihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5ndWVzc0N1cnJlbnRQYWdlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBzZXROdW1iZXJPZlBhZ2VzOiBmdW5jdGlvbiBzZXROdW1iZXJPZlBhZ2VzKCkge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICBpZiAoaXNBcnJheSh0aGlzLnBhZ2VzKSAmJiB0aGlzLnBhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmxvY2FsTnVtYmVyT2ZQYWdlcyA9IHRoaXMucGFnZXMubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9jYWxOdW1iZXJPZlBhZ2VzID0gc2FuaXRpemVOdW1iZXJPZlBhZ2VzKHRoaXMubnVtYmVyT2ZQYWdlcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM0Lmd1ZXNzQ3VycmVudFBhZ2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhwYWdlTnVtLCBldnQpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgLy8gRG9udCBkbyBhbnl0aGluZyBpZiBjbGlja2luZyB0aGUgY3VycmVudCBhY3RpdmUgcGFnZVxuICAgICAgICBpZiAocGFnZU51bSA9PT0gdGhpcy5jdXJyZW50UGFnZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3RBRihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSB2LW1vZGVsXG4gICAgICAgICAgLy8gRG9uZSBpbiBpbiByZXF1ZXN0QUYoKSB0byBhbGxvdyBicm93c2VyIHRvIGNvbXBsZXRlIHRoZVxuICAgICAgICAgIC8vIG5hdGl2ZSBicm93c2VyIGNsaWNrIGhhbmRsaW5nIG9mIGEgbGlua1xuICAgICAgICAgIF90aGlzNS5jdXJyZW50UGFnZSA9IHBhZ2VOdW07XG5cbiAgICAgICAgICBfdGhpczUuJGVtaXQoJ2NoYW5nZScsIHBhZ2VOdW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIERvbmUgaW4gYSBuZXh0VGljaygpIHRvIGVuc3VyZSByZW5kZXJpbmcgY29tcGxldGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRW11bGF0ZSBuYXRpdmUgbGluayBjbGljayBwYWdlIHJlbG9hZGluZyBiZWhhdmlvdXIgYnkgYmx1cnJpbmcgdGhlXG4gICAgICAgICAgICAvLyBwYWdpbmF0b3IgYW5kIHJldHVybmluZyBmb2N1cyB0byB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldnQuY3VycmVudFRhcmdldCB8fCBldnQudGFyZ2V0O1xuICAgICAgICAgICAgdGFyZ2V0LmJsdXIoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXRQYWdlSW5mbzogZnVuY3Rpb24gZ2V0UGFnZUluZm8ocGFnZU51bSkge1xuICAgICAgICBpZiAoIWlzQXJyYXkodGhpcy5wYWdlcykgfHwgdGhpcy5wYWdlcy5sZW5ndGggPT09IDAgfHwgaXNVbmRlZmluZWQodGhpcy5wYWdlc1twYWdlTnVtIC0gMV0pKSB7XG4gICAgICAgICAgdmFyIGxpbmsgPSBcIlwiLmNvbmNhdCh0aGlzLmJhc2VVcmwpLmNvbmNhdChwYWdlTnVtKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluazogdGhpcy51c2VSb3V0ZXIgPyB7XG4gICAgICAgICAgICAgIHBhdGg6IGxpbmtcbiAgICAgICAgICAgIH0gOiBsaW5rLFxuICAgICAgICAgICAgdGV4dDogdG9TdHJpbmckMShwYWdlTnVtKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5mbyA9IHRoaXMucGFnZXNbcGFnZU51bSAtIDFdO1xuXG4gICAgICAgIGlmIChpc09iamVjdChpbmZvKSkge1xuICAgICAgICAgIHZhciBfbGluayA9IGluZm8ubGluaztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGxpbmsgZm9yIHJvdXRlciB1c2VcbiAgICAgICAgICAgIGxpbms6IGlzT2JqZWN0KF9saW5rKSA/IF9saW5rIDogdGhpcy51c2VSb3V0ZXIgPyB7XG4gICAgICAgICAgICAgIHBhdGg6IF9saW5rXG4gICAgICAgICAgICB9IDogX2xpbmssXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGV4dCBoYXMgYSB2YWx1ZVxuICAgICAgICAgICAgdGV4dDogdG9TdHJpbmckMShpbmZvLnRleHQgfHwgcGFnZU51bSlcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5rOiB0b1N0cmluZyQxKGluZm8pLFxuICAgICAgICAgICAgdGV4dDogdG9TdHJpbmckMShwYWdlTnVtKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtYWtlUGFnZTogZnVuY3Rpb24gbWFrZVBhZ2UocGFnZU51bSkge1xuICAgICAgICB2YXIgaW5mbyA9IHRoaXMuZ2V0UGFnZUluZm8ocGFnZU51bSk7XG5cbiAgICAgICAgaWYgKHRoaXMucGFnZUdlbiAmJiBpc0Z1bmN0aW9uKHRoaXMucGFnZUdlbikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYWdlR2VuKHBhZ2VOdW0sIGluZm8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZm8udGV4dDtcbiAgICAgIH0sXG4gICAgICBtYWtlTGluazogZnVuY3Rpb24gbWFrZUxpbmsocGFnZU51bSkge1xuICAgICAgICB2YXIgaW5mbyA9IHRoaXMuZ2V0UGFnZUluZm8ocGFnZU51bSk7XG5cbiAgICAgICAgaWYgKHRoaXMubGlua0dlbiAmJiBpc0Z1bmN0aW9uKHRoaXMubGlua0dlbikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5saW5rR2VuKHBhZ2VOdW0sIGluZm8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZm8ubGluaztcbiAgICAgIH0sXG4gICAgICBsaW5rUHJvcHM6IGZ1bmN0aW9uIGxpbmtQcm9wcyhwYWdlTnVtKSB7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5tYWtlTGluayhwYWdlTnVtKTtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIHRhcmdldDogdGhpcy50YXJnZXQgfHwgbnVsbCxcbiAgICAgICAgICByZWw6IHRoaXMucmVsIHx8IG51bGwsXG4gICAgICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQsXG4gICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBwcm9wcyBhcmUgb25seSB1c2VkIGlmIEJMaW5rIGRldGVjdHMgcm91dGVyXG4gICAgICAgICAgZXhhY3Q6IHRoaXMuZXhhY3QsXG4gICAgICAgICAgYWN0aXZlQ2xhc3M6IHRoaXMuYWN0aXZlQ2xhc3MsXG4gICAgICAgICAgZXhhY3RBY3RpdmVDbGFzczogdGhpcy5leGFjdEFjdGl2ZUNsYXNzLFxuICAgICAgICAgIGFwcGVuZDogdGhpcy5hcHBlbmQsXG4gICAgICAgICAgcmVwbGFjZTogdGhpcy5yZXBsYWNlLFxuICAgICAgICAgIC8vIG51eHQtbGluayBzcGVjaWZpYyBwcm9wXG4gICAgICAgICAgbm9QcmVmZXRjaDogdGhpcy5ub1ByZWZldGNoXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMudXNlUm91dGVyIHx8IGlzT2JqZWN0KGxpbmspKSB7XG4gICAgICAgICAgcHJvcHMudG8gPSBsaW5rO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzLmhyZWYgPSBsaW5rO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgICAgfSxcbiAgICAgIHJlc29sdmVMaW5rOiBmdW5jdGlvbiByZXNvbHZlTGluaygpIHtcbiAgICAgICAgdmFyIHRvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICAgICAgLy8gR2l2ZW4gYSB0byAob3IgaHJlZiBzdHJpbmcpLCBjb252ZXJ0IHRvIG5vcm1hbGl6ZWQgcm91dGUtbGlrZSBzdHJ1Y3R1cmVcbiAgICAgICAgLy8gV29ya3Mgb25seSBjbGllbnQgc2lkZSEhXG4gICAgICAgIHZhciBsaW5rO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQ29udmVydCB0aGUgYHRvYCB0byBhIEhSRUYgdmlhIGEgdGVtcG9yYXJ5IGBhYCB0YWdcbiAgICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgIGxpbmsuaHJlZiA9IGNvbXB1dGVIcmVmKHtcbiAgICAgICAgICAgIHRvOiB0b1xuICAgICAgICAgIH0sICdhJywgJy8nLCAnLycpOyAvLyBXZSBuZWVkIHRvIGFkZCB0aGUgYW5jaG9yIHRvIHRoZSBkb2N1bWVudCB0byBtYWtlIHN1cmUgdGhlXG4gICAgICAgICAgLy8gYHBhdGhuYW1lYCBpcyBjb3JyZWN0bHkgZGV0ZWN0ZWQgaW4gYW55IGJyb3dzZXIgKGkuZS4gSUUpXG5cbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspOyAvLyBPbmNlIGhyZWYgaXMgYXNzaWduZWQsIHRoZSBsaW5rIHdpbGwgYmUgbm9ybWFsaXplZCB0byB0aGUgZnVsbCBVUkwgYml0c1xuXG4gICAgICAgICAgdmFyIF9saW5rMiA9IGxpbmssXG4gICAgICAgICAgICAgIHBhdGhuYW1lID0gX2xpbmsyLnBhdGhuYW1lLFxuICAgICAgICAgICAgICBoYXNoID0gX2xpbmsyLmhhc2gsXG4gICAgICAgICAgICAgIHNlYXJjaCA9IF9saW5rMi5zZWFyY2g7IC8vIFJlbW92ZSBsaW5rIGZyb20gZG9jdW1lbnRcblxuICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGluayk7IC8vIFJldHVybiB0aGUgbG9jYXRpb24gaW4gYSByb3V0ZS1saWtlIG9iamVjdFxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGhuYW1lLFxuICAgICAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgICAgIHF1ZXJ5OiBwYXJzZVF1ZXJ5KHNlYXJjaClcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGluayAmJiBsaW5rLnBhcmVudE5vZGUgJiYgbGluay5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuXG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzb2x2ZVJvdXRlOiBmdW5jdGlvbiByZXNvbHZlUm91dGUoKSB7XG4gICAgICAgIHZhciB0byA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG5cbiAgICAgICAgLy8gR2l2ZW4gYSB0byAob3IgaHJlZiBzdHJpbmcpLCBjb252ZXJ0IHRvIG5vcm1hbGl6ZWQgcm91dGUgbG9jYXRpb24gc3RydWN0dXJlXG4gICAgICAgIC8vIHdvcmtzIG9ubHkgd2hlbiByb3V0ZXIgYXZhaWxhYmxlISFcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcm91dGUgPSB0aGlzLiRyb3V0ZXIucmVzb2x2ZSh0bywgdGhpcy4kcm91dGUpLnJvdXRlO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoOiByb3V0ZS5wYXRoLFxuICAgICAgICAgICAgaGFzaDogcm91dGUuaGFzaCxcbiAgICAgICAgICAgIHF1ZXJ5OiByb3V0ZS5xdWVyeVxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGd1ZXNzQ3VycmVudFBhZ2U6IGZ1bmN0aW9uIGd1ZXNzQ3VycmVudFBhZ2UoKSB7XG4gICAgICAgIHZhciBndWVzcyA9IHRoaXMuY29tcHV0ZWRWYWx1ZTtcbiAgICAgICAgdmFyICRyb3V0ZXIgPSB0aGlzLiRyb3V0ZXI7XG4gICAgICAgIHZhciAkcm91dGUgPSB0aGlzLiRyb3V0ZTsgLy8gVGhpcyBzZWN0aW9uIG9ubHkgb2NjdXJzIGlmIHdlIGFyZSBjbGllbnQgc2lkZSwgb3Igc2VydmVyLXNpZGUgd2l0aCAkcm91dGVyXG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblxuICAgICAgICBpZiAoIXRoaXMubm9QYWdlRGV0ZWN0ICYmICFndWVzcyAmJiAoaXNCcm93c2VyIHx8ICFpc0Jyb3dzZXIgJiYgJHJvdXRlcikpIHtcbiAgICAgICAgICAvLyBDdXJyZW50IHJvdXRlIChpZiByb3V0ZXIgYXZhaWxhYmxlKVxuICAgICAgICAgIHZhciBjdXJyUm91dGUgPSAkcm91dGVyICYmICRyb3V0ZSA/IHtcbiAgICAgICAgICAgIHBhdGg6ICRyb3V0ZS5wYXRoLFxuICAgICAgICAgICAgaGFzaDogJHJvdXRlLmhhc2gsXG4gICAgICAgICAgICBxdWVyeTogJHJvdXRlLnF1ZXJ5XG4gICAgICAgICAgfSA6IHt9OyAvLyBDdXJyZW50IHBhZ2UgZnVsbCBIUkVGIChpZiBjbGllbnQgc2lkZSkuIENhbid0IGJlIGRvbmUgYXMgYSBjb21wdXRlZCBwcm9wIVxuXG4gICAgICAgICAgdmFyIGxvYyA9IGlzQnJvd3NlciA/IHdpbmRvdy5sb2NhdGlvbiB8fCBkb2N1bWVudC5sb2NhdGlvbiA6IG51bGw7XG4gICAgICAgICAgdmFyIGN1cnJMaW5rID0gbG9jID8ge1xuICAgICAgICAgICAgcGF0aDogbG9jLnBhdGhuYW1lLFxuICAgICAgICAgICAgaGFzaDogbG9jLmhhc2gsXG4gICAgICAgICAgICBxdWVyeTogcGFyc2VRdWVyeShsb2Muc2VhcmNoKVxuICAgICAgICAgIH0gOiB7fTsgLy8gTG9vcCB0aHJvdWdoIHRoZSBwb3NzaWJsZSBwYWdlcyBsb29raW5nIGZvciBhIG1hdGNoIHVudGlsIGZvdW5kXG5cbiAgICAgICAgICBmb3IgKHZhciBwYWdlID0gMTsgIWd1ZXNzICYmIHBhZ2UgPD0gdGhpcy5sb2NhbE51bWJlck9mUGFnZXM7IHBhZ2UrKykge1xuICAgICAgICAgICAgdmFyIHRvID0gdGhpcy5tYWtlTGluayhwYWdlKTtcblxuICAgICAgICAgICAgaWYgKCRyb3V0ZXIgJiYgKGlzT2JqZWN0KHRvKSB8fCB0aGlzLnVzZVJvdXRlcikpIHtcbiAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB0aGUgcGFnZSB2aWEgdGhlICRyb3V0ZXJcbiAgICAgICAgICAgICAgZ3Vlc3MgPSBsb29zZUVxdWFsKHRoaXMucmVzb2x2ZVJvdXRlKHRvKSwgY3VyclJvdXRlKSA/IHBhZ2UgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgICAgLy8gSWYgbm8gJHJvdXRlciBhdmFpbGFibGUgKG9yICF0aGlzLnVzZVJvdXRlciB3aGVuIGB0b2AgaXMgYSBzdHJpbmcpXG4gICAgICAgICAgICAgIC8vIHdlIGNvbXBhcmUgdXNpbmcgcGFyc2VkIFVSSXNcbiAgICAgICAgICAgICAgZ3Vlc3MgPSBsb29zZUVxdWFsKHRoaXMucmVzb2x2ZUxpbmsodG8pLCBjdXJyTGluaykgPyBwYWdlIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHByb2JhYmx5IFNTUiwgYnV0IG5vICRyb3V0ZXIgc28gd2UgY2FuJ3QgZ3Vlc3MsIHNvIGxldHMgYnJlYWsgb3V0IG9mXG4gICAgICAgICAgICAgIC8vIHRoZSBsb29wIGVhcmx5XG5cbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgZ3Vlc3MgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gV2Ugc2V0IGN1cnJlbnRQYWdlIHRvIDAgdG8gdHJpZ2dlciBhbiAkZW1pdCgnaW5wdXQnLCBudWxsKVxuICAgICAgICAvLyBBcyB0aGUgZGVmYXVsdCBmb3IgdGhpcy5jdXJyZW50UGFnZSBpcyAtMSB3aGVuIG5vIHZhbHVlIGlzIHNwZWNpZmllZFxuICAgICAgICAvLyBBbmQgdmFsaWQgcGFnZSBudW1iZXJzIGFyZSBncmVhdGVyIHRoYW4gMFxuXG5cbiAgICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IGd1ZXNzID4gMCA/IGd1ZXNzIDogMDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBQYWdpbmF0aW9uTmF2UGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBCUGFnaW5hdGlvbk5hdjogQlBhZ2luYXRpb25OYXZcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEJhc2Ugb24tZGVtYW5kIGNvbXBvbmVudCBmb3IgdG9vbHRpcCAvIHBvcG92ZXIgdGVtcGxhdGVzXG4gIHZhciBOQU1FJHMgPSAnQlZQb3BwZXInO1xuICB2YXIgQXR0YWNobWVudE1hcCQxID0ge1xuICAgIEFVVE86ICdhdXRvJyxcbiAgICBUT1A6ICd0b3AnLFxuICAgIFJJR0hUOiAncmlnaHQnLFxuICAgIEJPVFRPTTogJ2JvdHRvbScsXG4gICAgTEVGVDogJ2xlZnQnLFxuICAgIFRPUExFRlQ6ICd0b3AnLFxuICAgIFRPUFJJR0hUOiAndG9wJyxcbiAgICBSSUdIVFRPUDogJ3JpZ2h0JyxcbiAgICBSSUdIVEJPVFRPTTogJ3JpZ2h0JyxcbiAgICBCT1RUT01MRUZUOiAnYm90dG9tJyxcbiAgICBCT1RUT01SSUdIVDogJ2JvdHRvbScsXG4gICAgTEVGVFRPUDogJ2xlZnQnLFxuICAgIExFRlRCT1RUT006ICdsZWZ0J1xuICB9O1xuICB2YXIgT2Zmc2V0TWFwID0ge1xuICAgIEFVVE86IDAsXG4gICAgVE9QTEVGVDogLTEsXG4gICAgVE9QOiAwLFxuICAgIFRPUFJJR0hUOiArMSxcbiAgICBSSUdIVFRPUDogLTEsXG4gICAgUklHSFQ6IDAsXG4gICAgUklHSFRCT1RUT006ICsxLFxuICAgIEJPVFRPTUxFRlQ6IC0xLFxuICAgIEJPVFRPTTogMCxcbiAgICBCT1RUT01SSUdIVDogKzEsXG4gICAgTEVGVFRPUDogLTEsXG4gICAgTEVGVDogMCxcbiAgICBMRUZUQk9UVE9NOiArMVxuICB9OyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCVlBvcHBlciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogTkFNRSRzLFxuICAgIHByb3BzOiB7XG4gICAgICB0YXJnZXQ6IHtcbiAgICAgICAgLy8gRWxlbWVudCB0aGF0IHRoZSB0b29sdGlwL3BvcG92ZXIgaXMgcG9zaXRpb25lZCByZWxhdGl2ZSB0b1xuICAgICAgICB0eXBlOiBbSFRNTEVsZW1lbnQsIFNWR0VsZW1lbnRdLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgcGxhY2VtZW50OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ3RvcCdcbiAgICAgIH0sXG4gICAgICBmYWxsYmFja1BsYWNlbWVudDoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0sXG4gICAgICAgIGRlZmF1bHQ6ICdmbGlwJ1xuICAgICAgfSxcbiAgICAgIG9mZnNldDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgIH0sXG4gICAgICBib3VuZGFyeToge1xuICAgICAgICAvLyAnc2Nyb2xsUGFyZW50JywgJ3ZpZXdwb3J0JywgJ3dpbmRvdycsIG9yIEVsZW1lbnRcbiAgICAgICAgdHlwZTogW1N0cmluZywgSFRNTEVsZW1lbnRdLFxuICAgICAgICBkZWZhdWx0OiAnc2Nyb2xsUGFyZW50J1xuICAgICAgfSxcbiAgICAgIGJvdW5kYXJ5UGFkZGluZzoge1xuICAgICAgICAvLyBUb29sdGlwL3BvcG92ZXIgd2lsbCB0cnkgYW5kIHN0YXkgYXdheSBmcm9tXG4gICAgICAgIC8vIGJvdW5kYXJ5IGVkZ2UgYnkgdGhpcyBtYW55IHBpeGVsc1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIGRlZmF1bHQ6IDVcbiAgICAgIH0sXG4gICAgICBhcnJvd1BhZGRpbmc6IHtcbiAgICAgICAgLy8gVGhlIG1pbmltdW0gZGlzdGFuY2UgKGluIGBweGApIGZyb20gdGhlIGVkZ2Ugb2YgdGhlXG4gICAgICAgIC8vIHRvb2x0aXAvcG9wb3ZlciB0aGF0IHRoZSBhcnJvdyBjYW4gYmUgcG9zaXRpb25lZFxuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIGRlZmF1bHQ6IDZcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyByZWFjdGl2ZSBwcm9wcyBzZXQgYnkgcGFyZW50XG4gICAgICAgIG5vRmFkZTogZmFsc2UsXG4gICAgICAgIC8vIFN0YXRlIHJlbGF0ZWQgZGF0YVxuICAgICAgICBsb2NhbFNob3c6IHRydWUsXG4gICAgICAgIGF0dGFjaG1lbnQ6IHRoaXMuZ2V0QXR0YWNobWVudCh0aGlzLnBsYWNlbWVudClcbiAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgdGVtcGxhdGVUeXBlOiBmdW5jdGlvbiB0ZW1wbGF0ZVR5cGUoKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHtcbiAgICAgICAgLy8gT3ZlcnJpZGRlbiBieSB0ZW1wbGF0ZSBjb21wb25lbnRcbiAgICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICAgIH0sXG4gICAgICBwb3BwZXJDb25maWc6IGZ1bmN0aW9uIHBvcHBlckNvbmZpZygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgcGxhY2VtZW50ID0gdGhpcy5wbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGxhY2VtZW50OiB0aGlzLmdldEF0dGFjaG1lbnQocGxhY2VtZW50KSxcbiAgICAgICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuZ2V0T2Zmc2V0KHBsYWNlbWVudClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmbGlwOiB7XG4gICAgICAgICAgICAgIGJlaGF2aW9yOiB0aGlzLmZhbGxiYWNrUGxhY2VtZW50XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gYGFycm93LmVsZW1lbnRgIGNhbiBhbHNvIGJlIGEgcmVmZXJlbmNlIHRvIGFuIEhUTUwgRWxlbWVudFxuICAgICAgICAgICAgLy8gbWF5YmUgd2Ugc2hvdWxkIG1ha2UgdGhpcyBhIGAkcmVmYCBpbiB0aGUgdGVtcGxhdGVzP1xuICAgICAgICAgICAgYXJyb3c6IHtcbiAgICAgICAgICAgICAgZWxlbWVudDogJy5hcnJvdydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAgICAgICAgICAgcGFkZGluZzogdGhpcy5ib3VuZGFyeVBhZGRpbmcsXG4gICAgICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiB0aGlzLmJvdW5kYXJ5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoZGF0YSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGZsaXBwaW5nIGFycm93IGNsYXNzZXNcbiAgICAgICAgICAgIGlmIChkYXRhLm9yaWdpbmFsUGxhY2VtZW50ICE9PSBkYXRhLnBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogY2FuJ3QgdGVzdCBpbiBKU0RPTSAqL1xuICAgICAgICAgICAgICBfdGhpcy5wb3BwZXJQbGFjZW1lbnRDaGFuZ2UoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoZGF0YSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGZsaXBwaW5nIGFycm93IGNsYXNzZXNcbiAgICAgICAgICAgIF90aGlzLnBvcHBlclBsYWNlbWVudENoYW5nZShkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIE5vdGU6IFdlIGFyZSBjcmVhdGVkIG9uLWRlbWFuZCwgYW5kIHNob3VsZCBiZSBndWFyYW50ZWVkIHRoYXRcbiAgICAgIC8vIERPTSBpcyByZW5kZXJlZC9yZWFkeSBieSB0aGUgdGltZSB0aGUgY3JlYXRlZCBob29rIHJ1bnNcbiAgICAgIHRoaXMuJF9wb3BwZXIgPSBudWxsOyAvLyBFbnN1cmUgd2Ugc2hvdyBhcyB3ZSBtb3VudFxuXG4gICAgICB0aGlzLmxvY2FsU2hvdyA9IHRydWU7IC8vIENyZWF0ZSBwb3BwZXIgaW5zdGFuY2UgYmVmb3JlIHNob3duXG5cbiAgICAgIHRoaXMuJG9uKCdzaG93JywgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIF90aGlzMi5wb3BwZXJDcmVhdGUoZWwpO1xuICAgICAgfSk7IC8vIFNlbGYgZGVzdHJ1Y3Qgb25jZSBoaWRkZW5cblxuICAgICAgdGhpcy4kb24oJ2hpZGRlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLiRuZXh0VGljayhfdGhpczIuJGRlc3Ryb3kpO1xuICAgICAgfSk7IC8vIElmIHBhcmVudCBpcyBkZXN0cm95ZWQsIGVuc3VyZSB3ZSBhcmUgZGVzdHJveWVkXG5cbiAgICAgIHRoaXMuJHBhcmVudC4kb25jZSgnaG9vazpkZXN0cm95ZWQnLCB0aGlzLiRkZXN0cm95KTtcbiAgICB9LFxuICAgIGJlZm9yZU1vdW50OiBmdW5jdGlvbiBiZWZvcmVNb3VudCgpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBhdHRhY2htZW50IHBvc2l0aW9uIGlzIGNvcnJlY3QgYmVmb3JlIG1vdW50aW5nXG4gICAgICAvLyBhcyBvdXIgcHJvcHNEYXRhIGlzIGFkZGVkIGFmdGVyIGBuZXcgVGVtcGxhdGUoey4uLn0pYFxuICAgICAgdGhpcy5hdHRhY2htZW50ID0gdGhpcy5nZXRBdHRhY2htZW50KHRoaXMucGxhY2VtZW50KTtcbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7Ly8gVEJEXG4gICAgfSxcbiAgICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkKCkge1xuICAgICAgLy8gVXBkYXRlIHBvcHBlciBpZiBuZWVkZWRcbiAgICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGJlIGEgd2F0Y2hlciBvbiBgdGhpcy5wb3BwZXJDb25maWdgIGluc3RlYWQ/XG4gICAgICB0aGlzLnBvcHBlclVwZGF0ZSgpO1xuICAgIH0sXG4gICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgIHRoaXMucG9wcGVyRGVzdHJveSgpO1xuICAgIH0sXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQoKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGVtcGxhdGUgaXMgcmVtb3ZlZCBmcm9tIERPTVxuICAgICAgdmFyIGVsID0gdGhpcy4kZWw7XG4gICAgICBlbCAmJiBlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgLy8gXCJQdWJsaWNcIiBtZXRob2QgdG8gdHJpZ2dlciBoaWRlIHRlbXBsYXRlXG4gICAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICB0aGlzLmxvY2FsU2hvdyA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIC8vIFByaXZhdGVcbiAgICAgIGdldEF0dGFjaG1lbnQ6IGZ1bmN0aW9uIGdldEF0dGFjaG1lbnQocGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiBBdHRhY2htZW50TWFwJDFbU3RyaW5nKHBsYWNlbWVudCkudG9VcHBlckNhc2UoKV0gfHwgJ2F1dG8nO1xuICAgICAgfSxcbiAgICAgIGdldE9mZnNldDogZnVuY3Rpb24gZ2V0T2Zmc2V0KHBsYWNlbWVudCkge1xuICAgICAgICBpZiAoIXRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgLy8gQ291bGQgc2V0IGEgcmVmIGZvciB0aGUgYXJyb3cgZWxlbWVudFxuICAgICAgICAgIHZhciBhcnJvdyA9IHRoaXMuJHJlZnMuYXJyb3cgfHwgc2VsZWN0KCcuYXJyb3cnLCB0aGlzLiRlbCk7XG4gICAgICAgICAgdmFyIGFycm93T2Zmc2V0ID0gKHBhcnNlRmxvYXQoZ2V0Q1MoYXJyb3cpLndpZHRoKSB8fCAwKSArIChwYXJzZUZsb2F0KHRoaXMuYXJyb3dQYWRkaW5nKSB8fCAwKTtcblxuICAgICAgICAgIHN3aXRjaCAoT2Zmc2V0TWFwW1N0cmluZyhwbGFjZW1lbnQpLnRvVXBwZXJDYXNlKCldIHx8IDApIHtcbiAgICAgICAgICAgIGNhc2UgKzE6XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBjYW4ndCB0ZXN0IGluIEpTRE9NICovXG4gICAgICAgICAgICAgIHJldHVybiBcIis1MCVwIC0gXCIuY29uY2F0KGFycm93T2Zmc2V0LCBcInB4XCIpO1xuXG4gICAgICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogY2FuJ3QgdGVzdCBpbiBKU0RPTSAqL1xuICAgICAgICAgICAgICByZXR1cm4gXCItNTAlcCArIFwiLmNvbmNhdChhcnJvd09mZnNldCwgXCJweFwiKTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQ7XG4gICAgICB9LFxuICAgICAgcG9wcGVyQ3JlYXRlOiBmdW5jdGlvbiBwb3BwZXJDcmVhdGUoZWwpIHtcbiAgICAgICAgdGhpcy5wb3BwZXJEZXN0cm95KCk7IC8vIFdlIHVzZSBgZWxgIHJhdGhlciB0aGFuIGB0aGlzLiRlbGAganVzdCBpbiBjYXNlIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyBtb3VudHBvaW50IHJvb3QgZWxlbWVudCB0eXBlIHdhcyBjaGFuZ2VkIGJ5IHRoZSB0ZW1wbGF0ZVxuXG4gICAgICAgIHRoaXMuJF9wb3BwZXIgPSBuZXcgUG9wcGVyKHRoaXMudGFyZ2V0LCBlbCwgdGhpcy5wb3BwZXJDb25maWcpO1xuICAgICAgfSxcbiAgICAgIHBvcHBlckRlc3Ryb3k6IGZ1bmN0aW9uIHBvcHBlckRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuJF9wb3BwZXIgJiYgdGhpcy4kX3BvcHBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuJF9wb3BwZXIgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIHBvcHBlclVwZGF0ZTogZnVuY3Rpb24gcG9wcGVyVXBkYXRlKCkge1xuICAgICAgICB0aGlzLiRfcG9wcGVyICYmIHRoaXMuJF9wb3BwZXIuc2NoZWR1bGVVcGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICBwb3BwZXJQbGFjZW1lbnRDaGFuZ2U6IGZ1bmN0aW9uIHBvcHBlclBsYWNlbWVudENoYW5nZShkYXRhKSB7XG4gICAgICAgIC8vIENhbGxiYWNrIHVzZWQgYnkgcG9wcGVyIHRvIGFkanVzdCB0aGUgYXJyb3cgcGxhY2VtZW50XG4gICAgICAgIHRoaXMuYXR0YWNobWVudCA9IHRoaXMuZ2V0QXR0YWNobWVudChkYXRhLnBsYWNlbWVudCk7XG4gICAgICB9LFxuICAgICAgcmVuZGVyVGVtcGxhdGU6IGZ1bmN0aW9uIHJlbmRlclRlbXBsYXRlKGgpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAge1xuICAgICAgICAvLyBXaWxsIGJlIG92ZXJyaWRkZW4gYnkgdGVtcGxhdGVzXG4gICAgICAgIHJldHVybiBoKCdkaXYnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAvLyBOb3RlOiBgc2hvd2AgYW5kICdmYWRlJyBjbGFzc2VzIGFyZSBvbmx5IGFwcGxlZCBkdXJpbmcgdHJhbnNpdGlvblxuICAgICAgcmV0dXJuIGgoQlZUcmFuc2l0aW9uLCB7XG4gICAgICAgIC8vIFRyYW5zaXRpb25zIGFzIHNvb24gYXMgbW91bnRlZFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGFwcGVhcjogdHJ1ZSxcbiAgICAgICAgICBub0ZhZGU6IHRoaXMubm9GYWRlXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgLy8gRXZlbnRzIHVzZWQgYnkgcGFyZW50IGNvbXBvbmVudC9pbnN0YW5jZVxuICAgICAgICAgIGJlZm9yZUVudGVyOiBmdW5jdGlvbiBiZWZvcmVFbnRlcihlbCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy4kZW1pdCgnc2hvdycsIGVsKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFmdGVyRW50ZXI6IGZ1bmN0aW9uIGFmdGVyRW50ZXIoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuJGVtaXQoJ3Nob3duJywgZWwpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYmVmb3JlTGVhdmU6IGZ1bmN0aW9uIGJlZm9yZUxlYXZlKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLiRlbWl0KCdoaWRlJywgZWwpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWZ0ZXJMZWF2ZTogZnVuY3Rpb24gYWZ0ZXJMZWF2ZShlbCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy4kZW1pdCgnaGlkZGVuJywgZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgW3RoaXMubG9jYWxTaG93ID8gdGhpcy5yZW5kZXJUZW1wbGF0ZShoKSA6IGgoKV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIE5BTUUkdCA9ICdCVlRvb2x0aXBUZW1wbGF0ZSc7IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJWVG9vbHRpcFRlbXBsYXRlID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiBOQU1FJHQsXG4gICAgZXh0ZW5kczogQlZQb3BwZXIsXG4gICAgbWl4aW5zOiBbc2NvcGVkU3R5bGVBdHRyc01peGluXSxcbiAgICBwcm9wczoge1xuICAgICAgLy8gT3RoZXIgbm9uLXJlYWN0aXZlICh3aGlsZSBvcGVuKSBwcm9wcyBhcmUgcHVsbGVkIGluIGZyb20gQlZQb3BwZXJcbiAgICAgIGlkOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIGh0bWw6IHtcbiAgICAgICAgLy8gVXNlZCBvbmx5IGJ5IHRoZSBkaXJlY3RpdmUgdmVyc2lvbnNcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAvLyBXZSB1c2UgZGF0YSwgcmF0aGVyIHRoYW4gcHJvcHMgdG8gZW5zdXJlIHJlYWN0aXZpdHlcbiAgICAgIC8vIFBhcmVudCBjb21wb25lbnQgd2lsbCBkaXJlY3RseSBzZXQgdGhpcyBkYXRhXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZTogJycsXG4gICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICB2YXJpYW50OiBudWxsLFxuICAgICAgICBjdXN0b21DbGFzczogbnVsbCxcbiAgICAgICAgaW50ZXJhY3RpdmU6IHRydWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgdGVtcGxhdGVUeXBlOiBmdW5jdGlvbiB0ZW1wbGF0ZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiAndG9vbHRpcCc7XG4gICAgICB9LFxuICAgICAgdGVtcGxhdGVDbGFzc2VzOiBmdW5jdGlvbiB0ZW1wbGF0ZUNsYXNzZXMoKSB7XG4gICAgICAgIHZhciBfcmVmO1xuXG4gICAgICAgIHJldHVybiBbKF9yZWYgPSB7XG4gICAgICAgICAgLy8gRGlzYWJsZXMgcG9pbnRlciBldmVudHMgdG8gaGlkZSB0aGUgdG9vbHRpcCB3aGVuIHRoZSB1c2VyXG4gICAgICAgICAgLy8gaG92ZXJzIG92ZXIgaXRzIGNvbnRlbnRcbiAgICAgICAgICBub25pbnRlcmFjdGl2ZTogIXRoaXMuaW50ZXJhY3RpdmVcbiAgICAgICAgfSwgX2RlZmluZVByb3BlcnR5KF9yZWYsIFwiYi1cIi5jb25jYXQodGhpcy50ZW1wbGF0ZVR5cGUsIFwiLVwiKS5jb25jYXQodGhpcy52YXJpYW50KSwgdGhpcy52YXJpYW50KSwgX2RlZmluZVByb3BlcnR5KF9yZWYsIFwiYnMtXCIuY29uY2F0KHRoaXMudGVtcGxhdGVUeXBlLCBcIi1cIikuY29uY2F0KHRoaXMuYXR0YWNobWVudCksIHRoaXMuYXR0YWNobWVudCksIF9yZWYpLCB0aGlzLmN1c3RvbUNsYXNzXTtcbiAgICAgIH0sXG4gICAgICB0ZW1wbGF0ZUF0dHJpYnV0ZXM6IGZ1bmN0aW9uIHRlbXBsYXRlQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICByb2xlOiAndG9vbHRpcCcsXG4gICAgICAgICAgdGFiaW5kZXg6ICctMSdcbiAgICAgICAgfSwgdGhpcy5zY29wZWRTdHlsZUF0dHJzKTtcbiAgICAgIH0sXG4gICAgICB0ZW1wbGF0ZUxpc3RlbmVyczogZnVuY3Rpb24gdGVtcGxhdGVMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgLy8gVXNlZCBmb3IgaG92ZXIvZm9jdXMgdHJpZ2dlciBsaXN0ZW5lcnNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb3VzZWVudGVyOiBmdW5jdGlvbiBtb3VzZWVudGVyKGV2dCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byB0ZXN0IGluIEpTRE9NICovXG4gICAgICAgICAgICBfdGhpcy4kZW1pdCgnbW91c2VlbnRlcicsIGV2dCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtb3VzZWxlYXZlOiBmdW5jdGlvbiBtb3VzZWxlYXZlKGV2dCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byB0ZXN0IGluIEpTRE9NICovXG4gICAgICAgICAgICBfdGhpcy4kZW1pdCgnbW91c2VsZWF2ZScsIGV2dCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb2N1c2luOiBmdW5jdGlvbiBmb2N1c2luKGV2dCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byB0ZXN0IGluIEpTRE9NICovXG4gICAgICAgICAgICBfdGhpcy4kZW1pdCgnZm9jdXNpbicsIGV2dCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb2N1c291dDogZnVuY3Rpb24gZm9jdXNvdXQoZXZ0KSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIHRlc3QgaW4gSlNET00gKi9cbiAgICAgICAgICAgIF90aGlzLiRlbWl0KCdmb2N1c291dCcsIGV2dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgcmVuZGVyVGVtcGxhdGU6IGZ1bmN0aW9uIHJlbmRlclRlbXBsYXRlKGgpIHtcbiAgICAgICAgLy8gVGl0bGUgY2FuIGJlIGEgc2NvcGVkIHNsb3QgZnVuY3Rpb25cbiAgICAgICAgdmFyICR0aXRsZSA9IGlzRnVuY3Rpb24odGhpcy50aXRsZSkgPyB0aGlzLnRpdGxlKHt9KSA6IGlzVW5kZWZpbmVkT3JOdWxsKHRoaXMudGl0bGUpID8gaCgpIDogdGhpcy50aXRsZTsgLy8gRGlyZWN0aXZlIHZlcnNpb25zIG9ubHlcblxuICAgICAgICB2YXIgZG9tUHJvcHMgPSB0aGlzLmh0bWwgJiYgIWlzRnVuY3Rpb24odGhpcy50aXRsZSkgPyB7XG4gICAgICAgICAgaW5uZXJIVE1MOiB0aGlzLnRpdGxlXG4gICAgICAgIH0gOiB7fTtcbiAgICAgICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogJ3Rvb2x0aXAgYi10b29sdGlwJyxcbiAgICAgICAgICBjbGFzczogdGhpcy50ZW1wbGF0ZUNsYXNzZXMsXG4gICAgICAgICAgYXR0cnM6IHRoaXMudGVtcGxhdGVBdHRyaWJ1dGVzLFxuICAgICAgICAgIG9uOiB0aGlzLnRlbXBsYXRlTGlzdGVuZXJzXG4gICAgICAgIH0sIFtoKCdkaXYnLCB7XG4gICAgICAgICAgcmVmOiAnYXJyb3cnLFxuICAgICAgICAgIHN0YXRpY0NsYXNzOiAnYXJyb3cnXG4gICAgICAgIH0pLCBoKCdkaXYnLCB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICd0b29sdGlwLWlubmVyJyxcbiAgICAgICAgICBkb21Qcm9wczogZG9tUHJvcHNcbiAgICAgICAgfSwgWyR0aXRsZV0pXSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB2YXIgTkFNRSR1ID0gJ0JWVG9vbHRpcCc7IC8vIE1vZGFsIGNvbnRhaW5lciBzZWxlY3RvciBmb3IgYXBwZW5kaW5nIHRvb2x0aXAvcG9wb3ZlclxuXG4gIHZhciBNT0RBTF9TRUxFQ1RPUiA9ICcubW9kYWwtY29udGVudCc7IC8vIE1vZGFsIGAkcm9vdGAgaGlkZGVuIGV2ZW50XG5cbiAgdmFyIE1PREFMX0NMT1NFX0VWRU5UID0gJ2J2Ojptb2RhbDo6aGlkZGVuJzsgLy8gRm9yIGRyb3Bkb3duIHNuaWZmaW5nXG5cbiAgdmFyIERST1BET1dOX0NMQVNTID0gJ2Ryb3Bkb3duJztcbiAgdmFyIERST1BET1dOX09QRU5fU0VMRUNUT1IgPSAnLmRyb3Bkb3duLW1lbnUuc2hvdyc7IC8vIERhdGEgc3BlY2lmaWMgdG8gcG9wcGVyIGFuZCB0ZW1wbGF0ZVxuICAvLyBXZSBkb24ndCB1c2UgcHJvcHMsIGFzIHdlIG5lZWQgcmVhY3Rpdml0eSAod2UgY2FuJ3QgcGFzcyByZWFjdGl2ZSBwcm9wcylcblxuICB2YXIgdGVtcGxhdGVEYXRhID0ge1xuICAgIC8vIFRleHQgc3RyaW5nIG9yIFNjb3BlZCBzbG90IGZ1bmN0aW9uXG4gICAgdGl0bGU6ICcnLFxuICAgIC8vIFRleHQgc3RyaW5nIG9yIFNjb3BlZCBzbG90IGZ1bmN0aW9uXG4gICAgY29udGVudDogJycsXG4gICAgLy8gU3RyaW5nXG4gICAgdmFyaWFudDogbnVsbCxcbiAgICAvLyBTdHJpbmcsIEFycmF5LCBPYmplY3RcbiAgICBjdXN0b21DbGFzczogbnVsbCxcbiAgICAvLyBTdHJpbmcgb3IgYXJyYXkgb2YgU3RyaW5ncyAob3ZlcndyaXR0ZW4gYnkgQlZQb3BwZXIpXG4gICAgdHJpZ2dlcnM6ICcnLFxuICAgIC8vIFN0cmluZyAob3ZlcndyaXR0ZW4gYnkgQlZQb3BwZXIpXG4gICAgcGxhY2VtZW50OiAnYXV0bycsXG4gICAgLy8gU3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3NcbiAgICBmYWxsYmFja1BsYWNlbWVudDogJ2ZsaXAnLFxuICAgIC8vIEVsZW1lbnQgb3IgQ29tcG9uZW50IHJlZmVyZW5jZSAob3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGVsZW1lbnQpIG9mXG4gICAgLy8gdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGhhdmUgdGhlIHRyaWdnZXIgZXZlbnRzIGJvdW5kLCBhbmQgaXMgYWxzb1xuICAgIC8vIGRlZmF1bHQgZWxlbWVudCBmb3IgcG9zaXRpb25pbmdcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgLy8gSFRNTCBJRCwgRWxlbWVudCBvciBDb21wb25lbnQgcmVmZXJlbmNlXG4gICAgY29udGFpbmVyOiBudWxsLFxuICAgIC8vICdib2R5J1xuICAgIC8vIEJvb2xlYW5cbiAgICBub0ZhZGU6IGZhbHNlLFxuICAgIC8vICdzY3JvbGxQYXJlbnQnLCAndmlld3BvcnQnLCAnd2luZG93JywgRWxlbWVudCwgb3IgQ29tcG9uZW50IHJlZmVyZW5jZVxuICAgIGJvdW5kYXJ5OiAnc2Nyb2xsUGFyZW50JyxcbiAgICAvLyBUb29sdGlwL3BvcG92ZXIgd2lsbCB0cnkgYW5kIHN0YXkgYXdheSBmcm9tXG4gICAgLy8gYm91bmRhcnkgZWRnZSBieSB0aGlzIG1hbnkgcGl4ZWxzIChOdW1iZXIpXG4gICAgYm91bmRhcnlQYWRkaW5nOiA1LFxuICAgIC8vIEFycm93IG9mZnNldCAoTnVtYmVyKVxuICAgIG9mZnNldDogMCxcbiAgICAvLyBIb3Zlci9mb2N1cyBkZWxheSAoTnVtYmVyIG9yIE9iamVjdClcbiAgICBkZWxheTogMCxcbiAgICAvLyBBcnJvdyBvZiBUb29sdGlwL3BvcG92ZXIgd2lsbCB0cnkgYW5kIHN0YXkgYXdheSBmcm9tXG4gICAgLy8gdGhlIGVkZ2Ugb2YgdG9vbHRpcC9wb3BvdmVyIGVkZ2UgYnkgdGhpcyBtYW55IHBpeGVsc1xuICAgIGFycm93UGFkZGluZzogNixcbiAgICAvLyBJbnRlcmFjdGl2ZSBzdGF0ZSAoQm9vbGVhbilcbiAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICAvLyBEaXNhYmxlZCBzdGF0ZSAoQm9vbGVhbilcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgLy8gSUQgdG8gdXNlIGZvciB0b29sdGlwL3BvcG92ZXJcbiAgICBpZDogbnVsbCxcbiAgICAvLyBGbGFnIHVzZWQgYnkgZGlyZWN0aXZlcyBvbmx5LCBmb3IgSFRNTCBjb250ZW50XG4gICAgaHRtbDogZmFsc2VcbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQlZUb29sdGlwID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiBOQU1FJHUsXG4gICAgcHJvcHM6IHsvLyBOb25lXG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHt9LCB0ZW1wbGF0ZURhdGEsIHtcbiAgICAgICAgLy8gU3RhdGUgbWFuYWdlbWVudCBkYXRhXG4gICAgICAgIGFjdGl2ZVRyaWdnZXI6IHtcbiAgICAgICAgICAvLyBtYW51YWw6IGZhbHNlLFxuICAgICAgICAgIGhvdmVyOiBmYWxzZSxcbiAgICAgICAgICBjbGljazogZmFsc2UsXG4gICAgICAgICAgZm9jdXM6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGxvY2FsU2hvdzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIHRlbXBsYXRlVHlwZTogZnVuY3Rpb24gdGVtcGxhdGVUeXBlKCkge1xuICAgICAgICAvLyBPdmVyd3JpdHRlbiBieSBCVlBvcG92ZXJcbiAgICAgICAgcmV0dXJuICd0b29sdGlwJztcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZElkOiBmdW5jdGlvbiBjb21wdXRlZElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZCB8fCBcIl9fYnZfXCIuY29uY2F0KHRoaXMudGVtcGxhdGVUeXBlLCBcIl9cIikuY29uY2F0KHRoaXMuX3VpZCwgXCJfX1wiKTtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZERlbGF5OiBmdW5jdGlvbiBjb21wdXRlZERlbGF5KCkge1xuICAgICAgICAvLyBOb3JtYWxpemVzIGRlbGF5IGludG8gb2JqZWN0IGZvcm1cbiAgICAgICAgdmFyIGRlbGF5ID0ge1xuICAgICAgICAgIHNob3c6IDAsXG4gICAgICAgICAgaGlkZTogMFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHRoaXMuZGVsYXkpKSB7XG4gICAgICAgICAgZGVsYXkuc2hvdyA9IE1hdGgubWF4KHBhcnNlSW50KHRoaXMuZGVsYXkuc2hvdywgMTApIHx8IDAsIDApO1xuICAgICAgICAgIGRlbGF5LmhpZGUgPSBNYXRoLm1heChwYXJzZUludCh0aGlzLmRlbGF5LmhpZGUsIDEwKSB8fCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcih0aGlzLmRlbGF5KSB8fCBpc1N0cmluZyh0aGlzLmRlbGF5KSkge1xuICAgICAgICAgIGRlbGF5LnNob3cgPSBkZWxheS5oaWRlID0gTWF0aC5tYXgocGFyc2VJbnQodGhpcy5kZWxheSwgMTApIHx8IDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlbGF5O1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkVHJpZ2dlcnM6IGZ1bmN0aW9uIGNvbXB1dGVkVHJpZ2dlcnMoKSB7XG4gICAgICAgIC8vIFJldHVybnMgdGhlIHRyaWdnZXJzIGluIHNvcnRlZCBhcnJheSBmb3JtXG4gICAgICAgIC8vIFRPRE86IFN3aXRjaCB0aGlzIHRvIG9iamVjdCBmb3JtIGZvciBlYXNpZXIgbG9va3VwXG4gICAgICAgIHJldHVybiBjb25jYXQodGhpcy50cmlnZ2VycykuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKS50cmltKCkudG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKy8pLnNvcnQoKTtcbiAgICAgIH0sXG4gICAgICBpc1dpdGhBY3RpdmVUcmlnZ2VyOiBmdW5jdGlvbiBpc1dpdGhBY3RpdmVUcmlnZ2VyKCkge1xuICAgICAgICBmb3IgKHZhciB0cmlnZ2VyIGluIHRoaXMuYWN0aXZlVHJpZ2dlcikge1xuICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVRyaWdnZXJbdHJpZ2dlcl0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZFRlbXBsYXRlRGF0YTogZnVuY3Rpb24gY29tcHV0ZWRUZW1wbGF0ZURhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgICAgICAgY29udGVudDogdGhpcy5jb250ZW50LFxuICAgICAgICAgIHZhcmlhbnQ6IHRoaXMudmFyaWFudCxcbiAgICAgICAgICBjdXN0b21DbGFzczogdGhpcy5jdXN0b21DbGFzcyxcbiAgICAgICAgICBub0ZhZGU6IHRoaXMubm9GYWRlLFxuICAgICAgICAgIGludGVyYWN0aXZlOiB0aGlzLmludGVyYWN0aXZlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgY29tcHV0ZWRUcmlnZ2VyczogZnVuY3Rpb24gY29tcHV0ZWRUcmlnZ2VycyhuZXdUcmlnZ2Vycywgb2xkVHJpZ2dlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAvLyBUcmlnZ2VycyBoYXZlIGNoYW5nZWQsIHNvIHJlLXJlZ2lzdGVyIHRoZW1cblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoIWxvb3NlRXF1YWwobmV3VHJpZ2dlcnMsIG9sZFRyaWdnZXJzKSkge1xuICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIERpc2FibGUgdHJpZ2dlciBsaXN0ZW5lcnNcbiAgICAgICAgICAgIF90aGlzLnVuTGlzdGVuKCk7IC8vIENsZWFyIGFueSBhY3RpdmUgdHJpZ2dlcnMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBsaXN0IG9mIHRyaWdnZXJzXG5cblxuICAgICAgICAgICAgb2xkVHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJpZ2dlcikge1xuICAgICAgICAgICAgICBpZiAoIWFycmF5SW5jbHVkZXMobmV3VHJpZ2dlcnMsIHRyaWdnZXIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmFjdGl2ZVRyaWdnZXJbdHJpZ2dlcl0pIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZVRyaWdnZXJbdHJpZ2dlcl0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pOyAvLyBSZS1lbmFibGUgdGhlIHRyaWdnZXIgbGlzdGVuZXJzXG5cbiAgICAgICAgICAgIF90aGlzLmxpc3RlbigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRUZW1wbGF0ZURhdGE6IGZ1bmN0aW9uIGNvbXB1dGVkVGVtcGxhdGVEYXRhKCkge1xuICAgICAgICAvLyBJZiBhbnkgb2YgdGhlIHdoaWxlIG9wZW4gcmVhY3RpdmUgXCJwcm9wc1wiIGNoYW5nZSxcbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHRlbXBsYXRlIHVwZGF0ZXMgYWNjb3JkaW5nbHlcbiAgICAgICAgdGhpcy5oYW5kbGVUZW1wbGF0ZVVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIGRpc2FibGVkOiBmdW5jdGlvbiBkaXNhYmxlZChuZXdWYWwpIHtcbiAgICAgICAgbmV3VmFsID8gdGhpcy5kaXNhYmxlKCkgOiB0aGlzLmVuYWJsZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBDcmVhdGUgbm9uLXJlYWN0aXZlIHByb3BlcnRpZXNcbiAgICAgIHRoaXMuJF90aXAgPSBudWxsO1xuICAgICAgdGhpcy4kX2hvdmVyVGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLiRfaG92ZXJTdGF0ZSA9ICcnO1xuICAgICAgdGhpcy4kX3Zpc2libGVJbnRlcnZhbCA9IG51bGw7XG4gICAgICB0aGlzLiRfZW5hYmxlZCA9ICF0aGlzLmRpc2FibGVkO1xuICAgICAgdGhpcy4kX25vb3AgPSBub29wLmJpbmQodGhpcyk7IC8vIERlc3Ryb3kgb3Vyc2VsdmVzIHdoZW4gdGhlIHBhcmVudCBpcyBkZXN0cm95ZWRcblxuICAgICAgaWYgKHRoaXMuJHBhcmVudCkge1xuICAgICAgICB0aGlzLiRwYXJlbnQuJG9uY2UoJ2hvb2s6YmVmb3JlRGVzdHJveScsIHRoaXMuJGRlc3Ryb3kpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBfdGhpczIuZ2V0VGFyZ2V0KCk7XG5cbiAgICAgICAgaWYgKHRhcmdldCAmJiBjb250YWlucyhkb2N1bWVudC5ib2R5LCB0YXJnZXQpKSB7XG4gICAgICAgICAgLy8gQ29weSB0aGUgcGFyZW50J3Mgc2NvcGVkIHN0eWxlIGF0dHJpYnV0ZVxuICAgICAgICAgIF90aGlzMi5zY29wZUlkID0gZ2V0U2NvcGVJZChfdGhpczIuJHBhcmVudCk7IC8vIFNldCB1cCBhbGwgdHJpZ2dlciBoYW5kbGVycyBhbmQgbGlzdGVuZXJzXG5cbiAgICAgICAgICBfdGhpczIubGlzdGVuKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICB3YXJuKCdVbmFibGUgdG8gZmluZCB0YXJnZXQgZWxlbWVudCBpbiBkb2N1bWVudC4nLCBfdGhpczIudGVtcGxhdGVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkKClcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHtcbiAgICAgIC8vIFVzdWFsbHkgY2FsbGVkIHdoZW4gdGhlIHNsb3RzL2RhdGEgY2hhbmdlc1xuICAgICAgdGhpcy4kbmV4dFRpY2sodGhpcy5oYW5kbGVUZW1wbGF0ZVVwZGF0ZSk7XG4gICAgfSxcbiAgICBkZWFjdGl2YXRlZDogZnVuY3Rpb24gZGVhY3RpdmF0ZWQoKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAge1xuICAgICAgLy8gSW4gYSBrZWVwYWxpdmUgdGhhdCBoYXMgYmVlbiBkZWFjdGl2YXRlZCwgc28gaGlkZVxuICAgICAgLy8gdGhlIHRvb2x0aXAvcG9wb3ZlciBpZiBpdCBpcyBzaG93aW5nXG4gICAgICB0aGlzLmZvcmNlSGlkZSgpO1xuICAgIH0sXG4gICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB7XG4gICAgICAvLyBSZW1vdmUgYWxsIGhhbmRsZXIvbGlzdGVuZXJzXG4gICAgICB0aGlzLnVuTGlzdGVuKCk7XG4gICAgICB0aGlzLnNldFdoaWxlT3Blbkxpc3RlbmVycyhmYWxzZSk7IC8vIENsZWFyIGFueSB0aW1lb3V0cy9pbnRlcnZhbHNcblxuICAgICAgdGhpcy5jbGVhckhvdmVyVGltZW91dCgpO1xuICAgICAgdGhpcy5jbGVhclZpc2liaWxpdHlJbnRlcnZhbCgpOyAvLyBEZXN0cm95IHRoZSB0ZW1wbGF0ZVxuXG4gICAgICB0aGlzLmRlc3Ryb3lUZW1wbGF0ZSgpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgLy8gLS0tIE1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBkZXN0cm95aW5nIHRoZSB0ZW1wbGF0ZSAtLS1cbiAgICAgIGdldFRlbXBsYXRlOiBmdW5jdGlvbiBnZXRUZW1wbGF0ZSgpIHtcbiAgICAgICAgLy8gT3ZlcnJpZGRlbiBieSBCVlBvcG92ZXJcbiAgICAgICAgcmV0dXJuIEJWVG9vbHRpcFRlbXBsYXRlO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZURhdGE6IGZ1bmN0aW9uIHVwZGF0ZURhdGEoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgLy8gTWV0aG9kIGZvciB1cGRhdGluZyBwb3BwZXIvdGVtcGxhdGUgZGF0YVxuICAgICAgICAvLyBXZSBvbmx5IHVwZGF0ZSBkYXRhIGlmIGl0IGV4aXN0cywgYW5kIGhhcyBub3QgY2hhbmdlZFxuICAgICAgICB2YXIgdGl0bGVVcGRhdGVkID0gZmFsc2U7XG4gICAgICAgIGtleXModGVtcGxhdGVEYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChkYXRhW3Byb3BdKSAmJiBfdGhpczNbcHJvcF0gIT09IGRhdGFbcHJvcF0pIHtcbiAgICAgICAgICAgIF90aGlzM1twcm9wXSA9IGRhdGFbcHJvcF07XG5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAndGl0bGUnKSB7XG4gICAgICAgICAgICAgIHRpdGxlVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGl0bGVVcGRhdGVkICYmIHRoaXMubG9jYWxTaG93KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHRpdGxlIGhhcyB1cGRhdGVkLCB3ZSBtYXkgbmVlZCB0byBoYW5kbGUgdGhlIHRpdGxlXG4gICAgICAgICAgLy8gYXR0cmlidXRlIG9uIHRoZSB0cmlnZ2VyIHRhcmdldC4gV2Ugb25seSBkbyB0aGlzIHdoaWxlIHRoZVxuICAgICAgICAgIC8vIHRlbXBsYXRlIGlzIG9wZW5cbiAgICAgICAgICB0aGlzLmZpeFRpdGxlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVUZW1wbGF0ZUFuZFNob3c6IGZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlQW5kU2hvdygpIHtcbiAgICAgICAgLy8gQ3JlYXRlcyB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgYW5kIHNob3cgaXRcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgIHZhciBUZW1wbGF0ZSA9IHRoaXMuZ2V0VGVtcGxhdGUoKTtcbiAgICAgICAgdmFyICR0aXAgPSB0aGlzLiRfdGlwID0gbmV3IFRlbXBsYXRlKHtcbiAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBpcyBub3QgcmVhY3RpdmUgdG8gY2hhbmdlcyBpbiB0aGUgcHJvcHMgZGF0YVxuICAgICAgICAgIHByb3BzRGF0YToge1xuICAgICAgICAgICAgLy8gVGhlc2UgdmFsdWVzIGNhbm5vdCBiZSBjaGFuZ2VkIHdoaWxlIHRlbXBsYXRlIGlzIHNob3dpbmdcbiAgICAgICAgICAgIGlkOiB0aGlzLmNvbXB1dGVkSWQsXG4gICAgICAgICAgICBodG1sOiB0aGlzLmh0bWwsXG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHRoaXMucGxhY2VtZW50LFxuICAgICAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnQ6IHRoaXMuZmFsbGJhY2tQbGFjZW1lbnQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuZ2V0UGxhY2VtZW50VGFyZ2V0KCksXG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5nZXRCb3VuZGFyeSgpLFxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBmb2xsb3dpbmcgYXJlIGludGVnZXJzXG4gICAgICAgICAgICBvZmZzZXQ6IHBhcnNlSW50KHRoaXMub2Zmc2V0LCAxMCkgfHwgMCxcbiAgICAgICAgICAgIGFycm93UGFkZGluZzogcGFyc2VJbnQodGhpcy5hcnJvd1BhZGRpbmcsIDEwKSB8fCAwLFxuICAgICAgICAgICAgYm91bmRhcnlQYWRkaW5nOiBwYXJzZUludCh0aGlzLmJvdW5kYXJ5UGFkZGluZywgMTApIHx8IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBXZSBzZXQgdGhlIGluaXRpYWwgcmVhY3RpdmUgZGF0YSAodmFsdWVzIHRoYXQgY2FuIGJlIGNoYW5nZWQgd2hpbGUgb3BlbilcblxuICAgICAgICB0aGlzLmhhbmRsZVRlbXBsYXRlVXBkYXRlKCk7IC8vIFRlbXBsYXRlIHRyYW5zaXRpb24gcGhhc2UgZXZlbnRzIChoYW5kbGVkIG9uY2Ugb25seSlcbiAgICAgICAgLy8gV2hlbiB0aGUgdGVtcGxhdGUgaGFzIG1vdW50ZWQsIGJ1dCBub3QgdmlzaWJseSBzaG93biB5ZXRcblxuICAgICAgICAkdGlwLiRvbmNlKCdzaG93JywgdGhpcy5vblRlbXBsYXRlU2hvdyk7IC8vIFdoZW4gdGhlIHRlbXBsYXRlIGhhcyBjb21wbGV0ZWQgc2hvd2luZ1xuXG4gICAgICAgICR0aXAuJG9uY2UoJ3Nob3duJywgdGhpcy5vblRlbXBsYXRlU2hvd24pOyAvLyBXaGVuIHRoZSB0ZW1wbGF0ZSBoYXMgc3RhcnRlZCB0byBoaWRlXG5cbiAgICAgICAgJHRpcC4kb25jZSgnaGlkZScsIHRoaXMub25UZW1wbGF0ZUhpZGUpOyAvLyBXaGVuIHRoZSB0ZW1wbGF0ZSBoYXMgY29tcGxldGVkIGhpZGluZ1xuXG4gICAgICAgICR0aXAuJG9uY2UoJ2hpZGRlbicsIHRoaXMub25UZW1wbGF0ZUhpZGRlbik7IC8vIFdoZW4gdGhlIHRlbXBsYXRlIGdldHMgZGVzdHJveWVkIGZvciBhbnkgcmVhc29uXG5cbiAgICAgICAgJHRpcC4kb25jZSgnaG9vazpkZXN0cm95ZWQnLCB0aGlzLmRlc3Ryb3lUZW1wbGF0ZSk7IC8vIENvbnZlbmllbmNlIGV2ZW50cyBmcm9tIHRlbXBsYXRlXG4gICAgICAgIC8vIFRvIHNhdmUgdXMgZnJvbSBtYW51YWxseSBhZGRpbmcvcmVtb3ZpbmcgRE9NXG4gICAgICAgIC8vIGxpc3RlbmVycyB0byB0aXAgZWxlbWVudCB3aGVuIGl0IGlzIG9wZW5cblxuICAgICAgICAkdGlwLiRvbignZm9jdXNpbicsIHRoaXMuaGFuZGxlRXZlbnQpO1xuICAgICAgICAkdGlwLiRvbignZm9jdXNvdXQnLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgJHRpcC4kb24oJ21vdXNlZW50ZXInLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgJHRpcC4kb24oJ21vdXNlbGVhdmUnLCB0aGlzLmhhbmRsZUV2ZW50KTsgLy8gTW91bnQgKHdoaWNoIHRyaWdnZXJzIHRoZSBgc2hvd2ApXG5cbiAgICAgICAgJHRpcC4kbW91bnQoY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKSk7IC8vIFRlbXBsYXRlIHdpbGwgYXV0b21hdGljYWxseSByZW1vdmUgaXRzIG1hcmt1cCBmcm9tIERPTSB3aGVuIGhpZGRlblxuICAgICAgfSxcbiAgICAgIGhpZGVUZW1wbGF0ZTogZnVuY3Rpb24gaGlkZVRlbXBsYXRlKCkge1xuICAgICAgICAvLyBUcmlnZ2VyIHRoZSB0ZW1wbGF0ZSB0byBzdGFydCBoaWRpbmdcbiAgICAgICAgLy8gVGhlIHRlbXBsYXRlIHdpbGwgZW1pdCB0aGUgYGhpZGVgIGV2ZW50IGFmdGVyIHRoaXMgYW5kXG4gICAgICAgIC8vIHRoZW4gZW1pdCB0aGUgYGhpZGRlbmAgZXZlbnQgb25jZSBpdCBpcyBmdWxseSBoaWRkZW5cbiAgICAgICAgLy8gVGhlIGBob29rOmRlc3Ryb3llZGAgd2lsbCBhbHNvIGJlIGNhbGxlZCAoc2FmZXR5IG1lYXN1cmUpXG4gICAgICAgIHRoaXMuJF90aXAgJiYgdGhpcy4kX3RpcC5oaWRlKCk7IC8vIENsZWFyIG91dCBhbnkgc3RyYWdnaW5nIGFjdGl2ZSB0cmlnZ2Vyc1xuXG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmVUcmlnZ2VycygpOyAvLyBSZXNldCB0aGUgaG92ZXIgc3RhdGVcblxuICAgICAgICB0aGlzLiRfaG92ZXJTdGF0ZSA9ICcnO1xuICAgICAgfSxcbiAgICAgIC8vIERlc3Ryb3kgdGhlIHRlbXBsYXRlIGluc3RhbmNlIGFuZCByZXNldCBzdGF0ZVxuICAgICAgZGVzdHJveVRlbXBsYXRlOiBmdW5jdGlvbiBkZXN0cm95VGVtcGxhdGUoKSB7XG4gICAgICAgIHRoaXMuc2V0V2hpbGVPcGVuTGlzdGVuZXJzKGZhbHNlKTtcbiAgICAgICAgdGhpcy5jbGVhckhvdmVyVGltZW91dCgpO1xuICAgICAgICB0aGlzLiRfaG92ZXJTdGF0ZSA9ICcnO1xuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlVHJpZ2dlcnMoKTtcbiAgICAgICAgdGhpcy5sb2NhbFBsYWNlbWVudFRhcmdldCA9IG51bGw7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLiRfdGlwICYmIHRoaXMuJF90aXAuJGRlc3Ryb3koKTtcbiAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkge31cblxuICAgICAgICB0aGlzLiRfdGlwID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW1vdmVBcmlhRGVzY3JpYmVkYnkoKTtcbiAgICAgICAgdGhpcy5yZXN0b3JlVGl0bGUoKTtcbiAgICAgICAgdGhpcy5sb2NhbFNob3cgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBnZXRUZW1wbGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uIGdldFRlbXBsYXRlRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJF90aXAgPyB0aGlzLiRfdGlwLiRlbCA6IG51bGw7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVGVtcGxhdGVVcGRhdGU6IGZ1bmN0aW9uIGhhbmRsZVRlbXBsYXRlVXBkYXRlKCkge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICAvLyBVcGRhdGUgb3VyIHRlbXBsYXRlIHRpdGxlL2NvbnRlbnQgXCJwcm9wc1wiXG4gICAgICAgIC8vIFNvIHRoYXQgdGhlIHRlbXBsYXRlIHVwZGF0ZXMgYWNjb3JkaW5nbHlcbiAgICAgICAgdmFyICR0aXAgPSB0aGlzLiRfdGlwO1xuXG4gICAgICAgIGlmICgkdGlwKSB7XG4gICAgICAgICAgdmFyIHByb3BzID0gWyd0aXRsZScsICdjb250ZW50JywgJ3ZhcmlhbnQnLCAnY3VzdG9tQ2xhc3MnLCAnbm9GYWRlJywgJ2ludGVyYWN0aXZlJ107IC8vIE9ubHkgdXBkYXRlIHRoZSB2YWx1ZXMgaWYgdGhleSBoYXZlIGNoYW5nZWRcblxuICAgICAgICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmICgkdGlwW3Byb3BdICE9PSBfdGhpczRbcHJvcF0pIHtcbiAgICAgICAgICAgICAgJHRpcFtwcm9wXSA9IF90aGlzNFtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIC0tLSBTaG93L0hpZGUgaGFuZGxlcnMgLS0tXG4gICAgICAvLyBTaG93IHRoZSB0b29sdGlwXG4gICAgICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXQoKTtcblxuICAgICAgICBpZiAoIXRhcmdldCB8fCAhY29udGFpbnMoZG9jdW1lbnQuYm9keSwgdGFyZ2V0KSB8fCAhaXNWaXNpYmxlKHRhcmdldCkgfHwgdGhpcy5kcm9wZG93bk9wZW4oKSB8fCAoaXNVbmRlZmluZWRPck51bGwodGhpcy50aXRsZSkgfHwgdGhpcy50aXRsZSA9PT0gJycpICYmIChpc1VuZGVmaW5lZE9yTnVsbCh0aGlzLmNvbnRlbnQpIHx8IHRoaXMuY29udGVudCA9PT0gJycpKSB7XG4gICAgICAgICAgLy8gSWYgdHJpZ2dlciBlbGVtZW50IGlzbid0IGluIHRoZSBET00gb3IgaXMgbm90IHZpc2libGUsIG9yXG4gICAgICAgICAgLy8gaXMgb24gYW4gb3BlbiBkcm9wZG93biB0b2dnbGUsIG9yIGhhcyBubyBjb250ZW50LCB0aGVuXG4gICAgICAgICAgLy8gd2UgZXhpdCB3aXRob3V0IHNob3dpbmdcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gSWYgdGlwIGFscmVhZHkgZXhpc3RzLCBleGl0IGVhcmx5XG5cblxuICAgICAgICBpZiAodGhpcy4kX3RpcCB8fCB0aGlzLmxvY2FsU2hvdykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIEluIHRoZSBwcm9jZXNzIG9mIHNob3dpbmdcblxuXG4gICAgICAgIHRoaXMubG9jYWxTaG93ID0gdHJ1ZTsgLy8gQ3JlYXRlIGEgY2FuY2VsYWJsZSBCdkV2ZW50XG5cbiAgICAgICAgdmFyIHNob3dFdnQgPSB0aGlzLmJ1aWxkRXZlbnQoJ3Nob3cnLCB7XG4gICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoc2hvd0V2dCk7IC8vIERvbid0IHNob3cgaWYgZXZlbnQgY2FuY2VsbGVkXG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGlnbm9yZSBmb3Igbm93ICovXG5cbiAgICAgICAgaWYgKHNob3dFdnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIC8vIERlc3Ryb3kgdGhlIHRlbXBsYXRlIChpZiBmb3Igc29tZSByZWFzb24gaXQgd2FzIGNyZWF0ZWQpXG5cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHRoaXMuZGVzdHJveVRlbXBsYXRlKCk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBGaXggdGhlIHRpdGxlIGF0dHJpYnV0ZSBvbiB0YXJnZXRcblxuXG4gICAgICAgIHRoaXMuZml4VGl0bGUoKTsgLy8gU2V0IGFyaWEtZGVzY3JpYmVkYnkgb24gdGFyZ2V0XG5cbiAgICAgICAgdGhpcy5hZGRBcmlhRGVzY3JpYmVkYnkoKTsgLy8gQ3JlYXRlIGFuZCBzaG93IHRoZSB0b29sdGlwXG5cbiAgICAgICAgdGhpcy5jcmVhdGVUZW1wbGF0ZUFuZFNob3coKTtcbiAgICAgIH0sXG4gICAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICB2YXIgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgICAgICAvLyBIaWRlIHRoZSB0b29sdGlwXG4gICAgICAgIHZhciB0aXAgPSB0aGlzLmdldFRlbXBsYXRlRWxlbWVudCgpO1xuXG4gICAgICAgIGlmICghdGlwIHx8ICF0aGlzLmxvY2FsU2hvdykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgdGhpcy5yZXN0b3JlVGl0bGUoKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIEVtaXQgY2FuY2VsYWJsZSBCdkV2ZW50ICdoaWRlJ1xuICAgICAgICAvLyBXZSBkaXNhYmxlIGNhbmNlbGxpbmcgaWYgYGZvcmNlYCBpcyB0cnVlXG5cblxuICAgICAgICB2YXIgaGlkZUV2dCA9IHRoaXMuYnVpbGRFdmVudCgnaGlkZScsIHtcbiAgICAgICAgICBjYW5jZWxhYmxlOiAhZm9yY2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KGhpZGVFdnQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogaWdub3JlIGZvciBub3cgKi9cblxuICAgICAgICBpZiAoaGlkZUV2dC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgaGlkZSBpZiBldmVudCBjYW5jZWxsZWRcblxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFRlbGwgdGhlIHRlbXBsYXRlIHRvIGhpZGVcblxuXG4gICAgICAgIHRoaXMuaGlkZVRlbXBsYXRlKCk7XG4gICAgICB9LFxuICAgICAgZm9yY2VIaWRlOiBmdW5jdGlvbiBmb3JjZUhpZGUoKSB7XG4gICAgICAgIC8vIEZvcmNlZnVsbHkgaGlkZXMvZGVzdHJveXMgdGhlIHRlbXBsYXRlLCByZWdhcmRsZXNzIG9mIGFueSBhY3RpdmUgdHJpZ2dlcnNcbiAgICAgICAgdmFyIHRpcCA9IHRoaXMuZ2V0VGVtcGxhdGVFbGVtZW50KCk7XG5cbiAgICAgICAgaWYgKCF0aXAgfHwgIXRoaXMubG9jYWxTaG93KSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gRGlzYWJsZSB3aGlsZSBvcGVuIGxpc3RlbmVycy93YXRjaGVyc1xuICAgICAgICAvLyBUaGlzIGlzIGFsc28gZG9uZSBpbiB0aGUgdGVtcGxhdGUgYGhpZGVgIGV2dCBoYW5kbGVyXG5cblxuICAgICAgICB0aGlzLnNldFdoaWxlT3Blbkxpc3RlbmVycyhmYWxzZSk7IC8vIENsZWFyIGFueSBob3ZlciBlbnRlci9sZWF2ZSBldmVudFxuXG4gICAgICAgIHRoaXMuY2xlYXJIb3ZlclRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy4kX2hvdmVyU3RhdGUgPSAnJztcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZVRyaWdnZXJzKCk7IC8vIERpc2FibGUgdGhlIGZhZGUgYW5pbWF0aW9uIG9uIHRoZSB0ZW1wbGF0ZVxuXG4gICAgICAgIGlmICh0aGlzLiRfdGlwKSB7XG4gICAgICAgICAgdGhpcy4kX3RpcC5ub0ZhZGUgPSB0cnVlO1xuICAgICAgICB9IC8vIEhpZGUgdGhlIHRpcCAod2l0aCBmb3JjZSA9IHRydWUpXG5cblxuICAgICAgICB0aGlzLmhpZGUodHJ1ZSk7XG4gICAgICB9LFxuICAgICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICAgIHRoaXMuJF9lbmFibGVkID0gdHJ1ZTsgLy8gQ3JlYXRlIGEgbm9uLWNhbmNlbGFibGUgQnZFdmVudFxuXG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KHRoaXMuYnVpbGRFdmVudCgnZW5hYmxlZCcpKTtcbiAgICAgIH0sXG4gICAgICBkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgICB0aGlzLiRfZW5hYmxlZCA9IGZhbHNlOyAvLyBDcmVhdGUgYSBub24tY2FuY2VsYWJsZSBCdkV2ZW50XG5cbiAgICAgICAgdGhpcy5lbWl0RXZlbnQodGhpcy5idWlsZEV2ZW50KCdkaXNhYmxlZCcpKTtcbiAgICAgIH0sXG4gICAgICAvLyAtLS0gSGFuZGxlcnMgZm9yIHRlbXBsYXRlIGV2ZW50cyAtLS1cbiAgICAgIC8vIFdoZW4gdGVtcGxhdGUgaXMgaW5zZXJ0ZWQgaW50byBET00sIGJ1dCBub3QgeWV0IHNob3duXG4gICAgICBvblRlbXBsYXRlU2hvdzogZnVuY3Rpb24gb25UZW1wbGF0ZVNob3coKSB7XG4gICAgICAgIC8vIEVuYWJsZSB3aGlsZSBvcGVuIGxpc3RlbmVycy93YXRjaGVyc1xuICAgICAgICB0aGlzLnNldFdoaWxlT3Blbkxpc3RlbmVycyh0cnVlKTtcbiAgICAgIH0sXG4gICAgICAvLyBXaGVuIHRlbXBsYXRlIHNob3cgdHJhbnNpdGlvbiBjb21wbGV0ZXNcbiAgICAgIG9uVGVtcGxhdGVTaG93bjogZnVuY3Rpb24gb25UZW1wbGF0ZVNob3duKCkge1xuICAgICAgICB2YXIgcHJldkhvdmVyU3RhdGUgPSB0aGlzLiRfaG92ZXJTdGF0ZTtcbiAgICAgICAgdGhpcy4kX2hvdmVyU3RhdGUgPSAnJztcblxuICAgICAgICBpZiAocHJldkhvdmVyU3RhdGUgPT09ICdvdXQnKSB7XG4gICAgICAgICAgdGhpcy5sZWF2ZShudWxsKTtcbiAgICAgICAgfSAvLyBFbWl0IGEgbm9uLWNhbmNlbGFibGUgQnZFdmVudCAnc2hvd24nXG5cblxuICAgICAgICB0aGlzLmVtaXRFdmVudCh0aGlzLmJ1aWxkRXZlbnQoJ3Nob3duJykpO1xuICAgICAgfSxcbiAgICAgIC8vIFdoZW4gdGVtcGxhdGUgaXMgc3RhcnRpbmcgdG8gaGlkZVxuICAgICAgb25UZW1wbGF0ZUhpZGU6IGZ1bmN0aW9uIG9uVGVtcGxhdGVIaWRlKCkge1xuICAgICAgICAvLyBEaXNhYmxlIHdoaWxlIG9wZW4gbGlzdGVuZXJzL3dhdGNoZXJzXG4gICAgICAgIHRoaXMuc2V0V2hpbGVPcGVuTGlzdGVuZXJzKGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICAvLyBXaGVuIHRlbXBsYXRlIGhhcyBjb21wbGV0ZWQgY2xvc2luZyAoanVzdCBiZWZvcmUgaXQgc2VsZiBkZXN0cnVjdHMpXG4gICAgICBvblRlbXBsYXRlSGlkZGVuOiBmdW5jdGlvbiBvblRlbXBsYXRlSGlkZGVuKCkge1xuICAgICAgICAvLyBEZXN0cm95IHRoZSB0ZW1wbGF0ZVxuICAgICAgICB0aGlzLmRlc3Ryb3lUZW1wbGF0ZSgpOyAvLyBFbWl0IGEgbm9uLWNhbmNlbGFibGUgQnZFdmVudCAnc2hvd24nXG5cbiAgICAgICAgdGhpcy5lbWl0RXZlbnQodGhpcy5idWlsZEV2ZW50KCdoaWRkZW4nKSk7XG4gICAgICB9LFxuICAgICAgLy8gLS0tIFV0aWxpdHkgbWV0aG9kcyAtLS1cbiAgICAgIGdldFRhcmdldDogZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSB0YXJnZXQgbWF5IGJlIGEgY29tcG9uZW50IHJlZlxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQgPyB0aGlzLnRhcmdldC4kZWwgfHwgdGhpcy50YXJnZXQgOiBudWxsOyAvLyBJZiBhbiBJRFxuXG4gICAgICAgIHRhcmdldCA9IGlzU3RyaW5nKHRhcmdldCkgPyBnZXRCeUlkKHRhcmdldC5yZXBsYWNlKC9eIy8sICcnKSkgOiB0YXJnZXQ7IC8vIElmIGEgZnVuY3Rpb25cblxuICAgICAgICB0YXJnZXQgPSBpc0Z1bmN0aW9uKHRhcmdldCkgPyB0YXJnZXQoKSA6IHRhcmdldDsgLy8gSWYgYW4gZWxlbWVudCByZWZcblxuICAgICAgICByZXR1cm4gaXNFbGVtZW50KHRhcmdldCkgPyB0YXJnZXQgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIGdldFBsYWNlbWVudFRhcmdldDogZnVuY3Rpb24gZ2V0UGxhY2VtZW50VGFyZ2V0KCkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSB0YXJnZXQgdGhhdCB0aGUgdG9vbHRpcCB3aWxsIGJlIHBsYWNlZCBvbiwgd2hpY2ggbWF5IG5vdFxuICAgICAgICAvLyBuZWNlc3NhcmlseSBiZSB0aGUgc2FtZSBlbGVtZW50IHRoYXQgaGFzIHRoZSB0cmlnZ2VyIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAvLyBGb3Igbm93LCB0aGlzIGlzIHRoZSBzYW1lIGFzIHRhcmdldFxuICAgICAgICAvLyBUT0RPOlxuICAgICAgICAvLyAgIEFkZCBpbiBjaGlsZCBzZWxlY3RvciBzdXBwb3J0XG4gICAgICAgIC8vICAgQWRkIGluIHZpc2liaWxpdHkgY2hlY2tzIGZvciB0aGlzIGVsZW1lbnRcbiAgICAgICAgLy8gICBGYWxsYmFjayB0byB0YXJnZXQgaWYgbm90IGZvdW5kXG4gICAgICAgIHJldHVybiB0aGlzLmdldFRhcmdldCgpO1xuICAgICAgfSxcbiAgICAgIGdldFRhcmdldElkOiBmdW5jdGlvbiBnZXRUYXJnZXRJZCgpIHtcbiAgICAgICAgLy8gUmV0dXJucyB0aGUgSUQgb2YgdGhlIHRyaWdnZXIgZWxlbWVudFxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXQoKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldCAmJiB0YXJnZXQuaWQgPyB0YXJnZXQuaWQgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIGdldENvbnRhaW5lcjogZnVuY3Rpb24gZ2V0Q29udGFpbmVyKCkge1xuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBjb250YWluZXIgbWF5IGJlIGEgY29tcG9uZW50IHJlZlxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIgPyB0aGlzLmNvbnRhaW5lci4kZWwgfHwgdGhpcy5jb250YWluZXIgOiBmYWxzZTtcbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXQoKTsgLy8gSWYgd2UgYXJlIGluIGEgbW9kYWwsIHdlIGFwcGVuZCB0byB0aGUgbW9kYWwgaW5zdGVhZFxuICAgICAgICAvLyBvZiBib2R5LCB1bmxlc3MgYSBjb250YWluZXIgaXMgc3BlY2lmaWVkXG4gICAgICAgIC8vIFRPRE86XG4gICAgICAgIC8vICAgVGVtcGxhdGUgc2hvdWxkIHBlcmlvZGljYWxseSBjaGVjayB0byBzZWUgaWYgaXQgaXMgaW4gZG9tXG4gICAgICAgIC8vICAgQW5kIGlmIG5vdCwgc2VsZiBkZXN0cnVjdCAoaWYgY29udGFpbmVyIGdvdCB2LWlmJ2VkIG91dCBvZiBET00pXG4gICAgICAgIC8vICAgT3IgdGhpcyBjb3VsZCBwb3NzaWJseSBiZSBwYXJ0IG9mIHRoZSB2aXNpYmlsaXR5IGNoZWNrXG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lciA9PT0gZmFsc2UgPyBjbG9zZXN0KE1PREFMX1NFTEVDVE9SLCB0YXJnZXQpIHx8IGJvZHkgOiBpc1N0cmluZyhjb250YWluZXIpID8gZ2V0QnlJZChjb250YWluZXIucmVwbGFjZSgvXiMvLCAnJykpIHx8IGJvZHkgOiBib2R5O1xuICAgICAgfSxcbiAgICAgIGdldEJvdW5kYXJ5OiBmdW5jdGlvbiBnZXRCb3VuZGFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRhcnkgPyB0aGlzLmJvdW5kYXJ5LiRlbCB8fCB0aGlzLmJvdW5kYXJ5IDogJ3Njcm9sbFBhcmVudCc7XG4gICAgICB9LFxuICAgICAgaXNJbk1vZGFsOiBmdW5jdGlvbiBpc0luTW9kYWwoKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmdldFRhcmdldCgpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0ICYmIGNsb3Nlc3QoTU9EQUxfU0VMRUNUT1IsIHRhcmdldCk7XG4gICAgICB9LFxuICAgICAgaXNEcm9wZG93bjogZnVuY3Rpb24gaXNEcm9wZG93bigpIHtcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIHRyaWdnZXIgaXMgYSBkcm9wZG93blxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXQoKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldCAmJiBoYXNDbGFzcyh0YXJnZXQsIERST1BET1dOX0NMQVNTKTtcbiAgICAgIH0sXG4gICAgICBkcm9wZG93bk9wZW46IGZ1bmN0aW9uIGRyb3Bkb3duT3BlbigpIHtcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIHRyaWdnZXIgaXMgYSBkcm9wZG93biBhbmQgdGhlIGRyb3Bkb3duIG1lbnUgaXMgb3BlblxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEcm9wZG93bigpICYmIHRhcmdldCAmJiBzZWxlY3QoRFJPUERPV05fT1BFTl9TRUxFQ1RPUiwgdGFyZ2V0KTtcbiAgICAgIH0sXG4gICAgICBjbGVhckhvdmVyVGltZW91dDogZnVuY3Rpb24gY2xlYXJIb3ZlclRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLiRfaG92ZXJUaW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuJF9ob3ZlclRpbWVvdXQpO1xuICAgICAgICAgIHRoaXMuJF9ob3ZlclRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2xlYXJWaXNpYmlsaXR5SW50ZXJ2YWw6IGZ1bmN0aW9uIGNsZWFyVmlzaWJpbGl0eUludGVydmFsKCkge1xuICAgICAgICBpZiAodGhpcy4kX3Zpc2libGVJbnRlcnZhbCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy4kX3Zpc2libGVJbnRlcnZhbCk7XG4gICAgICAgICAgdGhpcy4kX3Zpc2libGVJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjbGVhckFjdGl2ZVRyaWdnZXJzOiBmdW5jdGlvbiBjbGVhckFjdGl2ZVRyaWdnZXJzKCkge1xuICAgICAgICBmb3IgKHZhciB0cmlnZ2VyIGluIHRoaXMuYWN0aXZlVHJpZ2dlcikge1xuICAgICAgICAgIHRoaXMuYWN0aXZlVHJpZ2dlclt0cmlnZ2VyXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWRkQXJpYURlc2NyaWJlZGJ5OiBmdW5jdGlvbiBhZGRBcmlhRGVzY3JpYmVkYnkoKSB7XG4gICAgICAgIC8vIEFkZCBhcmlhLWRlc2NyaWJlZGJ5IG9uIHRyaWdnZXIgZWxlbWVudCwgd2l0aG91dCByZW1vdmluZyBhbnkgb3RoZXIgSURzXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmdldFRhcmdldCgpO1xuICAgICAgICB2YXIgZGVzYyA9IGdldEF0dHIodGFyZ2V0LCAnYXJpYS1kZXNjcmliZWRieScpIHx8ICcnO1xuICAgICAgICBkZXNjID0gZGVzYy5zcGxpdCgvXFxzKy8pLmNvbmNhdCh0aGlzLmNvbXB1dGVkSWQpLmpvaW4oJyAnKS50cmltKCk7IC8vIFVwZGF0ZS9hZGQgYXJpYS1kZXNjcmliZWQgYnlcblxuICAgICAgICBzZXRBdHRyKHRhcmdldCwgJ2FyaWEtZGVzY3JpYmVkYnknLCBkZXNjKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVBcmlhRGVzY3JpYmVkYnk6IGZ1bmN0aW9uIHJlbW92ZUFyaWFEZXNjcmliZWRieSgpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGFyaWEtZGVzY3JpYmVkYnkgb24gdHJpZ2dlciBlbGVtZW50LCB3aXRob3V0IHJlbW92aW5nIGFueSBvdGhlciBJRHNcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZ2V0VGFyZ2V0KCk7XG4gICAgICAgIHZhciBkZXNjID0gZ2V0QXR0cih0YXJnZXQsICdhcmlhLWRlc2NyaWJlZGJ5JykgfHwgJyc7XG4gICAgICAgIGRlc2MgPSBkZXNjLnNwbGl0KC9cXHMrLykuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQgIT09IF90aGlzNS5jb21wdXRlZElkO1xuICAgICAgICB9KS5qb2luKCcgJykudHJpbSgpOyAvLyBVcGRhdGUgb3IgcmVtb3ZlIGFyaWEtZGVzY3JpYmVkYnlcblxuICAgICAgICBpZiAoZGVzYykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgc2V0QXR0cih0YXJnZXQsICdhcmlhLWRlc2NyaWJlZGJ5JywgZGVzYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQXR0cih0YXJnZXQsICdhcmlhLWRlc2NyaWJlZGJ5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmaXhUaXRsZTogZnVuY3Rpb24gZml4VGl0bGUoKSB7XG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaGFzIGEgdGl0bGUgYXR0cmlidXRlLCBudWxsIGl0IG91dCBhbmRcbiAgICAgICAgLy8gc3RvcmUgb24gZGF0YS10aXRsZVxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXQoKTtcblxuICAgICAgICBpZiAodGFyZ2V0ICYmIGdldEF0dHIodGFyZ2V0LCAndGl0bGUnKSkge1xuICAgICAgICAgIC8vIFdlIG9ubHkgdXBkYXRlIHRpdGxlIGF0dHJpYnV0ZSBpZiBpdCBoYXMgYSB2YWx1ZVxuICAgICAgICAgIHNldEF0dHIodGFyZ2V0LCAnZGF0YS1vcmlnaW5hbC10aXRsZScsIGdldEF0dHIodGFyZ2V0LCAndGl0bGUnKSB8fCAnJyk7XG4gICAgICAgICAgc2V0QXR0cih0YXJnZXQsICd0aXRsZScsICcnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc3RvcmVUaXRsZTogZnVuY3Rpb24gcmVzdG9yZVRpdGxlKCkge1xuICAgICAgICAvLyBJZiB0YXJnZXQgaGFkIGEgdGl0bGUsIHJlc3RvcmUgdGhlIHRpdGxlIGF0dHJpYnV0ZVxuICAgICAgICAvLyBhbmQgcmVtb3ZlIHRoZSBkYXRhLXRpdGxlIGF0dHJpYnV0ZVxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXQoKTtcblxuICAgICAgICBpZiAodGFyZ2V0ICYmIGhhc0F0dHIodGFyZ2V0LCAnZGF0YS1vcmlnaW5hbC10aXRsZScpKSB7XG4gICAgICAgICAgc2V0QXR0cih0YXJnZXQsICd0aXRsZScsIGdldEF0dHIodGFyZ2V0LCAnZGF0YS1vcmlnaW5hbC10aXRsZScpIHx8ICcnKTtcbiAgICAgICAgICByZW1vdmVBdHRyKHRhcmdldCwgJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIC0tLSBCdkV2ZW50IGhlbHBlcnMgLS0tXG4gICAgICBidWlsZEV2ZW50OiBmdW5jdGlvbiBidWlsZEV2ZW50KHR5cGUpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICAvLyBEZWZhdWx0cyB0byBhIG5vbi1jYW5jZWxsYWJsZSBldmVudFxuICAgICAgICByZXR1cm4gbmV3IEJ2RXZlbnQodHlwZSwgX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICAgIHRhcmdldDogdGhpcy5nZXRUYXJnZXQoKSxcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLmdldFRlbXBsYXRlRWxlbWVudCgpIHx8IG51bGwsXG4gICAgICAgICAgY29tcG9uZW50SWQ6IHRoaXMuY29tcHV0ZWRJZCxcbiAgICAgICAgICB2dWVUYXJnZXQ6IHRoaXNcbiAgICAgICAgfSwgb3B0aW9ucykpO1xuICAgICAgfSxcbiAgICAgIGVtaXRFdmVudDogZnVuY3Rpb24gZW1pdEV2ZW50KGJ2RXZ0KSB7XG4gICAgICAgIC8vIEVtaXRzIGEgQnZFdmVudCBvbiAkcm9vdCBhbmQgdGhpcyBpbnN0YW5jZVxuICAgICAgICB2YXIgZXZ0TmFtZSA9IGJ2RXZ0LnR5cGU7XG4gICAgICAgIHZhciAkcm9vdCA9IHRoaXMuJHJvb3Q7XG5cbiAgICAgICAgaWYgKCRyb290ICYmICRyb290LiRlbWl0KSB7XG4gICAgICAgICAgLy8gRW1pdCBhbiBldmVudCBvbiAkcm9vdFxuICAgICAgICAgICRyb290LiRlbWl0KFwiYnY6OlwiLmNvbmNhdCh0aGlzLnRlbXBsYXRlVHlwZSwgXCI6OlwiKS5jb25jYXQoZXZ0TmFtZSksIGJ2RXZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGVtaXQoZXZ0TmFtZSwgYnZFdnQpO1xuICAgICAgfSxcbiAgICAgIC8vIC0tLSBFdmVudCBoYW5kbGVyIHNldHVwIG1ldGhvZHMgLS0tXG4gICAgICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3RlbigpIHtcbiAgICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgICAgLy8gRW5hYmxlIHRyaWdnZXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgdmFyIGVsID0gdGhpcy5nZXRUYXJnZXQoKTtcblxuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gTGlzdGVuIGZvciBnbG9iYWwgc2hvdy9oaWRlIGV2ZW50c1xuXG5cbiAgICAgICAgdGhpcy5zZXRSb290TGlzdGVuZXIodHJ1ZSk7IC8vIFNldCB1cCBvdXIgbGlzdGVuZXJzIG9uIHRoZSB0YXJnZXQgdHJpZ2dlciBlbGVtZW50XG5cbiAgICAgICAgdGhpcy5jb21wdXRlZFRyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgICAgICBpZiAodHJpZ2dlciA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgZXZlbnRPbihlbCwgJ2NsaWNrJywgX3RoaXM2LmhhbmRsZUV2ZW50LCBFVkVOVF9PUFRJT05TX05PX0NBUFRVUkUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHJpZ2dlciA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgZXZlbnRPbihlbCwgJ2ZvY3VzaW4nLCBfdGhpczYuaGFuZGxlRXZlbnQsIEVWRU5UX09QVElPTlNfTk9fQ0FQVFVSRSk7XG4gICAgICAgICAgICBldmVudE9uKGVsLCAnZm9jdXNvdXQnLCBfdGhpczYuaGFuZGxlRXZlbnQsIEVWRU5UX09QVElPTlNfTk9fQ0FQVFVSRSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyID09PSAnYmx1cicpIHtcbiAgICAgICAgICAgIC8vIFVzZWQgdG8gY2xvc2UgJHRpcCB3aGVuIGVsZW1lbnQgbG9vc2VzIGZvY3VzXG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBldmVudE9uKGVsLCAnZm9jdXNvdXQnLCBfdGhpczYuaGFuZGxlRXZlbnQsIEVWRU5UX09QVElPTlNfTk9fQ0FQVFVSRSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyID09PSAnaG92ZXInKSB7XG4gICAgICAgICAgICBldmVudE9uKGVsLCAnbW91c2VlbnRlcicsIF90aGlzNi5oYW5kbGVFdmVudCwgRVZFTlRfT1BUSU9OU19OT19DQVBUVVJFKTtcbiAgICAgICAgICAgIGV2ZW50T24oZWwsICdtb3VzZWxlYXZlJywgX3RoaXM2LmhhbmRsZUV2ZW50LCBFVkVOVF9PUFRJT05TX05PX0NBUFRVUkUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9LFxuICAgICAgdW5MaXN0ZW46IGZ1bmN0aW9uIHVuTGlzdGVuKClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB7XG4gICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0cmlnZ2VyIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIHZhciBldmVudHMgPSBbJ2NsaWNrJywgJ2ZvY3VzaW4nLCAnZm9jdXNvdXQnLCAnbW91c2VlbnRlcicsICdtb3VzZWxlYXZlJ107XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmdldFRhcmdldCgpOyAvLyBTdG9wIGxpc3RlbmluZyBmb3IgZ2xvYmFsIHNob3cvaGlkZS9lbmFibGUvZGlzYWJsZSBldmVudHNcblxuICAgICAgICB0aGlzLnNldFJvb3RMaXN0ZW5lcihmYWxzZSk7IC8vIENsZWFyIG91dCBhbnkgYWN0aXZlIHRhcmdldCBsaXN0ZW5lcnNcblxuICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgdGFyZ2V0ICYmIGV2ZW50T2ZmKHRhcmdldCwgZXZ0LCBfdGhpczcuaGFuZGxlRXZlbnQsIEVWRU5UX09QVElPTlNfTk9fQ0FQVFVSRSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHNldFJvb3RMaXN0ZW5lcjogZnVuY3Rpb24gc2V0Um9vdExpc3RlbmVyKG9uKSB7XG4gICAgICAgIC8vIExpc3RlbiBmb3IgZ2xvYmFsIGBidjo6e2hpZGV8c2hvd306Ont0b29sdGlwfHBvcG92ZXJ9YCBoaWRlIHJlcXVlc3QgZXZlbnRcbiAgICAgICAgdmFyICRyb290ID0gdGhpcy4kcm9vdDtcblxuICAgICAgICBpZiAoJHJvb3QpIHtcbiAgICAgICAgICB2YXIgbWV0aG9kID0gb24gPyAnJG9uJyA6ICckb2ZmJztcbiAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMudGVtcGxhdGVUeXBlO1xuICAgICAgICAgICRyb290W21ldGhvZF0oXCJidjo6aGlkZTo6XCIuY29uY2F0KHR5cGUpLCB0aGlzLmRvSGlkZSk7XG4gICAgICAgICAgJHJvb3RbbWV0aG9kXShcImJ2OjpzaG93OjpcIi5jb25jYXQodHlwZSksIHRoaXMuZG9TaG93KTtcbiAgICAgICAgICAkcm9vdFttZXRob2RdKFwiYnY6OmRpc2FibGU6OlwiLmNvbmNhdCh0eXBlKSwgdGhpcy5kb0Rpc2FibGUpO1xuICAgICAgICAgICRyb290W21ldGhvZF0oXCJidjo6ZW5hYmxlOjpcIi5jb25jYXQodHlwZSksIHRoaXMuZG9FbmFibGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0V2hpbGVPcGVuTGlzdGVuZXJzOiBmdW5jdGlvbiBzZXRXaGlsZU9wZW5MaXN0ZW5lcnMob24pIHtcbiAgICAgICAgLy8gRXZlbnRzIHRoYXQgYXJlIG9ubHkgcmVnaXN0ZXJlZCB3aGVuIHRoZSB0ZW1wbGF0ZSBpcyBzaG93aW5nXG4gICAgICAgIC8vIE1vZGFsIGNsb3NlIGV2ZW50c1xuICAgICAgICB0aGlzLnNldE1vZGFsTGlzdGVuZXIob24pOyAvLyBEcm9wZG93biBvcGVuIGV2ZW50cyAoaWYgd2UgYXJlIGF0dGFjaGVkIHRvIGEgZHJvcGRvd24pXG5cbiAgICAgICAgdGhpcy5zZXREcm9wZG93bkxpc3RlbmVyKG9uKTsgLy8gUGVyaW9kaWMgJGVsZW1lbnQgdmlzaWJpbGl0eSBjaGVja1xuICAgICAgICAvLyBGb3IgaGFuZGxpbmcgd2hlbiB0aXAgdGFyZ2V0IGlzIGluIDxrZWVwYWxpdmU+LCB0YWJzLCBjYXJvdXNlbCwgZXRjXG5cbiAgICAgICAgdGhpcy52aXNpYmxlQ2hlY2sob24pOyAvLyBPbi10b3VjaCBzdGFydCBsaXN0ZW5lcnNcblxuICAgICAgICB0aGlzLnNldE9uVG91Y2hTdGFydExpc3RlbmVyKG9uKTtcbiAgICAgIH0sXG4gICAgICAvLyBIYW5kbGVyIGZvciBwZXJpb2RpYyB2aXNpYmlsaXR5IGNoZWNrXG4gICAgICB2aXNpYmxlQ2hlY2s6IGZ1bmN0aW9uIHZpc2libGVDaGVjayhvbikge1xuICAgICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgICB0aGlzLmNsZWFyVmlzaWJpbGl0eUludGVydmFsKCk7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmdldFRhcmdldCgpO1xuICAgICAgICB2YXIgdGlwID0gdGhpcy5nZXRUZW1wbGF0ZUVsZW1lbnQoKTtcblxuICAgICAgICBpZiAob24pIHtcbiAgICAgICAgICB0aGlzLiRfdmlzaWJsZUludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRpcCAmJiBfdGhpczgubG9jYWxTaG93ICYmICghdGFyZ2V0LnBhcmVudE5vZGUgfHwgIWlzVmlzaWJsZSh0YXJnZXQpKSkge1xuICAgICAgICAgICAgICAvLyBUYXJnZXQgZWxlbWVudCBpcyBubyBsb25nZXIgdmlzaWJsZSBvciBub3QgaW4gRE9NLCBzbyBmb3JjZS1oaWRlIHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgIF90aGlzOC5mb3JjZUhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0TW9kYWxMaXN0ZW5lcjogZnVuY3Rpb24gc2V0TW9kYWxMaXN0ZW5lcihvbikge1xuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSB0b29sdGlwL3RhcmdldCBpcyBpbiBhIG1vZGFsXG4gICAgICAgIGlmICh0aGlzLmlzSW5Nb2RhbCgpKSB7XG4gICAgICAgICAgLy8gV2UgY2FuIGxpc3RlbiBmb3IgbW9kYWwgaGlkZGVuIGV2ZW50cyBvbiBgJHJvb3RgXG4gICAgICAgICAgdGhpcy4kcm9vdFtvbiA/ICckb24nIDogJyRvZmYnXShNT0RBTF9DTE9TRV9FVkVOVCwgdGhpcy5mb3JjZUhpZGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0T25Ub3VjaFN0YXJ0TGlzdGVuZXI6IGZ1bmN0aW9uIHNldE9uVG91Y2hTdGFydExpc3RlbmVyKG9uKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IEpTRE9NIGRvZXNuJ3Qgc3VwcG9ydCBgb250b3VjaHN0YXJ0YCAqL1xuICAgICAge1xuICAgICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhIGVtcHR5XG4gICAgICAgIC8vIGBtb3VzZW92ZXJgIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlblxuICAgICAgICAvLyBPbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xuICAgICAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcbiAgICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgIGZyb20oZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGV2ZW50T25PZmYob24sIGVsLCAnbW91c2VvdmVyJywgX3RoaXM5LiRfbm9vcCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXREcm9wZG93bkxpc3RlbmVyOiBmdW5jdGlvbiBzZXREcm9wZG93bkxpc3RlbmVyKG9uKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmdldFRhcmdldCgpO1xuXG4gICAgICAgIGlmICghdGFyZ2V0IHx8ICF0aGlzLiRyb290IHx8ICF0aGlzLmlzRHJvcGRvd24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gV2UgY2FuIGxpc3RlbiBmb3IgZHJvcGRvd24gc2hvd24gZXZlbnRzIG9uIGl0cyBpbnN0YW5jZVxuICAgICAgICAvLyBUT0RPOlxuICAgICAgICAvLyAgIFdlIGNvdWxkIGdyYWIgdGhlIElEIGZyb20gdGhlIGRyb3Bkb3duLCBhbmQgbGlzdGVuIGZvclxuICAgICAgICAvLyAgICRyb290IGV2ZW50cyBmb3IgdGhhdCBwYXJ0aWN1bGFyIGRyb3Bkb3duIGlkXG4gICAgICAgIC8vICAgRHJvcGRvd24gc2hvd24gYW5kIGhpZGRlbiBldmVudHMgd2lsbCBuZWVkIHRvIGVtaXRcbiAgICAgICAgLy8gICBOb3RlOiBEcm9wZG93biBhdXRvLUlEIGhhcHBlbnMgaW4gYSBgJG5leHRUaWNrKClgIGFmdGVyIG1vdW50XG4gICAgICAgIC8vICAgICAgICAgU28gdGhlIElEIGxvb2t1cCB3b3VsZCBuZWVkIHRvIGJlIGRvbmUgaW4gYSBgJG5leHRUaWNrKClgXG5cblxuICAgICAgICBpZiAodGFyZ2V0Ll9fdnVlX18pIHtcbiAgICAgICAgICB0YXJnZXQuX192dWVfX1tvbiA/ICckb24nIDogJyRvZmYnXSgnc2hvd24nLCB0aGlzLmZvcmNlSGlkZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAtLS0gRXZlbnQgaGFuZGxlcnMgLS0tXG4gICAgICBoYW5kbGVFdmVudDogZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZ0KSB7XG4gICAgICAgIC8vIEdlbmVyYWwgdHJpZ2dlciBldmVudCBoYW5kbGVyXG4gICAgICAgIC8vIHRhcmdldCBpcyB0aGUgdHJpZ2dlciBlbGVtZW50XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmdldFRhcmdldCgpO1xuXG4gICAgICAgIGlmICghdGFyZ2V0IHx8IGlzRGlzYWJsZWQodGFyZ2V0KSB8fCAhdGhpcy4kX2VuYWJsZWQgfHwgdGhpcy5kcm9wZG93bk9wZW4oKSkge1xuICAgICAgICAgIC8vIElmIGRpc2FibGVkIG9yIG5vdCBlbmFibGVkLCBvciBpZiBhIGRyb3Bkb3duIHRoYXQgaXMgb3BlbiwgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgICAvLyBJZiB0aXAgaXMgc2hvd24gYmVmb3JlIGVsZW1lbnQgZ2V0cyBkaXNhYmxlZCwgdGhlbiB0aXAgd2lsbCBub3RcbiAgICAgICAgICAvLyBjbG9zZSB1bnRpbCBubyBsb25nZXIgZGlzYWJsZWQgb3IgZm9yY2VmdWxseSBjbG9zZWRcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHlwZSA9IGV2dC50eXBlO1xuICAgICAgICB2YXIgdHJpZ2dlcnMgPSB0aGlzLmNvbXB1dGVkVHJpZ2dlcnM7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjbGljaycgJiYgYXJyYXlJbmNsdWRlcyh0cmlnZ2VycywgJ2NsaWNrJykpIHtcbiAgICAgICAgICB0aGlzLmNsaWNrKGV2dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ21vdXNlZW50ZXInICYmIGFycmF5SW5jbHVkZXModHJpZ2dlcnMsICdob3ZlcicpKSB7XG4gICAgICAgICAgLy8gYG1vdXNlZW50ZXJgIGlzIGEgbm9uLWJ1YmJsaW5nIGV2ZW50XG4gICAgICAgICAgdGhpcy5lbnRlcihldnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdmb2N1c2luJyAmJiBhcnJheUluY2x1ZGVzKHRyaWdnZXJzLCAnZm9jdXMnKSkge1xuICAgICAgICAgIC8vIGBmb2N1c2luYCBpcyBhIGJ1YmJsaW5nIGV2ZW50XG4gICAgICAgICAgLy8gYGV2dGAgaW5jbHVkZXMgYHJlbGF0ZWRUYXJnZXRgIChlbGVtZW50IGxvb3NpbmcgZm9jdXMpXG4gICAgICAgICAgdGhpcy5lbnRlcihldnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdmb2N1c291dCcgJiYgKGFycmF5SW5jbHVkZXModHJpZ2dlcnMsICdmb2N1cycpIHx8IGFycmF5SW5jbHVkZXModHJpZ2dlcnMsICdibHVyJykpIHx8IHR5cGUgPT09ICdtb3VzZWxlYXZlJyAmJiBhcnJheUluY2x1ZGVzKHRyaWdnZXJzLCAnaG92ZXInKSkge1xuICAgICAgICAgIC8vIGBmb2N1c291dGAgaXMgYSBidWJibGluZyBldmVudFxuICAgICAgICAgIC8vIGBtb3VzZWxlYXZlYCBpcyBhIG5vbi1idWJibGluZyBldmVudFxuICAgICAgICAgIC8vIGB0aXBgIGlzIHRoZSB0ZW1wbGF0ZSAod2lsbCBiZSBudWxsIGlmIG5vdCBvcGVuKVxuICAgICAgICAgIHZhciB0aXAgPSB0aGlzLmdldFRlbXBsYXRlRWxlbWVudCgpOyAvLyBgZXZ0VGFyZ2V0YCBpcyB0aGUgZWxlbWVudCB3aGljaCBpcyBsb29zaW5nIGZvY3VzL2hvdmVyIGFuZFxuXG4gICAgICAgICAgdmFyIGV2dFRhcmdldCA9IGV2dC50YXJnZXQ7IC8vIGByZWxhdGVkVGFyZ2V0YCBpcyB0aGUgZWxlbWVudCBnYWluaW5nIGZvY3VzL2hvdmVyXG5cbiAgICAgICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IGV2dC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgICAgICBpZiAoIC8vIEZyb20gdGlwIHRvIHRhcmdldFxuICAgICAgICAgIHRpcCAmJiBjb250YWlucyh0aXAsIGV2dFRhcmdldCkgJiYgY29udGFpbnModGFyZ2V0LCByZWxhdGVkVGFyZ2V0KSB8fCAvLyBGcm9tIHRhcmdldCB0byB0aXBcbiAgICAgICAgICB0aXAgJiYgY29udGFpbnModGFyZ2V0LCBldnRUYXJnZXQpICYmIGNvbnRhaW5zKHRpcCwgcmVsYXRlZFRhcmdldCkgfHwgLy8gV2l0aGluIHRpcFxuICAgICAgICAgIHRpcCAmJiBjb250YWlucyh0aXAsIGV2dFRhcmdldCkgJiYgY29udGFpbnModGlwLCByZWxhdGVkVGFyZ2V0KSB8fCAvLyBXaXRoaW4gdGFyZ2V0XG4gICAgICAgICAgY29udGFpbnModGFyZ2V0LCBldnRUYXJnZXQpICYmIGNvbnRhaW5zKHRhcmdldCwgcmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgICAgIC8vIElmIGZvY3VzL2hvdmVyIG1vdmVzIHdpdGhpbiBgdGlwYCBhbmQgYHRhcmdldGAsIGRvbid0IHRyaWdnZXIgYSBsZWF2ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gT3RoZXJ3aXNlIHRyaWdnZXIgYSBsZWF2ZVxuXG5cbiAgICAgICAgICB0aGlzLmxlYXZlKGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkb0hpZGU6IGZ1bmN0aW9uIGRvSGlkZShpZCkge1xuICAgICAgICAvLyBQcm9ncmFtbWF0aWNhbGx5IGhpZGUgdG9vbHRpcCBvciBwb3BvdmVyXG4gICAgICAgIGlmICghaWQgfHwgdGhpcy5nZXRUYXJnZXRJZCgpID09PSBpZCB8fCB0aGlzLmNvbXB1dGVkSWQgPT09IGlkKSB7XG4gICAgICAgICAgLy8gQ2xvc2UgYWxsIHRvb2x0aXBzIG9yIHBvcG92ZXJzLCBvciB0aGlzIHNwZWNpZmljIHRpcCAod2l0aCBJRClcbiAgICAgICAgICB0aGlzLmZvcmNlSGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZG9TaG93OiBmdW5jdGlvbiBkb1Nob3coaWQpIHtcbiAgICAgICAgLy8gUHJvZ3JhbW1hdGljYWxseSBzaG93IHRvb2x0aXAgb3IgcG9wb3ZlclxuICAgICAgICBpZiAoIWlkIHx8IHRoaXMuZ2V0VGFyZ2V0SWQoKSA9PT0gaWQgfHwgdGhpcy5jb21wdXRlZElkID09PSBpZCkge1xuICAgICAgICAgIC8vIE9wZW4gYWxsIHRvb2x0aXBzIG9yIHBvcG92ZXJzLCBvciB0aGlzIHNwZWNpZmljIHRpcCAod2l0aCBJRClcbiAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRvRGlzYWJsZTogZnVuY3Rpb24gZG9EaXNhYmxlKGlkKVxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgbmV4dDogaWdub3JlIGZvciBub3cgKi9cbiAgICAgIHtcbiAgICAgICAgLy8gUHJvZ3JhbW1hdGljYWxseSBkaXNhYmxlIHRvb2x0aXAgb3IgcG9wb3ZlclxuICAgICAgICBpZiAoIWlkIHx8IHRoaXMuZ2V0VGFyZ2V0SWQoKSA9PT0gaWQgfHwgdGhpcy5jb21wdXRlZElkID09PSBpZCkge1xuICAgICAgICAgIC8vIERpc2FibGUgYWxsIHRvb2x0aXBzIG9yIHBvcG92ZXJzIChubyBJRCksIG9yIHRoaXMgc3BlY2lmaWMgdGlwICh3aXRoIElEKVxuICAgICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZG9FbmFibGU6IGZ1bmN0aW9uIGRvRW5hYmxlKGlkKVxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgbmV4dDogaWdub3JlIGZvciBub3cgKi9cbiAgICAgIHtcbiAgICAgICAgLy8gUHJvZ3JhbW1hdGljYWxseSBlbmFibGUgdG9vbHRpcCBvciBwb3BvdmVyXG4gICAgICAgIGlmICghaWQgfHwgdGhpcy5nZXRUYXJnZXRJZCgpID09PSBpZCB8fCB0aGlzLmNvbXB1dGVkSWQgPT09IGlkKSB7XG4gICAgICAgICAgLy8gRW5hYmxlIGFsbCB0b29sdGlwcyBvciBwb3BvdmVycyAobm8gSUQpLCBvciB0aGlzIHNwZWNpZmljIHRpcCAod2l0aCBJRClcbiAgICAgICAgICB0aGlzLmVuYWJsZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMuJF9lbmFibGVkIHx8IHRoaXMuZHJvcGRvd25PcGVuKCkpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWN0aXZlVHJpZ2dlci5jbGljayA9ICF0aGlzLmFjdGl2ZVRyaWdnZXIuY2xpY2s7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNXaXRoQWN0aXZlVHJpZ2dlcikge1xuICAgICAgICAgIHRoaXMuZW50ZXIobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICB0aGlzLmxlYXZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHtcbiAgICAgICAgLy8gTWFudWFsIHRvZ2dsZSBoYW5kbGVyXG4gICAgICAgIGlmICghdGhpcy4kX2VuYWJsZWQgfHwgdGhpcy5kcm9wZG93bk9wZW4oKSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFNob3VsZCB3ZSByZWdpc3RlciBhcyBhbiBhY3RpdmUgdHJpZ2dlcj9cbiAgICAgICAgLy8gdGhpcy5hY3RpdmVUcmlnZ2VyLm1hbnVhbCA9ICF0aGlzLmFjdGl2ZVRyaWdnZXIubWFudWFsXG5cblxuICAgICAgICBpZiAodGhpcy5sb2NhbFNob3cpIHtcbiAgICAgICAgICB0aGlzLmxlYXZlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZW50ZXIobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlbnRlcjogZnVuY3Rpb24gZW50ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgICB2YXIgZXZ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuXG4gICAgICAgIC8vIE9wZW5pbmcgdHJpZ2dlciBoYW5kbGVyXG4gICAgICAgIC8vIE5vdGU6IENsaWNrIGV2ZW50cyBhcmUgc2VudCB3aXRoIGV2dCA9PT0gbnVsbFxuICAgICAgICBpZiAoZXZ0KSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmVUcmlnZ2VyW2V2dC50eXBlID09PSAnZm9jdXNpbicgPyAnZm9jdXMnIDogJ2hvdmVyJ10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICAgICAgICBpZiAodGhpcy5sb2NhbFNob3cgfHwgdGhpcy4kX2hvdmVyU3RhdGUgPT09ICdpbicpIHtcbiAgICAgICAgICB0aGlzLiRfaG92ZXJTdGF0ZSA9ICdpbic7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbGVhckhvdmVyVGltZW91dCgpO1xuICAgICAgICB0aGlzLiRfaG92ZXJTdGF0ZSA9ICdpbic7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNvbXB1dGVkRGVsYXkuc2hvdykge1xuICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEhpZGUgYW55IHRpdGxlIGF0dHJpYnV0ZSB3aGlsZSBlbnRlciBkZWxheSBpcyBhY3RpdmVcbiAgICAgICAgICB0aGlzLmZpeFRpdGxlKCk7XG4gICAgICAgICAgdGhpcy4kX2hvdmVyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChfdGhpczEwLiRfaG92ZXJTdGF0ZSA9PT0gJ2luJykge1xuICAgICAgICAgICAgICBfdGhpczEwLnNob3coKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIV90aGlzMTAubG9jYWxTaG93KSB7XG4gICAgICAgICAgICAgIF90aGlzMTAucmVzdG9yZVRpdGxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcy5jb21wdXRlZERlbGF5LnNob3cpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGVhdmU6IGZ1bmN0aW9uIGxlYXZlKCkge1xuICAgICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGV2dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcblxuICAgICAgICAvLyBDbG9zaW5nIHRyaWdnZXIgaGFuZGxlclxuICAgICAgICAvLyBOb3RlOiBDbGljayBldmVudHMgYXJlIHNlbnQgd2l0aCBldnQgPT09IG51bGxcbiAgICAgICAgaWYgKGV2dCkge1xuICAgICAgICAgIHRoaXMuYWN0aXZlVHJpZ2dlcltldnQudHlwZSA9PT0gJ2ZvY3Vzb3V0JyA/ICdmb2N1cycgOiAnaG92ZXInXSA9IGZhbHNlO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgICAgICBpZiAoZXZ0LnR5cGUgPT09ICdmb2N1c291dCcgJiYgYXJyYXlJbmNsdWRlcyh0aGlzLmNvbXB1dGVkVHJpZ2dlcnMsICdibHVyJykpIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYGJsdXJgOiB3ZSBjbGVhciBvdXQgdGhlIG90aGVyIHRyaWdnZXJzXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVRyaWdnZXIuY2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVHJpZ2dlci5ob3ZlciA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogaWdub3JlIGZvciBub3cgKi9cblxuXG4gICAgICAgIGlmICh0aGlzLmlzV2l0aEFjdGl2ZVRyaWdnZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsZWFySG92ZXJUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuJF9ob3ZlclN0YXRlID0gJ291dCc7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNvbXB1dGVkRGVsYXkuaGlkZSkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuJF9ob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczExLiRfaG92ZXJTdGF0ZSA9PT0gJ291dCcpIHtcbiAgICAgICAgICAgICAgX3RoaXMxMS5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcy5jb21wdXRlZERlbGF5LmhpZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB2YXIgTkFNRSR2ID0gJ0JUb29sdGlwJzsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQlRvb2x0aXAgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6IE5BTUUkdixcbiAgICBwcm9wczoge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nIC8vIGRlZmF1bHQ6IHVuZGVmaW5lZFxuXG4gICAgICB9LFxuICAgICAgLy8gQWRkZWQgaW4gYnkgQlBvcG92ZXJcbiAgICAgIC8vIGNvbnRlbnQ6IHtcbiAgICAgIC8vICAgdHlwZTogU3RyaW5nLFxuICAgICAgLy8gICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICAgIC8vIH0sXG4gICAgICB0YXJnZXQ6IHtcbiAgICAgICAgLy8gU3RyaW5nIElEIG9mIGVsZW1lbnQsIG9yIGVsZW1lbnQvY29tcG9uZW50IHJlZmVyZW5jZVxuICAgICAgICAvLyBPciBmdW5jdGlvbiB0aGF0IHJldHVybnMgb25lIG9mIHRoZSBhYm92ZVxuICAgICAgICB0eXBlOiBbU3RyaW5nLCBIVE1MRWxlbWVudCwgU1ZHRWxlbWVudCwgRnVuY3Rpb24sIE9iamVjdF0sXG4gICAgICAgIC8vIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgIH0sXG4gICAgICB0cmlnZ2Vyczoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0sXG4gICAgICAgIGRlZmF1bHQ6ICdob3ZlciBmb2N1cydcbiAgICAgIH0sXG4gICAgICBwbGFjZW1lbnQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAndG9wJ1xuICAgICAgfSxcbiAgICAgIGZhbGxiYWNrUGxhY2VtZW50OiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5XSxcbiAgICAgICAgZGVmYXVsdDogJ2ZsaXAnLFxuICAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHYpO1xuICAgICAgICAgIH0pIHx8IGFycmF5SW5jbHVkZXMoWydmbGlwJywgJ2Nsb2Nrd2lzZScsICdjb3VudGVyY2xvY2t3aXNlJ10sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZhcmlhbnQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkdiwgJ3ZhcmlhbnQnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGN1c3RvbUNsYXNzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJHYsICdjdXN0b21DbGFzcycpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVsYXk6IHtcbiAgICAgICAgdHlwZTogW051bWJlciwgT2JqZWN0LCBTdHJpbmddLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkdiwgJ2RlbGF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBib3VuZGFyeToge1xuICAgICAgICAvLyBTdHJpbmc6IHNjcm9sbFBhcmVudCwgd2luZG93LCBvciB2aWV3cG9ydFxuICAgICAgICAvLyBFbGVtZW50OiBlbGVtZW50IHJlZmVyZW5jZVxuICAgICAgICAvLyBPYmplY3Q6IFZ1ZSBjb21wb25lbnRcbiAgICAgICAgdHlwZTogW1N0cmluZywgSFRNTEVsZW1lbnQsIE9iamVjdF0sXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSR2LCAnYm91bmRhcnknKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJvdW5kYXJ5UGFkZGluZzoge1xuICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkdiwgJ2JvdW5kYXJ5UGFkZGluZycpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb2Zmc2V0OiB7XG4gICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgIH0sXG4gICAgICBub0ZhZGU6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBjb250YWluZXI6IHtcbiAgICAgICAgLy8gU3RyaW5nOiBIVE1MIElEIG9mIGNvbnRhaW5lciwgaWYgbnVsbCBib2R5IGlzIHVzZWQgKGRlZmF1bHQpXG4gICAgICAgIC8vIEhUTUxFbGVtZW50OiBlbGVtZW50IHJlZmVyZW5jZSByZWZlcmVuY2VcbiAgICAgICAgLy8gT2JqZWN0OiBWdWUgQ29tcG9uZW50XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIEhUTUxFbGVtZW50LCBPYmplY3RdIC8vIGRlZmF1bHQ6IHVuZGVmaW5lZFxuXG4gICAgICB9LFxuICAgICAgc2hvdzoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIG5vbmludGVyYWN0aXZlOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZGlzYWJsZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBpZDoge1xuICAgICAgICAvLyBJRCB0byB1c2UgZm9yIHRvb2x0aXAgZWxlbWVudFxuICAgICAgICAvLyBJZiBub3QgcHJvdmlkZWQgb24gd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGdlbmVyYXRlZFxuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbFNob3c6IHRoaXMuc2hvdyxcbiAgICAgICAgbG9jYWxUaXRsZTogJycsXG4gICAgICAgIGxvY2FsQ29udGVudDogJydcbiAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgdGVtcGxhdGVEYXRhOiBmdW5jdGlvbiB0ZW1wbGF0ZURhdGEoKSB7XG4gICAgICAgIC8vIERhdGEgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgdGVtcGxhdGUgYW5kIHBvcHBlclxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC8vIFdlIHVzZSBtYXNzYWdlZCB2ZXJzaW9ucyBvZiB0aGUgdGl0bGUgYW5kIGNvbnRlbnQgcHJvcHMvc2xvdHNcbiAgICAgICAgICB0aXRsZTogdGhpcy5sb2NhbFRpdGxlLFxuICAgICAgICAgIGNvbnRlbnQ6IHRoaXMubG9jYWxDb250ZW50LFxuICAgICAgICAgIC8vIFBhc3MgdGhlc2UgcHJvcHMgYXMgaXNcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMudGFyZ2V0LFxuICAgICAgICAgIHRyaWdnZXJzOiB0aGlzLnRyaWdnZXJzLFxuICAgICAgICAgIHBsYWNlbWVudDogdGhpcy5wbGFjZW1lbnQsXG4gICAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnQ6IHRoaXMuZmFsbGJhY2tQbGFjZW1lbnQsXG4gICAgICAgICAgdmFyaWFudDogdGhpcy52YXJpYW50LFxuICAgICAgICAgIGN1c3RvbUNsYXNzOiB0aGlzLmN1c3RvbUNsYXNzLFxuICAgICAgICAgIGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgYm91bmRhcnk6IHRoaXMuYm91bmRhcnksXG4gICAgICAgICAgYm91bmRhcnlQYWRkaW5nOiB0aGlzLmJvdW5kYXJ5UGFkZGluZyxcbiAgICAgICAgICBkZWxheTogdGhpcy5kZWxheSxcbiAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgIG5vRmFkZTogdGhpcy5ub0ZhZGUsXG4gICAgICAgICAgaW50ZXJhY3RpdmU6ICF0aGlzLm5vbmludGVyYWN0aXZlLFxuICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkLFxuICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdGVtcGxhdGVUaXRsZUNvbnRlbnQ6IGZ1bmN0aW9uIHRlbXBsYXRlVGl0bGVDb250ZW50KCkge1xuICAgICAgICAvLyBVc2VkIHRvIHdhdGNoIGZvciBjaGFuZ2VzIHRvIHRoZSB0aXRsZSBhbmQgY29udGVudCBwcm9wc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRpdGxlOiB0aGlzLnRpdGxlLFxuICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgIHNob3c6IGZ1bmN0aW9uIHNob3coX3Nob3csIG9sZFZhbCkge1xuICAgICAgICBpZiAoX3Nob3cgIT09IG9sZFZhbCAmJiBfc2hvdyAhPT0gdGhpcy5sb2NhbFNob3cgJiYgdGhpcy4kX2J2X3Rvb2xwb3ApIHtcbiAgICAgICAgICBpZiAoX3Nob3cpIHtcbiAgICAgICAgICAgIHRoaXMuJF9idl90b29scG9wLnNob3coKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgdXNlIGBmb3JjZUhpZGUoKWAgdG8gb3ZlcnJpZGUgYW55IGFjdGl2ZSB0cmlnZ2Vyc1xuICAgICAgICAgICAgdGhpcy4kX2J2X3Rvb2xwb3AuZm9yY2VIaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzYWJsZWQ6IGZ1bmN0aW9uIGRpc2FibGVkKG5ld1ZhbCkge1xuICAgICAgICBpZiAobmV3VmFsKSB7XG4gICAgICAgICAgdGhpcy5kb0Rpc2FibGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRvRW5hYmxlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsb2NhbFNob3c6IGZ1bmN0aW9uIGxvY2FsU2hvdyhuZXdWYWwpIHtcbiAgICAgICAgLy8gVE9ETzogTWF5IG5lZWQgdG8gYmUgZG9uZSBpbiBhIGAkbmV4dFRpY2soKWBcbiAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOnNob3cnLCBuZXdWYWwpO1xuICAgICAgfSxcbiAgICAgIHRlbXBsYXRlRGF0YTogZnVuY3Rpb24gdGVtcGxhdGVEYXRhKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuJF9idl90b29scG9wKSB7XG4gICAgICAgICAgICBfdGhpcy4kX2J2X3Rvb2xwb3AudXBkYXRlRGF0YShfdGhpcy50ZW1wbGF0ZURhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgLy8gV2F0Y2hlcnMgZm9yIHRpdGxlL2NvbnRlbnQgcHJvcHMgKHByb3AgY2hhbmdlcyBkbyBub3QgdHJpZ2dlciB0aGUgYHVwZGF0ZWQoKWAgaG9vaylcbiAgICAgIHRlbXBsYXRlVGl0bGVDb250ZW50OiBmdW5jdGlvbiB0ZW1wbGF0ZVRpdGxlQ29udGVudCgpIHtcbiAgICAgICAgdGhpcy4kbmV4dFRpY2sodGhpcy51cGRhdGVDb250ZW50KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgICAvLyBOb24gcmVhY3RpdmUgcHJvcGVydGllc1xuICAgICAgdGhpcy4kX2J2X3Rvb2xwb3AgPSBudWxsO1xuICAgIH0sXG4gICAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCgpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgYHByb3BEYXRhYCBvYmplY3RcbiAgICAgIC8vIERvbmUgaW4gYSBgJG5leHRUaWNrKClgIHRvIGVuc3VyZSBzbG90KHMpIGhhdmUgdXBkYXRlZFxuICAgICAgdGhpcy4kbmV4dFRpY2sodGhpcy51cGRhdGVDb250ZW50KTtcbiAgICB9LFxuICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgICAvLyBTaHV0ZG93biBvdXIgbG9jYWwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB0aGlzLiRvZmYoJ29wZW4nLCB0aGlzLmRvT3Blbik7XG4gICAgICB0aGlzLiRvZmYoJ2Nsb3NlJywgdGhpcy5kb0Nsb3NlKTtcbiAgICAgIHRoaXMuJG9mZignZGlzYWJsZScsIHRoaXMuZG9EaXNhYmxlKTtcbiAgICAgIHRoaXMuJG9mZignZW5hYmxlJywgdGhpcy5kb0VuYWJsZSk7IC8vIERlc3Ryb3kgdGhlIHRpcCBpbnN0YW5jZVxuXG4gICAgICB0aGlzLiRfYnZfdG9vbHBvcCAmJiB0aGlzLiRfYnZfdG9vbHBvcC4kZGVzdHJveSgpO1xuICAgICAgdGhpcy4kX2J2X3Rvb2xwb3AgPSBudWxsO1xuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBJbnN0YW50aWF0ZSBhIG5ldyBCVlRvb2x0aXAgaW5zdGFuY2VcbiAgICAgIC8vIERvbmUgaW4gYSBgJG5leHRUaWNrKClgIHRvIGVuc3VyZSBET00gaGFzIGNvbXBsZXRlZCByZW5kZXJpbmdcbiAgICAgIC8vIHNvIHRoYXQgdGFyZ2V0IGNhbiBiZSBmb3VuZFxuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBMb2FkIHRoZSBvbiBkZW1hbmQgY2hpbGQgaW5zdGFuY2VcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IF90aGlzMi5nZXRDb21wb25lbnQoKTsgLy8gRW5zdXJlIHdlIGhhdmUgaW5pdGlhbCBjb250ZW50XG5cblxuICAgICAgICBfdGhpczIudXBkYXRlQ29udGVudCgpOyAvLyBQYXNzIGRvd24gdGhlIHNjb3BlZCBzdHlsZSBhdHRyaWJ1dGUgaWYgYXZhaWxhYmxlXG5cblxuICAgICAgICB2YXIgc2NvcGVJZCA9IGdldFNjb3BlSWQoX3RoaXMyKSB8fCBnZXRTY29wZUlkKF90aGlzMi4kcGFyZW50KTsgLy8gQ3JlYXRlIHRoZSBpbnN0YW5jZVxuXG4gICAgICAgIHZhciAkdG9vbHBvcCA9IF90aGlzMi4kX2J2X3Rvb2xwb3AgPSBuZXcgQ29tcG9uZW50KHtcbiAgICAgICAgICBwYXJlbnQ6IF90aGlzMixcbiAgICAgICAgICAvLyBQYXNzIGRvd24gdGhlIHNjb3BlZCBzdHlsZSBJRFxuICAgICAgICAgIF9zY29wZUlkOiBzY29wZUlkIHx8IHVuZGVmaW5lZFxuICAgICAgICB9KTsgLy8gU2V0IHRoZSBpbml0aWFsIGRhdGFcblxuICAgICAgICAkdG9vbHBvcC51cGRhdGVEYXRhKF90aGlzMi50ZW1wbGF0ZURhdGEpOyAvLyBTZXQgbGlzdGVuZXJzXG5cbiAgICAgICAgJHRvb2xwb3AuJG9uKCdzaG93JywgX3RoaXMyLm9uU2hvdyk7XG4gICAgICAgICR0b29scG9wLiRvbignc2hvd24nLCBfdGhpczIub25TaG93bik7XG4gICAgICAgICR0b29scG9wLiRvbignaGlkZScsIF90aGlzMi5vbkhpZGUpO1xuICAgICAgICAkdG9vbHBvcC4kb24oJ2hpZGRlbicsIF90aGlzMi5vbkhpZGRlbik7XG4gICAgICAgICR0b29scG9wLiRvbignZGlzYWJsZWQnLCBfdGhpczIub25EaXNhYmxlZCk7XG4gICAgICAgICR0b29scG9wLiRvbignZW5hYmxlZCcsIF90aGlzMi5vbkVuYWJsZWQpOyAvLyBJbml0aWFsbHkgZGlzYWJsZWQ/XG5cbiAgICAgICAgaWYgKF90aGlzMi5kaXNhYmxlZCkge1xuICAgICAgICAgIC8vIEluaXRpYWxseSBkaXNhYmxlZFxuICAgICAgICAgIF90aGlzMi5kb0Rpc2FibGUoKTtcbiAgICAgICAgfSAvLyBMaXN0ZW4gdG8gb3BlbiBzaWduYWxzIGZyb20gb3RoZXJzXG5cblxuICAgICAgICBfdGhpczIuJG9uKCdvcGVuJywgX3RoaXMyLmRvT3Blbik7IC8vIExpc3RlbiB0byBjbG9zZSBzaWduYWxzIGZyb20gb3RoZXJzXG5cblxuICAgICAgICBfdGhpczIuJG9uKCdjbG9zZScsIF90aGlzMi5kb0Nsb3NlKTsgLy8gTGlzdGVuIHRvIGRpc2FibGUgc2lnbmFscyBmcm9tIG90aGVyc1xuXG5cbiAgICAgICAgX3RoaXMyLiRvbignZGlzYWJsZScsIF90aGlzMi5kb0Rpc2FibGUpOyAvLyBMaXN0ZW4gdG8gZW5hYmxlIHNpZ25hbHMgZnJvbSBvdGhlcnNcblxuXG4gICAgICAgIF90aGlzMi4kb24oJ2VuYWJsZScsIF90aGlzMi5kb0VuYWJsZSk7IC8vIEluaXRpYWxseSBzaG93IHRvb2x0aXA/XG5cblxuICAgICAgICBpZiAoX3RoaXMyLmxvY2FsU2hvdykge1xuICAgICAgICAgIF90aGlzMi4kX2J2X3Rvb2xwb3AgJiYgX3RoaXMyLiRfYnZfdG9vbHBvcC5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgZ2V0Q29tcG9uZW50OiBmdW5jdGlvbiBnZXRDb21wb25lbnQoKSB7XG4gICAgICAgIC8vIE92ZXJyaWRkZW4gYnkgQlBvcG92ZXJcbiAgICAgICAgcmV0dXJuIEJWVG9vbHRpcDtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVDb250ZW50OiBmdW5jdGlvbiB1cGRhdGVDb250ZW50KCkge1xuICAgICAgICAvLyBPdmVycmlkZGVuIGJ5IEJQb3BvdmVyXG4gICAgICAgIC8vIFRvb2x0aXA6IERlZmF1bHQgc2xvdCBpcyBgdGl0bGVgXG4gICAgICAgIC8vIFBvcG92ZXI6IERlZmF1bHQgc2xvdCBpcyBgY29udGVudGAsIGB0aXRsZWAgc2xvdCBpcyB0aXRsZVxuICAgICAgICAvLyBXZSBwYXNzIGEgc2NvcGVkIHNsb3QgZnVuY3Rpb24gcmVmZXJlbmNlIGJ5IGRlZmF1bHQgKFZ1ZSB2Mi42eClcbiAgICAgICAgLy8gQW5kIHBhc3MgdGhlIHRpdGxlIHByb3AgYXMgYSBmYWxsYmFja1xuICAgICAgICB0aGlzLnNldFRpdGxlKHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQgfHwgdGhpcy50aXRsZSk7XG4gICAgICB9LFxuICAgICAgLy8gSGVscGVyIG1ldGhvZHMgZm9yIGB1cGRhdGVDb250ZW50KClgXG4gICAgICBzZXRUaXRsZTogZnVuY3Rpb24gc2V0VGl0bGUodmFsKSB7XG4gICAgICAgIHZhbCA9IGlzVW5kZWZpbmVkT3JOdWxsKHZhbCkgPyAnJyA6IHZhbDsgLy8gV2Ugb25seSB1cGRhdGUgdGhlIHZhbHVlIGlmIGl0IGhhcyBjaGFuZ2VkXG5cbiAgICAgICAgaWYgKHRoaXMubG9jYWxUaXRsZSAhPT0gdmFsKSB7XG4gICAgICAgICAgdGhpcy5sb2NhbFRpdGxlID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0Q29udGVudDogZnVuY3Rpb24gc2V0Q29udGVudCh2YWwpIHtcbiAgICAgICAgdmFsID0gaXNVbmRlZmluZWRPck51bGwodmFsKSA/ICcnIDogdmFsOyAvLyBXZSBvbmx5IHVwZGF0ZSB0aGUgdmFsdWUgaWYgaXQgaGFzIGNoYW5nZWRcblxuICAgICAgICBpZiAodGhpcy5sb2NhbENvbnRlbnQgIT09IHZhbCkge1xuICAgICAgICAgIHRoaXMubG9jYWxDb250ZW50ID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gLS0tIFRlbXBsYXRlIGV2ZW50IGhhbmRsZXJzIC0tLVxuICAgICAgb25TaG93OiBmdW5jdGlvbiBvblNob3coYnZFdnQpIHtcbiAgICAgICAgLy8gUGxhY2Vob2xkZXJcbiAgICAgICAgdGhpcy4kZW1pdCgnc2hvdycsIGJ2RXZ0KTtcblxuICAgICAgICBpZiAoYnZFdnQpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsU2hvdyA9ICFidkV2dC5kZWZhdWx0UHJldmVudGVkO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25TaG93bjogZnVuY3Rpb24gb25TaG93bihidkV2dCkge1xuICAgICAgICAvLyBUaXAgaXMgbm93IHNob3dpbmdcbiAgICAgICAgdGhpcy5sb2NhbFNob3cgPSB0cnVlO1xuICAgICAgICB0aGlzLiRlbWl0KCdzaG93bicsIGJ2RXZ0KTtcbiAgICAgIH0sXG4gICAgICBvbkhpZGU6IGZ1bmN0aW9uIG9uSGlkZShidkV2dCkge1xuICAgICAgICB0aGlzLiRlbWl0KCdoaWRlJywgYnZFdnQpO1xuICAgICAgfSxcbiAgICAgIG9uSGlkZGVuOiBmdW5jdGlvbiBvbkhpZGRlbihidkV2dCkge1xuICAgICAgICAvLyBUaXAgaXMgbm8gbG9uZ2VyIHNob3dpbmdcbiAgICAgICAgdGhpcy4kZW1pdCgnaGlkZGVuJywgYnZFdnQpO1xuICAgICAgICB0aGlzLmxvY2FsU2hvdyA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIG9uRGlzYWJsZWQ6IGZ1bmN0aW9uIG9uRGlzYWJsZWQoYnZFdnQpIHtcbiAgICAgICAgLy8gUHJldmVudCBwb3NzaWJsZSBlbmRsZXNzIGxvb3AgaWYgdXNlciBtaXN0YWtlbmx5XG4gICAgICAgIC8vIGZpcmVzIGBkaXNhYmxlZGAgaW5zdGVhZCBvZiBgZGlzYWJsZWBcbiAgICAgICAgaWYgKGJ2RXZ0ICYmIGJ2RXZ0LnR5cGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6ZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdkaXNhYmxlZCcsIGJ2RXZ0KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uRW5hYmxlZDogZnVuY3Rpb24gb25FbmFibGVkKGJ2RXZ0KSB7XG4gICAgICAgIC8vIFByZXZlbnQgcG9zc2libGUgZW5kbGVzcyBsb29wIGlmIHVzZXIgbWlzdGFrZW5seVxuICAgICAgICAvLyBmaXJlcyBgZW5hYmxlZGAgaW5zdGVhZCBvZiBgZW5hYmxlYFxuICAgICAgICBpZiAoYnZFdnQgJiYgYnZFdnQudHlwZSA9PT0gJ2VuYWJsZWQnKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOmRpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ2VuYWJsZWQnLCBidkV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAtLS0gTG9jYWwgZXZlbnQgbGlzdGVuZXJzIC0tLVxuICAgICAgZG9PcGVuOiBmdW5jdGlvbiBkb09wZW4oKSB7XG4gICAgICAgICF0aGlzLmxvY2FsU2hvdyAmJiB0aGlzLiRfYnZfdG9vbHBvcCAmJiB0aGlzLiRfYnZfdG9vbHBvcC5zaG93KCk7XG4gICAgICB9LFxuICAgICAgZG9DbG9zZTogZnVuY3Rpb24gZG9DbG9zZSgpIHtcbiAgICAgICAgdGhpcy5sb2NhbFNob3cgJiYgdGhpcy4kX2J2X3Rvb2xwb3AgJiYgdGhpcy4kX2J2X3Rvb2xwb3AuaGlkZSgpO1xuICAgICAgfSxcbiAgICAgIGRvRGlzYWJsZTogZnVuY3Rpb24gZG9EaXNhYmxlKCkge1xuICAgICAgICB0aGlzLiRfYnZfdG9vbHBvcCAmJiB0aGlzLiRfYnZfdG9vbHBvcC5kaXNhYmxlKCk7XG4gICAgICB9LFxuICAgICAgZG9FbmFibGU6IGZ1bmN0aW9uIGRvRW5hYmxlKCkge1xuICAgICAgICB0aGlzLiRfYnZfdG9vbHBvcCAmJiB0aGlzLiRfYnZfdG9vbHBvcC5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIC8vIEFsd2F5cyByZW5kZXJzIGEgY29tbWVudCBub2RlXG4gICAgICAvLyBUT0RPOlxuICAgICAgLy8gICBGdXR1cmU6IFBvc3NpYmx5IHJlbmRlciBhIHRhcmdldCBzbG90IChzaW5nbGUgcm9vdCBlbGVtZW50KVxuICAgICAgLy8gICB3aGljaCB3ZSBjYW4gYXBwbHkgdGhlIGxpc3RlbmVycyB0byAocGFzcyBgdGhpcy4kZWxgIHRvIEJWVG9vbHRpcClcbiAgICAgIHJldHVybiBoKCk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgTkFNRSR3ID0gJ0JWUG9wb3ZlclRlbXBsYXRlJzsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQlZQb3BvdmVyVGVtcGxhdGUgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6IE5BTUUkdyxcbiAgICBleHRlbmRzOiBCVlRvb2x0aXBUZW1wbGF0ZSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgdGVtcGxhdGVUeXBlOiBmdW5jdGlvbiB0ZW1wbGF0ZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiAncG9wb3Zlcic7XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICByZW5kZXJUZW1wbGF0ZTogZnVuY3Rpb24gcmVuZGVyVGVtcGxhdGUoaCkge1xuICAgICAgICAvLyBUaXRsZSBhbmQgY29udGVudCBjb3VsZCBiZSBhIHNjb3BlZCBzbG90IGZ1bmN0aW9uXG4gICAgICAgIHZhciAkdGl0bGUgPSBpc0Z1bmN0aW9uKHRoaXMudGl0bGUpID8gdGhpcy50aXRsZSh7fSkgOiB0aGlzLnRpdGxlO1xuICAgICAgICB2YXIgJGNvbnRlbnQgPSBpc0Z1bmN0aW9uKHRoaXMuY29udGVudCkgPyB0aGlzLmNvbnRlbnQoe30pIDogdGhpcy5jb250ZW50OyAvLyBEaXJlY3RpdmUgdXNhZ2Ugb25seVxuXG4gICAgICAgIHZhciB0aXRsZURvbVByb3BzID0gdGhpcy5odG1sICYmICFpc0Z1bmN0aW9uKHRoaXMudGl0bGUpID8ge1xuICAgICAgICAgIGlubmVySFRNTDogdGhpcy50aXRsZVxuICAgICAgICB9IDoge307XG4gICAgICAgIHZhciBjb250ZW50RG9tUHJvcHMgPSB0aGlzLmh0bWwgJiYgIWlzRnVuY3Rpb24odGhpcy5jb250ZW50KSA/IHtcbiAgICAgICAgICBpbm5lckhUTUw6IHRoaXMuY29udGVudFxuICAgICAgICB9IDoge307XG4gICAgICAgIHJldHVybiBoKCdkaXYnLCB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICdwb3BvdmVyIGItcG9wb3ZlcicsXG4gICAgICAgICAgY2xhc3M6IHRoaXMudGVtcGxhdGVDbGFzc2VzLFxuICAgICAgICAgIGF0dHJzOiB0aGlzLnRlbXBsYXRlQXR0cmlidXRlcyxcbiAgICAgICAgICBvbjogdGhpcy50ZW1wbGF0ZUxpc3RlbmVyc1xuICAgICAgICB9LCBbaCgnZGl2Jywge1xuICAgICAgICAgIHJlZjogJ2Fycm93JyxcbiAgICAgICAgICBzdGF0aWNDbGFzczogJ2Fycm93J1xuICAgICAgICB9KSwgaXNVbmRlZmluZWRPck51bGwoJHRpdGxlKSB8fCAkdGl0bGUgPT09ICcnID8gaCgpIDogaCgnaDMnLCB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICdwb3BvdmVyLWhlYWRlcicsXG4gICAgICAgICAgZG9tUHJvcHM6IHRpdGxlRG9tUHJvcHNcbiAgICAgICAgfSwgWyR0aXRsZV0pLCBpc1VuZGVmaW5lZE9yTnVsbCgkY29udGVudCkgfHwgJGNvbnRlbnQgPT09ICcnID8gaCgpIDogaCgnZGl2Jywge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiAncG9wb3Zlci1ib2R5JyxcbiAgICAgICAgICBkb21Qcm9wczogY29udGVudERvbVByb3BzXG4gICAgICAgIH0sIFskY29udGVudF0pXSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBQb3BvdmVyIFwiQ2xhc3NcIiAoQnVpbHQgYXMgYSByZW5kZXJsZXNzIFZ1ZSBpbnN0YW5jZSlcbiAgdmFyIE5BTUUkeCA9ICdCVlBvcG92ZXInOyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCVlBvcG92ZXIgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6IE5BTUUkeCxcbiAgICBleHRlbmRzOiBCVlRvb2x0aXAsXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIC8vIE92ZXJ3cml0ZXMgQlZUb29sdGlwXG4gICAgICB0ZW1wbGF0ZVR5cGU6IGZ1bmN0aW9uIHRlbXBsYXRlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdwb3BvdmVyJztcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGdldFRlbXBsYXRlOiBmdW5jdGlvbiBnZXRUZW1wbGF0ZSgpIHtcbiAgICAgICAgLy8gT3ZlcndyaXRlcyBCVlRvb2x0aXBcbiAgICAgICAgcmV0dXJuIEJWUG9wb3ZlclRlbXBsYXRlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIE5BTUUkeSA9ICdCUG9wb3Zlcic7XG4gIHZhciBCUG9wb3ZlciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogTkFNRSR5LFxuICAgIGV4dGVuZHM6IEJUb29sdGlwLFxuICAgIGluaGVyaXRBdHRyczogZmFsc2UsXG4gICAgcHJvcHM6IHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyAvLyBkZWZhdWx0OiB1bmRlZmluZWRcblxuICAgICAgfSxcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nIC8vIGRlZmF1bHQ6IHVuZGVmaW5lZFxuXG4gICAgICB9LFxuICAgICAgdHJpZ2dlcnM6IHtcbiAgICAgICAgdHlwZTogW1N0cmluZywgQXJyYXldLFxuICAgICAgICBkZWZhdWx0OiAnY2xpY2snXG4gICAgICB9LFxuICAgICAgcGxhY2VtZW50OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ3JpZ2h0J1xuICAgICAgfSxcbiAgICAgIHZhcmlhbnQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkeSwgJ3ZhcmlhbnQnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGN1c3RvbUNsYXNzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJHksICdjdXN0b21DbGFzcycpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVsYXk6IHtcbiAgICAgICAgdHlwZTogW051bWJlciwgT2JqZWN0LCBTdHJpbmddLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkeSwgJ2RlbGF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBib3VuZGFyeToge1xuICAgICAgICAvLyBTdHJpbmc6IHNjcm9sbFBhcmVudCwgd2luZG93LCBvciB2aWV3cG9ydFxuICAgICAgICAvLyBFbGVtZW50OiBlbGVtZW50IHJlZmVyZW5jZVxuICAgICAgICAvLyBPYmplY3Q6IFZ1ZSBjb21wb25lbnRcbiAgICAgICAgdHlwZTogW1N0cmluZywgSFRNTEVsZW1lbnQsIE9iamVjdF0sXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSR5LCAnYm91bmRhcnknKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJvdW5kYXJ5UGFkZGluZzoge1xuICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkeSwgJ2JvdW5kYXJ5UGFkZGluZycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uIGdldENvbXBvbmVudCgpIHtcbiAgICAgICAgLy8gT3ZlcnJpZGRlbiBieSBCUG9wb3ZlclxuICAgICAgICByZXR1cm4gQlZQb3BvdmVyO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uIHVwZGF0ZUNvbnRlbnQoKSB7XG4gICAgICAgIC8vIFRvb2x0aXA6IERlZmF1bHQgc2xvdCBpcyBgdGl0bGVgXG4gICAgICAgIC8vIFBvcG92ZXI6IERlZmF1bHQgc2xvdCBpcyBgY29udGVudGAsIGB0aXRsZWAgc2xvdCBpcyB0aXRsZVxuICAgICAgICAvLyBXZSBwYXNzIGEgc2NvcGVkIHNsb3QgZnVuY3Rpb24gcmVmZXJlbmNlcyBieSBkZWZhdWx0IChWdWUgdjIuNngpXG4gICAgICAgIC8vIEFuZCBwYXNzIHRoZSB0aXRsZSBwcm9wIGFzIGEgZmFsbGJhY2tcbiAgICAgICAgdGhpcy5zZXRDb250ZW50KHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQgfHwgdGhpcy5jb250ZW50KTtcbiAgICAgICAgdGhpcy5zZXRUaXRsZSh0aGlzLiRzY29wZWRTbG90cy50aXRsZSB8fCB0aGlzLnRpdGxlKTtcbiAgICAgIH1cbiAgICB9IC8vIFJlbmRlciBmdW5jdGlvbiBwcm92aWRlZCBieSBCVG9vbHRpcFxuXG4gIH0pO1xuXG4gIHZhciBCVl9QT1BPVkVSID0gJ19fQlZfUG9wb3Zlcl9fJzsgLy8gRGVmYXVsdCB0cmlnZ2VyXG5cbiAgdmFyIERlZmF1bHRUcmlnZ2VyID0gJ2NsaWNrJzsgLy8gVmFsaWQgZXZlbnQgdHJpZ2dlcnNcblxuICB2YXIgdmFsaWRUcmlnZ2VycyA9IHtcbiAgICBmb2N1czogdHJ1ZSxcbiAgICBob3ZlcjogdHJ1ZSxcbiAgICBjbGljazogdHJ1ZSxcbiAgICBibHVyOiB0cnVlLFxuICAgIG1hbnVhbDogdHJ1ZVxuICB9OyAvLyBEaXJlY3RpdmUgbW9kaWZpZXIgdGVzdCByZWd1bGFyIGV4cHJlc3Npb25zLiBQcmUtY29tcGlsZSBmb3IgcGVyZm9ybWFuY2VcblxuICB2YXIgaHRtbFJFID0gL15odG1sJC9pO1xuICB2YXIgbm9GYWRlUkUgPSAvXm5vZmFkZSQvaTtcbiAgdmFyIHBsYWNlbWVudFJFID0gL14oYXV0b3x0b3AobGVmdHxyaWdodCk/fGJvdHRvbShsZWZ0fHJpZ2h0KT98bGVmdCh0b3B8Ym90dG9tKT98cmlnaHQodG9wfGJvdHRvbSk/KSQvaTtcbiAgdmFyIGJvdW5kYXJ5UkUgPSAvXih3aW5kb3d8dmlld3BvcnR8c2Nyb2xsUGFyZW50KSQvaTtcbiAgdmFyIGRlbGF5UkUgPSAvXmRcXGQrJC9pO1xuICB2YXIgZGVsYXlTaG93UkUgPSAvXmRzXFxkKyQvaTtcbiAgdmFyIGRlbGF5SGlkZVJFID0gL15kaFxcZCskL2k7XG4gIHZhciBvZmZzZXRSRSA9IC9eby0/XFxkKyQvaTtcbiAgdmFyIHZhcmlhbnRSRSA9IC9edi0uKyQvaTtcbiAgdmFyIHNwYWNlc1JFID0gL1xccysvOyAvLyBCdWlsZCBhIFBvcG92ZXIgY29uZmlnIGJhc2VkIG9uIGJpbmRpbmdzIChpZiBhbnkpXG4gIC8vIEFyZ3VtZW50cyBhbmQgbW9kaWZpZXJzIHRha2UgcHJlY2VkZW5jZSBvdmVyIHBhc3NlZCB2YWx1ZSBjb25maWcgb2JqZWN0XG5cbiAgdmFyIHBhcnNlQmluZGluZ3MgPSBmdW5jdGlvbiBwYXJzZUJpbmRpbmdzKGJpbmRpbmdzLCB2bm9kZSlcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCBlYXN5IHRvIHRlc3QgKi9cbiAge1xuICAgIC8vIFdlIHN0YXJ0IG91dCB3aXRoIGEgYmFzaWMgY29uZmlnXG4gICAgdmFyIE5BTUUgPSAnQlBvcG92ZXInO1xuICAgIHZhciBjb25maWcgPSB7XG4gICAgICB0aXRsZTogdW5kZWZpbmVkLFxuICAgICAgY29udGVudDogdW5kZWZpbmVkLFxuICAgICAgdHJpZ2dlcjogJycsXG4gICAgICAvLyBEZWZhdWx0IHNldCBiZWxvdyBpZiBuZWVkZWRcbiAgICAgIHBsYWNlbWVudDogJ3JpZ2h0JyxcbiAgICAgIGZhbGxiYWNrUGxhY2VtZW50OiAnZmxpcCcsXG4gICAgICBjb250YWluZXI6IGZhbHNlLFxuICAgICAgLy8gRGVmYXVsdCBvZiBib2R5XG4gICAgICBhbmltYXRpb246IHRydWUsXG4gICAgICBvZmZzZXQ6IDAsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICBpZDogbnVsbCxcbiAgICAgIGh0bWw6IGZhbHNlLFxuICAgICAgZGVsYXk6IGdldENvbXBvbmVudENvbmZpZyhOQU1FLCAnZGVsYXknKSxcbiAgICAgIGJvdW5kYXJ5OiBTdHJpbmcoZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUsICdib3VuZGFyeScpKSxcbiAgICAgIGJvdW5kYXJ5UGFkZGluZzogcGFyc2VJbnQoZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUsICdib3VuZGFyeVBhZGRpbmcnKSwgMTApIHx8IDAsXG4gICAgICB2YXJpYW50OiBnZXRDb21wb25lbnRDb25maWcoTkFNRSwgJ3ZhcmlhbnQnKSxcbiAgICAgIGN1c3RvbUNsYXNzOiBnZXRDb21wb25lbnRDb25maWcoTkFNRSwgJ2N1c3RvbUNsYXNzJylcbiAgICB9OyAvLyBQcm9jZXNzIGBiaW5kaW5ncy52YWx1ZWBcblxuICAgIGlmIChpc1N0cmluZyhiaW5kaW5ncy52YWx1ZSkgfHwgaXNOdW1iZXIoYmluZGluZ3MudmFsdWUpKSB7XG4gICAgICAvLyBWYWx1ZSBpcyBwb3BvdmVyIGNvbnRlbnQgKGh0bWwgb3B0aW9uYWxseSBzdXBwb3J0ZWQpXG4gICAgICBjb25maWcuY29udGVudCA9IGJpbmRpbmdzLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihiaW5kaW5ncy52YWx1ZSkpIHtcbiAgICAgIC8vIENvbnRlbnQgZ2VuZXJhdG9yIGZ1bmN0aW9uXG4gICAgICBjb25maWcuY29udGVudCA9IGJpbmRpbmdzLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChiaW5kaW5ncy52YWx1ZSkpIHtcbiAgICAgIC8vIFZhbHVlIGlzIGNvbmZpZyBvYmplY3QsIHNvIG1lcmdlXG4gICAgICBjb25maWcgPSBfb2JqZWN0U3ByZWFkMih7fSwgY29uZmlnLCB7fSwgYmluZGluZ3MudmFsdWUpO1xuICAgIH0gLy8gSWYgYXJndW1lbnQsIGFzc3VtZSBlbGVtZW50IElEIG9mIGNvbnRhaW5lciBlbGVtZW50XG5cblxuICAgIGlmIChiaW5kaW5ncy5hcmcpIHtcbiAgICAgIC8vIEVsZW1lbnQgSUQgc3BlY2lmaWVkIGFzIGFyZ1xuICAgICAgLy8gV2UgbXVzdCBwcmVwZW5kICcjJyB0byBiZWNvbWUgYSBDU1Mgc2VsZWN0b3JcbiAgICAgIGNvbmZpZy5jb250YWluZXIgPSBcIiNcIi5jb25jYXQoYmluZGluZ3MuYXJnKTtcbiAgICB9IC8vIElmIHRpdGxlIGlzIG5vdCBwcm92aWRlZCwgdHJ5IHRpdGxlIGF0dHJpYnV0ZVxuXG5cbiAgICBpZiAoaXNVbmRlZmluZWQoY29uZmlnLnRpdGxlKSkge1xuICAgICAgLy8gVHJ5IGF0dHJpYnV0ZVxuICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhIHx8IHt9O1xuICAgICAgY29uZmlnLnRpdGxlID0gZGF0YS5hdHRycyAmJiAhaXNVbmRlZmluZWRPck51bGwoZGF0YS5hdHRycy50aXRsZSkgPyBkYXRhLmF0dHJzLnRpdGxlIDogdW5kZWZpbmVkO1xuICAgIH0gLy8gTm9ybWFsaXplIGRlbGF5XG5cblxuICAgIGlmICghaXNQbGFpbk9iamVjdChjb25maWcuZGVsYXkpKSB7XG4gICAgICBjb25maWcuZGVsYXkgPSB7XG4gICAgICAgIHNob3c6IHBhcnNlSW50KGNvbmZpZy5kZWxheSwgMTApIHx8IDAsXG4gICAgICAgIGhpZGU6IHBhcnNlSW50KGNvbmZpZy5kZWxheSwgMTApIHx8IDBcbiAgICAgIH07XG4gICAgfSAvLyBQcm9jZXNzIG1vZGlmaWVyc1xuXG5cbiAgICBrZXlzKGJpbmRpbmdzLm1vZGlmaWVycykuZm9yRWFjaChmdW5jdGlvbiAobW9kKSB7XG4gICAgICBpZiAoaHRtbFJFLnRlc3QobW9kKSkge1xuICAgICAgICAvLyBUaXRsZS9jb250ZW50IGFsbG93cyBIVE1MXG4gICAgICAgIGNvbmZpZy5odG1sID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAobm9GYWRlUkUudGVzdChtb2QpKSB7XG4gICAgICAgIC8vIE5vIGFuaW1hdGlvblxuICAgICAgICBjb25maWcuYW5pbWF0aW9uID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHBsYWNlbWVudFJFLnRlc3QobW9kKSkge1xuICAgICAgICAvLyBQbGFjZW1lbnQgb2YgcG9wb3ZlclxuICAgICAgICBjb25maWcucGxhY2VtZW50ID0gbW9kO1xuICAgICAgfSBlbHNlIGlmIChib3VuZGFyeVJFLnRlc3QobW9kKSkge1xuICAgICAgICAvLyBCb3VuZGFyeSBvZiBwb3BvdmVyXG4gICAgICAgIG1vZCA9IG1vZCA9PT0gJ3Njcm9sbHBhcmVudCcgPyAnc2Nyb2xsUGFyZW50JyA6IG1vZDtcbiAgICAgICAgY29uZmlnLmJvdW5kYXJ5ID0gbW9kO1xuICAgICAgfSBlbHNlIGlmIChkZWxheVJFLnRlc3QobW9kKSkge1xuICAgICAgICAvLyBEZWxheSB2YWx1ZVxuICAgICAgICB2YXIgZGVsYXkgPSBwYXJzZUludChtb2Quc2xpY2UoMSksIDEwKSB8fCAwO1xuICAgICAgICBjb25maWcuZGVsYXkuc2hvdyA9IGRlbGF5O1xuICAgICAgICBjb25maWcuZGVsYXkuaGlkZSA9IGRlbGF5O1xuICAgICAgfSBlbHNlIGlmIChkZWxheVNob3dSRS50ZXN0KG1vZCkpIHtcbiAgICAgICAgLy8gRGVsYXkgc2hvdyB2YWx1ZVxuICAgICAgICBjb25maWcuZGVsYXkuc2hvdyA9IHBhcnNlSW50KG1vZC5zbGljZSgyKSwgMTApIHx8IDA7XG4gICAgICB9IGVsc2UgaWYgKGRlbGF5SGlkZVJFLnRlc3QobW9kKSkge1xuICAgICAgICAvLyBEZWxheSBoaWRlIHZhbHVlXG4gICAgICAgIGNvbmZpZy5kZWxheS5oaWRlID0gcGFyc2VJbnQobW9kLnNsaWNlKDIpLCAxMCkgfHwgMDtcbiAgICAgIH0gZWxzZSBpZiAob2Zmc2V0UkUudGVzdChtb2QpKSB7XG4gICAgICAgIC8vIE9mZnNldCB2YWx1ZSwgbmVnYXRpdmUgYWxsb3dlZFxuICAgICAgICBjb25maWcub2Zmc2V0ID0gcGFyc2VJbnQobW9kLnNsaWNlKDEpLCAxMCkgfHwgMDtcbiAgICAgIH0gZWxzZSBpZiAodmFyaWFudFJFLnRlc3QobW9kKSkge1xuICAgICAgICAvLyBWYXJpYW50XG4gICAgICAgIGNvbmZpZy52YXJpYW50ID0gbW9kLnNsaWNlKDIpIHx8IG51bGw7XG4gICAgICB9XG4gICAgfSk7IC8vIFNwZWNpYWwgaGFuZGxpbmcgb2YgZXZlbnQgdHJpZ2dlciBtb2RpZmllcnMgdHJpZ2dlciBpc1xuICAgIC8vIGEgc3BhY2Ugc2VwYXJhdGVkIGxpc3RcblxuICAgIHZhciBzZWxlY3RlZFRyaWdnZXJzID0ge307IC8vIFBhcnNlIGN1cnJlbnQgY29uZmlnIG9iamVjdCB0cmlnZ2VyXG5cbiAgICBjb25jYXQoY29uZmlnLnRyaWdnZXIgfHwgJycpLmZpbHRlcihpZGVudGl0eSkuam9pbignICcpLnRyaW0oKS50b0xvd2VyQ2FzZSgpLnNwbGl0KHNwYWNlc1JFKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmlnZ2VyKSB7XG4gICAgICBpZiAodmFsaWRUcmlnZ2Vyc1t0cmlnZ2VyXSkge1xuICAgICAgICBzZWxlY3RlZFRyaWdnZXJzW3RyaWdnZXJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTsgLy8gUGFyc2UgbW9kaWZpZXJzIGZvciB0cmlnZ2Vyc1xuXG4gICAga2V5cyhiaW5kaW5ncy5tb2RpZmllcnMpLmZvckVhY2goZnVuY3Rpb24gKG1vZCkge1xuICAgICAgbW9kID0gbW9kLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmICh2YWxpZFRyaWdnZXJzW21vZF0pIHtcbiAgICAgICAgLy8gSWYgbW9kaWZpZXIgaXMgYSB2YWxpZCB0cmlnZ2VyXG4gICAgICAgIHNlbGVjdGVkVHJpZ2dlcnNbbW9kXSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7IC8vIFNhbml0aXplIHRyaWdnZXJzXG5cbiAgICBjb25maWcudHJpZ2dlciA9IGtleXMoc2VsZWN0ZWRUcmlnZ2Vycykuam9pbignICcpO1xuXG4gICAgaWYgKGNvbmZpZy50cmlnZ2VyID09PSAnYmx1cicpIHtcbiAgICAgIC8vIEJsdXIgYnkgaXRzZWxmIGlzIHVzZWxlc3MsIHNvIGNvbnZlcnQgaXQgdG8gJ2ZvY3VzJ1xuICAgICAgY29uZmlnLnRyaWdnZXIgPSAnZm9jdXMnO1xuICAgIH1cblxuICAgIGlmICghY29uZmlnLnRyaWdnZXIpIHtcbiAgICAgIC8vIFVzZSBkZWZhdWx0IHRyaWdnZXJcbiAgICAgIGNvbmZpZy50cmlnZ2VyID0gRGVmYXVsdFRyaWdnZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfTsgLy8gQWRkIG9yIHVwZGF0ZSBQb3BvdmVyIG9uIG91ciBlbGVtZW50XG5cblxuICB2YXIgYXBwbHlQb3BvdmVyID0gZnVuY3Rpb24gYXBwbHlQb3BvdmVyKGVsLCBiaW5kaW5ncywgdm5vZGUpIHtcbiAgICBpZiAoIWlzQnJvd3Nlcikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29uZmlnID0gcGFyc2VCaW5kaW5ncyhiaW5kaW5ncywgdm5vZGUpO1xuXG4gICAgaWYgKCFlbFtCVl9QT1BPVkVSXSkge1xuICAgICAgdmFyICRwYXJlbnQgPSB2bm9kZS5jb250ZXh0O1xuICAgICAgZWxbQlZfUE9QT1ZFUl0gPSBuZXcgQlZQb3BvdmVyKHtcbiAgICAgICAgcGFyZW50OiAkcGFyZW50LFxuICAgICAgICAvLyBBZGQgdGhlIHBhcmVudCdzIHNjb3BlZCBzdHlsZSBhdHRyaWJ1dGUgZGF0YVxuICAgICAgICBfc2NvcGVJZDogZ2V0U2NvcGVJZCgkcGFyZW50LCB1bmRlZmluZWQpXG4gICAgICB9KTtcbiAgICAgIGVsW0JWX1BPUE9WRVJdLl9fYnZfcHJldl9kYXRhX18gPSB7fTtcbiAgICAgIGVsW0JWX1BPUE9WRVJdLiRvbignc2hvdycsIGZ1bmN0aW9uICgpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZm9yIG5vdyAqL1xuICAgICAge1xuICAgICAgICAvLyBCZWZvcmUgc2hvd2luZyB0aGUgcG9wb3Zlciwgd2UgdXBkYXRlIHRoZSB0aXRsZVxuICAgICAgICAvLyBhbmQgY29udGVudCBpZiB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihjb25maWcudGl0bGUpKSB7XG4gICAgICAgICAgZGF0YS50aXRsZSA9IGNvbmZpZy50aXRsZShlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihjb25maWcuY29udGVudCkpIHtcbiAgICAgICAgICBkYXRhLmNvbnRlbnQgPSBjb25maWcuY29udGVudChlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5cyhkYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZWxbQlZfUE9QT1ZFUl0udXBkYXRlRGF0YShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICB0aXRsZTogY29uZmlnLnRpdGxlLFxuICAgICAgY29udGVudDogY29uZmlnLmNvbnRlbnQsXG4gICAgICB0cmlnZ2VyczogY29uZmlnLnRyaWdnZXIsXG4gICAgICBwbGFjZW1lbnQ6IGNvbmZpZy5wbGFjZW1lbnQsXG4gICAgICBmYWxsYmFja1BsYWNlbWVudDogY29uZmlnLmZhbGxiYWNrUGxhY2VtZW50LFxuICAgICAgdmFyaWFudDogY29uZmlnLnZhcmlhbnQsXG4gICAgICBjdXN0b21DbGFzczogY29uZmlnLmN1c3RvbUNsYXNzLFxuICAgICAgY29udGFpbmVyOiBjb25maWcuY29udGFpbmVyLFxuICAgICAgYm91bmRhcnk6IGNvbmZpZy5ib3VuZGFyeSxcbiAgICAgIGRlbGF5OiBjb25maWcuZGVsYXksXG4gICAgICBvZmZzZXQ6IGNvbmZpZy5vZmZzZXQsXG4gICAgICBub0ZhZGU6ICFjb25maWcuYW5pbWF0aW9uLFxuICAgICAgaWQ6IGNvbmZpZy5pZCxcbiAgICAgIGRpc2FibGVkOiBjb25maWcuZGlzYWJsZWQsXG4gICAgICBodG1sOiBjb25maWcuaHRtbFxuICAgIH07XG4gICAgdmFyIG9sZERhdGEgPSBlbFtCVl9QT1BPVkVSXS5fX2J2X3ByZXZfZGF0YV9fO1xuICAgIGVsW0JWX1BPUE9WRVJdLl9fYnZfcHJldl9kYXRhX18gPSBkYXRhO1xuXG4gICAgaWYgKCFsb29zZUVxdWFsKGRhdGEsIG9sZERhdGEpKSB7XG4gICAgICAvLyBXZSBvbmx5IHVwZGF0ZSB0aGUgaW5zdGFuY2UgaWYgZGF0YSBoYXMgY2hhbmdlZFxuICAgICAgdmFyIG5ld0RhdGEgPSB7XG4gICAgICAgIHRhcmdldDogZWxcbiAgICAgIH07XG4gICAgICBrZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgLy8gV2Ugb25seSBwYXNzIGRhdGEgcHJvcGVydGllcyB0aGF0IGhhdmUgY2hhbmdlZFxuICAgICAgICBpZiAoZGF0YVtwcm9wXSAhPT0gb2xkRGF0YVtwcm9wXSkge1xuICAgICAgICAgIC8vIElmIHRpdGxlL2NvbnRlbnQgaXMgYSBmdW5jdGlvbiwgd2UgZXhlY3V0ZSBpdCBoZXJlXG4gICAgICAgICAgbmV3RGF0YVtwcm9wXSA9IChwcm9wID09PSAndGl0bGUnIHx8IHByb3AgPT09ICdjb250ZW50JykgJiYgaXNGdW5jdGlvbihkYXRhW3Byb3BdKSA/IGRhdGFbcHJvcF0oZWwpIDogZGF0YVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlbFtCVl9QT1BPVkVSXS51cGRhdGVEYXRhKG5ld0RhdGEpO1xuICAgIH1cbiAgfTsgLy8gUmVtb3ZlIFBvcG92ZXIgZnJvbSBvdXIgZWxlbWVudFxuXG5cbiAgdmFyIHJlbW92ZVBvcG92ZXIgPSBmdW5jdGlvbiByZW1vdmVQb3BvdmVyKGVsKSB7XG4gICAgaWYgKGVsW0JWX1BPUE9WRVJdKSB7XG4gICAgICBlbFtCVl9QT1BPVkVSXS4kZGVzdHJveSgpO1xuICAgICAgZWxbQlZfUE9QT1ZFUl0gPSBudWxsO1xuICAgIH1cblxuICAgIGRlbGV0ZSBlbFtCVl9QT1BPVkVSXTtcbiAgfTsgLy8gRXhwb3J0IG91ciBkaXJlY3RpdmVcblxuXG4gIHZhciBWQlBvcG92ZXIgPSB7XG4gICAgYmluZDogZnVuY3Rpb24gYmluZChlbCwgYmluZGluZ3MsIHZub2RlKSB7XG4gICAgICBhcHBseVBvcG92ZXIoZWwsIGJpbmRpbmdzLCB2bm9kZSk7XG4gICAgfSxcbiAgICAvLyBXZSB1c2UgYGNvbXBvbmVudFVwZGF0ZWRgIGhlcmUgaW5zdGVhZCBvZiBgdXBkYXRlYCwgYXMgdGhlIGZvcm1lclxuICAgIC8vIHdhaXRzIHVudGlsIHRoZSBjb250YWluaW5nIGNvbXBvbmVudCBhbmQgY2hpbGRyZW4gaGF2ZSBmaW5pc2hlZCB1cGRhdGluZ1xuICAgIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmdzLCB2bm9kZSkge1xuICAgICAgLy8gUGVyZm9ybWVkIGluIGEgYCRuZXh0VGljaygpYCB0byBwcmV2ZW50IGVuZGxlc3MgcmVuZGVyL3VwZGF0ZSBsb29wc1xuICAgICAgdm5vZGUuY29udGV4dC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBhcHBseVBvcG92ZXIoZWwsIGJpbmRpbmdzLCB2bm9kZSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKGVsKSB7XG4gICAgICByZW1vdmVQb3BvdmVyKGVsKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIFZCUG9wb3ZlclBsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgVkJQb3BvdmVyOiBWQlBvcG92ZXJcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBQb3BvdmVyUGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBCUG9wb3ZlcjogQlBvcG92ZXJcbiAgICB9LFxuICAgIHBsdWdpbnM6IHtcbiAgICAgIFZCUG9wb3ZlclBsdWdpbjogVkJQb3BvdmVyUGx1Z2luXG4gICAgfVxuICB9KTtcblxuICB2YXIgTkFNRSR6ID0gJ0JQcm9ncmVzc0Jhcic7IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJQcm9ncmVzc0JhciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogTkFNRSR6LFxuICAgIG1peGluczogW25vcm1hbGl6ZVNsb3RNaXhpbl0sXG4gICAgaW5qZWN0OiB7XG4gICAgICBidlByb2dyZXNzOiB7XG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KClcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgIH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBsYWJlbEh0bWw6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICB9LFxuICAgICAgLy8gJHBhcmVudCAodGhpcy5idlByb2dyZXNzKSBwcm9wIHZhbHVlcyBtYXkgdGFrZSBwcmVjZWRlbmNlIG92ZXIgdGhlIGZvbGxvd2luZyBwcm9wc1xuICAgICAgLy8gV2hpY2ggaXMgd2h5IHRoZXkgYXJlIGRlZmF1bHRlZCB0byBudWxsXG4gICAgICBtYXg6IHtcbiAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHByZWNpc2lvbjoge1xuICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgdmFyaWFudDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSR6LCAndmFyaWFudCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3RyaXBlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgYW5pbWF0ZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHNob3dQcm9ncmVzczoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgc2hvd1ZhbHVlOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBwcm9ncmVzc0JhckNsYXNzZXM6IGZ1bmN0aW9uIHByb2dyZXNzQmFyQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmNvbXB1dGVkVmFyaWFudCA/IFwiYmctXCIuY29uY2F0KHRoaXMuY29tcHV0ZWRWYXJpYW50KSA6ICcnLCB0aGlzLmNvbXB1dGVkU3RyaXBlZCB8fCB0aGlzLmNvbXB1dGVkQW5pbWF0ZWQgPyAncHJvZ3Jlc3MtYmFyLXN0cmlwZWQnIDogJycsIHRoaXMuY29tcHV0ZWRBbmltYXRlZCA/ICdwcm9ncmVzcy1iYXItYW5pbWF0ZWQnIDogJyddO1xuICAgICAgfSxcbiAgICAgIHByb2dyZXNzQmFyU3R5bGVzOiBmdW5jdGlvbiBwcm9ncmVzc0JhclN0eWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogMTAwICogKHRoaXMuY29tcHV0ZWRWYWx1ZSAvIHRoaXMuY29tcHV0ZWRNYXgpICsgJyUnXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRWYWx1ZTogZnVuY3Rpb24gY29tcHV0ZWRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRvRmxvYXQodGhpcy52YWx1ZSkgfHwgMDtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZE1heDogZnVuY3Rpb24gY29tcHV0ZWRNYXgoKSB7XG4gICAgICAgIC8vIFByZWZlciBvdXIgbWF4IG92ZXIgcGFyZW50IHNldHRpbmdcbiAgICAgICAgdmFyIG1heCA9IHRvRmxvYXQodGhpcy5tYXgpO1xuICAgICAgICByZXR1cm4gaXNOYU4obWF4KSA/IHRvRmxvYXQodGhpcy5idlByb2dyZXNzLm1heCkgfHwgMTAwIDogbWF4O1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkUHJlY2lzaW9uOiBmdW5jdGlvbiBjb21wdXRlZFByZWNpc2lvbigpIHtcbiAgICAgICAgLy8gUHJlZmVyIG91ciBwcmVjaXNpb24gb3ZlciBwYXJlbnQgc2V0dGluZ1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gdG9JbnRlZ2VyKHRoaXMucHJlY2lzaW9uKTtcbiAgICAgICAgcmV0dXJuIGlzTmFOKHByZWNpc2lvbikgPyB0b0ludGVnZXIodGhpcy5idlByb2dyZXNzLnByZWNpc2lvbikgfHwgMCA6IHByZWNpc2lvbjtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZFByb2dyZXNzOiBmdW5jdGlvbiBjb21wdXRlZFByb2dyZXNzKCkge1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gdGhpcy5jb21wdXRlZFByZWNpc2lvbjtcbiAgICAgICAgdmFyIHAgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICAgICAgcmV0dXJuIHRvRml4ZWQoMTAwICogcCAqIHRoaXMuY29tcHV0ZWRWYWx1ZSAvIHRoaXMuY29tcHV0ZWRNYXggLyBwLCBwcmVjaXNpb24pO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkVmFyaWFudDogZnVuY3Rpb24gY29tcHV0ZWRWYXJpYW50KCkge1xuICAgICAgICAvLyBQcmVmZXIgb3VyIHZhcmlhbnQgb3ZlciBwYXJlbnQgc2V0dGluZ1xuICAgICAgICByZXR1cm4gdGhpcy52YXJpYW50IHx8IHRoaXMuYnZQcm9ncmVzcy52YXJpYW50O1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkU3RyaXBlZDogZnVuY3Rpb24gY29tcHV0ZWRTdHJpcGVkKCkge1xuICAgICAgICAvLyBQcmVmZXIgb3VyIHN0cmlwZWQgb3ZlciBwYXJlbnQgc2V0dGluZ1xuICAgICAgICByZXR1cm4gaXNCb29sZWFuKHRoaXMuc3RyaXBlZCkgPyB0aGlzLnN0cmlwZWQgOiB0aGlzLmJ2UHJvZ3Jlc3Muc3RyaXBlZCB8fCBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZEFuaW1hdGVkOiBmdW5jdGlvbiBjb21wdXRlZEFuaW1hdGVkKCkge1xuICAgICAgICAvLyBQcmVmZXIgb3VyIGFuaW1hdGVkIG92ZXIgcGFyZW50IHNldHRpbmdcbiAgICAgICAgcmV0dXJuIGlzQm9vbGVhbih0aGlzLmFuaW1hdGVkKSA/IHRoaXMuYW5pbWF0ZWQgOiB0aGlzLmJ2UHJvZ3Jlc3MuYW5pbWF0ZWQgfHwgZmFsc2U7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRTaG93UHJvZ3Jlc3M6IGZ1bmN0aW9uIGNvbXB1dGVkU2hvd1Byb2dyZXNzKCkge1xuICAgICAgICAvLyBQcmVmZXIgb3VyIHNob3dQcm9ncmVzcyBvdmVyIHBhcmVudCBzZXR0aW5nXG4gICAgICAgIHJldHVybiBpc0Jvb2xlYW4odGhpcy5zaG93UHJvZ3Jlc3MpID8gdGhpcy5zaG93UHJvZ3Jlc3MgOiB0aGlzLmJ2UHJvZ3Jlc3Muc2hvd1Byb2dyZXNzIHx8IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkU2hvd1ZhbHVlOiBmdW5jdGlvbiBjb21wdXRlZFNob3dWYWx1ZSgpIHtcbiAgICAgICAgLy8gUHJlZmVyIG91ciBzaG93VmFsdWUgb3ZlciBwYXJlbnQgc2V0dGluZ1xuICAgICAgICByZXR1cm4gaXNCb29sZWFuKHRoaXMuc2hvd1ZhbHVlKSA/IHRoaXMuc2hvd1ZhbHVlIDogdGhpcy5idlByb2dyZXNzLnNob3dWYWx1ZSB8fCBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHZhciBjaGlsZE5vZGVzID0gaCgpO1xuXG4gICAgICBpZiAodGhpcy5oYXNOb3JtYWxpemVkU2xvdCgnZGVmYXVsdCcpKSB7XG4gICAgICAgIGNoaWxkTm9kZXMgPSB0aGlzLm5vcm1hbGl6ZVNsb3QoJ2RlZmF1bHQnKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5sYWJlbCB8fCB0aGlzLmxhYmVsSHRtbCkge1xuICAgICAgICBjaGlsZE5vZGVzID0gaCgnc3BhbicsIHtcbiAgICAgICAgICBkb21Qcm9wczogaHRtbE9yVGV4dCh0aGlzLmxhYmVsSHRtbCwgdGhpcy5sYWJlbClcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY29tcHV0ZWRTaG93UHJvZ3Jlc3MpIHtcbiAgICAgICAgY2hpbGROb2RlcyA9IHRoaXMuY29tcHV0ZWRQcm9ncmVzcztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jb21wdXRlZFNob3dWYWx1ZSkge1xuICAgICAgICBjaGlsZE5vZGVzID0gdG9GaXhlZCh0aGlzLmNvbXB1dGVkVmFsdWUsIHRoaXMuY29tcHV0ZWRQcmVjaXNpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ3Byb2dyZXNzLWJhcicsXG4gICAgICAgIGNsYXNzOiB0aGlzLnByb2dyZXNzQmFyQ2xhc3NlcyxcbiAgICAgICAgc3R5bGU6IHRoaXMucHJvZ3Jlc3NCYXJTdHlsZXMsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgcm9sZTogJ3Byb2dyZXNzYmFyJyxcbiAgICAgICAgICAnYXJpYS12YWx1ZW1pbic6ICcwJyxcbiAgICAgICAgICAnYXJpYS12YWx1ZW1heCc6IHRvU3RyaW5nJDEodGhpcy5jb21wdXRlZE1heCksXG4gICAgICAgICAgJ2FyaWEtdmFsdWVub3cnOiB0b0ZpeGVkKHRoaXMuY29tcHV0ZWRWYWx1ZSwgdGhpcy5jb21wdXRlZFByZWNpc2lvbilcbiAgICAgICAgfVxuICAgICAgfSwgW2NoaWxkTm9kZXNdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBOQU1FJEEgPSAnQlByb2dyZXNzJzsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQlByb2dyZXNzID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiBOQU1FJEEsXG4gICAgbWl4aW5zOiBbbm9ybWFsaXplU2xvdE1peGluXSxcbiAgICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnZQcm9ncmVzczogdGhpc1xuICAgICAgfTtcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAvLyBUaGVzZSBwcm9wcyBjYW4gYmUgaW5oZXJpdGVkIHZpYSB0aGUgY2hpbGQgYi1wcm9ncmVzcy1iYXIocylcbiAgICAgIHZhcmlhbnQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkQSwgJ3ZhcmlhbnQnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN0cmlwZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBhbmltYXRlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGhlaWdodDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBwcmVjaXNpb246IHtcbiAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgZGVmYXVsdDogMFxuICAgICAgfSxcbiAgICAgIHNob3dQcm9ncmVzczoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHNob3dWYWx1ZToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIG1heDoge1xuICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICBkZWZhdWx0OiAxMDBcbiAgICAgIH0sXG4gICAgICAvLyBUaGlzIHByb3AgaXMgbm90IGluaGVyaXRlZCBieSBjaGlsZCBiLXByb2dyZXNzLWJhcihzKVxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgZGVmYXVsdDogMFxuICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIHByb2dyZXNzSGVpZ2h0OiBmdW5jdGlvbiBwcm9ncmVzc0hlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0IHx8IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpcy5ub3JtYWxpemVTbG90KCdkZWZhdWx0Jyk7XG5cbiAgICAgIGlmICghY2hpbGROb2Rlcykge1xuICAgICAgICBjaGlsZE5vZGVzID0gaChCUHJvZ3Jlc3NCYXIsIHtcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgICAgICBtYXg6IHRoaXMubWF4LFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0aGlzLnByZWNpc2lvbixcbiAgICAgICAgICAgIHZhcmlhbnQ6IHRoaXMudmFyaWFudCxcbiAgICAgICAgICAgIGFuaW1hdGVkOiB0aGlzLmFuaW1hdGVkLFxuICAgICAgICAgICAgc3RyaXBlZDogdGhpcy5zdHJpcGVkLFxuICAgICAgICAgICAgc2hvd1Byb2dyZXNzOiB0aGlzLnNob3dQcm9ncmVzcyxcbiAgICAgICAgICAgIHNob3dWYWx1ZTogdGhpcy5zaG93VmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICBjbGFzczogWydwcm9ncmVzcyddLFxuICAgICAgICBzdHlsZTogdGhpcy5wcm9ncmVzc0hlaWdodFxuICAgICAgfSwgW2NoaWxkTm9kZXNdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBQcm9ncmVzc1BsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgY29tcG9uZW50czoge1xuICAgICAgQlByb2dyZXNzOiBCUHJvZ3Jlc3MsXG4gICAgICBCUHJvZ3Jlc3NCYXI6IEJQcm9ncmVzc0JhclxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIE5BTUUkQiA9ICdCU3Bpbm5lcic7IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJTcGlubmVyID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiBOQU1FJEIsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczoge1xuICAgICAgdHlwZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICdib3JkZXInIC8vIFNDU1MgY3VycmVudGx5IHN1cHBvcnRzICdib3JkZXInIG9yICdncm93J1xuXG4gICAgICB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgdmFyaWFudDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRCLCAndmFyaWFudCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc21hbGw6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICByb2xlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ3N0YXR1cydcbiAgICAgIH0sXG4gICAgICB0YWc6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnc3BhbidcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9yZWYpIHtcbiAgICAgIHZhciBfY2xhc3M7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBzbG90cyA9IF9yZWYuc2xvdHMsXG4gICAgICAgICAgc2NvcGVkU2xvdHMgPSBfcmVmLnNjb3BlZFNsb3RzO1xuICAgICAgdmFyICRzbG90cyA9IHNsb3RzKCk7XG4gICAgICB2YXIgJHNjb3BlZFNsb3RzID0gc2NvcGVkU2xvdHMgfHwge307XG4gICAgICB2YXIgbGFiZWwgPSBub3JtYWxpemVTbG90KCdsYWJlbCcsIHt9LCAkc2NvcGVkU2xvdHMsICRzbG90cykgfHwgcHJvcHMubGFiZWw7XG5cbiAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICBsYWJlbCA9IGgoJ3NwYW4nLCB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICdzci1vbmx5J1xuICAgICAgICB9LCBsYWJlbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoKHByb3BzLnRhZywgYShkYXRhLCB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgcm9sZTogbGFiZWwgPyBwcm9wcy5yb2xlIHx8ICdzdGF0dXMnIDogbnVsbCxcbiAgICAgICAgICAnYXJpYS1oaWRkZW4nOiBsYWJlbCA/IG51bGwgOiAndHJ1ZSdcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3M6IChfY2xhc3MgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9jbGFzcywgXCJzcGlubmVyLVwiLmNvbmNhdChwcm9wcy50eXBlKSwgcHJvcHMudHlwZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsIFwic3Bpbm5lci1cIi5jb25jYXQocHJvcHMudHlwZSwgXCItc21cIiksIHByb3BzLnNtYWxsKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzcywgXCJ0ZXh0LVwiLmNvbmNhdChwcm9wcy52YXJpYW50KSwgcHJvcHMudmFyaWFudCksIF9jbGFzcylcbiAgICAgIH0pLCBbbGFiZWwgfHwgaCgpXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgU3Bpbm5lclBsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgY29tcG9uZW50czoge1xuICAgICAgQlNwaW5uZXI6IEJTcGlubmVyXG4gICAgfVxuICB9KTtcblxuICAvLyBNaXhpbiB0byBkZXRlcm1pbmUgaWYgYW4gZXZlbnQgbGlzdGVuZXIgaGFzIGJlZW4gcmVnaXN0ZXJlZFxuXG4gIHZhciBoYXNMaXN0ZW5lck1peGluID0ge1xuICAgIG1ldGhvZHM6IHtcbiAgICAgIGhhc0xpc3RlbmVyOiBmdW5jdGlvbiBoYXNMaXN0ZW5lcihuYW1lKSB7XG4gICAgICAgIC8vIE9ubHkgaW5jbHVkZXMgbGlzdGVuZXJzIHJlZ2lzdGVyZCB2aWEgYHYtb246bmFtZWBcbiAgICAgICAgdmFyICRsaXN0ZW5lcnMgPSB0aGlzLiRsaXN0ZW5lcnMgfHwge307IC8vIEluY2x1ZGVzIGB2LW9uOm5hbWVgIGFuZCBgdGhpcy4kb24oJ25hbWUnKWAgcmVnaXN0ZXJkIGxpc3RlbmVyc1xuICAgICAgICAvLyBOb3RlIHRoaXMgcHJvcGVydHkgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBWdWUgQVBJLCBidXQgaXQgaXNcbiAgICAgICAgLy8gdGhlIG9ubHkgd2F5IHRvIGRldGVybWluZSBpZiBhIGxpc3RlbmVyIHdhcyBhZGRlZCB2aWEgYHZtLiRvbmBcblxuICAgICAgICB2YXIgJGV2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTsgLy8gUmVnaXN0ZXJlZCBsaXN0ZW5lcnMgaW4gYHRoaXMuX2V2ZW50c2AgYXJlIGFsd2F5cyBhbiBhcnJheSxcbiAgICAgICAgLy8gYnV0IG1pZ2h0IGJlIHplcm8gbGVuZ3RoXG5cbiAgICAgICAgcmV0dXJuICFpc1VuZGVmaW5lZCgkbGlzdGVuZXJzW25hbWVdKSB8fCBpc0FycmF5KCRldmVudHNbbmFtZV0pICYmICRldmVudHNbbmFtZV0ubGVuZ3RoID4gMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgc3RyaW5nLCBpbmNsdWRpbmcgc3RyaW5ncyBpbiBjYW1lbENhc2Ugb3Igc25ha2VfY2FzZSwgaW50byBTdGFydCBDYXNlIChhIHZhcmlhbnRcbiAgICogb2YgVGl0bGUgQ2FzZSB3aGVyZSBhbGwgd29yZHMgc3RhcnQgd2l0aCBhIGNhcGl0YWwgbGV0dGVyKSwgaXQga2VlcHMgb3JpZ2luYWwgc2luZ2xlIHF1b3RlXG4gICAqIGFuZCBoeXBoZW4gaW4gdGhlIHdvcmQuXG4gICAqXG4gICAqIENvcHlyaWdodCAoYykgMjAxNyBDb21wYXNzIChNSVQpXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9VcmJhbkNvbXBhc3MvdG8tc3RhcnQtY2FzZVxuICAgKiBAYXV0aG9yIFpodW95dWFuIFpoYW5nIDxodHRwczovL2dpdGh1Yi5jb20vZHJhd3lhbj5cbiAgICogQGF1dGhvciBXZWkgV2FuZyA8aHR0cHM6Ly9naXRodWIuY29tL29ubHl3ZWk+XG4gICAqXG4gICAqXG4gICAqICAgJ21hbmFnZW1lbnRfY29tcGFuaWVzJyB0byAnTWFuYWdlbWVudCBDb21wYW5pZXMnXG4gICAqICAgJ21hbmFnZW1lbnRDb21wYW5pZXMnIHRvICdNYW5hZ2VtZW50IENvbXBhbmllcydcbiAgICogICBgaGVsbCdzIGtpdGNoZW5gIHRvIGBIZWxsJ3MgS2l0Y2hlbmBcbiAgICogICBgY28tb3BgIHRvIGBDby1vcGBcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgLy8gUHJlY29tcGlsZSByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBwZXJmb3JtYW5jZVxuICB2YXIgUlhfVU5ERVJTQ09SRSA9IC9fL2c7XG4gIHZhciBSWF9MT1dFUl9VUFBFUiA9IC8oW2Etel0pKFtBLVpdKS9nO1xuICB2YXIgUlhfU1RBUlRfU1BBQ0VfV09SRCA9IC8oXFxzfF4pKFxcdykvZztcblxuICB2YXIgc3RhcnRDYXNlID0gZnVuY3Rpb24gc3RhcnRDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShSWF9VTkRFUlNDT1JFLCAnICcpLnJlcGxhY2UoUlhfTE9XRVJfVVBQRVIsIGZ1bmN0aW9uIChzdHIsICQxLCAkMikge1xuICAgICAgcmV0dXJuICQxICsgJyAnICsgJDI7XG4gICAgfSkucmVwbGFjZShSWF9TVEFSVF9TUEFDRV9XT1JELCBmdW5jdGlvbiAoc3RyLCAkMSwgJDIpIHtcbiAgICAgIHJldHVybiAkMSArICQyLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ29uc3RhbnRzIHVzZWQgYnkgdGFibGUgaGVscGVyc1xuICAvLyBPYmplY3Qgb2YgaXRlbSBrZXlzIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWQgZm9yIGhlYWRlcnMgYW5kXG4gIC8vIHN0cmluZ2lmaWNhdGlvbiBhbmQgZmlsdGVyIGV2ZW50c1xuICB2YXIgSUdOT1JFRF9GSUVMRF9LRVlTID0ge1xuICAgIF9yb3dWYXJpYW50OiB0cnVlLFxuICAgIF9jZWxsVmFyaWFudHM6IHRydWUsXG4gICAgX3Nob3dEZXRhaWxzOiB0cnVlXG4gIH07IC8vIEZpbHRlciBDU1Mgc2VsZWN0b3IgZm9yIGNsaWNrL2RibGNsaWNrL2V0Yy4gZXZlbnRzXG4gIC8vIElmIGFueSBvZiB0aGVzZSBzZWxlY3RvcnMgbWF0Y2ggdGhlIGNsaWNrZWQgZWxlbWVudCwgd2UgaWdub3JlIHRoZSBldmVudFxuXG4gIHZhciBFVkVOVF9GSUxURVIgPSBbJ2EnLCAnYSAqJywgLy8gSW5jbHVkZSBjb250ZW50IGluc2lkZSBsaW5rc1xuICAnYnV0dG9uJywgJ2J1dHRvbiAqJywgLy8gSW5jbHVkZSBjb250ZW50IGluc2lkZSBidXR0b25zXG4gICdpbnB1dDpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSknLCAnc2VsZWN0Om5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKScsICd0ZXh0YXJlYTpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSknLCAnW3JvbGU9XCJsaW5rXCJdJywgJ1tyb2xlPVwibGlua1wiXSAqJywgJ1tyb2xlPVwiYnV0dG9uXCJdJywgJ1tyb2xlPVwiYnV0dG9uXCJdIConLCAnW3RhYmluZGV4XTpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSknXS5qb2luKCcsJyk7XG5cbiAgdmFyIHByb2Nlc3NGaWVsZCA9IGZ1bmN0aW9uIHByb2Nlc3NGaWVsZChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGZpZWxkID0gbnVsbDtcblxuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIC8vIExhYmVsIHNob3J0Y3V0XG4gICAgICBmaWVsZCA9IHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIGxhYmVsOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAvLyBGb3JtYXR0ZXIgc2hvcnRjdXRcbiAgICAgIGZpZWxkID0ge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgZm9ybWF0dGVyOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgZmllbGQgPSBjbG9uZSh2YWx1ZSk7XG4gICAgICBmaWVsZC5rZXkgPSBmaWVsZC5rZXkgfHwga2V5O1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBqdXN0IGtleVxuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgZmllbGQgPSB7XG4gICAgICAgIGtleToga2V5XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZDtcbiAgfTsgLy8gV2Ugbm9ybWFsaXplIGZpZWxkcyBpbnRvIGFuIGFycmF5IG9mIG9iamVjdHNcbiAgLy8gWyB7IGtleTouLi4sIGxhYmVsOi4uLiwgLi4ufSwgey4uLn0sIC4uLiwgey4ufV1cblxuXG4gIHZhciBub3JtYWxpemVGaWVsZHMgPSBmdW5jdGlvbiBub3JtYWxpemVGaWVsZHMob3JpZ0ZpZWxkcywgaXRlbXMpIHtcbiAgICB2YXIgZmllbGRzID0gW107XG5cbiAgICBpZiAoaXNBcnJheShvcmlnRmllbGRzKSkge1xuICAgICAgLy8gTm9ybWFsaXplIGFycmF5IEZvcm1cbiAgICAgIG9yaWdGaWVsZHMuZmlsdGVyKGlkZW50aXR5KS5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIGlmIChpc1N0cmluZyhmKSkge1xuICAgICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgIGtleTogZixcbiAgICAgICAgICAgIGxhYmVsOiBzdGFydENhc2UoZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChmKSAmJiBmLmtleSAmJiBpc1N0cmluZyhmLmtleSkpIHtcbiAgICAgICAgICAvLyBGdWxsIG9iamVjdCBkZWZpbml0aW9uLiBXZSB1c2UgYXNzaWduIHNvIHRoYXQgd2UgZG9uJ3QgbXV0YXRlIHRoZSBvcmlnaW5hbFxuICAgICAgICAgIGZpZWxkcy5wdXNoKGNsb25lKGYpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChmKSAmJiBrZXlzKGYpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIC8vIFNob3J0Y3V0IG9iamVjdCAoaS5lLiB7ICdmb29fYmFyJzogJ1RoaXMgaXMgRm9vIEJhcicgfVxuICAgICAgICAgIHZhciBrZXkgPSBrZXlzKGYpWzBdO1xuICAgICAgICAgIHZhciBmaWVsZCA9IHByb2Nlc3NGaWVsZChrZXksIGZba2V5XSk7XG5cbiAgICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gLy8gSWYgbm8gZmllbGQgcHJvdmlkZWQsIHRha2UgYSBzYW1wbGUgZnJvbSBmaXJzdCByZWNvcmQgKGlmIGV4aXRzKVxuXG5cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMCAmJiBpc0FycmF5KGl0ZW1zKSAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgc2FtcGxlID0gaXRlbXNbMF07XG4gICAgICBrZXlzKHNhbXBsZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoIUlHTk9SRURfRklFTERfS0VZU1trXSkge1xuICAgICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgIGtleTogayxcbiAgICAgICAgICAgIGxhYmVsOiBzdGFydENhc2UoaylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSAvLyBFbnN1cmUgd2UgaGF2ZSBhIHVuaXF1ZSBhcnJheSBvZiBmaWVsZHMgYW5kIHRoYXQgdGhleSBoYXZlIFN0cmluZyBsYWJlbHNcblxuXG4gICAgdmFyIG1lbW8gPSB7fTtcbiAgICByZXR1cm4gZmllbGRzLmZpbHRlcihmdW5jdGlvbiAoZikge1xuICAgICAgaWYgKCFtZW1vW2Yua2V5XSkge1xuICAgICAgICBtZW1vW2Yua2V5XSA9IHRydWU7XG4gICAgICAgIGYubGFiZWwgPSBpc1N0cmluZyhmLmxhYmVsKSA/IGYubGFiZWwgOiBzdGFydENhc2UoZi5rZXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBpdGVtc01peGluID0ge1xuICAgIHByb3BzOiB7XG4gICAgICBpdGVtczoge1xuICAgICAgICAvLyBQcm92aWRlciBtaXhpbiBhZGRzIGluIGBGdW5jdGlvbmAgdHlwZVxuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmllbGRzOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgcHJpbWFyeUtleToge1xuICAgICAgICAvLyBQcmltYXJ5IGtleSBmb3IgcmVjb3JkXG4gICAgICAgIC8vIElmIHByb3ZpZGVkIHRoZSB2YWx1ZSBpbiBlYWNoIHJvdyBtdXN0IGJlIHVuaXF1ZSFcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgLy8gYHYtbW9kZWxgIGZvciByZXRyaWV2aW5nIHRoZSBjdXJyZW50IGRpc3BsYXllZCByb3dzXG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBPdXIgbG9jYWwgY29weSBvZiB0aGUgaXRlbXNcbiAgICAgICAgLy8gTXVzdCBiZSBhbiBhcnJheVxuICAgICAgICBsb2NhbEl0ZW1zOiBpc0FycmF5KHRoaXMuaXRlbXMpID8gdGhpcy5pdGVtcy5zbGljZSgpIDogW11cbiAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgY29tcHV0ZWRGaWVsZHM6IGZ1bmN0aW9uIGNvbXB1dGVkRmllbGRzKCkge1xuICAgICAgICAvLyBXZSBub3JtYWxpemUgZmllbGRzIGludG8gYW4gYXJyYXkgb2Ygb2JqZWN0c1xuICAgICAgICAvLyBgWyB7IGtleTouLi4sIGxhYmVsOi4uLiwgLi4ufSwgey4uLn0sIC4uLiwgey4ufV1gXG4gICAgICAgIHJldHVybiBub3JtYWxpemVGaWVsZHModGhpcy5maWVsZHMsIHRoaXMubG9jYWxJdGVtcyk7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRGaWVsZHNPYmo6IGZ1bmN0aW9uIGNvbXB1dGVkRmllbGRzT2JqKCkge1xuICAgICAgICAvLyBGaWVsZHMgYXMgYSBzaW1wbGUgbG9va3VwIGhhc2ggb2JqZWN0XG4gICAgICAgIC8vIE1haW5seSBmb3IgZm9ybWF0dGVyIGxvb2t1cCBhbmQgdXNlIGluIGBzY29wZWRTbG90c2AgZm9yIGNvbnZlbmllbmNlXG4gICAgICAgIC8vIElmIHRoZSBmaWVsZCBoYXMgYSBmb3JtYXR0ZXIsIGl0IG5vcm1hbGl6ZXMgZm9ybWF0dGVyIHRvIGFcbiAgICAgICAgLy8gZnVuY3Rpb24gcmVmIG9yIGB1bmRlZmluZWRgIGlmIG5vIGZvcm1hdHRlclxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy4kcGFyZW50O1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlZEZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgZikge1xuICAgICAgICAgIC8vIFdlIHVzZSBvYmplY3Qgc3ByZWFkIGhlcmUgc28gd2UgZG9uJ3QgbXV0YXRlIHRoZSBvcmlnaW5hbCBmaWVsZCBvYmplY3RcbiAgICAgICAgICBvYmpbZi5rZXldID0gY2xvbmUoZik7XG5cbiAgICAgICAgICBpZiAoZi5mb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBmb3JtYXR0ZXIgdG8gYSBmdW5jdGlvbiByZWYgb3IgYHVuZGVmaW5lZGBcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZXIgPSBmLmZvcm1hdHRlcjtcblxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGZvcm1hdHRlcikgJiYgaXNGdW5jdGlvbihwYXJlbnRbZm9ybWF0dGVyXSkpIHtcbiAgICAgICAgICAgICAgZm9ybWF0dGVyID0gcGFyZW50W2Zvcm1hdHRlcl07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0Z1bmN0aW9uKGZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgZm9ybWF0dGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSAvLyBSZXR1cm4gZm9ybWF0dGVyIGZ1bmN0aW9uIG9yIGB1bmRlZmluZWRgIGlmIG5vbmVcblxuXG4gICAgICAgICAgICBvYmpbZi5rZXldLmZvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCB7fSk7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRJdGVtczogZnVuY3Rpb24gY29tcHV0ZWRJdGVtcygpIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgaWYgdmFyaW91cyBtaXhpbnMgbm90IHByb3ZpZGVkXG4gICAgICAgIHJldHVybiAodGhpcy5wYWdpbmF0ZWRJdGVtcyB8fCB0aGlzLnNvcnRlZEl0ZW1zIHx8IHRoaXMuZmlsdGVyZWRJdGVtcyB8fCB0aGlzLmxvY2FsSXRlbXMgfHwgW10pLnNsaWNlKCk7XG4gICAgICB9LFxuICAgICAgY29udGV4dDogZnVuY3Rpb24gY29udGV4dCgpIHtcbiAgICAgICAgLy8gQ3VycmVudCBzdGF0ZSBvZiBzb3J0aW5nLCBmaWx0ZXJpbmcgYW5kIHBhZ2luYXRpb24gcHJvcHMvdmFsdWVzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZmlsdGVyOiB0aGlzLmxvY2FsRmlsdGVyLFxuICAgICAgICAgIHNvcnRCeTogdGhpcy5sb2NhbFNvcnRCeSxcbiAgICAgICAgICBzb3J0RGVzYzogdGhpcy5sb2NhbFNvcnREZXNjLFxuICAgICAgICAgIHBlclBhZ2U6IHBhcnNlSW50KHRoaXMucGVyUGFnZSwgMTApIHx8IDAsXG4gICAgICAgICAgY3VycmVudFBhZ2U6IHBhcnNlSW50KHRoaXMuY3VycmVudFBhZ2UsIDEwKSB8fCAxLFxuICAgICAgICAgIGFwaVVybDogdGhpcy5hcGlVcmxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICBpdGVtczogZnVuY3Rpb24gaXRlbXMobmV3SXRlbXMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGlzQXJyYXkobmV3SXRlbXMpKSB7XG4gICAgICAgICAgLy8gU2V0IGBsb2NhbEl0ZW1zYC9gZmlsdGVyZWRJdGVtc2AgdG8gYSBjb3B5IG9mIHRoZSBwcm92aWRlZCBhcnJheVxuICAgICAgICAgIHRoaXMubG9jYWxJdGVtcyA9IG5ld0l0ZW1zLnNsaWNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZmluZWRPck51bGwobmV3SXRlbXMpKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICB0aGlzLmxvY2FsSXRlbXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFdhdGNoIGZvciBjaGFuZ2VzIG9uIGBjb21wdXRlZEl0ZW1zYCBhbmQgdXBkYXRlIHRoZSBgdi1tb2RlbGBcbiAgICAgIGNvbXB1dGVkSXRlbXM6IGZ1bmN0aW9uIGNvbXB1dGVkSXRlbXMobmV3VmFsKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgbmV3VmFsKTtcbiAgICAgIH0sXG4gICAgICAvLyBXYXRjaCBmb3IgY29udGV4dCBjaGFuZ2VzXG4gICAgICBjb250ZXh0OiBmdW5jdGlvbiBjb250ZXh0KG5ld1ZhbCwgb2xkVmFsKSB7XG4gICAgICAgIC8vIEVtaXQgY29udGV4dCBpbmZvcm1hdGlvbiBmb3IgZXh0ZXJuYWwgcGFnaW5nL2ZpbHRlcmluZy9zb3J0aW5nIGhhbmRsaW5nXG4gICAgICAgIGlmICghbG9vc2VFcXVhbChuZXdWYWwsIG9sZFZhbCkpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdjb250ZXh0LWNoYW5nZWQnLCBuZXdWYWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgLy8gSW5pdGlhbGx5IHVwZGF0ZSB0aGUgYHYtbW9kZWxgIG9mIGRpc3BsYXllZCBpdGVtc1xuICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB0aGlzLmNvbXB1dGVkSXRlbXMpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgLy8gTWV0aG9kIHRvIGdldCB0aGUgZm9ybWF0dGVyIG1ldGhvZCBmb3IgYSBnaXZlbiBmaWVsZCBrZXlcbiAgICAgIGdldEZpZWxkRm9ybWF0dGVyOiBmdW5jdGlvbiBnZXRGaWVsZEZvcm1hdHRlcihrZXkpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5jb21wdXRlZEZpZWxkc09ialtrZXldOyAvLyBgdGhpcy5jb21wdXRlZEZpZWxkc09iamAgaGFzIHByZS1ub3JtYWxpemVkIHRoZSBmb3JtYXR0ZXIgdG8gYVxuICAgICAgICAvLyBmdW5jdGlvbiByZWYgaWYgcHJlc2VudCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG5cbiAgICAgICAgcmV0dXJuIGZpZWxkID8gZmllbGQuZm9ybWF0dGVyIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBNaXhpbiBmb3IgcHJvdmlkaW5nIHN0YWNrZWQgdGFibGVzXG4gIHZhciBzdGFja2VkTWl4aW4gPSB7XG4gICAgcHJvcHM6IHtcbiAgICAgIHN0YWNrZWQ6IHtcbiAgICAgICAgdHlwZTogW0Jvb2xlYW4sIFN0cmluZ10sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgaXNTdGFja2VkOiBmdW5jdGlvbiBpc1N0YWNrZWQoKSB7XG4gICAgICAgIC8vIGB0cnVlYCB3aGVuIGFsd2F5cyBzdGFja2VkLCBvciByZXR1cm5zIGJyZWFrcG9pbnQgc3BlY2lmaWVkXG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrZWQgPT09ICcnID8gdHJ1ZSA6IHRoaXMuc3RhY2tlZDtcbiAgICAgIH0sXG4gICAgICBpc1N0YWNrZWRBbHdheXM6IGZ1bmN0aW9uIGlzU3RhY2tlZEFsd2F5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTdGFja2VkID09PSB0cnVlO1xuICAgICAgfSxcbiAgICAgIHN0YWNrZWRUYWJsZUNsYXNzZXM6IGZ1bmN0aW9uIHN0YWNrZWRUYWJsZUNsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgICdiLXRhYmxlLXN0YWNrZWQnOiB0aGlzLmlzU3RhY2tlZEFsd2F5c1xuICAgICAgICB9LCBcImItdGFibGUtc3RhY2tlZC1cIi5jb25jYXQodGhpcy5zdGFja2VkKSwgIXRoaXMuaXNTdGFja2VkQWx3YXlzICYmIHRoaXMuaXNTdGFja2VkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHNhbml0aXplUm93ID0gZnVuY3Rpb24gc2FuaXRpemVSb3cocm93LCBpZ25vcmVGaWVsZHMsIGluY2x1ZGVGaWVsZHMpIHtcbiAgICB2YXIgZmllbGRzT2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICByZXR1cm4ga2V5cyhyb3cpLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICAgIC8vIElnbm9yZSBzcGVjaWFsIGZpZWxkcyB0aGF0IHN0YXJ0IHdpdGggYF9gXG4gICAgICAvLyBJZ25vcmUgZmllbGRzIGluIHRoZSBgaWdub3JlRmllbGRzYCBhcnJheVxuICAgICAgLy8gSW5jbHVkZSBvbmx5IGZpZWxkcyBpbiB0aGUgYGluY2x1ZGVGaWVsZHNgIGFycmF5XG4gICAgICBpZiAoIUlHTk9SRURfRklFTERfS0VZU1trZXldICYmICEoaWdub3JlRmllbGRzICYmIGlnbm9yZUZpZWxkcy5sZW5ndGggPiAwICYmIGFycmF5SW5jbHVkZXMoaWdub3JlRmllbGRzLCBrZXkpKSAmJiAhKGluY2x1ZGVGaWVsZHMgJiYgaW5jbHVkZUZpZWxkcy5sZW5ndGggPiAwICYmICFhcnJheUluY2x1ZGVzKGluY2x1ZGVGaWVsZHMsIGtleSkpKSB7XG4gICAgICAgIHZhciBmID0gZmllbGRzT2JqW2tleV0gfHwge307XG4gICAgICAgIHZhciB2YWwgPSByb3dba2V5XTsgLy8gYGYuZmlsdGVyQnlGb3JtYXR0ZWRgIHdpbGwgZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYm9vbGVhblxuICAgICAgICAvLyBgZi5mb3JtYXRlcmAgd2lsbCBoYXZlIGFscmVhZHkgYmVlbiBub3JhbWxpemVkIGludG8gYSBmdW5jdGlvbiByZWZcblxuICAgICAgICB2YXIgZmlsdGVyQnlGb3JtYXR0ZWQgPSBmLmZpbHRlckJ5Rm9ybWF0dGVkO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gaXNGdW5jdGlvbihmaWx0ZXJCeUZvcm1hdHRlZCkgPyBmaWx0ZXJCeUZvcm1hdHRlZCA6IGZpbHRlckJ5Rm9ybWF0dGVkID8gZi5mb3JtYXR0ZXIgOiBudWxsO1xuICAgICAgICBvYmpba2V5XSA9IGlzRnVuY3Rpb24oZm9ybWF0dGVyKSA/IGZvcm1hdHRlcih2YWwsIGtleSwgcm93KSA6IHZhbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG4gIH07XG5cbiAgLy8gU1NSIHNhZmUgZGV0ZXJtaW5pc3RpYyB3YXkgKGtleXMgYXJlIHNvcnRlZCBiZWZvcmUgc3RyaW5naWZpY2F0aW9uKVxuICAvL1xuICAvLyAgIGV4OlxuICAvLyAgICAgeyBiOiAzLCBjOiB7IHo6ICd6enonLCBkOiBudWxsLCBlOiAyIH0sIGQ6IFsxMCwgMTIsIDExXSwgYTogJ29uZScgfVxuICAvLyAgIGJlY29tZXNcbiAgLy8gICAgICdvbmUgMyAyIHp6eiAxMCAxMiAxMSdcbiAgLy9cbiAgLy8gUHJpbWl0aXZlcyAobnVtYmVycy9zdHJpbmdzKSBhcmUgcmV0dXJuZWQgYXMtaXNcbiAgLy8gTnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBhcmUgZmlsdGVyZWQgb3V0XG4gIC8vIERhdGVzIGFyZSBjb252ZXJ0ZWQgdG8gdGhlaXIgbmF0aXZlIHN0cmluZyBmb3JtYXRcblxuICB2YXIgc3RyaW5naWZ5T2JqZWN0VmFsdWVzID0gZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0VmFsdWVzKHZhbCkge1xuICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbCh2YWwpKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gLy8gQXJyYXlzIGFyZSBhbHNvIG9iamVjdCwgYW5kIGtleXMganVzdCByZXR1cm5zIHRoZSBhcnJheSBpbmRleGVzXG4gICAgLy8gRGF0ZSBvYmplY3RzIHdlIGNvbnZlcnQgdG8gc3RyaW5nc1xuXG5cbiAgICBpZiAoaXNPYmplY3QodmFsKSAmJiAhaXNEYXRlKHZhbCkpIHtcbiAgICAgIHJldHVybiBrZXlzKHZhbCkuc29ydCgpIC8vIFNvcnQgdG8gcHJldmVudCBTU1IgaXNzdWVzIG9uIHByZS1yZW5kZXJlZCBzb3J0ZWQgdGFibGVzXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiAhaXNVbmRlZmluZWRPck51bGwodik7XG4gICAgICB9KSAvLyBJZ25vcmUgdW5kZWZpbmVkL251bGwgdmFsdWVzXG4gICAgICAubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3RWYWx1ZXModmFsW2tdKTtcbiAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9TdHJpbmckMSh2YWwpO1xuICB9O1xuXG4gIC8vIFRPRE86IEFkZCBvcHRpb24gdG8gc3RyaW5naWZ5IGBzY29wZWRTbG90YCBpdGVtc1xuXG4gIHZhciBzdHJpbmdpZnlSZWNvcmRWYWx1ZXMgPSBmdW5jdGlvbiBzdHJpbmdpZnlSZWNvcmRWYWx1ZXMocm93LCBpZ25vcmVGaWVsZHMsIGluY2x1ZGVGaWVsZHMsIGZpZWxkc09iaikge1xuICAgIHJldHVybiBpc09iamVjdChyb3cpID8gc3RyaW5naWZ5T2JqZWN0VmFsdWVzKHNhbml0aXplUm93KHJvdywgaWdub3JlRmllbGRzLCBpbmNsdWRlRmllbGRzLCBmaWVsZHNPYmopKSA6ICcnO1xuICB9O1xuXG4gIHZhciBERUJPVU5DRV9ERVBSRUNBVEVEX01TRyA9ICdQcm9wIFwiZmlsdGVyLWRlYm91bmNlXCIgaXMgZGVwcmVjYXRlZC4gVXNlIHRoZSBkZWJvdW5jZSBmZWF0dXJlIG9mIFwiPGItZm9ybS1pbnB1dD5cIiBpbnN0ZWFkLic7XG4gIHZhciBSWF9TUEFDRVMkMSA9IC9bXFxzXFx1RkVGRlxceEEwXSsvZztcbiAgdmFyIGZpbHRlcmluZ01peGluID0ge1xuICAgIHByb3BzOiB7XG4gICAgICBmaWx0ZXI6IHtcbiAgICAgICAgdHlwZTogW1N0cmluZywgUmVnRXhwLCBPYmplY3QsIEFycmF5XSxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIGZpbHRlckZ1bmN0aW9uOiB7XG4gICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgZmlsdGVySWdub3JlZEZpZWxkczoge1xuICAgICAgICB0eXBlOiBBcnJheSAvLyBkZWZhdWx0OiB1bmRlZmluZWRcblxuICAgICAgfSxcbiAgICAgIGZpbHRlckluY2x1ZGVkRmllbGRzOiB7XG4gICAgICAgIHR5cGU6IEFycmF5IC8vIGRlZmF1bHQ6IHVuZGVmaW5lZFxuXG4gICAgICB9LFxuICAgICAgZmlsdGVyRGVib3VuY2U6IHtcbiAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgZGVwcmVjYXRlZDogREVCT1VOQ0VfREVQUkVDQVRFRF9NU0csXG4gICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHZhbCkge1xuICAgICAgICAgIHJldHVybiAvXlxcZCsvLnRlc3QoU3RyaW5nKHZhbCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRmxhZyBmb3IgZGlzcGxheWluZyB3aGljaCBlbXB0eSBzbG90IHRvIHNob3cgYW5kIHNvbWUgZXZlbnQgdHJpZ2dlcmluZ1xuICAgICAgICBpc0ZpbHRlcmVkOiBmYWxzZSxcbiAgICAgICAgLy8gV2hlcmUgd2Ugc3RvcmUgdGhlIGNvcHkgb2YgdGhlIGZpbHRlciBjcml0ZXJpYSBhZnRlciBkZWJvdW5jaW5nXG4gICAgICAgIC8vIFdlIHByZS1zZXQgaXQgd2l0aCB0aGUgc2FuaXRpemVkIGZpbHRlciB2YWx1ZVxuICAgICAgICBsb2NhbEZpbHRlcjogdGhpcy5maWx0ZXJTYW5pdGl6ZSh0aGlzLmZpbHRlcilcbiAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgY29tcHV0ZWRGaWx0ZXJJZ25vcmVkOiBmdW5jdGlvbiBjb21wdXRlZEZpbHRlcklnbm9yZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcklnbm9yZWRGaWVsZHMgPyBjb25jYXQodGhpcy5maWx0ZXJJZ25vcmVkRmllbGRzKS5maWx0ZXIoQm9vbGVhbikgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkRmlsdGVySW5jbHVkZWQ6IGZ1bmN0aW9uIGNvbXB1dGVkRmlsdGVySW5jbHVkZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlckluY2x1ZGVkRmllbGRzID8gY29uY2F0KHRoaXMuZmlsdGVySW5jbHVkZWRGaWVsZHMpLmZpbHRlcihCb29sZWFuKSA6IG51bGw7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRGaWx0ZXJEZWJvdW5jZTogZnVuY3Rpb24gY29tcHV0ZWRGaWx0ZXJEZWJvdW5jZSgpIHtcbiAgICAgICAgdmFyIG1zID0gdG9JbnRlZ2VyKHRoaXMuZmlsdGVyRGVib3VuY2UpIHx8IDA7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgICAgaWYgKG1zID4gMCkge1xuICAgICAgICAgIHdhcm4oREVCT1VOQ0VfREVQUkVDQVRFRF9NU0csICdCVGFibGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtcztcbiAgICAgIH0sXG4gICAgICBsb2NhbEZpbHRlcmluZzogZnVuY3Rpb24gbG9jYWxGaWx0ZXJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1Byb3ZpZGVyID8gISF0aGlzLm5vUHJvdmlkZXJGaWx0ZXJpbmcgOiB0cnVlO1xuICAgICAgfSxcbiAgICAgIC8vIEZvciB3YXRjaGluZyBjaGFuZ2VzIHRvIGBmaWx0ZXJlZEl0ZW1zYCB2cyBgbG9jYWxJdGVtc2BcbiAgICAgIGZpbHRlcmVkQ2hlY2s6IGZ1bmN0aW9uIGZpbHRlcmVkQ2hlY2soKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZmlsdGVyZWRJdGVtczogdGhpcy5maWx0ZXJlZEl0ZW1zLFxuICAgICAgICAgIGxvY2FsSXRlbXM6IHRoaXMubG9jYWxJdGVtcyxcbiAgICAgICAgICBsb2NhbEZpbHRlcjogdGhpcy5sb2NhbEZpbHRlclxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIC8vIFNhbml0aXplZC9ub3JtYWxpemUgZmlsdGVyLWZ1bmN0aW9uIHByb3BcbiAgICAgIGxvY2FsRmlsdGVyRm46IGZ1bmN0aW9uIGxvY2FsRmlsdGVyRm4oKSB7XG4gICAgICAgIC8vIFJldHVybiBgbnVsbGAgdG8gc2lnbmFsIHRvIHVzZSBpbnRlcm5hbCBmaWx0ZXIgZnVuY3Rpb25cbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odGhpcy5maWx0ZXJGdW5jdGlvbikgPyB0aGlzLmZpbHRlckZ1bmN0aW9uIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICAvLyBSZXR1cm5zIHRoZSByZWNvcmRzIGluIGBsb2NhbEl0ZW1zYCB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIgY3JpdGVyaWFcbiAgICAgIC8vIFJldHVybnMgdGhlIG9yaWdpbmFsIGBsb2NhbEl0ZW1zYCBhcnJheSBpZiBub3Qgc29ydGluZ1xuICAgICAgZmlsdGVyZWRJdGVtczogZnVuY3Rpb24gZmlsdGVyZWRJdGVtcygpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5sb2NhbEl0ZW1zIHx8IFtdOyAvLyBOb3RlIHRoZSBjcml0ZXJpYSBpcyBkZWJvdW5jZWQgYW5kIHNhbml0aXplZFxuXG4gICAgICAgIHZhciBjcml0ZXJpYSA9IHRoaXMubG9jYWxGaWx0ZXI7IC8vIFJlc29sdmUgdGhlIGZpbHRlcmluZyBmdW5jdGlvbiwgd2hlbiByZXF1ZXN0ZWRcbiAgICAgICAgLy8gV2UgcHJlZmVyIHRoZSBwcm92aWRlZCBmaWx0ZXJpbmcgZnVuY3Rpb24gYW5kIGZhbGxiYWNrIHRvIHRoZSBpbnRlcm5hbCBvbmVcbiAgICAgICAgLy8gV2hlbiBubyBmaWx0ZXJpbmcgY3JpdGVyaWEgaXMgc3BlY2lmaWVkIHRoZSBmaWx0ZXJpbmcgZmFjdG9yaWVzIHdpbGwgcmV0dXJuIGBudWxsYFxuXG4gICAgICAgIHZhciBmaWx0ZXJGbiA9IHRoaXMubG9jYWxGaWx0ZXJpbmcgPyB0aGlzLmZpbHRlckZuRmFjdG9yeSh0aGlzLmxvY2FsRmlsdGVyRm4sIGNyaXRlcmlhKSB8fCB0aGlzLmRlZmF1bHRGaWx0ZXJGbkZhY3RvcnkoY3JpdGVyaWEpIDogbnVsbDsgLy8gV2Ugb25seSBkbyBsb2NhbCBmaWx0ZXJpbmcgd2hlbiByZXF1ZXN0ZWQgYW5kIHRoZXJlIGFyZSByZWNvcmRzIHRvIGZpbHRlclxuXG4gICAgICAgIHJldHVybiBmaWx0ZXJGbiAmJiBpdGVtcy5sZW5ndGggPiAwID8gaXRlbXMuZmlsdGVyKGZpbHRlckZuKSA6IGl0ZW1zO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgIC8vIFdhdGNoIGZvciBkZWJvdW5jZSBiZWluZyBzZXQgdG8gMFxuICAgICAgY29tcHV0ZWRGaWx0ZXJEZWJvdW5jZTogZnVuY3Rpb24gY29tcHV0ZWRGaWx0ZXJEZWJvdW5jZShuZXdWYWwpIHtcbiAgICAgICAgaWYgKCFuZXdWYWwgJiYgdGhpcy4kX2ZpbHRlclRpbWVyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuJF9maWx0ZXJUaW1lcik7XG4gICAgICAgICAgdGhpcy4kX2ZpbHRlclRpbWVyID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmxvY2FsRmlsdGVyID0gdGhpcy5maWx0ZXJTYW5pdGl6ZSh0aGlzLmZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBXYXRjaCBmb3IgY2hhbmdlcyB0byB0aGUgZmlsdGVyIGNyaXRlcmlhLCBhbmQgZGVib3VuY2UgaWYgbmVjZXNzYXJ5XG4gICAgICBmaWx0ZXI6IHtcbiAgICAgICAgLy8gV2UgbmVlZCBhIGRlZXAgd2F0Y2hlciBpbiBjYXNlIHRoZSB1c2VyIHBhc3Nlc1xuICAgICAgICAvLyBhbiBvYmplY3Qgd2hlbiB1c2luZyBgZmlsdGVyLWZ1bmN0aW9uYFxuICAgICAgICBkZWVwOiB0cnVlLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKG5ld0NyaXRlcmlhKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy5jb21wdXRlZEZpbHRlckRlYm91bmNlO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiRfZmlsdGVyVGltZXIpO1xuICAgICAgICAgIHRoaXMuJF9maWx0ZXJUaW1lciA9IG51bGw7XG5cbiAgICAgICAgICBpZiAodGltZW91dCAmJiB0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGRlYm91bmNlIHRpbWUsIGRlbGF5IHRoZSB1cGRhdGUgb2YgYGxvY2FsRmlsdGVyYFxuICAgICAgICAgICAgdGhpcy4kX2ZpbHRlclRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLmxvY2FsRmlsdGVyID0gX3RoaXMuZmlsdGVyU2FuaXRpemUobmV3Q3JpdGVyaWEpO1xuICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaW1tZWRpYXRlbHkgdXBkYXRlIGBsb2NhbEZpbHRlcmAgd2l0aCBgbmV3RmlsdGVyYCB2YWx1ZVxuICAgICAgICAgICAgdGhpcy5sb2NhbEZpbHRlciA9IHRoaXMuZmlsdGVyU2FuaXRpemUobmV3Q3JpdGVyaWEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFdhdGNoIGZvciBjaGFuZ2VzIHRvIHRoZSBmaWx0ZXIgY3JpdGVyaWEgYW5kIGZpbHRlcmVkIGl0ZW1zIHZzIGBsb2NhbEl0ZW1zYFxuICAgICAgLy8gU2V0IHZpc3VhbCBzdGF0ZSBhbmQgZW1pdCBldmVudHMgYXMgcmVxdWlyZWRcbiAgICAgIGZpbHRlcmVkQ2hlY2s6IGZ1bmN0aW9uIGZpbHRlcmVkQ2hlY2soX3JlZikge1xuICAgICAgICB2YXIgZmlsdGVyZWRJdGVtcyA9IF9yZWYuZmlsdGVyZWRJdGVtcyxcbiAgICAgICAgICAgIGxvY2FsRmlsdGVyID0gX3JlZi5sb2NhbEZpbHRlcjtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBkYXRhc2V0IGlzIGZpbHRlcmVkIG9yIG5vdFxuICAgICAgICB2YXIgaXNGaWx0ZXJlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghbG9jYWxGaWx0ZXIpIHtcbiAgICAgICAgICAvLyBJZiBmaWx0ZXIgY3JpdGVyaWEgaXMgZmFsc2V5XG4gICAgICAgICAgaXNGaWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGxvb3NlRXF1YWwobG9jYWxGaWx0ZXIsIFtdKSB8fCBsb29zZUVxdWFsKGxvY2FsRmlsdGVyLCB7fSkpIHtcbiAgICAgICAgICAvLyBJZiBmaWx0ZXIgY3JpdGVyaWEgaXMgYW4gZW1wdHkgYXJyYXkgb3Igb2JqZWN0XG4gICAgICAgICAgaXNGaWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsRmlsdGVyKSB7XG4gICAgICAgICAgLy8gSWYgZmlsdGVyIGNyaXRlcmlhIGlzIHRydXRoeVxuICAgICAgICAgIGlzRmlsdGVyZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRmlsdGVyZWQpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdmaWx0ZXJlZCcsIGZpbHRlcmVkSXRlbXMsIGZpbHRlcmVkSXRlbXMubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNGaWx0ZXJlZCA9IGlzRmlsdGVyZWQ7XG4gICAgICB9LFxuICAgICAgaXNGaWx0ZXJlZDogZnVuY3Rpb24gaXNGaWx0ZXJlZChuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICBpZiAobmV3VmFsID09PSBmYWxzZSAmJiBvbGRWYWwgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIGVtaXQgYSBmaWx0ZXJlZCBldmVudCBpZiBpc0ZpbHRlcmVkIHRyYW5zaXRpb25zIGZyb20gdHJ1ZSB0b1xuICAgICAgICAgIC8vIGZhbHNlIHNvIHRoYXQgdXNlcnMgY2FuIHVwZGF0ZSB0aGVpciBwYWdpbmF0aW9uIGNvbnRyb2xzLlxuICAgICAgICAgIHRoaXMuJGVtaXQoJ2ZpbHRlcmVkJywgdGhpcy5sb2NhbEl0ZW1zLCB0aGlzLmxvY2FsSXRlbXMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBDcmVhdGUgbm9uLXJlYWN0aXZlIHByb3Agd2hlcmUgd2Ugc3RvcmUgdGhlIGRlYm91bmNlIHRpbWVyIGlkXG4gICAgICB0aGlzLiRfZmlsdGVyVGltZXIgPSBudWxsOyAvLyBJZiBmaWx0ZXIgaXMgXCJwcmUtc2V0XCIsIHNldCB0aGUgY3JpdGVyaWFcbiAgICAgIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGFueSB3YXRjaGVycy9kZXBlbmRlbnRzXG4gICAgICAvLyB0aGlzLmxvY2FsRmlsdGVyID0gdGhpcy5maWx0ZXJTYW5pdGl6ZSh0aGlzLmZpbHRlcilcbiAgICAgIC8vIFNldCB0aGUgaW5pdGlhbCBmaWx0ZXJlZCBzdGF0ZSBpbiBhIGAkbmV4dFRpY2soKWAgc28gdGhhdFxuICAgICAgLy8gd2UgdHJpZ2dlciBhIGZpbHRlcmVkIGV2ZW50IGlmIG5lZWRlZFxuXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5pc0ZpbHRlcmVkID0gQm9vbGVhbihfdGhpczIubG9jYWxGaWx0ZXIpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KClcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiRfZmlsdGVyVGltZXIpO1xuICAgICAgdGhpcy4kX2ZpbHRlclRpbWVyID0gbnVsbDtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGZpbHRlclNhbml0aXplOiBmdW5jdGlvbiBmaWx0ZXJTYW5pdGl6ZShjcml0ZXJpYSkge1xuICAgICAgICAvLyBTYW5pdGl6ZXMgZmlsdGVyIGNyaXRlcmlhIGJhc2VkIG9uIGludGVybmFsIG9yIGV4dGVybmFsIGZpbHRlcmluZ1xuICAgICAgICBpZiAodGhpcy5sb2NhbEZpbHRlcmluZyAmJiAhdGhpcy5sb2NhbEZpbHRlckZuICYmICEoaXNTdHJpbmcoY3JpdGVyaWEpIHx8IGlzUmVnRXhwKGNyaXRlcmlhKSkpIHtcbiAgICAgICAgICAvLyBJZiB1c2luZyBpbnRlcm5hbCBmaWx0ZXIgZnVuY3Rpb24sIHdoaWNoIG9ubHkgYWNjZXB0cyBzdHJpbmcgb3IgUmVnRXhwLFxuICAgICAgICAgIC8vIHJldHVybiAnJyB0byBzaWduaWZ5IG5vIGZpbHRlclxuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSAvLyBDb3VsZCBiZSBhIHN0cmluZywgb2JqZWN0IG9yIGFycmF5LCBhcyBuZWVkZWQgYnkgZXh0ZXJuYWwgZmlsdGVyIGZ1bmN0aW9uXG4gICAgICAgIC8vIFdlIHVzZSBgY2xvbmVEZWVwYCB0byBlbnN1cmUgd2UgaGF2ZSBhIG5ldyBjb3B5IG9mIGFuIG9iamVjdCBvciBhcnJheVxuICAgICAgICAvLyB3aXRob3V0IFZ1ZSdzIHJlYWN0aXZlIG9ic2VydmVyc1xuXG5cbiAgICAgICAgcmV0dXJuIGNsb25lRGVlcChjcml0ZXJpYSk7XG4gICAgICB9LFxuICAgICAgLy8gRmlsdGVyIEZ1bmN0aW9uIGZhY3Rvcmllc1xuICAgICAgZmlsdGVyRm5GYWN0b3J5OiBmdW5jdGlvbiBmaWx0ZXJGbkZhY3RvcnkoZmlsdGVyRm4sIGNyaXRlcmlhKSB7XG4gICAgICAgIC8vIFdyYXBwZXIgZmFjdG9yeSBmb3IgZXh0ZXJuYWwgZmlsdGVyIGZ1bmN0aW9uc1xuICAgICAgICAvLyBXcmFwIHRoZSBwcm92aWRlZCBmaWx0ZXItZnVuY3Rpb24gYW5kIHJldHVybiBhIG5ldyBmdW5jdGlvblxuICAgICAgICAvLyBSZXR1cm5zIGBudWxsYCBpZiBubyBmaWx0ZXItZnVuY3Rpb24gZGVmaW5lZCBvciBpZiBjcml0ZXJpYSBpcyBmYWxzZXlcbiAgICAgICAgLy8gUmF0aGVyIHRoYW4gZGlyZWN0bHkgZ3JhYmJpbmcgYHRoaXMuY29tcHV0ZWRMb2NhbEZpbHRlckZuYCBvciBgdGhpcy5maWx0ZXJGdW5jdGlvbmBcbiAgICAgICAgLy8gd2UgaGF2ZSBpdCBwYXNzZWQsIHNvIHRoYXQgdGhlIGNhbGxlciBjb21wdXRlZCBwcm9wIHdpbGwgYmUgcmVhY3RpdmUgdG8gY2hhbmdlc1xuICAgICAgICAvLyBpbiB0aGUgb3JpZ2luYWwgZmlsdGVyLWZ1bmN0aW9uIChhcyB0aGlzIHJvdXRpbmUgaXMgYSBtZXRob2QpXG4gICAgICAgIGlmICghZmlsdGVyRm4gfHwgIWlzRnVuY3Rpb24oZmlsdGVyRm4pIHx8ICFjcml0ZXJpYSB8fCBsb29zZUVxdWFsKGNyaXRlcmlhLCBbXSkgfHwgbG9vc2VFcXVhbChjcml0ZXJpYSwge30pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gLy8gQnVpbGQgdGhlIHdyYXBwZWQgZmlsdGVyIHRlc3QgZnVuY3Rpb24sIHBhc3NpbmcgdGhlIGNyaXRlcmlhIHRvIHRoZSBwcm92aWRlZCBmdW5jdGlvblxuXG5cbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gZm4oaXRlbSkge1xuICAgICAgICAgIC8vIEdlbmVyYXRlZCBmdW5jdGlvbiByZXR1cm5zIHRydWUgaWYgdGhlIGNyaXRlcmlhIG1hdGNoZXMgcGFydFxuICAgICAgICAgIC8vIG9mIHRoZSBzZXJpYWxpemVkIGRhdGEsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICAgIHJldHVybiBmaWx0ZXJGbihpdGVtLCBjcml0ZXJpYSk7XG4gICAgICAgIH07IC8vIFJldHVybiB0aGUgd3JhcHBlZCBmdW5jdGlvblxuXG5cbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfSxcbiAgICAgIGRlZmF1bHRGaWx0ZXJGbkZhY3Rvcnk6IGZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXJGbkZhY3RvcnkoY3JpdGVyaWEpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBkZWZhdWx0IGZpbHRlciBmdW5jdGlvbiwgdXNpbmcgdGhlIGdpdmVuIGZpbHRlciBjcml0ZXJpYVxuICAgICAgICAvLyBSZXR1cm5zIGBudWxsYCBpZiBubyBjcml0ZXJpYSBvciBjcml0ZXJpYSBmb3JtYXQgbm90IHN1cHBvcnRlZFxuICAgICAgICBpZiAoIWNyaXRlcmlhIHx8ICEoaXNTdHJpbmcoY3JpdGVyaWEpIHx8IGlzUmVnRXhwKGNyaXRlcmlhKSkpIHtcbiAgICAgICAgICAvLyBCdWlsdCBpbiBmaWx0ZXIgY2FuIG9ubHkgc3VwcG9ydCBzdHJpbmdzIG9yIFJlZ0V4cCBjcml0ZXJpYSAoYXQgdGhlIG1vbWVudClcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSAvLyBCdWlsZCB0aGUgUmVnRXhwIG5lZWRlZCBmb3IgZmlsdGVyaW5nXG5cblxuICAgICAgICB2YXIgcmVnRXhwID0gY3JpdGVyaWE7XG5cbiAgICAgICAgaWYgKGlzU3RyaW5nKHJlZ0V4cCkpIHtcbiAgICAgICAgICAvLyBFc2NhcGUgc3BlY2lhbCBSZWdFeHAgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIGFuZCBjb252ZXJ0IGNvbnRpZ3VvdXNcbiAgICAgICAgICAvLyB3aGl0ZXNwYWNlIHRvIFxccysgbWF0Y2hlc1xuICAgICAgICAgIHZhciBwYXR0ZXJuID0gZXNjYXBlUmVnRXhwKGNyaXRlcmlhKS5yZXBsYWNlKFJYX1NQQUNFUyQxLCAnXFxcXHMrJyk7IC8vIEJ1aWxkIHRoZSBSZWdFeHAgKG5vIG5lZWQgZm9yIGdsb2JhbCBmbGFnLCBhcyB3ZSBvbmx5IG5lZWRcbiAgICAgICAgICAvLyB0byBmaW5kIHRoZSB2YWx1ZSBvbmNlIGluIHRoZSBzdHJpbmcpXG5cbiAgICAgICAgICByZWdFeHAgPSBuZXcgUmVnRXhwKFwiLipcIi5jb25jYXQocGF0dGVybiwgXCIuKlwiKSwgJ2knKTtcbiAgICAgICAgfSAvLyBHZW5lcmF0ZSB0aGUgd3JhcHBlZCBmaWx0ZXIgdGVzdCBmdW5jdGlvbiB0byB1c2VcblxuXG4gICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIGZuKGl0ZW0pIHtcbiAgICAgICAgICAvLyBUaGlzIHNlYXJjaGVzIGFsbCByb3cgdmFsdWVzIChhbmQgc3ViIHByb3BlcnR5IHZhbHVlcykgaW4gdGhlIGVudGlyZSAoZXhjbHVkaW5nXG4gICAgICAgICAgLy8gc3BlY2lhbCBgX2AgcHJlZml4ZWQga2V5cyksIGJlY2F1c2Ugd2UgY29udmVydCB0aGUgcmVjb3JkIHRvIGEgc3BhY2Utc2VwYXJhdGVkXG4gICAgICAgICAgLy8gc3RyaW5nIGNvbnRhaW5pbmcgYWxsIHRoZSB2YWx1ZSBwcm9wZXJ0aWVzIChyZWN1cnNpdmVseSksIGV2ZW4gb25lcyB0aGF0IGFyZVxuICAgICAgICAgIC8vIG5vdCB2aXNpYmxlIChub3Qgc3BlY2lmaWVkIGluIHRoaXMuZmllbGRzKVxuICAgICAgICAgIC8vIFVzZXJzIGNhbiBpZ25vcmUgZmlsdGVyaW5nIG9uIHNwZWNpZmljIGZpZWxkcywgb3Igb24gb25seSBjZXJ0YWluIGZpZWxkcyxcbiAgICAgICAgICAvLyBhbmQgY2FuIG9wdGlvbmFsbCBzcGVjaWZ5IHNlYXJjaGluZyByZXN1bHRzIG9mIGZpZWxkcyB3aXRoIGZvcm1hdHRlclxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVE9ETzogRW5hYmxlIHNlYXJjaGluZyBvbiBzY29wZWQgc2xvdHMgKG9wdGlvbmFsLCBhcyBpdCB3aWxsIGJlIFNMT1cpXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBHZW5lcmF0ZWQgZnVuY3Rpb24gcmV0dXJucyB0cnVlIGlmIHRoZSBjcml0ZXJpYSBtYXRjaGVzIHBhcnQgb2ZcbiAgICAgICAgICAvLyB0aGUgc2VyaWFsaXplZCBkYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFdlIHNldCBgbGFzdEluZGV4ID0gMGAgb24gdGhlIGBSZWdFeHBgIGluIGNhc2Ugc29tZW9uZSBzcGVjaWZpZXMgdGhlIGAvZ2AgZ2xvYmFsIGZsYWdcbiAgICAgICAgICByZWdFeHAubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICByZXR1cm4gcmVnRXhwLnRlc3Qoc3RyaW5naWZ5UmVjb3JkVmFsdWVzKGl0ZW0sIF90aGlzMy5jb21wdXRlZEZpbHRlcklnbm9yZWQsIF90aGlzMy5jb21wdXRlZEZpbHRlckluY2x1ZGVkLCBfdGhpczMuY29tcHV0ZWRGaWVsZHNPYmopKTtcbiAgICAgICAgfTsgLy8gUmV0dXJuIHRoZSBnZW5lcmF0ZWQgZnVuY3Rpb25cblxuXG4gICAgICAgIHJldHVybiBmbjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLypcbiAgICogQ29uc2lzdGVudCBhbmQgc3RhYmxlIHNvcnQgZnVuY3Rpb24gYWNyb3NzIEphdmFTY3JpcHQgcGxhdGZvcm1zXG4gICAqXG4gICAqIEluY29uc2lzdGVudCBzb3J0cyBjYW4gY2F1c2UgU1NSIHByb2JsZW1zIGJldHdlZW4gY2xpZW50IGFuZCBzZXJ2ZXJcbiAgICogc3VjaCBhcyBpbiA8Yi10YWJsZT4gaWYgc29ydEJ5IGlzIGFwcGxpZWQgdG8gdGhlIGRhdGEgb24gc2VydmVyIHNpZGUgcmVuZGVyLlxuICAgKiBDaHJvbWUgYW5kIFY4IG5hdGl2ZSBzb3J0cyBhcmUgaW5jb25zaXN0ZW50L3Vuc3RhYmxlXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gdXNlcyBuYXRpdmUgc29ydCB3aXRoIGZhbGxiYWNrIHRvIGluZGV4IGNvbXBhcmUgd2hlbiB0aGUgYSBhbmQgYlxuICAgKiBjb21wYXJlIHJldHVybnMgMFxuICAgKlxuICAgKiBBbGdvcml0aG0gYmFzZWQgb246XG4gICAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0Mjc2MDgvZmFzdC1zdGFibGUtc29ydGluZy1hbGdvcml0aG0taW1wbGVtZW50YXRpb24taW4tamF2YXNjcmlwdC80NTQyMjY0NSM0NTQyMjY0NVxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSBhcnJheSB0byBzb3J0XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHNvcnQgY29tcGFyZSBmdW5jdGlvblxuICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICovXG4gIHZhciBzdGFibGVTb3J0ID0gZnVuY3Rpb24gc3RhYmxlU29ydChhcnJheSwgY29tcGFyZUZuKSB7XG4gICAgLy8gVXNpbmcgYC5iaW5kKGNvbXBhcmVGbilgIG9uIHRoZSB3cmFwcGVkIGFub255bW91cyBmdW5jdGlvbiBpbXByb3Zlc1xuICAgIC8vIHBlcmZvcm1hbmNlIGJ5IGF2b2lkaW5nIHRoZSBmdW5jdGlvbiBjYWxsIHNldHVwLiBXZSBkb24ndCB1c2UgYW4gYXJyb3dcbiAgICAvLyBmdW5jdGlvbiBoZXJlIGFzIGl0IGJpbmRzIGB0aGlzYCB0byB0aGUgYHN0YWJsZVNvcnRgIGNvbnRleHQgcmF0aGVyIHRoYW5cbiAgICAvLyB0aGUgYGNvbXBhcmVGbmAgY29udGV4dCwgd2hpY2ggd291bGRuJ3QgZ2l2ZSB1cyB0aGUgcGVyZm9ybWFuY2UgaW5jcmVhc2UuXG4gICAgcmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbiAoYSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBbaW5kZXgsIGFdO1xuICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiB0aGlzKGFbMV0sIGJbMV0pIHx8IGFbMF0gLSBiWzBdO1xuICAgIH0uYmluZChjb21wYXJlRm4pKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlWzFdO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vXG4gIC8vIFRPRE86IEFkZCBvcHRpb24gdG8gc29ydCBieSBtdWx0aXBsZSBjb2x1bW5zICh0cmktc3RhdGUgcGVyIGNvbHVtbixcbiAgLy8gICAgICAgcGx1cyBvcmRlciBvZiBjb2x1bW5zIGluIHNvcnQpICB3aGVyZSBzb3J0QnkgY291bGQgYmUgYW4gYXJyYXlcbiAgLy8gICAgICAgb2Ygb2JqZWN0cyBgWyB7a2V5OiAnZm9vJywgc29ydERpcjogJ2FzYyd9LCB7a2V5OidiYXInLCBzb3J0RGlyOiAnZGVzYyd9IC4uLl1gXG4gIC8vICAgICAgIG9yIGFuIGFycmF5IG9mIGFycmF5cyBgWyBbJ2ZvbycsJ2FzYyddLCBbJ2JhcicsJ2Rlc2MnXSBdYFxuICAvLyAgICAgICBNdWx0aXNvcnQgd2lsbCBtb3N0IGxpa2VseSBiZSBoYW5kbGVkIGluIG1peGluLXNvcnQuanMgYnlcbiAgLy8gICAgICAgY2FsbGluZyB0aGlzIG1ldGhvZCBmb3IgZWFjaCBzb3J0QnlcblxuICB2YXIgZGVmYXVsdFNvcnRDb21wYXJlID0gZnVuY3Rpb24gZGVmYXVsdFNvcnRDb21wYXJlKGEsIGIsIHNvcnRCeSwgc29ydERlc2MsIGZvcm1hdHRlciwgbG9jYWxlT3B0cywgbG9jYWxlLCBudWxsTGFzdCkge1xuICAgIHZhciBhYSA9IGdldChhLCBzb3J0QnksIG51bGwpO1xuICAgIHZhciBiYiA9IGdldChiLCBzb3J0QnksIG51bGwpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZm9ybWF0dGVyKSkge1xuICAgICAgYWEgPSBmb3JtYXR0ZXIoYWEsIHNvcnRCeSwgYSk7XG4gICAgICBiYiA9IGZvcm1hdHRlcihiYiwgc29ydEJ5LCBiKTtcbiAgICB9XG5cbiAgICBhYSA9IGlzVW5kZWZpbmVkT3JOdWxsKGFhKSA/ICcnIDogYWE7XG4gICAgYmIgPSBpc1VuZGVmaW5lZE9yTnVsbChiYikgPyAnJyA6IGJiO1xuXG4gICAgaWYgKGlzRGF0ZShhYSkgJiYgaXNEYXRlKGJiKSB8fCBpc051bWJlcihhYSkgJiYgaXNOdW1iZXIoYmIpKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGNvbXBhcmluZyBkYXRlcyBhbmQgbnVtYmVyc1xuICAgICAgLy8gSW50ZXJuYWxseSBkYXRlcyBhcmUgY29tcGFyZWQgdmlhIHRoZWlyIGVwb2NoIG51bWJlciB2YWx1ZXNcbiAgICAgIHJldHVybiBhYSA8IGJiID8gLTEgOiBhYSA+IGJiID8gMSA6IDA7XG4gICAgfSBlbHNlIGlmIChudWxsTGFzdCAmJiBhYSA9PT0gJycgJiYgYmIgIT09ICcnKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2Ugd2hlbiBzb3J0aW5nIG51bGwvdW5kZWZpbmVkL2VtcHR5IHN0cmluZyBsYXN0XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKG51bGxMYXN0ICYmIGFhICE9PSAnJyAmJiBiYiA9PT0gJycpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVuIHNvcnRpbmcgbnVsbC91bmRlZmluZWQvZW1wdHkgc3RyaW5nIGxhc3RcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IC8vIERvIGxvY2FsaXplZCBzdHJpbmcgY29tcGFyaXNvblxuXG5cbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0VmFsdWVzKGFhKS5sb2NhbGVDb21wYXJlKHN0cmluZ2lmeU9iamVjdFZhbHVlcyhiYiksIGxvY2FsZSwgbG9jYWxlT3B0cyk7XG4gIH07XG5cbiAgdmFyIHNvcnRpbmdNaXhpbiA9IHtcbiAgICBwcm9wczoge1xuICAgICAgc29ydEJ5OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0sXG4gICAgICBzb3J0RGVzYzoge1xuICAgICAgICAvLyBUT0RPOiBNYWtlIHRoaXMgdHJpLXN0YXRlOiB0cnVlLCBmYWxzZSwgbnVsbFxuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHNvcnREaXJlY3Rpb246IHtcbiAgICAgICAgLy8gVGhpcyBwcm9wIGlzIG5hbWVkIGluY29ycmVjdGx5XG4gICAgICAgIC8vIEl0IHNob3VsZCBiZSBgaW5pdGlhbFNvcnREaXJlY3Rpb25gIGFzIGl0IGlzIGEgYml0IG1pc2xlYWRpbmdcbiAgICAgICAgLy8gKG5vdCB0byBtZW50aW9uIGl0IHNjcmV3cyB1cCB0aGUgQVJJQSBsYWJlbCBvbiB0aGUgaGVhZGVycylcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnYXNjJyxcbiAgICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiB2YWxpZGF0b3IoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXMoWydhc2MnLCAnZGVzYycsICdsYXN0J10sIGRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzb3J0Q29tcGFyZToge1xuICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHNvcnRDb21wYXJlT3B0aW9uczoge1xuICAgICAgICAvLyBTdXBwb3J0ZWQgbG9jYWxDb21wYXJlIG9wdGlvbnMsIHNlZSBgb3B0aW9uc2Agc2VjdGlvbiBvZjpcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2xvY2FsZUNvbXBhcmVcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtZXJpYzogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzb3J0Q29tcGFyZUxvY2FsZToge1xuICAgICAgICAvLyBTdHJpbmc6IGxvY2FsZSBjb2RlXG4gICAgICAgIC8vIEFycmF5OiBhcnJheSBvZiBMb2NhbGUgc3RyaW5nc1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0gLy8gZGVmYXVsdDogdW5kZWZpbmVkXG5cbiAgICAgIH0sXG4gICAgICBzb3J0TnVsbExhc3Q6IHtcbiAgICAgICAgLy8gU29ydCBudWxsIGFuZCB1bmRlZmluZWQgdG8gYXBwZWFyIGxhc3RcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBub1NvcnRSZXNldDoge1xuICAgICAgICAvLyBBbm90aGVyIHByb3AgdGhhdCBzaG91bGQgaGF2ZSBoYWQgYSBiZXR0ZXIgbmFtZS5cbiAgICAgICAgLy8gSXQgc2hvdWxkIGJlIG5vU29ydENsZWFyIChvbiBub24tc29ydGFibGUgaGVhZGVycykuXG4gICAgICAgIC8vIFdlIHdpbGwgbmVlZCB0byBtYWtlIHN1cmUgdGhlIGRvY3VtZW50YXRpb24gaXMgY2xlYXIgb24gd2hhdFxuICAgICAgICAvLyB0aGlzIHByb3AgZG9lcyAoYXMgd2VsbCBhcyBpbiB0aGUgY29kZSBmb3IgZnV0dXJlIHJlZmVyZW5jZSlcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBsYWJlbFNvcnRBc2M6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnQ2xpY2sgdG8gc29ydCBBc2NlbmRpbmcnXG4gICAgICB9LFxuICAgICAgbGFiZWxTb3J0RGVzYzoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICdDbGljayB0byBzb3J0IERlc2NlbmRpbmcnXG4gICAgICB9LFxuICAgICAgbGFiZWxTb3J0Q2xlYXI6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnQ2xpY2sgdG8gY2xlYXIgc29ydGluZydcbiAgICAgIH0sXG4gICAgICBub0xvY2FsU29ydGluZzoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIG5vRm9vdGVyU29ydGluZzoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHNvcnRJY29uTGVmdDoge1xuICAgICAgICAvLyBQbGFjZSB0aGUgc29ydGluZyBpY29uIG9uIHRoZSBsZWZ0IG9mIHRoZSBoZWFkZXIgY2VsbHNcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbFNvcnRCeTogdGhpcy5zb3J0QnkgfHwgJycsXG4gICAgICAgIGxvY2FsU29ydERlc2M6IHRoaXMuc29ydERlc2MgfHwgZmFsc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgbG9jYWxTb3J0aW5nOiBmdW5jdGlvbiBsb2NhbFNvcnRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1Byb3ZpZGVyID8gISF0aGlzLm5vUHJvdmlkZXJTb3J0aW5nIDogIXRoaXMubm9Mb2NhbFNvcnRpbmc7XG4gICAgICB9LFxuICAgICAgaXNTb3J0YWJsZTogZnVuY3Rpb24gaXNTb3J0YWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZWRGaWVsZHMuc29tZShmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiBmLnNvcnRhYmxlO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzb3J0ZWRJdGVtczogZnVuY3Rpb24gc29ydGVkSXRlbXMoKSB7XG4gICAgICAgIC8vIFNvcnRzIHRoZSBmaWx0ZXJlZCBpdGVtcyBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiB0aGUgc29ydGVkIGl0ZW1zXG4gICAgICAgIC8vIG9yIHRoZSBvcmlnaW5hbCBpdGVtcyBhcnJheSBpZiBub3Qgc29ydGVkLlxuICAgICAgICB2YXIgaXRlbXMgPSAodGhpcy5maWx0ZXJlZEl0ZW1zIHx8IHRoaXMubG9jYWxJdGVtcyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgdmFyIHNvcnRCeSA9IHRoaXMubG9jYWxTb3J0Qnk7XG4gICAgICAgIHZhciBzb3J0RGVzYyA9IHRoaXMubG9jYWxTb3J0RGVzYztcbiAgICAgICAgdmFyIHNvcnRDb21wYXJlID0gdGhpcy5zb3J0Q29tcGFyZTtcbiAgICAgICAgdmFyIGxvY2FsU29ydGluZyA9IHRoaXMubG9jYWxTb3J0aW5nO1xuXG4gICAgICAgIHZhciBzb3J0T3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLnNvcnRDb21wYXJlT3B0aW9ucywge1xuICAgICAgICAgIHVzYWdlOiAnc29ydCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHNvcnRMb2NhbGUgPSB0aGlzLnNvcnRDb21wYXJlTG9jYWxlIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIG51bGxMYXN0ID0gdGhpcy5zb3J0TnVsbExhc3Q7XG5cbiAgICAgICAgaWYgKHNvcnRCeSAmJiBsb2NhbFNvcnRpbmcpIHtcbiAgICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmNvbXB1dGVkRmllbGRzT2JqW3NvcnRCeV0gfHwge307XG4gICAgICAgICAgdmFyIHNvcnRCeUZvcm1hdHRlZCA9IGZpZWxkLnNvcnRCeUZvcm1hdHRlZDtcbiAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gaXNGdW5jdGlvbihzb3J0QnlGb3JtYXR0ZWQpID8gc29ydEJ5Rm9ybWF0dGVkIDogc29ydEJ5Rm9ybWF0dGVkID8gdGhpcy5nZXRGaWVsZEZvcm1hdHRlcihzb3J0QnkpIDogdW5kZWZpbmVkOyAvLyBgc3RhYmxlU29ydGAgcmV0dXJucyBhIG5ldyBhcnJheSwgYW5kIGxlYXZlcyB0aGUgb3JpZ2luYWwgYXJyYXkgaW50YWN0XG5cbiAgICAgICAgICByZXR1cm4gc3RhYmxlU29ydChpdGVtcywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihzb3J0Q29tcGFyZSkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FsbCB1c2VyIHByb3ZpZGVkIHNvcnRDb21wYXJlIHJvdXRpbmVcbiAgICAgICAgICAgICAgcmVzdWx0ID0gc29ydENvbXBhcmUoYSwgYiwgc29ydEJ5LCBzb3J0RGVzYywgZm9ybWF0dGVyLCBzb3J0T3B0aW9ucywgc29ydExvY2FsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbChyZXN1bHQpIHx8IHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gYnVpbHQtaW4gZGVmYXVsdFNvcnRDb21wYXJlIGlmIHNvcnRDb21wYXJlXG4gICAgICAgICAgICAgIC8vIGlzIG5vdCBkZWZpbmVkIG9yIHJldHVybnMgbnVsbC9mYWxzZVxuICAgICAgICAgICAgICByZXN1bHQgPSBkZWZhdWx0U29ydENvbXBhcmUoYSwgYiwgc29ydEJ5LCBzb3J0RGVzYywgZm9ybWF0dGVyLCBzb3J0T3B0aW9ucywgc29ydExvY2FsZSwgbnVsbExhc3QpO1xuICAgICAgICAgICAgfSAvLyBOZWdhdGUgcmVzdWx0IGlmIHNvcnRpbmcgaW4gZGVzY2VuZGluZyBvcmRlclxuXG5cbiAgICAgICAgICAgIHJldHVybiAocmVzdWx0IHx8IDApICogKHNvcnREZXNjID8gLTEgOiAxKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICBpc1NvcnRhYmxlOiBmdW5jdGlvbiBpc1NvcnRhYmxlKG5ld1ZhbClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBwYWluIGluIHRoZSBidXR0IHRvIHRlc3QgKi9cbiAgICAgIHtcbiAgICAgICAgaWYgKG5ld1ZhbCkge1xuICAgICAgICAgIGlmICh0aGlzLmlzU29ydGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuJG9uKCdoZWFkLWNsaWNrZWQnLCB0aGlzLmhhbmRsZVNvcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiRvZmYoJ2hlYWQtY2xpY2tlZCcsIHRoaXMuaGFuZGxlU29ydCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzb3J0RGVzYzogZnVuY3Rpb24gc29ydERlc2MobmV3VmFsKSB7XG4gICAgICAgIGlmIChuZXdWYWwgPT09IHRoaXMubG9jYWxTb3J0RGVzYykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2NhbFNvcnREZXNjID0gbmV3VmFsIHx8IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHNvcnRCeTogZnVuY3Rpb24gc29ydEJ5KG5ld1ZhbCkge1xuICAgICAgICBpZiAobmV3VmFsID09PSB0aGlzLmxvY2FsU29ydEJ5KSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvY2FsU29ydEJ5ID0gbmV3VmFsIHx8ICcnO1xuICAgICAgfSxcbiAgICAgIC8vIFVwZGF0ZSAuc3luYyBwcm9wc1xuICAgICAgbG9jYWxTb3J0RGVzYzogZnVuY3Rpb24gbG9jYWxTb3J0RGVzYyhuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICAvLyBFbWl0IHVwZGF0ZSB0byBzb3J0LWRlc2Muc3luY1xuICAgICAgICBpZiAobmV3VmFsICE9PSBvbGRWYWwpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6c29ydERlc2MnLCBuZXdWYWwpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbG9jYWxTb3J0Qnk6IGZ1bmN0aW9uIGxvY2FsU29ydEJ5KG5ld1ZhbCwgb2xkVmFsKSB7XG4gICAgICAgIGlmIChuZXdWYWwgIT09IG9sZFZhbCkge1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTpzb3J0QnknLCBuZXdWYWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgaWYgKHRoaXMuaXNTb3J0YWJsZSkge1xuICAgICAgICB0aGlzLiRvbignaGVhZC1jbGlja2VkJywgdGhpcy5oYW5kbGVTb3J0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIC8vIEhhbmRsZXJzXG4gICAgICAvLyBOZWVkIHRvIG1vdmUgZnJvbSB0aGVhZC1taXhpblxuICAgICAgaGFuZGxlU29ydDogZnVuY3Rpb24gaGFuZGxlU29ydChrZXksIGZpZWxkLCBldnQsIGlzRm9vdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5pc1NvcnRhYmxlKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGb290ICYmIHRoaXMubm9Gb290ZXJTb3J0aW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFRPRE86IG1ha2UgdGhpcyB0cmktc3RhdGUgc29ydGluZ1xuICAgICAgICAvLyBjeWNsZSBkZXNjID0+IGFzYyA9PiBub25lID0+IGRlc2MgPT4gLi4uXG5cblxuICAgICAgICB2YXIgc29ydENoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICB2YXIgdG9nZ2xlTG9jYWxTb3J0RGVzYyA9IGZ1bmN0aW9uIHRvZ2dsZUxvY2FsU29ydERlc2MoKSB7XG4gICAgICAgICAgdmFyIHNvcnREaXJlY3Rpb24gPSBmaWVsZC5zb3J0RGlyZWN0aW9uIHx8IF90aGlzLnNvcnREaXJlY3Rpb247XG5cbiAgICAgICAgICBpZiAoc29ydERpcmVjdGlvbiA9PT0gJ2FzYycpIHtcbiAgICAgICAgICAgIF90aGlzLmxvY2FsU29ydERlc2MgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNvcnREaXJlY3Rpb24gPT09ICdkZXNjJykge1xuICAgICAgICAgICAgX3RoaXMubG9jYWxTb3J0RGVzYyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChmaWVsZC5zb3J0YWJsZSkge1xuICAgICAgICAgIGlmIChrZXkgPT09IHRoaXMubG9jYWxTb3J0QnkpIHtcbiAgICAgICAgICAgIC8vIENoYW5nZSBzb3J0aW5nIGRpcmVjdGlvbiBvbiBjdXJyZW50IGNvbHVtblxuICAgICAgICAgICAgdGhpcy5sb2NhbFNvcnREZXNjID0gIXRoaXMubG9jYWxTb3J0RGVzYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU3RhcnQgc29ydGluZyB0aGlzIGNvbHVtbiBhc2NlbmRpbmdcbiAgICAgICAgICAgIHRoaXMubG9jYWxTb3J0QnkgPSBrZXk7IC8vIHRoaXMubG9jYWxTb3J0RGVzYyA9IGZhbHNlXG5cbiAgICAgICAgICAgIHRvZ2dsZUxvY2FsU29ydERlc2MoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzb3J0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sb2NhbFNvcnRCeSAmJiAhdGhpcy5ub1NvcnRSZXNldCkge1xuICAgICAgICAgIHRoaXMubG9jYWxTb3J0QnkgPSAnJztcbiAgICAgICAgICB0b2dnbGVMb2NhbFNvcnREZXNjKCk7XG4gICAgICAgICAgc29ydENoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvcnRDaGFuZ2VkKSB7XG4gICAgICAgICAgLy8gU29ydGluZyBwYXJhbWV0ZXJzIGNoYW5nZWRcbiAgICAgICAgICB0aGlzLiRlbWl0KCdzb3J0LWNoYW5nZWQnLCB0aGlzLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gbWV0aG9kcyB0byBjb21wdXRlIGNsYXNzZXMgYW5kIGF0dHJzIGZvciB0aGVhZD50aCBjZWxsc1xuICAgICAgc29ydFRoZWFkVGhDbGFzc2VzOiBmdW5jdGlvbiBzb3J0VGhlYWRUaENsYXNzZXMoa2V5LCBmaWVsZCwgaXNGb290KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLy8gSWYgc29ydGFibGUgYW5kIHNvcnRJY29uTGVmdCBhcmUgdHJ1ZSwgdGhlbiBwbGFjZSBzb3J0IGljb24gb24gdGhlIGxlZnRcbiAgICAgICAgICAnYi10YWJsZS1zb3J0LWljb24tbGVmdCc6IGZpZWxkLnNvcnRhYmxlICYmIHRoaXMuc29ydEljb25MZWZ0ICYmICEoaXNGb290ICYmIHRoaXMubm9Gb290ZXJTb3J0aW5nKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHNvcnRUaGVhZFRoQXR0cnM6IGZ1bmN0aW9uIHNvcnRUaGVhZFRoQXR0cnMoa2V5LCBmaWVsZCwgaXNGb290KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1NvcnRhYmxlIHx8IGlzRm9vdCAmJiB0aGlzLm5vRm9vdGVyU29ydGluZykge1xuICAgICAgICAgIC8vIE5vIGF0dHJpYnV0ZXMgaWYgbm90IGEgc29ydGFibGUgdGFibGVcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc29ydGFibGUgPSBmaWVsZC5zb3J0YWJsZTsgLy8gQXNzZW1ibGUgdGhlIGFyaWEtc29ydCBhdHRyaWJ1dGUgdmFsdWVcblxuICAgICAgICB2YXIgYXJpYVNvcnQgPSBzb3J0YWJsZSAmJiB0aGlzLmxvY2FsU29ydEJ5ID09PSBrZXkgPyB0aGlzLmxvY2FsU29ydERlc2MgPyAnZGVzY2VuZGluZycgOiAnYXNjZW5kaW5nJyA6IHNvcnRhYmxlID8gJ25vbmUnIDogbnVsbDsgLy8gUmV0dXJuIHRoZSBhdHRyaWJ1dGVcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICdhcmlhLXNvcnQnOiBhcmlhU29ydFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHNvcnRUaGVhZFRoTGFiZWw6IGZ1bmN0aW9uIHNvcnRUaGVhZFRoTGFiZWwoa2V5LCBmaWVsZCwgaXNGb290KSB7XG4gICAgICAgIC8vIEEgbGFiZWwgdG8gYmUgcGxhY2VkIGluIGFuIGAuc3Itb25seWAgZWxlbWVudCBpbiB0aGUgaGVhZGVyIGNlbGxcbiAgICAgICAgaWYgKCF0aGlzLmlzU29ydGFibGUgfHwgaXNGb290ICYmIHRoaXMubm9Gb290ZXJTb3J0aW5nKSB7XG4gICAgICAgICAgLy8gTm8gbGFiZWwgaWYgbm90IGEgc29ydGFibGUgdGFibGVcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzb3J0YWJsZSA9IGZpZWxkLnNvcnRhYmxlOyAvLyBUaGUgY29ycmVjdG5lc3Mgb2YgdGhlc2UgbGFiZWxzIGlzIHZlcnkgaW1wb3J0YW50IGZvciBzY3JlZW4tcmVhZGVyIHVzZXJzLlxuXG4gICAgICAgIHZhciBsYWJlbFNvcnRpbmcgPSAnJztcblxuICAgICAgICBpZiAoc29ydGFibGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5sb2NhbFNvcnRCeSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAvLyBjdXJyZW50bHkgc29ydGVkIHNvcnRhYmxlIGNvbHVtbi5cbiAgICAgICAgICAgIGxhYmVsU29ydGluZyA9IHRoaXMubG9jYWxTb3J0RGVzYyA/IHRoaXMubGFiZWxTb3J0QXNjIDogdGhpcy5sYWJlbFNvcnREZXNjO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBOb3QgY3VycmVudGx5IHNvcnRlZCBzb3J0YWJsZSBjb2x1bW4uXG4gICAgICAgICAgICAvLyBOb3QgdXNpbmcgbmVzdGVkIHRlcm5hcnkncyBoZXJlIGZvciBjbGFyaXR5L3JlYWRhYmlsaXR5XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGZvciBhcmlhTGFiZWxcbiAgICAgICAgICAgIGxhYmVsU29ydGluZyA9IHRoaXMubG9jYWxTb3J0RGVzYyA/IHRoaXMubGFiZWxTb3J0RGVzYyA6IHRoaXMubGFiZWxTb3J0QXNjOyAvLyBIYW5kbGUgc29ydERpcmVjdGlvbiBzZXR0aW5nXG5cbiAgICAgICAgICAgIHZhciBzb3J0RGlyZWN0aW9uID0gdGhpcy5zb3J0RGlyZWN0aW9uIHx8IGZpZWxkLnNvcnREaXJlY3Rpb247XG5cbiAgICAgICAgICAgIGlmIChzb3J0RGlyZWN0aW9uID09PSAnYXNjJykge1xuICAgICAgICAgICAgICBsYWJlbFNvcnRpbmcgPSB0aGlzLmxhYmVsU29ydEFzYztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc29ydERpcmVjdGlvbiA9PT0gJ2Rlc2MnKSB7XG4gICAgICAgICAgICAgIGxhYmVsU29ydGluZyA9IHRoaXMubGFiZWxTb3J0RGVzYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMubm9Tb3J0UmVzZXQpIHtcbiAgICAgICAgICAvLyBOb24gc29ydGFibGUgY29sdW1uXG4gICAgICAgICAgbGFiZWxTb3J0aW5nID0gdGhpcy5sb2NhbFNvcnRCeSA/IHRoaXMubGFiZWxTb3J0Q2xlYXIgOiAnJztcbiAgICAgICAgfSAvLyBSZXR1cm4gdGhlIHNyLW9ubHkgc29ydCBsYWJlbCBvciBudWxsIGlmIG5vIGxhYmVsXG5cblxuICAgICAgICByZXR1cm4gdHJpbShsYWJlbFNvcnRpbmcpIHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBwYWdpbmF0aW9uTWl4aW4kMSA9IHtcbiAgICBwcm9wczoge1xuICAgICAgcGVyUGFnZToge1xuICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICBkZWZhdWx0OiAwXG4gICAgICB9LFxuICAgICAgY3VycmVudFBhZ2U6IHtcbiAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgZGVmYXVsdDogMVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGxvY2FsUGFnaW5nOiBmdW5jdGlvbiBsb2NhbFBhZ2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzUHJvdmlkZXIgPyAhIXRoaXMubm9Qcm92aWRlclBhZ2luZyA6IHRydWU7XG4gICAgICB9LFxuICAgICAgcGFnaW5hdGVkSXRlbXM6IGZ1bmN0aW9uIHBhZ2luYXRlZEl0ZW1zKCkge1xuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLnNvcnRlZEl0ZW1zIHx8IHRoaXMuZmlsdGVyZWRJdGVtcyB8fCB0aGlzLmxvY2FsSXRlbXMgfHwgW107XG4gICAgICAgIHZhciBjdXJyZW50UGFnZSA9IE1hdGgubWF4KHBhcnNlSW50KHRoaXMuY3VycmVudFBhZ2UsIDEwKSB8fCAxLCAxKTtcbiAgICAgICAgdmFyIHBlclBhZ2UgPSBNYXRoLm1heChwYXJzZUludCh0aGlzLnBlclBhZ2UsIDEwKSB8fCAwLCAwKTsgLy8gQXBwbHkgbG9jYWwgcGFnaW5hdGlvblxuXG4gICAgICAgIGlmICh0aGlzLmxvY2FsUGFnaW5nICYmICEhcGVyUGFnZSkge1xuICAgICAgICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgcGFnZSBvZiBkYXRhICh3aGljaCBtYXkgYmUgcGFzdCBmaWx0ZXJlZCBpdGVtcyBsaW1pdClcbiAgICAgICAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKChjdXJyZW50UGFnZSAtIDEpICogcGVyUGFnZSwgY3VycmVudFBhZ2UgKiBwZXJQYWdlKTtcbiAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGl0ZW1zIHRvIGRpc3BsYXkgaW4gdGhlIHRhYmxlXG5cblxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBjYXB0aW9uTWl4aW4gPSB7XG4gICAgcHJvcHM6IHtcbiAgICAgIC8vIGBjYXB0aW9uLXRvcGAgaXMgcGFydCBvZiB0YWJsZS1yZWRlcmUgbWl4aW4gKHN0eWxpbmcpXG4gICAgICAvLyBjYXB0aW9uVG9wOiB7XG4gICAgICAvLyAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAvLyAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAvLyB9LFxuICAgICAgY2FwdGlvbjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBjYXB0aW9uSHRtbDoge1xuICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBjYXB0aW9uSWQ6IGZ1bmN0aW9uIGNhcHRpb25JZCgpIHtcbiAgICAgICAgLy8gRXZlbiB0aG91Z2ggYHRoaXMuc2FmZUlkYCBsb29rcyBsaWtlIGEgbWV0aG9kLCBpdCBpcyBhIGNvbXB1dGVkIHByb3BcbiAgICAgICAgLy8gdGhhdCByZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIGlmIHRoZSB1bmRlcmx5aW5nIElEIGNoYW5nZXNcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTdGFja2VkID8gdGhpcy5zYWZlSWQoJ19jYXB0aW9uXycpIDogbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHJlbmRlckNhcHRpb246IGZ1bmN0aW9uIHJlbmRlckNhcHRpb24oKSB7XG4gICAgICAgIHZhciBoID0gdGhpcy4kY3JlYXRlRWxlbWVudDsgLy8gQnVpbGQgdGhlIGNhcHRpb25cblxuICAgICAgICB2YXIgJGNhcHRpb25TbG90ID0gdGhpcy5ub3JtYWxpemVTbG90KCd0YWJsZS1jYXB0aW9uJyk7XG4gICAgICAgIHZhciAkY2FwdGlvbiA9IGgoKTtcblxuICAgICAgICBpZiAoJGNhcHRpb25TbG90IHx8IHRoaXMuY2FwdGlvbiB8fCB0aGlzLmNhcHRpb25IdG1sKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBrZXk6ICdjYXB0aW9uJyxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGlkOiB0aGlzLmNhcHRpb25JZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoISRjYXB0aW9uU2xvdCkge1xuICAgICAgICAgICAgZGF0YS5kb21Qcm9wcyA9IGh0bWxPclRleHQodGhpcy5jYXB0aW9uSHRtbCwgdGhpcy5jYXB0aW9uKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkY2FwdGlvbiA9IGgoJ2NhcHRpb24nLCBkYXRhLCBbJGNhcHRpb25TbG90XSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJGNhcHRpb247XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBjb2xncm91cE1peGluID0ge1xuICAgIG1ldGhvZHM6IHtcbiAgICAgIHJlbmRlckNvbGdyb3VwOiBmdW5jdGlvbiByZW5kZXJDb2xncm91cCgpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLiRjcmVhdGVFbGVtZW50O1xuICAgICAgICB2YXIgZmllbGRzID0gdGhpcy5jb21wdXRlZEZpZWxkcztcbiAgICAgICAgdmFyICRjb2xncm91cCA9IGgoKTtcblxuICAgICAgICBpZiAodGhpcy5oYXNOb3JtYWxpemVkU2xvdCgndGFibGUtY29sZ3JvdXAnKSkge1xuICAgICAgICAgICRjb2xncm91cCA9IGgoJ2NvbGdyb3VwJywge1xuICAgICAgICAgICAga2V5OiAnY29sZ3JvdXAnXG4gICAgICAgICAgfSwgW3RoaXMubm9ybWFsaXplU2xvdCgndGFibGUtY29sZ3JvdXAnLCB7XG4gICAgICAgICAgICBjb2x1bW5zOiBmaWVsZHMubGVuZ3RoLFxuICAgICAgICAgICAgZmllbGRzOiBmaWVsZHNcbiAgICAgICAgICB9KV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRjb2xncm91cDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIFRBQkxFX1RBR19OQU1FUyA9IFsnVEQnLCAnVEgnLCAnVFInXTsgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgd2Ugc2hvdWxkIGlnbm9yZSB0aGUgY2xpY2svZG91YmxlLWNsaWNrL2tleXByZXNzIGV2ZW50XG4gIC8vIEF2b2lkcyBoYXZpbmcgdGhlIHVzZXIgbmVlZCB0byB1c2UgYEBjbGljay5zdG9wYCBvbiB0aGUgZm9ybSBjb250cm9sXG5cbiAgdmFyIGZpbHRlckV2ZW50ID0gZnVuY3Rpb24gZmlsdGVyRXZlbnQoZXZ0KSB7XG4gICAgLy8gRXhpdCBlYXJseSB3aGVuIHdlIGRvbid0IGhhdmUgYSB0YXJnZXQgZWxlbWVudFxuICAgIGlmICghZXZ0IHx8ICFldnQudGFyZ2V0KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBlbCA9IGV2dC50YXJnZXQ7IC8vIEV4aXQgZWFybHkgd2hlbiBlbGVtZW50IGlzIGRpc2FibGVkIG9yIGEgdGFibGUgZWxlbWVudFxuXG4gICAgaWYgKGVsLmRpc2FibGVkIHx8IFRBQkxFX1RBR19OQU1FUy5pbmRleE9mKGVsLnRhZ05hbWUpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gSWdub3JlIHRoZSBjbGljayB3aGVuIGl0IHdhcyBpbnNpZGUgYSBkcm9wZG93biBtZW51XG5cblxuICAgIGlmIChjbG9zZXN0KCcuZHJvcGRvd24tbWVudScsIGVsKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxhYmVsID0gZWwudGFnTmFtZSA9PT0gJ0xBQkVMJyA/IGVsIDogY2xvc2VzdCgnbGFiZWwnLCBlbCk7IC8vIElmIHRoZSBsYWJlbCdzIGZvcm0gY29udHJvbCBpcyBub3QgZGlzYWJsZWQgdGhlbiB3ZSBkb24ndCBwcm9wYWdhdGUgZXZlbnRcbiAgICAvLyBNb2Rlcm4gYnJvd3NlcnMgaGF2ZSBgbGFiZWwuY29udHJvbGAgdGhhdCByZWZlcmVuY2VzIHRoZSBhc3NvY2lhdGVkIGlucHV0LCBidXQgSUUgMTFcbiAgICAvLyBkb2VzIG5vdCBoYXZlIHRoaXMgcHJvcGVydHkgb24gdGhlIGxhYmVsIGVsZW1lbnQsIHNvIHdlIHJlc29ydCB0byBET00gbG9va3Vwc1xuXG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICB2YXIgbGFiZWxGb3IgPSBnZXRBdHRyKGxhYmVsLCAnZm9yJyk7XG4gICAgICB2YXIgaW5wdXQgPSBsYWJlbEZvciA/IGdldEJ5SWQobGFiZWxGb3IpIDogc2VsZWN0KCdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYScsIGxhYmVsKTtcblxuICAgICAgaWYgKGlucHV0ICYmICFpbnB1dC5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIE90aGVyd2lzZSBjaGVjayBpZiB0aGUgZXZlbnQgdGFyZ2V0IG1hdGNoZXMgb25lIG9mIHRoZSBzZWxlY3RvcnMgaW4gdGhlXG4gICAgLy8gZXZlbnQgZmlsdGVyIChpLmUuIGFuY2hvcnMsIG5vbiBkaXNhYmxlZCBpbnB1dHMsIGV0Yy4pXG4gICAgLy8gUmV0dXJuIGB0cnVlYCBpZiB3ZSBzaG91bGQgaWdub3JlIHRoZSBldmVudFxuXG5cbiAgICByZXR1cm4gbWF0Y2hlcyhlbCwgRVZFTlRfRklMVEVSKTtcbiAgfTtcblxuICAvLyBVc2VkIHRvIGZpbHRlciBvdXQgY2xpY2sgZXZlbnRzIGNhdXNlZCBieSB0aGUgbW91c2UgdXAgYXQgZW5kIG9mIHNlbGVjdGlvblxuICAvL1xuICAvLyBBY2NlcHRzIGFuIGVsZW1lbnQgYXMgb25seSBhcmd1bWVudCB0byB0ZXN0IHRvIHNlZSBpZiBzZWxlY3Rpb24gb3ZlcmxhcHMgb3IgaXNcbiAgLy8gY29udGFpbmVkIHdpdGhpbiB0aGUgZWxlbWVudFxuXG4gIHZhciB0ZXh0U2VsZWN0aW9uQWN0aXZlID0gZnVuY3Rpb24gdGV4dFNlbGVjdGlvbkFjdGl2ZSgpIHtcbiAgICB2YXIgZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGRvY3VtZW50O1xuICAgIHZhciBzZWwgPSBnZXRTZWwoKTtcbiAgICByZXR1cm4gc2VsICYmIHNlbC50b1N0cmluZygpLnRyaW0oKSAhPT0gJycgJiYgc2VsLmNvbnRhaW5zTm9kZSAmJiBpc0VsZW1lbnQoZWwpID8gc2VsLmNvbnRhaW5zTm9kZShlbCwgdHJ1ZSkgOiBmYWxzZTtcbiAgfTtcblxuICB2YXIgcHJvcHMkVCA9IHtcbiAgICBoZWFkVmFyaWFudDoge1xuICAgICAgLy8gQWxzbyBzbmlmZmVkIGJ5IDxiLXRyPiAvIDxiLXRkPiAvIDxiLXRoPlxuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgLy8gc3VwcG9ydGVkIHZhbHVlczogJ2xpdGUnLCAnZGFyaycsIG9yIG51bGxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9XG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJUaGVhZCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JUaGVhZCcsXG4gICAgbWl4aW5zOiBbbm9ybWFsaXplU2xvdE1peGluXSxcbiAgICBpbmhlcml0QXR0cnM6IGZhbHNlLFxuICAgIHByb3ZpZGU6IGZ1bmN0aW9uIHByb3ZpZGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBidlRhYmxlUm93R3JvdXA6IHRoaXNcbiAgICAgIH07XG4gICAgfSxcbiAgICBpbmplY3Q6IHtcbiAgICAgIGJ2VGFibGU6IHtcbiAgICAgICAgLy8gU25pZmZlZCBieSA8Yi10cj4gLyA8Yi10ZD4gLyA8Yi10aD5cbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wczogcHJvcHMkVCxcbiAgICBjb21wdXRlZDoge1xuICAgICAgaXNUaGVhZDogZnVuY3Rpb24gaXNUaGVhZCgpIHtcbiAgICAgICAgLy8gU25pZmZlZCBieSA8Yi10cj4gLyA8Yi10ZD4gLyA8Yi10aD5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgaXNEYXJrOiBmdW5jdGlvbiBpc0RhcmsoKSB7XG4gICAgICAgIC8vIFNuaWZmZWQgYnkgPGItdHI+IC8gPGItdGQ+IC8gPGItdGg+XG4gICAgICAgIHJldHVybiB0aGlzLmJ2VGFibGUuZGFyaztcbiAgICAgIH0sXG4gICAgICBpc1N0YWNrZWQ6IGZ1bmN0aW9uIGlzU3RhY2tlZCgpIHtcbiAgICAgICAgLy8gU25pZmZlZCBieSA8Yi10cj4gLyA8Yi10ZD4gLyA8Yi10aD5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnZUYWJsZS5pc1N0YWNrZWQ7XG4gICAgICB9LFxuICAgICAgaXNSZXNwb25zaXZlOiBmdW5jdGlvbiBpc1Jlc3BvbnNpdmUoKSB7XG4gICAgICAgIC8vIFNuaWZmZWQgYnkgPGItdHI+IC8gPGItdGQ+IC8gPGItdGg+XG4gICAgICAgIHJldHVybiB0aGlzLmJ2VGFibGUuaXNSZXNwb25zaXZlO1xuICAgICAgfSxcbiAgICAgIGlzU3RpY2t5SGVhZGVyOiBmdW5jdGlvbiBpc1N0aWNreUhlYWRlcigpIHtcbiAgICAgICAgLy8gU25pZmZlZCBieSA8Yi10cj4gLyA8Yi10ZD4gLyA8Yi10aD5cbiAgICAgICAgLy8gTmVlZGVkIHRvIGhhbmRsZSBoZWFkZXIgYmFja2dyb3VuZCBjbGFzc2VzLCBkdWUgdG8gbGFjayBvZlxuICAgICAgICAvLyBiYWNrZ3JvdW5kIGNvbG9yIGluaGVyaXRhbmNlIHdpdGggQm9vdHN0cmFwIHY0IHRhYmxlIENTU1xuICAgICAgICAvLyBTdGlja3kgaGVhZGVycyBvbmx5IGFwcGx5IHRvIGNlbGxzIGluIHRhYmxlIGB0aGVhZGBcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzU3RhY2tlZCAmJiB0aGlzLmJ2VGFibGUuc3RpY2t5SGVhZGVyO1xuICAgICAgfSxcbiAgICAgIGhhc1N0aWNreUhlYWRlcjogZnVuY3Rpb24gaGFzU3RpY2t5SGVhZGVyKCkge1xuICAgICAgICAvLyBTbmlmZmVkIGJ5IDxiLXRyPiAvIDxiLXRkPiAvIDxiLXRoPlxuICAgICAgICAvLyBOZWVkZWQgdG8gaGFuZGxlIGhlYWRlciBiYWNrZ3JvdW5kIGNsYXNzZXMsIGR1ZSB0byBsYWNrIG9mXG4gICAgICAgIC8vIGJhY2tncm91bmQgY29sb3IgaW5oZXJpdGFuY2Ugd2l0aCBCb290c3RyYXAgdjQgdGFibGUgQ1NTXG4gICAgICAgIHJldHVybiAhdGhpcy5pc1N0YWNrZWQgJiYgdGhpcy5idlRhYmxlLnN0aWNreUhlYWRlcjtcbiAgICAgIH0sXG4gICAgICB0YWJsZVZhcmlhbnQ6IGZ1bmN0aW9uIHRhYmxlVmFyaWFudCgpIHtcbiAgICAgICAgLy8gU25pZmZlZCBieSA8Yi10cj4gLyA8Yi10ZD4gLyA8Yi10aD5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnZUYWJsZS50YWJsZVZhcmlhbnQ7XG4gICAgICB9LFxuICAgICAgdGhlYWRDbGFzc2VzOiBmdW5jdGlvbiB0aGVhZENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5oZWFkVmFyaWFudCA/IFwidGhlYWQtXCIuY29uY2F0KHRoaXMuaGVhZFZhcmlhbnQpIDogbnVsbF07XG4gICAgICB9LFxuICAgICAgdGhlYWRBdHRyczogZnVuY3Rpb24gdGhlYWRBdHRycygpIHtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICByb2xlOiAncm93Z3JvdXAnXG4gICAgICAgIH0sIHRoaXMuJGF0dHJzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHJldHVybiBoKCd0aGVhZCcsIHtcbiAgICAgICAgY2xhc3M6IHRoaXMudGhlYWRDbGFzc2VzLFxuICAgICAgICBhdHRyczogdGhpcy50aGVhZEF0dHJzLFxuICAgICAgICAvLyBQYXNzIGRvd24gYW55IG5hdGl2ZSBsaXN0ZW5lcnNcbiAgICAgICAgb246IHRoaXMuJGxpc3RlbmVyc1xuICAgICAgfSwgdGhpcy5ub3JtYWxpemVTbG90KCdkZWZhdWx0JykpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHByb3BzJFUgPSB7XG4gICAgZm9vdFZhcmlhbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIC8vIHN1cHBvcnRlZCB2YWx1ZXM6ICdsaXRlJywgJ2RhcmsnLCBvciBudWxsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfVxuICB9OyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCVGZvb3QgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCVGZvb3QnLFxuICAgIG1peGluczogW25vcm1hbGl6ZVNsb3RNaXhpbl0sXG4gICAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnZUYWJsZVJvd0dyb3VwOiB0aGlzXG4gICAgICB9O1xuICAgIH0sXG4gICAgaW5qZWN0OiB7XG4gICAgICBidlRhYmxlOiB7XG4gICAgICAgIC8vIFNuaWZmZWQgYnkgPGItdHI+IC8gPGItdGQ+IC8gPGItdGg+XG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KClcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcHM6IHByb3BzJFUsXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGlzVGZvb3Q6IGZ1bmN0aW9uIGlzVGZvb3QoKSB7XG4gICAgICAgIC8vIFNuaWZmZWQgYnkgPGItdHI+IC8gPGItdGQ+IC8gPGItdGg+XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGlzRGFyazogZnVuY3Rpb24gaXNEYXJrKClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBOb3QgY3VycmVudGx5IHNuaWZmZWQgaW4gdGVzdHMgKi9cbiAgICAgIHtcbiAgICAgICAgLy8gU25pZmZlZCBieSA8Yi10cj4gLyA8Yi10ZD4gLyA8Yi10aD5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnZUYWJsZS5kYXJrO1xuICAgICAgfSxcbiAgICAgIGlzU3RhY2tlZDogZnVuY3Rpb24gaXNTdGFja2VkKCkge1xuICAgICAgICAvLyBTbmlmZmVkIGJ5IDxiLXRyPiAvIDxiLXRkPiAvIDxiLXRoPlxuICAgICAgICByZXR1cm4gdGhpcy5idlRhYmxlLmlzU3RhY2tlZDtcbiAgICAgIH0sXG4gICAgICBpc1Jlc3BvbnNpdmU6IGZ1bmN0aW9uIGlzUmVzcG9uc2l2ZSgpIHtcbiAgICAgICAgLy8gU25pZmZlZCBieSA8Yi10cj4gLyA8Yi10ZD4gLyA8Yi10aD5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnZUYWJsZS5pc1Jlc3BvbnNpdmU7XG4gICAgICB9LFxuICAgICAgaXNTdGlja3lIZWFkZXI6IGZ1bmN0aW9uIGlzU3RpY2t5SGVhZGVyKCkge1xuICAgICAgICAvLyBTbmlmZmVkIGJ5IDxiLXRyPiAvIDxiLXRkPiAvIDxiLXRoPlxuICAgICAgICAvLyBTdGlja3kgaGVhZGVycyBhcmUgb25seSBzdXBwb3J0ZWQgaW4gdGhlYWRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGhhc1N0aWNreUhlYWRlcjogZnVuY3Rpb24gaGFzU3RpY2t5SGVhZGVyKCkge1xuICAgICAgICAvLyBTbmlmZmVkIGJ5IDxiLXRyPiAvIDxiLXRkPiAvIDxiLXRoPlxuICAgICAgICAvLyBOZWVkZWQgdG8gaGFuZGxlIGhlYWRlciBiYWNrZ3JvdW5kIGNsYXNzZXMsIGR1ZSB0byBsYWNrIG9mXG4gICAgICAgIC8vIGJhY2tncm91bmQgY29sb3IgaW5oZXJpdGFuY2Ugd2l0aCBCb290c3RyYXAgdjQgdGFibGUgQ1NTXG4gICAgICAgIHJldHVybiAhdGhpcy5pc1N0YWNrZWQgJiYgdGhpcy5idlRhYmxlLnN0aWNreUhlYWRlcjtcbiAgICAgIH0sXG4gICAgICB0YWJsZVZhcmlhbnQ6IGZ1bmN0aW9uIHRhYmxlVmFyaWFudCgpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogTm90IGN1cnJlbnRseSBzbmlmZmVkIGluIHRlc3RzICovXG4gICAgICB7XG4gICAgICAgIC8vIFNuaWZmZWQgYnkgPGItdHI+IC8gPGItdGQ+IC8gPGItdGg+XG4gICAgICAgIHJldHVybiB0aGlzLmJ2VGFibGUudGFibGVWYXJpYW50O1xuICAgICAgfSxcbiAgICAgIHRmb290Q2xhc3NlczogZnVuY3Rpb24gdGZvb3RDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuZm9vdFZhcmlhbnQgPyBcInRoZWFkLVwiLmNvbmNhdCh0aGlzLmZvb3RWYXJpYW50KSA6IG51bGxdO1xuICAgICAgfSxcbiAgICAgIHRmb290QXR0cnM6IGZ1bmN0aW9uIHRmb290QXR0cnMoKSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgcm9sZTogJ3Jvd2dyb3VwJ1xuICAgICAgICB9LCB0aGlzLiRhdHRycyk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICByZXR1cm4gaCgndGZvb3QnLCB7XG4gICAgICAgIGNsYXNzOiB0aGlzLnRmb290Q2xhc3NlcyxcbiAgICAgICAgYXR0cnM6IHRoaXMudGZvb3RBdHRycyxcbiAgICAgICAgLy8gUGFzcyBkb3duIGFueSBuYXRpdmUgbGlzdGVuZXJzXG4gICAgICAgIG9uOiB0aGlzLiRsaXN0ZW5lcnNcbiAgICAgIH0sIHRoaXMubm9ybWFsaXplU2xvdCgnZGVmYXVsdCcpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwcm9wcyRWID0ge1xuICAgIHZhcmlhbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9XG4gIH07XG4gIHZhciBMSUdIVCA9ICdsaWdodCc7XG4gIHZhciBEQVJLID0gJ2RhcmsnOyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCVHIgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCVHInLFxuICAgIG1peGluczogW25vcm1hbGl6ZVNsb3RNaXhpbl0sXG4gICAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnZUYWJsZVRyOiB0aGlzXG4gICAgICB9O1xuICAgIH0sXG4gICAgaW5qZWN0OiB7XG4gICAgICBidlRhYmxlUm93R3JvdXA6IHtcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wczogcHJvcHMkVixcbiAgICBjb21wdXRlZDoge1xuICAgICAgaW5UYm9keTogZnVuY3Rpb24gaW5UYm9keSgpIHtcbiAgICAgICAgLy8gU25pZmZlZCBieSA8Yi10ZD4gLyA8Yi10aD5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnZUYWJsZVJvd0dyb3VwLmlzVGJvZHk7XG4gICAgICB9LFxuICAgICAgaW5UaGVhZDogZnVuY3Rpb24gaW5UaGVhZCgpIHtcbiAgICAgICAgLy8gU25pZmZlZCBieSA8Yi10ZD4gLyA8Yi10aD5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnZUYWJsZVJvd0dyb3VwLmlzVGhlYWQ7XG4gICAgICB9LFxuICAgICAgaW5UZm9vdDogZnVuY3Rpb24gaW5UZm9vdCgpIHtcbiAgICAgICAgLy8gU25pZmZlZCBieSA8Yi10ZD4gLyA8Yi10aD5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnZUYWJsZVJvd0dyb3VwLmlzVGZvb3Q7XG4gICAgICB9LFxuICAgICAgaXNEYXJrOiBmdW5jdGlvbiBpc0RhcmsoKSB7XG4gICAgICAgIC8vIFNuaWZmZWQgYnkgPGItdGQ+IC8gPGItdGg+XG4gICAgICAgIHJldHVybiB0aGlzLmJ2VGFibGVSb3dHcm91cC5pc0Rhcms7XG4gICAgICB9LFxuICAgICAgaXNTdGFja2VkOiBmdW5jdGlvbiBpc1N0YWNrZWQoKSB7XG4gICAgICAgIC8vIFNuaWZmZWQgYnkgPGItdGQ+IC8gPGItdGg+XG4gICAgICAgIHJldHVybiB0aGlzLmJ2VGFibGVSb3dHcm91cC5pc1N0YWNrZWQ7XG4gICAgICB9LFxuICAgICAgaXNSZXNwb25zaXZlOiBmdW5jdGlvbiBpc1Jlc3BvbnNpdmUoKSB7XG4gICAgICAgIC8vIFNuaWZmZWQgYnkgPGItdGQ+IC8gPGItdGg+XG4gICAgICAgIHJldHVybiB0aGlzLmJ2VGFibGVSb3dHcm91cC5pc1Jlc3BvbnNpdmU7XG4gICAgICB9LFxuICAgICAgaXNTdGlja3lIZWFkZXI6IGZ1bmN0aW9uIGlzU3RpY2t5SGVhZGVyKCkge1xuICAgICAgICAvLyBTbmlmZmVkIGJ5IDxiLXRkPiAvIDxiLXRoPlxuICAgICAgICAvLyBTdGlja3kgaGVhZGVycyBhcmUgb25seSBzdXBwb3J0ZWQgaW4gdGhlYWRcbiAgICAgICAgcmV0dXJuIHRoaXMuYnZUYWJsZVJvd0dyb3VwLmlzU3RpY2t5SGVhZGVyO1xuICAgICAgfSxcbiAgICAgIGhhc1N0aWNreUhlYWRlcjogZnVuY3Rpb24gaGFzU3RpY2t5SGVhZGVyKCkge1xuICAgICAgICAvLyBTbmlmZmVkIGJ5IDxiLXRyPiAvIDxiLXRkPiAvIDxiLXRoPlxuICAgICAgICAvLyBOZWVkZWQgdG8gaGFuZGxlIGhlYWRlciBiYWNrZ3JvdW5kIGNsYXNzZXMsIGR1ZSB0byBsYWNrIG9mXG4gICAgICAgIC8vIGJhY2tncm91bmQgY29sb3IgaW5oZXJpdGFuY2Ugd2l0aCBCb290c3RyYXAgdjQgdGFibGUgQ1NTXG4gICAgICAgIHJldHVybiAhdGhpcy5pc1N0YWNrZWQgJiYgdGhpcy5idlRhYmxlUm93R3JvdXAuaGFzU3RpY2t5SGVhZGVyO1xuICAgICAgfSxcbiAgICAgIHRhYmxlVmFyaWFudDogZnVuY3Rpb24gdGFibGVWYXJpYW50KCkge1xuICAgICAgICAvLyBTbmlmZmVkIGJ5IDxiLXRkPiAvIDxiLXRoPlxuICAgICAgICByZXR1cm4gdGhpcy5idlRhYmxlUm93R3JvdXAudGFibGVWYXJpYW50O1xuICAgICAgfSxcbiAgICAgIGhlYWRWYXJpYW50OiBmdW5jdGlvbiBoZWFkVmFyaWFudCgpIHtcbiAgICAgICAgLy8gU25pZmZlZCBieSA8Yi10ZD4gLyA8Yi10aD5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5UaGVhZCA/IHRoaXMuYnZUYWJsZVJvd0dyb3VwLmhlYWRWYXJpYW50IDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBmb290VmFyaWFudDogZnVuY3Rpb24gZm9vdFZhcmlhbnQoKSB7XG4gICAgICAgIC8vIFNuaWZmZWQgYnkgPGItdGQ+IC8gPGItdGg+XG4gICAgICAgIHJldHVybiB0aGlzLmluVGZvb3QgPyB0aGlzLmJ2VGFibGVSb3dHcm91cC5mb290VmFyaWFudCA6IG51bGw7XG4gICAgICB9LFxuICAgICAgaXNSb3dEYXJrOiBmdW5jdGlvbiBpc1Jvd0RhcmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRWYXJpYW50ID09PSBMSUdIVCB8fCB0aGlzLmZvb3RWYXJpYW50ID09PSBMSUdIVCA/IGZhbHNlIDogdGhpcy5oZWFkVmFyaWFudCA9PT0gREFSSyB8fCB0aGlzLmZvb3RWYXJpYW50ID09PSBEQVJLID8gdHJ1ZSA6IHRoaXMuaXNEYXJrO1xuICAgICAgfSxcbiAgICAgIHRyQ2xhc3NlczogZnVuY3Rpb24gdHJDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMudmFyaWFudCA/IFwiXCIuY29uY2F0KHRoaXMuaXNSb3dEYXJrID8gJ2JnJyA6ICd0YWJsZScsIFwiLVwiKS5jb25jYXQodGhpcy52YXJpYW50KSA6IG51bGxdO1xuICAgICAgfSxcbiAgICAgIHRyQXR0cnM6IGZ1bmN0aW9uIHRyQXR0cnMoKSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgcm9sZTogJ3JvdydcbiAgICAgICAgfSwgdGhpcy4kYXR0cnMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgcmV0dXJuIGgoJ3RyJywge1xuICAgICAgICBjbGFzczogdGhpcy50ckNsYXNzZXMsXG4gICAgICAgIGF0dHJzOiB0aGlzLnRyQXR0cnMsXG4gICAgICAgIC8vIFBhc3MgbmF0aXZlIGxpc3RlbmVycyB0byBjaGlsZFxuICAgICAgICBvbjogdGhpcy4kbGlzdGVuZXJzXG4gICAgICB9LCB0aGlzLm5vcm1hbGl6ZVNsb3QoJ2RlZmF1bHQnKSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZGlnaXRzUnggPSAvXlxcZCskLzsgLy8gUGFyc2UgYSByb3dzcGFuIG9yIGNvbHNwYW4gaW50byBhIGRpZ2l0IChvciBudWxsIGlmIDwgMSBvciBOYU4pXG5cbiAgdmFyIHBhcnNlU3BhbiA9IGZ1bmN0aW9uIHBhcnNlU3Bhbih2YWwpIHtcbiAgICB2YWwgPSBwYXJzZUludCh2YWwsIDEwKTtcbiAgICByZXR1cm4gZGlnaXRzUngudGVzdChTdHJpbmcodmFsKSkgJiYgdmFsID4gMCA/IHZhbCA6IG51bGw7XG4gIH07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICB2YXIgc3BhblZhbGlkYXRvciA9IGZ1bmN0aW9uIHNwYW5WYWxpZGF0b3IodmFsKSB7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkT3JOdWxsKHZhbCkgfHwgcGFyc2VTcGFuKHZhbCkgPiAwO1xuICB9O1xuXG4gIHZhciBwcm9wcyRXID0ge1xuICAgIHZhcmlhbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGNvbHNwYW46IHtcbiAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgdmFsaWRhdG9yOiBzcGFuVmFsaWRhdG9yXG4gICAgfSxcbiAgICByb3dzcGFuOiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIHZhbGlkYXRvcjogc3BhblZhbGlkYXRvclxuICAgIH0sXG4gICAgc3RhY2tlZEhlYWRpbmc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIHN0aWNreUNvbHVtbjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9OyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBCVGQgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCVGFibGVDZWxsJyxcbiAgICBtaXhpbnM6IFtub3JtYWxpemVTbG90TWl4aW5dLFxuICAgIGluaGVyaXRBdHRyczogZmFsc2UsXG4gICAgaW5qZWN0OiB7XG4gICAgICBidlRhYmxlVHI6IHtcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wczogcHJvcHMkVyxcbiAgICBjb21wdXRlZDoge1xuICAgICAgdGFnOiBmdW5jdGlvbiB0YWcoKSB7XG4gICAgICAgIC8vIE92ZXJyaWRkZW4gYnkgPGItdGg+XG4gICAgICAgIHJldHVybiAndGQnO1xuICAgICAgfSxcbiAgICAgIGluVGJvZHk6IGZ1bmN0aW9uIGluVGJvZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ2VGFibGVUci5pblRib2R5O1xuICAgICAgfSxcbiAgICAgIGluVGhlYWQ6IGZ1bmN0aW9uIGluVGhlYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ2VGFibGVUci5pblRoZWFkO1xuICAgICAgfSxcbiAgICAgIGluVGZvb3Q6IGZ1bmN0aW9uIGluVGZvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ2VGFibGVUci5pblRmb290O1xuICAgICAgfSxcbiAgICAgIGlzRGFyazogZnVuY3Rpb24gaXNEYXJrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idlRhYmxlVHIuaXNEYXJrO1xuICAgICAgfSxcbiAgICAgIGlzU3RhY2tlZDogZnVuY3Rpb24gaXNTdGFja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idlRhYmxlVHIuaXNTdGFja2VkO1xuICAgICAgfSxcbiAgICAgIGlzU3RhY2tlZENlbGw6IGZ1bmN0aW9uIGlzU3RhY2tlZENlbGwoKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCBzdGFja2VkLWhlYWRpbmcgaW4gdGJvZHkgaW4gc3RhY2tlZCBtb2RlXG4gICAgICAgIHJldHVybiB0aGlzLmluVGJvZHkgJiYgdGhpcy5pc1N0YWNrZWQ7XG4gICAgICB9LFxuICAgICAgaXNSZXNwb25zaXZlOiBmdW5jdGlvbiBpc1Jlc3BvbnNpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ2VGFibGVUci5pc1Jlc3BvbnNpdmU7XG4gICAgICB9LFxuICAgICAgaXNTdGlja3lIZWFkZXI6IGZ1bmN0aW9uIGlzU3RpY2t5SGVhZGVyKCkge1xuICAgICAgICAvLyBOZWVkZWQgdG8gaGFuZGxlIGhlYWRlciBiYWNrZ3JvdW5kIGNsYXNzZXMsIGR1ZSB0byBsYWNrIG9mXG4gICAgICAgIC8vIGJhY2tncm91bmQgY29sb3IgaW5oZXJpdGFuY2Ugd2l0aCBCb290c3RyYXAgdjQgdGFibGUgQ1NTXG4gICAgICAgIC8vIFN0aWNreSBoZWFkZXJzIG9ubHkgYXBwbHkgdG8gY2VsbHMgaW4gdGFibGUgYHRoZWFkYFxuICAgICAgICByZXR1cm4gdGhpcy5idlRhYmxlVHIuaXNTdGlja3lIZWFkZXI7XG4gICAgICB9LFxuICAgICAgaGFzU3RpY2t5SGVhZGVyOiBmdW5jdGlvbiBoYXNTdGlja3lIZWFkZXIoKSB7XG4gICAgICAgIC8vIE5lZWRlZCB0byBoYW5kbGUgaGVhZGVyIGJhY2tncm91bmQgY2xhc3NlcywgZHVlIHRvIGxhY2sgb2ZcbiAgICAgICAgLy8gYmFja2dyb3VuZCBjb2xvciBpbmhlcml0YW5jZSB3aXRoIEJvb3RzdHJhcCB2NCB0YWJsZSBDU1NcbiAgICAgICAgcmV0dXJuIHRoaXMuYnZUYWJsZVRyLmhhc1N0aWNreUhlYWRlcjtcbiAgICAgIH0sXG4gICAgICBpc1N0aWNreUNvbHVtbjogZnVuY3Rpb24gaXNTdGlja3lDb2x1bW4oKSB7XG4gICAgICAgIC8vIE5lZWRlZCB0byBoYW5kbGUgYmFja2dyb3VuZCBjbGFzc2VzLCBkdWUgdG8gbGFjayBvZlxuICAgICAgICAvLyBiYWNrZ3JvdW5kIGNvbG9yIGluaGVyaXRhbmNlIHdpdGggQm9vdHN0cmFwIHY0IHRhYmxlIENTU1xuICAgICAgICAvLyBTdGlja3kgY29sdW1uIGNlbGxzIGFyZSBvbmx5IGF2YWlsYWJsZSBpbiByZXNwb25zaXZlXG4gICAgICAgIC8vIG1vZGUgKGhvcml6b250YWwgc2Nyb2xsaW5nKSBvciB3aGVuIHN0aWNreSBoZWFkZXIgbW9kZVxuICAgICAgICAvLyBBcHBsaWVzIHRvIGNlbGxzIGluIGB0aGVhZGAsIGB0Ym9keWAgYW5kIGB0Zm9vdGBcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzU3RhY2tlZCAmJiAodGhpcy5pc1Jlc3BvbnNpdmUgfHwgdGhpcy5oYXNTdGlja3lIZWFkZXIpICYmIHRoaXMuc3RpY2t5Q29sdW1uO1xuICAgICAgfSxcbiAgICAgIHJvd1ZhcmlhbnQ6IGZ1bmN0aW9uIHJvd1ZhcmlhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ2VGFibGVUci52YXJpYW50O1xuICAgICAgfSxcbiAgICAgIGhlYWRWYXJpYW50OiBmdW5jdGlvbiBoZWFkVmFyaWFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnZUYWJsZVRyLmhlYWRWYXJpYW50O1xuICAgICAgfSxcbiAgICAgIGZvb3RWYXJpYW50OiBmdW5jdGlvbiBmb290VmFyaWFudCgpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbmVlZCB0byBhZGQgaW4gdGVzdHMgZm9yIGZvb3RlciB2YXJpYW50ICovXG4gICAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ2VGFibGVUci5mb290VmFyaWFudDtcbiAgICAgIH0sXG4gICAgICB0YWJsZVZhcmlhbnQ6IGZ1bmN0aW9uIHRhYmxlVmFyaWFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnZUYWJsZVRyLnRhYmxlVmFyaWFudDtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZENvbHNwYW46IGZ1bmN0aW9uIGNvbXB1dGVkQ29sc3BhbigpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlU3Bhbih0aGlzLmNvbHNwYW4pO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkUm93c3BhbjogZnVuY3Rpb24gY29tcHV0ZWRSb3dzcGFuKCkge1xuICAgICAgICByZXR1cm4gcGFyc2VTcGFuKHRoaXMucm93c3Bhbik7XG4gICAgICB9LFxuICAgICAgY2VsbENsYXNzZXM6IGZ1bmN0aW9uIGNlbGxDbGFzc2VzKCkge1xuICAgICAgICAvLyBXZSB1c2UgY29tcHV0ZWQgcHJvcHMgaGVyZSBmb3IgaW1wcm92ZWQgcGVyZm9ybWFuY2UgYnkgY2FjaGluZ1xuICAgICAgICAvLyB0aGUgcmVzdWx0cyBvZiB0aGUgc3RyaW5nIGludGVycG9sYXRpb25cbiAgICAgICAgLy8gVE9ETzogbmVlZCB0byBhZGQgaGFuZGxpbmcgZm9yIGZvb3RWYXJpYW50XG4gICAgICAgIHZhciB2YXJpYW50ID0gdGhpcy52YXJpYW50O1xuXG4gICAgICAgIGlmICghdmFyaWFudCAmJiB0aGlzLmlzU3RpY2t5SGVhZGVyICYmICF0aGlzLmhlYWRWYXJpYW50IHx8ICF2YXJpYW50ICYmIHRoaXMuaXNTdGlja3lDb2x1bW4pIHtcbiAgICAgICAgICAvLyBOZWVkZWQgZm9yIHN0aWNreS1oZWFkZXIgbW9kZSBhcyBCb290c3RyYXAgdjQgdGFibGUgY2VsbHMgZG9cbiAgICAgICAgICAvLyBub3QgaW5oZXJpdCBwYXJlbnQncyBiYWNrZ3JvdW5kLWNvbG9yLiBCb28hXG4gICAgICAgICAgdmFyaWFudCA9IHRoaXMucm93VmFyaWFudCB8fCB0aGlzLnRhYmxlVmFyaWFudCB8fCAnYi10YWJsZS1kZWZhdWx0JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbdmFyaWFudCA/IFwiXCIuY29uY2F0KHRoaXMuaXNEYXJrID8gJ2JnJyA6ICd0YWJsZScsIFwiLVwiKS5jb25jYXQodmFyaWFudCkgOiBudWxsLCB0aGlzLmlzU3RpY2t5Q29sdW1uID8gJ2ItdGFibGUtc3RpY2t5LWNvbHVtbicgOiBudWxsXTtcbiAgICAgIH0sXG4gICAgICBjZWxsQXR0cnM6IGZ1bmN0aW9uIGNlbGxBdHRycygpIHtcbiAgICAgICAgLy8gV2UgdXNlIGNvbXB1dGVkIHByb3BzIGhlcmUgZm9yIGltcHJvdmVkIHBlcmZvcm1hbmNlIGJ5IGNhY2hpbmdcbiAgICAgICAgLy8gdGhlIHJlc3VsdHMgb2YgdGhlIG9iamVjdCBzcHJlYWQgKE9iamVjdC5hc3NpZ24pXG4gICAgICAgIHZhciBoZWFkT3JGb290ID0gdGhpcy5pblRoZWFkIHx8IHRoaXMuaW5UZm9vdDsgLy8gTWFrZSBzdXJlIGNvbC9yb3dzcGFuJ3MgYXJlID4gMCBvciBudWxsXG5cbiAgICAgICAgdmFyIGNvbHNwYW4gPSB0aGlzLmNvbXB1dGVkQ29sc3BhbjtcbiAgICAgICAgdmFyIHJvd3NwYW4gPSB0aGlzLmNvbXB1dGVkUm93c3BhbjsgLy8gRGVmYXVsdCByb2xlIGFuZCBzY29wZVxuXG4gICAgICAgIHZhciByb2xlID0gJ2NlbGwnO1xuICAgICAgICB2YXIgc2NvcGUgPSBudWxsOyAvLyBDb21wdXRlIHJvbGUgYW5kIHNjb3BlXG4gICAgICAgIC8vIFdlIG9ubHkgYWRkIHNjb3BlcyB3aXRoIGFuIGV4cGxpY2l0IHNwYW4gb2YgMSBvciBncmVhdGVyXG5cbiAgICAgICAgaWYgKGhlYWRPckZvb3QpIHtcbiAgICAgICAgICAvLyBIZWFkZXIgb3IgZm9vdGVyIGNlbGxzXG4gICAgICAgICAgcm9sZSA9ICdjb2x1bW5oZWFkZXInO1xuICAgICAgICAgIHNjb3BlID0gY29sc3BhbiA+IDAgPyAnY29sc3BhbicgOiAnY29sJztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRhZyA9PT0gJ3RoJykge1xuICAgICAgICAgIC8vIHRoJ3MgaW4gdGJvZHlcbiAgICAgICAgICByb2xlID0gJ3Jvd2hlYWRlcic7XG4gICAgICAgICAgc2NvcGUgPSByb3dzcGFuID4gMCA/ICdyb3dncm91cCcgOiAncm93JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgY29sc3BhbjogY29sc3BhbixcbiAgICAgICAgICByb3dzcGFuOiByb3dzcGFuLFxuICAgICAgICAgIHJvbGU6IHJvbGUsXG4gICAgICAgICAgc2NvcGU6IHNjb3BlXG4gICAgICAgIH0sIHRoaXMuJGF0dHJzLCB7XG4gICAgICAgICAgLy8gQWRkIGluIHRoZSBzdGFja2VkIGNlbGwgbGFiZWwgZGF0YS1hdHRyaWJ1dGUgaWYgaW5cbiAgICAgICAgICAvLyBzdGFja2VkIG1vZGUgKGlmIGEgc3RhY2tlZCBoZWFkaW5nIGxhYmVsIGlzIHByb3ZpZGVkKVxuICAgICAgICAgICdkYXRhLWxhYmVsJzogdGhpcy5pc1N0YWNrZWRDZWxsICYmICFpc1VuZGVmaW5lZE9yTnVsbCh0aGlzLnN0YWNrZWRIZWFkaW5nKSA/IHRvU3RyaW5nJDEodGhpcy5zdGFja2VkSGVhZGluZykgOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBbdGhpcy5ub3JtYWxpemVTbG90KCdkZWZhdWx0JyldO1xuICAgICAgcmV0dXJuIGgodGhpcy50YWcsIHtcbiAgICAgICAgY2xhc3M6IHRoaXMuY2VsbENsYXNzZXMsXG4gICAgICAgIGF0dHJzOiB0aGlzLmNlbGxBdHRycyxcbiAgICAgICAgLy8gVHJhbnNmZXIgYW55IG5hdGl2ZSBsaXN0ZW5lcnNcbiAgICAgICAgb246IHRoaXMuJGxpc3RlbmVyc1xuICAgICAgfSwgW3RoaXMuaXNTdGFja2VkQ2VsbCA/IGgoJ2RpdicsIFtjb250ZW50XSkgOiBjb250ZW50XSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgQlRoID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQlRoJyxcbiAgICBleHRlbmRzOiBCVGQsXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIHRhZzogZnVuY3Rpb24gdGFnKCkge1xuICAgICAgICByZXR1cm4gJ3RoJztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciB0aGVhZE1peGluID0ge1xuICAgIHByb3BzOiB7XG4gICAgICBoZWFkVmFyaWFudDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIC8vICdsaWdodCcsICdkYXJrJyBvciBgbnVsbGAgKG9yIGN1c3RvbSlcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZygnQlRhYmxlJywgJ2hlYWRWYXJpYW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoZWFkUm93VmFyaWFudDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIC8vIEFueSBCb290c3RyYXAgdGhlbWUgdmFyaWFudCAob3IgY3VzdG9tKVxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgdGhlYWRDbGFzczoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSAvLyBkZWZhdWx0OiB1bmRlZmluZWRcblxuICAgICAgfSxcbiAgICAgIHRoZWFkVHJDbGFzczoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSAvLyBkZWZhdWx0OiB1bmRlZmluZWRcblxuICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgZmllbGRDbGFzc2VzOiBmdW5jdGlvbiBmaWVsZENsYXNzZXMoZmllbGQpIHtcbiAgICAgICAgLy8gSGVhZGVyIGZpZWxkICg8dGg+KSBjbGFzc2VzXG4gICAgICAgIHJldHVybiBbZmllbGQuY2xhc3MgPyBmaWVsZC5jbGFzcyA6ICcnLCBmaWVsZC50aENsYXNzID8gZmllbGQudGhDbGFzcyA6ICcnXTtcbiAgICAgIH0sXG4gICAgICBoZWFkQ2xpY2tlZDogZnVuY3Rpb24gaGVhZENsaWNrZWQoZXZ0LCBmaWVsZCwgaXNGb290KSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3BJZkJ1c3kgJiYgdGhpcy5zdG9wSWZCdXN5KGV2dCkpIHtcbiAgICAgICAgICAvLyBJZiB0YWJsZSBpcyBidXN5ICh2aWEgcHJvdmlkZXIpIHRoZW4gZG9uJ3QgcHJvcGFnYXRlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbHRlckV2ZW50KGV2dCkpIHtcbiAgICAgICAgICAvLyBDbGlja2VkIG9uIGEgbm9uLWRpc2FibGVkIGNvbnRyb2wgc28gaWdub3JlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHRTZWxlY3Rpb25BY3RpdmUodGhpcy4kZWwpKSB7XG4gICAgICAgICAgLy8gVXNlciBpcyBzZWxlY3RpbmcgdGV4dCwgc28gaWdub3JlXG5cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogSlNET00gZG9lc24ndCBzdXBwb3J0IGdldFNlbGVjdGlvbigpICovXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy4kZW1pdCgnaGVhZC1jbGlja2VkJywgZmllbGQua2V5LCBmaWVsZCwgZXZ0LCBpc0Zvb3QpO1xuICAgICAgfSxcbiAgICAgIHJlbmRlclRoZWFkOiBmdW5jdGlvbiByZW5kZXJUaGVhZCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgaXNGb290ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgICAgdmFyIGggPSB0aGlzLiRjcmVhdGVFbGVtZW50O1xuICAgICAgICB2YXIgZmllbGRzID0gdGhpcy5jb21wdXRlZEZpZWxkcyB8fCBbXTtcblxuICAgICAgICBpZiAodGhpcy5pc1N0YWNrZWRBbHdheXMgfHwgZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vIEluIGFsd2F5cyBzdGFja2VkIG1vZGUsIHdlIGRvbid0IGJvdGhlciByZW5kZXJpbmcgdGhlIGhlYWQvZm9vdFxuICAgICAgICAgIC8vIE9yIGlmIG5vIGZpZWxkIGhlYWRpbmdzIChlbXB0eSB0YWJsZSlcbiAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9IC8vIFJlZmVyZW5jZSB0byBgc2VsZWN0QWxsUm93c2AgYW5kIGBjbGVhclNlbGVjdGVkKClgLCBpZiB0YWJsZSBpcyBzZWxlY3RhYmxlXG5cblxuICAgICAgICB2YXIgc2VsZWN0QWxsUm93cyA9IHRoaXMuaXNTZWxlY3RhYmxlID8gdGhpcy5zZWxlY3RBbGxSb3dzIDogZnVuY3Rpb24gKCkge307XG4gICAgICAgIHZhciBjbGVhclNlbGVjdGVkID0gdGhpcy5pc1NlbGVjdGFibGUgPyB0aGlzLmNsZWFyU2VsZWN0ZWQgOiBmdW5jdGlvbiAoKSB7fTsgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgZmllbGQgPHRoPiBjZWxsXG5cbiAgICAgICAgdmFyIG1ha2VDZWxsID0gZnVuY3Rpb24gbWFrZUNlbGwoZmllbGQsIGNvbEluZGV4KSB7XG4gICAgICAgICAgdmFyIGFyaWFMYWJlbCA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoIWZpZWxkLmxhYmVsLnRyaW0oKSAmJiAhZmllbGQuaGVhZGVyVGl0bGUpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgZmllbGQncyBsYWJlbCBhbmQgdGl0bGUgYXJlIGVtcHR5L2JsYW5rXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGFkZCBhIGhpbnQgYWJvdXQgd2hhdCB0aGUgY29sdW1uIGlzIGFib3V0IGZvciBub24tc2lnaHRlZCB1c2Vyc1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgYXJpYUxhYmVsID0gc3RhcnRDYXNlKGZpZWxkLmtleSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGhhc0hlYWRDbGlja0xpc3RlbmVyID0gX3RoaXMuaGFzTGlzdGVuZXIoJ2hlYWQtY2xpY2tlZCcpIHx8IF90aGlzLmlzU29ydGFibGU7XG5cbiAgICAgICAgICB2YXIgaGFuZGxlcnMgPSB7fTtcblxuICAgICAgICAgIGlmIChoYXNIZWFkQ2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgaGFuZGxlcnMuY2xpY2sgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgIF90aGlzLmhlYWRDbGlja2VkKGV2dCwgZmllbGQsIGlzRm9vdCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBoYW5kbGVycy5rZXlkb3duID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICB2YXIga2V5Q29kZSA9IGV2dC5rZXlDb2RlO1xuXG4gICAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBLRVlfQ09ERVMuRU5URVIgfHwga2V5Q29kZSA9PT0gS0VZX0NPREVTLlNQQUNFKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGVhZENsaWNrZWQoZXZ0LCBmaWVsZCwgaXNGb290KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc29ydEF0dHJzID0gX3RoaXMuaXNTb3J0YWJsZSA/IF90aGlzLnNvcnRUaGVhZFRoQXR0cnMoZmllbGQua2V5LCBmaWVsZCwgaXNGb290KSA6IHt9O1xuICAgICAgICAgIHZhciBzb3J0Q2xhc3MgPSBfdGhpcy5pc1NvcnRhYmxlID8gX3RoaXMuc29ydFRoZWFkVGhDbGFzc2VzKGZpZWxkLmtleSwgZmllbGQsIGlzRm9vdCkgOiBudWxsO1xuICAgICAgICAgIHZhciBzb3J0TGFiZWwgPSBfdGhpcy5pc1NvcnRhYmxlID8gX3RoaXMuc29ydFRoZWFkVGhMYWJlbChmaWVsZC5rZXksIGZpZWxkLCBpc0Zvb3QpIDogbnVsbDtcbiAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGtleTogZmllbGQua2V5LFxuICAgICAgICAgICAgY2xhc3M6IFtfdGhpcy5maWVsZENsYXNzZXMoZmllbGQpLCBzb3J0Q2xhc3NdLFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgdmFyaWFudDogZmllbGQudmFyaWFudCxcbiAgICAgICAgICAgICAgc3RpY2t5Q29sdW1uOiBmaWVsZC5zdGlja3lDb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZTogZmllbGQudGhTdHlsZSB8fCB7fSxcbiAgICAgICAgICAgIGF0dHJzOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgIC8vIFdlIG9ubHkgYWRkIGEgdGFiaW5kZXggb2YgMCBpZiB0aGVyZSBpcyBhIGhlYWQtY2xpY2tlZCBsaXN0ZW5lclxuICAgICAgICAgICAgICB0YWJpbmRleDogaGFzSGVhZENsaWNrTGlzdGVuZXIgPyAnMCcgOiBudWxsLFxuICAgICAgICAgICAgICBhYmJyOiBmaWVsZC5oZWFkZXJBYmJyIHx8IG51bGwsXG4gICAgICAgICAgICAgIHRpdGxlOiBmaWVsZC5oZWFkZXJUaXRsZSB8fCBudWxsLFxuICAgICAgICAgICAgICAnYXJpYS1jb2xpbmRleCc6IGNvbEluZGV4ICsgMSxcbiAgICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiBhcmlhTGFiZWxcbiAgICAgICAgICAgIH0sIF90aGlzLmdldFRoVmFsdWVzKG51bGwsIGZpZWxkLmtleSwgZmllbGQudGhBdHRyLCBpc0Zvb3QgPyAnZm9vdCcgOiAnaGVhZCcsIHt9KSwge30sIHNvcnRBdHRycyksXG4gICAgICAgICAgICBvbjogaGFuZGxlcnNcbiAgICAgICAgICB9OyAvLyBIYW5kbGUgZWRnZSBjYXNlIHdoZXJlIGluLWRvY3VtZW50IHRlbXBsYXRlcyBhcmUgdXNlZCB3aXRoIG5ld1xuICAgICAgICAgIC8vIGB2LXNsb3Q6bmFtZWAgc3ludGF4IHdoZXJlIHRoZSBicm93c2VyIGxvd2VyLWNhc2VzIHRoZSB2LXNsb3Qnc1xuICAgICAgICAgIC8vIG5hbWUgKGF0dHJpYnV0ZXMgYmVjb21lIGxvd2VyIGNhc2VkIHdoZW4gcGFyc2VkIGJ5IHRoZSBicm93c2VyKVxuICAgICAgICAgIC8vIFdlIGhhdmUgcmVwbGFjZWQgdGhlIHNxdWFyZSBicmFja2V0IHN5bnRheCB3aXRoIHJvdW5kIGJyYWNrZXRzXG4gICAgICAgICAgLy8gdG8gcHJldmVudCBjb25mdXNpb24gd2l0aCBkeW5hbWljIHNsb3QgbmFtZXNcblxuICAgICAgICAgIHZhciBzbG90TmFtZXMgPSBbXCJoZWFkKFwiLmNvbmNhdChmaWVsZC5rZXksIFwiKVwiKSwgXCJoZWFkKFwiLmNvbmNhdChmaWVsZC5rZXkudG9Mb3dlckNhc2UoKSwgXCIpXCIpLCAnaGVhZCgpJ107XG5cbiAgICAgICAgICBpZiAoaXNGb290KSB7XG4gICAgICAgICAgICAvLyBGb290ZXIgd2lsbCBmYWxsYmFjayB0byBoZWFkZXIgc2xvdCBuYW1lc1xuICAgICAgICAgICAgc2xvdE5hbWVzID0gW1wiZm9vdChcIi5jb25jYXQoZmllbGQua2V5LCBcIilcIiksIFwiZm9vdChcIi5jb25jYXQoZmllbGQua2V5LnRvTG93ZXJDYXNlKCksIFwiKVwiKSwgJ2Zvb3QoKSddLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoc2xvdE5hbWVzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNjb3BlID0ge1xuICAgICAgICAgICAgbGFiZWw6IGZpZWxkLmxhYmVsLFxuICAgICAgICAgICAgY29sdW1uOiBmaWVsZC5rZXksXG4gICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICBpc0Zvb3Q6IGlzRm9vdCxcbiAgICAgICAgICAgIC8vIEFkZCBpbiByb3cgc2VsZWN0IG1ldGhvZHNcbiAgICAgICAgICAgIHNlbGVjdEFsbFJvd3M6IHNlbGVjdEFsbFJvd3MsXG4gICAgICAgICAgICBjbGVhclNlbGVjdGVkOiBjbGVhclNlbGVjdGVkXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgY29udGVudCA9IF90aGlzLm5vcm1hbGl6ZVNsb3Qoc2xvdE5hbWVzLCBzY29wZSkgfHwgKGZpZWxkLmxhYmVsSHRtbCA/IGgoJ2RpdicsIHtcbiAgICAgICAgICAgIGRvbVByb3BzOiBodG1sT3JUZXh0KGZpZWxkLmxhYmVsSHRtbClcbiAgICAgICAgICB9KSA6IGZpZWxkLmxhYmVsKTtcbiAgICAgICAgICB2YXIgc3JMYWJlbCA9IHNvcnRMYWJlbCA/IGgoJ3NwYW4nLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3NyLW9ubHknXG4gICAgICAgICAgfSwgXCIgKFwiLmNvbmNhdChzb3J0TGFiZWwsIFwiKVwiKSkgOiBudWxsOyAvLyBSZXR1cm4gdGhlIGhlYWRlciBjZWxsXG5cbiAgICAgICAgICByZXR1cm4gaChCVGgsIGRhdGEsIFtjb250ZW50LCBzckxhYmVsXS5maWx0ZXIoaWRlbnRpdHkpKTtcbiAgICAgICAgfTsgLy8gR2VuZXJhdGUgdGhlIGFycmF5IG9mIDx0aD4gY2VsbHNcblxuXG4gICAgICAgIHZhciAkY2VsbHMgPSBmaWVsZHMubWFwKG1ha2VDZWxsKS5maWx0ZXIoaWRlbnRpdHkpOyAvLyBHZW5yYXRlIHRoZSByb3cocylcblxuICAgICAgICB2YXIgJHRycyA9IFtdO1xuXG4gICAgICAgIGlmIChpc0Zvb3QpIHtcbiAgICAgICAgICB2YXIgdHJQcm9wcyA9IHtcbiAgICAgICAgICAgIHZhcmlhbnQ6IGlzVW5kZWZpbmVkT3JOdWxsKHRoaXMuZm9vdFJvd1ZhcmlhbnQpID8gdGhpcy5oZWFkUm93VmFyaWFudCA6IHRoaXMuZm9vdFJvd1ZhcmlhbnRcbiAgICAgICAgICB9O1xuICAgICAgICAgICR0cnMucHVzaChoKEJUciwge1xuICAgICAgICAgICAgY2xhc3M6IHRoaXMudGZvb3RUckNsYXNzLFxuICAgICAgICAgICAgcHJvcHM6IHRyUHJvcHNcbiAgICAgICAgICB9LCAkY2VsbHMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2NvcGUgPSB7XG4gICAgICAgICAgICBjb2x1bW5zOiBmaWVsZHMubGVuZ3RoLFxuICAgICAgICAgICAgZmllbGRzOiBmaWVsZHMsXG4gICAgICAgICAgICAvLyBBZGQgaW4gcm93IHNlbGVjdCBtZXRob2RzXG4gICAgICAgICAgICBzZWxlY3RBbGxSb3dzOiBzZWxlY3RBbGxSb3dzLFxuICAgICAgICAgICAgY2xlYXJTZWxlY3RlZDogY2xlYXJTZWxlY3RlZFxuICAgICAgICAgIH07XG4gICAgICAgICAgJHRycy5wdXNoKHRoaXMubm9ybWFsaXplU2xvdCgndGhlYWQtdG9wJywgc2NvcGUpIHx8IGgoKSk7XG4gICAgICAgICAgJHRycy5wdXNoKGgoQlRyLCB7XG4gICAgICAgICAgICBjbGFzczogdGhpcy50aGVhZFRyQ2xhc3MsXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICB2YXJpYW50OiB0aGlzLmhlYWRSb3dWYXJpYW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgJGNlbGxzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaChpc0Zvb3QgPyBCVGZvb3QgOiBCVGhlYWQsIHtcbiAgICAgICAgICBrZXk6IGlzRm9vdCA/ICdidi10Zm9vdCcgOiAnYnYtdGhlYWQnLFxuICAgICAgICAgIGNsYXNzOiAoaXNGb290ID8gdGhpcy50Zm9vdENsYXNzIDogdGhpcy50aGVhZENsYXNzKSB8fCBudWxsLFxuICAgICAgICAgIHByb3BzOiBpc0Zvb3QgPyB7XG4gICAgICAgICAgICBmb290VmFyaWFudDogdGhpcy5mb290VmFyaWFudCB8fCB0aGlzLmhlYWRWYXJpYW50IHx8IG51bGxcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgaGVhZFZhcmlhbnQ6IHRoaXMuaGVhZFZhcmlhbnQgfHwgbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfSwgJHRycyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciB0Zm9vdE1peGluID0ge1xuICAgIHByb3BzOiB7XG4gICAgICBmb290Q2xvbmU6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBmb290VmFyaWFudDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIC8vICdkYXJrJywgJ2xpZ2h0Jywgb3IgYG51bGxgIChvciBjdXN0b20pXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoJ0JUYWJsZScsICdmb290VmFyaWFudCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZm9vdFJvd1ZhcmlhbnQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAvLyBBbnkgQm9vdHN0cmFwIHRoZW1lIHZhcmlhbnQgKG9yIGN1c3RvbSkuIEZhbGxzIGJhY2sgdG8gYGhlYWRSb3dWYXJpYW50YFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgdGZvb3RDbGFzczoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHRmb290VHJDbGFzczoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgcmVuZGVyVEZvb3RDdXN0b206IGZ1bmN0aW9uIHJlbmRlclRGb290Q3VzdG9tKCkge1xuICAgICAgICB2YXIgaCA9IHRoaXMuJGNyZWF0ZUVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzTm9ybWFsaXplZFNsb3QoJ2N1c3RvbS1mb290JykpIHtcbiAgICAgICAgICByZXR1cm4gaChCVGZvb3QsIHtcbiAgICAgICAgICAgIGtleTogJ2J2LXRmb290LWN1c3RvbScsXG4gICAgICAgICAgICBjbGFzczogdGhpcy50Zm9vdENsYXNzIHx8IG51bGwsXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICBmb290VmFyaWFudDogdGhpcy5mb290VmFyaWFudCB8fCB0aGlzLmhlYWRWYXJpYW50IHx8IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzLm5vcm1hbGl6ZVNsb3QoJ2N1c3RvbS1mb290Jywge1xuICAgICAgICAgICAgaXRlbXM6IHRoaXMuY29tcHV0ZWRJdGVtcy5zbGljZSgpLFxuICAgICAgICAgICAgZmllbGRzOiB0aGlzLmNvbXB1dGVkRmllbGRzLnNsaWNlKCksXG4gICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmNvbXB1dGVkRmllbGRzLmxlbmd0aFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVuZGVyVGZvb3Q6IGZ1bmN0aW9uIHJlbmRlclRmb290KCkge1xuICAgICAgICAvLyBQYXNzaW5nIHRydWUgdG8gcmVuZGVyVGhlYWQgd2lsbCBtYWtlIGl0IHJlbmRlciBhIHRmb290XG4gICAgICAgIHJldHVybiB0aGlzLmZvb3RDbG9uZSA/IHRoaXMucmVuZGVyVGhlYWQodHJ1ZSkgOiB0aGlzLnJlbmRlclRGb290Q3VzdG9tKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBwcm9wcyRYID0ge1xuICAgIHRib2R5VHJhbnNpdGlvblByb3BzOiB7XG4gICAgICB0eXBlOiBPYmplY3QgLy8gZGVmYXVsdDogdW5kZWZpbmVkXG5cbiAgICB9LFxuICAgIHRib2R5VHJhbnNpdGlvbkhhbmRsZXJzOiB7XG4gICAgICB0eXBlOiBPYmplY3QgLy8gZGVmYXVsdDogdW5kZWZpbmVkXG5cbiAgICB9XG4gIH07IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJUYm9keSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JUYm9keScsXG4gICAgbWl4aW5zOiBbbm9ybWFsaXplU2xvdE1peGluXSxcbiAgICBpbmhlcml0QXR0cnM6IGZhbHNlLFxuICAgIHByb3ZpZGU6IGZ1bmN0aW9uIHByb3ZpZGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBidlRhYmxlUm93R3JvdXA6IHRoaXNcbiAgICAgIH07XG4gICAgfSxcbiAgICBpbmplY3Q6IHtcbiAgICAgIGJ2VGFibGU6IHtcbiAgICAgICAgLy8gU25pZmZlZCBieSA8Yi10cj4gLyA8Yi10ZD4gLyA8Yi10aD5cbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wczogcHJvcHMkWCxcbiAgICBjb21wdXRlZDoge1xuICAgICAgaXNUYm9keTogZnVuY3Rpb24gaXNUYm9keSgpIHtcbiAgICAgICAgLy8gU25pZmZlZCBieSA8Yi10cj4gLyA8Yi10ZD4gLyA8Yi10aD5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgaXNEYXJrOiBmdW5jdGlvbiBpc0RhcmsoKSB7XG4gICAgICAgIC8vIFNuaWZmZWQgYnkgPGItdHI+IC8gPGItdGQ+IC8gPGItdGg+XG4gICAgICAgIHJldHVybiB0aGlzLmJ2VGFibGUuZGFyaztcbiAgICAgIH0sXG4gICAgICBpc1N0YWNrZWQ6IGZ1bmN0aW9uIGlzU3RhY2tlZCgpIHtcbiAgICAgICAgLy8gU25pZmZlZCBieSA8Yi10cj4gLyA8Yi10ZD4gLyA8Yi10aD5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnZUYWJsZS5pc1N0YWNrZWQ7XG4gICAgICB9LFxuICAgICAgaXNSZXNwb25zaXZlOiBmdW5jdGlvbiBpc1Jlc3BvbnNpdmUoKSB7XG4gICAgICAgIC8vIFNuaWZmZWQgYnkgPGItdHI+IC8gPGItdGQ+IC8gPGItdGg+XG4gICAgICAgIHJldHVybiB0aGlzLmJ2VGFibGUuaXNSZXNwb25zaXZlO1xuICAgICAgfSxcbiAgICAgIGlzU3RpY2t5SGVhZGVyOiBmdW5jdGlvbiBpc1N0aWNreUhlYWRlcigpIHtcbiAgICAgICAgLy8gU25pZmZlZCBieSA8Yi10cj4gLyA8Yi10ZD4gLyA8Yi10aD5cbiAgICAgICAgLy8gU3RpY2t5IGhlYWRlcnMgYXJlIG9ubHkgc3VwcG9ydGVkIGluIHRoZWFkXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBoYXNTdGlja3lIZWFkZXI6IGZ1bmN0aW9uIGhhc1N0aWNreUhlYWRlcigpIHtcbiAgICAgICAgLy8gU25pZmZlZCBieSA8Yi10cj4gLyA8Yi10ZD4gLyA8Yi10aD5cbiAgICAgICAgLy8gTmVlZGVkIHRvIGhhbmRsZSBoZWFkZXIgYmFja2dyb3VuZCBjbGFzc2VzLCBkdWUgdG8gbGFjayBvZlxuICAgICAgICAvLyBiYWNrZ3JvdW5kIGNvbG9yIGluaGVyaXRhbmNlIHdpdGggQm9vdHN0cmFwIHY0IHRhYmxlIENTU1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNTdGFja2VkICYmIHRoaXMuYnZUYWJsZS5zdGlja3lIZWFkZXI7XG4gICAgICB9LFxuICAgICAgdGFibGVWYXJpYW50OiBmdW5jdGlvbiB0YWJsZVZhcmlhbnQoKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IE5vdCBjdXJyZW50bHkgc25pZmZlZCBpbiB0ZXN0cyAqL1xuICAgICAge1xuICAgICAgICAvLyBTbmlmZmVkIGJ5IDxiLXRyPiAvIDxiLXRkPiAvIDxiLXRoPlxuICAgICAgICByZXR1cm4gdGhpcy5idlRhYmxlLnRhYmxlVmFyaWFudDtcbiAgICAgIH0sXG4gICAgICBpc1RyYW5zaXRpb25Hcm91cDogZnVuY3Rpb24gaXNUcmFuc2l0aW9uR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRib2R5VHJhbnNpdGlvblByb3BzIHx8IHRoaXMudGJvZHlUcmFuc2l0aW9uSGFuZGxlcnM7XG4gICAgICB9LFxuICAgICAgdGJvZHlBdHRyczogZnVuY3Rpb24gdGJvZHlBdHRycygpIHtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICByb2xlOiAncm93Z3JvdXAnXG4gICAgICAgIH0sIHRoaXMuJGF0dHJzKTtcbiAgICAgIH0sXG4gICAgICB0Ym9keVByb3BzOiBmdW5jdGlvbiB0Ym9keVByb3BzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50Ym9keVRyYW5zaXRpb25Qcm9wcyA/IF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLnRib2R5VHJhbnNpdGlvblByb3BzLCB7XG4gICAgICAgICAgdGFnOiAndGJvZHknXG4gICAgICAgIH0pIDoge307XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgcHJvcHM6IHRoaXMudGJvZHlQcm9wcyxcbiAgICAgICAgYXR0cnM6IHRoaXMudGJvZHlBdHRyc1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuaXNUcmFuc2l0aW9uR3JvdXApIHtcbiAgICAgICAgLy8gV2UgdXNlIG5hdGl2ZSBsaXN0ZW5lcnMgaWYgYSB0cmFuc2l0aW9uIGdyb3VwXG4gICAgICAgIC8vIGZvciBhbnkgZGVsZWdhdGVkIGV2ZW50c1xuICAgICAgICBkYXRhLm9uID0gdGhpcy50Ym9keVRyYW5zaXRpb25IYW5kbGVycyB8fCB7fTtcbiAgICAgICAgZGF0YS5uYXRpdmVPbiA9IHRoaXMuJGxpc3RlbmVycyB8fCB7fTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSB3ZSBwbGFjZSBhbnkgbGlzdGVuZXJzIG9uIHRoZSB0Ym9keSBlbGVtZW50XG4gICAgICAgIGRhdGEub24gPSB0aGlzLiRsaXN0ZW5lcnMgfHwge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoKHRoaXMuaXNUcmFuc2l0aW9uR3JvdXAgPyAndHJhbnNpdGlvbi1ncm91cCcgOiAndGJvZHknLCBkYXRhLCB0aGlzLm5vcm1hbGl6ZVNsb3QoJ2RlZmF1bHQnKSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZGV0YWlsc1Nsb3ROYW1lID0gJ3Jvdy1kZXRhaWxzJztcbiAgdmFyIHRib2R5Um93TWl4aW4gPSB7XG4gICAgcHJvcHM6IHtcbiAgICAgIHRib2R5VHJDbGFzczoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0LCBGdW5jdGlvbl0sXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICB0Ym9keVRyQXR0cjoge1xuICAgICAgICB0eXBlOiBbT2JqZWN0LCBGdW5jdGlvbl0sXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBkZXRhaWxzVGRDbGFzczoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgLy8gTWV0aG9kcyBmb3IgY29tcHV0aW5nIGNsYXNzZXMsIGF0dHJpYnV0ZXMgYW5kIHN0eWxlcyBmb3IgdGFibGUgY2VsbHNcbiAgICAgIGdldFRkVmFsdWVzOiBmdW5jdGlvbiBnZXRUZFZhbHVlcyhpdGVtLCBrZXksIHRkVmFsdWUsIGRlZlZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLiRwYXJlbnQ7XG5cbiAgICAgICAgaWYgKHRkVmFsdWUpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBnZXQoaXRlbSwga2V5LCAnJyk7XG5cbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0ZFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRkVmFsdWUodmFsdWUsIGtleSwgaXRlbSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyh0ZFZhbHVlKSAmJiBpc0Z1bmN0aW9uKHBhcmVudFt0ZFZhbHVlXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRbdGRWYWx1ZV0odmFsdWUsIGtleSwgaXRlbSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRkVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmVmFsdWU7XG4gICAgICB9LFxuICAgICAgZ2V0VGhWYWx1ZXM6IGZ1bmN0aW9uIGdldFRoVmFsdWVzKGl0ZW0sIGtleSwgdGhWYWx1ZSwgdHlwZSwgZGVmVmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudDtcblxuICAgICAgICBpZiAodGhWYWx1ZSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGdldChpdGVtLCBrZXksICcnKTtcblxuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhWYWx1ZSh2YWx1ZSwga2V5LCBpdGVtLCB0eXBlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHRoVmFsdWUpICYmIGlzRnVuY3Rpb24ocGFyZW50W3RoVmFsdWVdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFt0aFZhbHVlXSh2YWx1ZSwga2V5LCBpdGVtLCB0eXBlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZWYWx1ZTtcbiAgICAgIH0sXG4gICAgICAvLyBNZXRob2QgdG8gZ2V0IHRoZSB2YWx1ZSBmb3IgYSBmaWVsZFxuICAgICAgZ2V0Rm9ybWF0dGVkVmFsdWU6IGZ1bmN0aW9uIGdldEZvcm1hdHRlZFZhbHVlKGl0ZW0sIGZpZWxkKSB7XG4gICAgICAgIHZhciBrZXkgPSBmaWVsZC5rZXk7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSB0aGlzLmdldEZpZWxkRm9ybWF0dGVyKGtleSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGdldChpdGVtLCBrZXksIG51bGwpO1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGZvcm1hdHRlcikpIHtcbiAgICAgICAgICB2YWx1ZSA9IGZvcm1hdHRlcih2YWx1ZSwga2V5LCBpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkgPyAnJyA6IHZhbHVlO1xuICAgICAgfSxcbiAgICAgIC8vIEZhY3RvcnkgZnVuY3Rpb24gbWV0aG9kc1xuICAgICAgdG9nZ2xlRGV0YWlsc0ZhY3Rvcnk6IGZ1bmN0aW9uIHRvZ2dsZURldGFpbHNGYWN0b3J5KGhhc0RldGFpbHNTbG90LCBpdGVtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHRvZ2dsZSBhIHJvdydzIGRldGFpbHMgc2xvdFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChoYXNEZXRhaWxzU2xvdCkge1xuICAgICAgICAgICAgX3RoaXMuJHNldChpdGVtLCAnX3Nob3dEZXRhaWxzJywgIWl0ZW0uX3Nob3dEZXRhaWxzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgLy8gUm93IGV2ZW50IGhhbmRsZXJzXG4gICAgICByb3dIb3ZlcmVkOiBmdW5jdGlvbiByb3dIb3ZlcmVkKGV2dCkge1xuICAgICAgICAvLyBgbW91c2VlbnRlcmAgaGFuZGxlciAobm9uLWJ1YmJsaW5nKVxuICAgICAgICAvLyBgdGhpcy50Ym9keVJvd0V2dFN0b3BwZWRgIGZyb20gdGJvZHkgbWl4aW5cbiAgICAgICAgaWYgKCF0aGlzLnRib2R5Um93RXZ0U3RvcHBlZChldnQpKSB7XG4gICAgICAgICAgLy8gYHRoaXMuZW1pdFRib2R5Um93RXZlbnRgIGZyb20gdGJvZHkgbWl4aW5cbiAgICAgICAgICB0aGlzLmVtaXRUYm9keVJvd0V2ZW50KCdyb3ctaG92ZXJlZCcsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByb3dVbmhvdmVyZWQ6IGZ1bmN0aW9uIHJvd1VuaG92ZXJlZChldnQpIHtcbiAgICAgICAgLy8gYG1vdXNlbGVhdmVgIGhhbmRsZXIgKG5vbi1idWJibGluZylcbiAgICAgICAgLy8gYHRoaXMudGJvZHlSb3dFdnRTdG9wcGVkYCBmcm9tIHRib2R5IG1peGluXG4gICAgICAgIGlmICghdGhpcy50Ym9keVJvd0V2dFN0b3BwZWQoZXZ0KSkge1xuICAgICAgICAgIC8vIGB0aGlzLmVtaXRUYm9keVJvd0V2ZW50YCBmcm9tIHRib2R5IG1peGluXG4gICAgICAgICAgdGhpcy5lbWl0VGJvZHlSb3dFdmVudCgncm93LXVuaG92ZXJlZCcsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBSZW5kZXIgaGVscGVyc1xuICAgICAgcmVuZGVyVGJvZHlSb3dDZWxsOiBmdW5jdGlvbiByZW5kZXJUYm9keVJvd0NlbGwoZmllbGQsIGNvbEluZGV4LCBpdGVtLCByb3dJbmRleCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAvLyBSZW5kZXJzIGEgVEQgb3IgVEggZm9yIGEgcm93J3MgZmllbGRcbiAgICAgICAgdmFyIGggPSB0aGlzLiRjcmVhdGVFbGVtZW50O1xuICAgICAgICB2YXIgaGFzRGV0YWlsc1Nsb3QgPSB0aGlzLmhhc05vcm1hbGl6ZWRTbG90KGRldGFpbHNTbG90TmFtZSk7XG4gICAgICAgIHZhciBmb3JtYXR0ZWQgPSB0aGlzLmdldEZvcm1hdHRlZFZhbHVlKGl0ZW0sIGZpZWxkKTtcbiAgICAgICAgdmFyIGtleSA9IGZpZWxkLmtleTtcbiAgICAgICAgdmFyIHN0aWNreUNvbHVtbiA9ICF0aGlzLmlzU3RhY2tlZCAmJiAodGhpcy5pc1Jlc3BvbnNpdmUgfHwgdGhpcy5zdGlja3lIZWFkZXIpICYmIGZpZWxkLnN0aWNreUNvbHVtbjsgLy8gV2Ugb25seSB1c2VzIHRoZSBoZWxwZXIgY29tcG9uZW50cyBmb3Igc3RpY2t5IGNvbHVtbnMgdG9cbiAgICAgICAgLy8gaW1wcm92ZSBwZXJmb3JtYW5jZSBvZiBCVGFibGUvQlRhYmxlTGl0ZSBieSByZWR1Y2luZyB0aGVcbiAgICAgICAgLy8gdG90YWwgbnVtYmVyIG9mIHZ1ZSBpbnN0YW5jZXMgY3JlYXRlZCBkdXJpbmcgcmVuZGVyXG5cbiAgICAgICAgdmFyIGNlbGxUYWcgPSBzdGlja3lDb2x1bW4gPyBmaWVsZC5pc1Jvd0hlYWRlciA/IEJUaCA6IEJUZCA6IGZpZWxkLmlzUm93SGVhZGVyID8gJ3RoJyA6ICd0ZCc7XG4gICAgICAgIHZhciBjZWxsVmFyaWFudCA9IGl0ZW0uX2NlbGxWYXJpYW50cyAmJiBpdGVtLl9jZWxsVmFyaWFudHNba2V5XSA/IGl0ZW0uX2NlbGxWYXJpYW50c1trZXldIDogZmllbGQudmFyaWFudCB8fCBudWxsO1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAvLyBGb3IgdGhlIFZ1ZSBrZXksIHdlIGNvbmNhdGVuYXRlIHRoZSBjb2x1bW4gaW5kZXggYW5kXG4gICAgICAgICAgLy8gZmllbGQga2V5IChhcyBmaWVsZCBrZXlzIGNvdWxkIGJlIGR1cGxpY2F0ZWQpXG4gICAgICAgICAgLy8gVE9ETzogQWx0aG91Z2ggd2UgZG8gcHJldmVudCBkdXBsaWNhdGUgZmllbGQga2V5cy4uLlxuICAgICAgICAgIC8vICAgU28gd2UgY291bGQgY2hhbmdlIHRoaXMgdG86IGByb3ctJHtyb3dJbmRleH0tY2VsbC0ke2tleX1gXG4gICAgICAgICAga2V5OiBcInJvdy1cIi5jb25jYXQocm93SW5kZXgsIFwiLWNlbGwtXCIpLmNvbmNhdChjb2xJbmRleCwgXCItXCIpLmNvbmNhdChrZXkpLFxuICAgICAgICAgIGNsYXNzOiBbZmllbGQuY2xhc3MgPyBmaWVsZC5jbGFzcyA6ICcnLCB0aGlzLmdldFRkVmFsdWVzKGl0ZW0sIGtleSwgZmllbGQudGRDbGFzcywgJycpXSxcbiAgICAgICAgICBwcm9wczoge30sXG4gICAgICAgICAgYXR0cnM6IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICAgICdhcmlhLWNvbGluZGV4JzogU3RyaW5nKGNvbEluZGV4ICsgMSlcbiAgICAgICAgICB9LCBmaWVsZC5pc1Jvd0hlYWRlciA/IHRoaXMuZ2V0VGhWYWx1ZXMoaXRlbSwga2V5LCBmaWVsZC50aEF0dHIsICdyb3cnLCB7fSkgOiB0aGlzLmdldFRkVmFsdWVzKGl0ZW0sIGtleSwgZmllbGQudGRBdHRyLCB7fSkpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHN0aWNreUNvbHVtbikge1xuICAgICAgICAgIC8vIFdlIGFyZSB1c2luZyB0aGUgaGVscGVyIEJUZCBvciBCVGhcbiAgICAgICAgICBkYXRhLnByb3BzID0ge1xuICAgICAgICAgICAgc3RhY2tlZEhlYWRpbmc6IHRoaXMuaXNTdGFja2VkID8gZmllbGQubGFiZWwgOiBudWxsLFxuICAgICAgICAgICAgc3RpY2t5Q29sdW1uOiB0cnVlLFxuICAgICAgICAgICAgdmFyaWFudDogY2VsbFZhcmlhbnRcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFVzaW5nIG5hdGl2ZSBURCBvciBUSCBlbGVtZW50LCBzbyB3ZSBuZWVkIHRvXG4gICAgICAgICAgLy8gYWRkIGluIHRoZSBhdHRyaWJ1dGVzIGFuZCB2YXJpYW50IGNsYXNzXG4gICAgICAgICAgZGF0YS5hdHRyc1snZGF0YS1sYWJlbCddID0gdGhpcy5pc1N0YWNrZWQgJiYgIWlzVW5kZWZpbmVkT3JOdWxsKGZpZWxkLmxhYmVsKSA/IHRvU3RyaW5nJDEoZmllbGQubGFiZWwpIDogbnVsbDtcbiAgICAgICAgICBkYXRhLmF0dHJzLnJvbGUgPSBmaWVsZC5pc1Jvd0hlYWRlciA/ICdyb3doZWFkZXInIDogJ2NlbGwnO1xuICAgICAgICAgIGRhdGEuYXR0cnMuc2NvcGUgPSBmaWVsZC5pc1Jvd0hlYWRlciA/ICdyb3cnIDogbnVsbDsgLy8gQWRkIGluIHRoZSB2YXJpYW50IGNsYXNzXG5cbiAgICAgICAgICBpZiAoY2VsbFZhcmlhbnQpIHtcbiAgICAgICAgICAgIGRhdGEuY2xhc3MucHVzaChcIlwiLmNvbmNhdCh0aGlzLmRhcmsgPyAnYmcnIDogJ3RhYmxlJywgXCItXCIpLmNvbmNhdChjZWxsVmFyaWFudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzbG90U2NvcGUgPSB7XG4gICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICBpbmRleDogcm93SW5kZXgsXG4gICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgIHVuZm9ybWF0dGVkOiBnZXQoaXRlbSwga2V5LCAnJyksXG4gICAgICAgICAgdmFsdWU6IGZvcm1hdHRlZCxcbiAgICAgICAgICB0b2dnbGVEZXRhaWxzOiB0aGlzLnRvZ2dsZURldGFpbHNGYWN0b3J5KGhhc0RldGFpbHNTbG90LCBpdGVtKSxcbiAgICAgICAgICBkZXRhaWxzU2hvd2luZzogQm9vbGVhbihpdGVtLl9zaG93RGV0YWlscylcbiAgICAgICAgfTsgLy8gSWYgdGFibGUgc3VwcG9ydHMgc2VsZWN0YWJsZSBtb2RlLCB0aGVuIGFkZCBpbiB0aGUgZm9sbG93aW5nIHNjb3BlXG4gICAgICAgIC8vIHRoaXMuc3VwcG9ydHNTZWxlY3RhYmxlUm93cyB3aWxsIGJlIHVuZGVmaW5lZCBpZiBtaXhpbiBpc24ndCBsb2FkZWRcblxuICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1NlbGVjdGFibGVSb3dzKSB7XG4gICAgICAgICAgc2xvdFNjb3BlLnJvd1NlbGVjdGVkID0gdGhpcy5pc1Jvd1NlbGVjdGVkKHJvd0luZGV4KTtcblxuICAgICAgICAgIHNsb3RTY29wZS5zZWxlY3RSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLnNlbGVjdFJvdyhyb3dJbmRleCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHNsb3RTY29wZS51bnNlbGVjdFJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIudW5zZWxlY3RSb3cocm93SW5kZXgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gLy8gVGhlIG5ldyBgdi1zbG90YCBzeW50YXggZG9lc24ndCBsaWtlIGEgc2xvdCBuYW1lIHN0YXJ0aW5nIHdpdGhcbiAgICAgICAgLy8gYSBzcXVhcmUgYnJhY2tldCBhbmQgaWYgdXNpbmcgaW4tZG9jdW1lbnQgSFRNTCB0ZW1wbGF0ZXMsIHRoZVxuICAgICAgICAvLyB2LXNsb3QgYXR0cmlidXRlcyBhcmUgbG93ZXItY2FzZWQgYnkgdGhlIGJyb3dzZXIuXG4gICAgICAgIC8vIFN3aXRjaGVkIHRvIHJvdW5kIGJyYWNrZXQgc3ludGF4IHRvIHByZXZlbnQgY29uZnVzaW9uIHdpdGhcbiAgICAgICAgLy8gZHluYW1pYyBzbG90IG5hbWUgc3ludGF4LlxuICAgICAgICAvLyBXZSBsb29rIGZvciBzbG90cyBpbiB0aGlzIG9yZGVyOiBgY2VsbCgke2tleX0pYCwgYGNlbGwoJHtrZXkudG9Mb3dlckNhc2UoKX0pYCwgJ2NlbGwoKSdcbiAgICAgICAgLy8gU2xvdCBuYW1lcyBhcmUgbm93IGNhY2hlZCBieSBtaXhpbiB0Ym9keSBpbiBgdGhpcy4kX2JvZHlGaWVsZFNsb3ROYW1lQ2FjaGVgXG4gICAgICAgIC8vIFdpbGwgYmUgYG51bGxgIGlmIG5vIHNsb3QgKG9yIGZhbGxiYWNrIHNsb3QpIGV4aXN0c1xuXG5cbiAgICAgICAgdmFyIHNsb3ROYW1lID0gdGhpcy4kX2JvZHlGaWVsZFNsb3ROYW1lQ2FjaGVba2V5XTtcbiAgICAgICAgdmFyICRjaGlsZE5vZGVzID0gc2xvdE5hbWUgPyB0aGlzLm5vcm1hbGl6ZVNsb3Qoc2xvdE5hbWUsIHNsb3RTY29wZSkgOiB0b1N0cmluZyQxKGZvcm1hdHRlZCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTdGFja2VkKSB7XG4gICAgICAgICAgLy8gV2Ugd3JhcCBpbiBhIERJViB0byBlbnN1cmUgcmVuZGVyZWQgYXMgYSBzaW5nbGUgY2VsbCB3aGVuIHZpc3VhbGx5IHN0YWNrZWQhXG4gICAgICAgICAgJGNoaWxkTm9kZXMgPSBbaCgnZGl2JywgWyRjaGlsZE5vZGVzXSldO1xuICAgICAgICB9IC8vIFJlbmRlciBlaXRoZXIgYSB0ZCBvciB0aCBjZWxsXG5cblxuICAgICAgICByZXR1cm4gaChjZWxsVGFnLCBkYXRhLCBbJGNoaWxkTm9kZXNdKTtcbiAgICAgIH0sXG4gICAgICByZW5kZXJUYm9keVJvdzogZnVuY3Rpb24gcmVuZGVyVGJvZHlSb3coaXRlbSwgcm93SW5kZXgpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgLy8gUmVuZGVycyBhbiBpdGVtJ3Mgcm93IChvciByb3dzIGlmIGRldGFpbHMgc3VwcG9ydGVkKVxuICAgICAgICB2YXIgaCA9IHRoaXMuJGNyZWF0ZUVsZW1lbnQ7XG4gICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmNvbXB1dGVkRmllbGRzO1xuICAgICAgICB2YXIgdGFibGVTdHJpcGVkID0gdGhpcy5zdHJpcGVkO1xuICAgICAgICB2YXIgaGFzRGV0YWlsc1Nsb3QgPSB0aGlzLmhhc05vcm1hbGl6ZWRTbG90KGRldGFpbHNTbG90TmFtZSk7XG4gICAgICAgIHZhciByb3dTaG93RGV0YWlscyA9IGl0ZW0uX3Nob3dEZXRhaWxzICYmIGhhc0RldGFpbHNTbG90O1xuICAgICAgICB2YXIgaGFzUm93Q2xpY2tIYW5kbGVyID0gdGhpcy4kbGlzdGVuZXJzWydyb3ctY2xpY2tlZCddIHx8IHRoaXMuaGFzU2VsZWN0YWJsZVJvd0NsaWNrOyAvLyBXZSBjYW4gcmV0dXJuIG1vcmUgdGhhbiBvbmUgVFIgaWYgcm93RGV0YWlscyBlbmFibGVkXG5cbiAgICAgICAgdmFyICRyb3dzID0gW107IC8vIERldGFpbHMgSUQgbmVlZGVkIGZvciBgYXJpYS1kZXRhaWxzYCB3aGVuIGRldGFpbHMgc2hvd2luZ1xuICAgICAgICAvLyBXZSBzZXQgaXQgdG8gYG51bGxgIHdoZW4gbm90IHNob3dpbmcgc28gdGhhdCBhdHRyaWJ1dGVcbiAgICAgICAgLy8gZG9lcyBub3QgYXBwZWFyIG9uIHRoZSBlbGVtZW50XG5cbiAgICAgICAgdmFyIGRldGFpbHNJZCA9IHJvd1Nob3dEZXRhaWxzID8gdGhpcy5zYWZlSWQoXCJfZGV0YWlsc19cIi5jb25jYXQocm93SW5kZXgsIFwiX1wiKSkgOiBudWxsOyAvLyBGb3IgZWFjaCBpdGVtIGRhdGEgZmllbGQgaW4gcm93XG5cbiAgICAgICAgdmFyICR0ZHMgPSBmaWVsZHMubWFwKGZ1bmN0aW9uIChmaWVsZCwgY29sSW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLnJlbmRlclRib2R5Um93Q2VsbChmaWVsZCwgY29sSW5kZXgsIGl0ZW0sIHJvd0luZGV4KTtcbiAgICAgICAgfSk7IC8vIENhbGN1bGF0ZSB0aGUgcm93IG51bWJlciBpbiB0aGUgZGF0YXNldCAoaW5kZXhlZCBmcm9tIDEpXG5cbiAgICAgICAgdmFyIGFyaWFSb3dJbmRleCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhZ2UgJiYgdGhpcy5wZXJQYWdlICYmIHRoaXMucGVyUGFnZSA+IDApIHtcbiAgICAgICAgICBhcmlhUm93SW5kZXggPSBTdHJpbmcoKHRoaXMuY3VycmVudFBhZ2UgLSAxKSAqIHRoaXMucGVyUGFnZSArIHJvd0luZGV4ICsgMSk7XG4gICAgICAgIH0gLy8gQ3JlYXRlIGEgdW5pcXVlIDprZXkgdG8gaGVscCBlbnN1cmUgdGhhdCBzdWIgY29tcG9uZW50cyBhcmUgcmUtcmVuZGVyZWQgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gcmUtdXNlZCwgd2hpY2ggY2FuIGNhdXNlIGlzc3Vlcy4gSWYgYSBwcmltYXJ5IGtleSBpcyBub3QgcHJvdmlkZWQgd2UgdXNlIHRoZSByZW5kZXJlZFxuICAgICAgICAvLyByb3dzIGluZGV4IHdpdGhpbiB0aGUgdGJvZHkuXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Jvb3RzdHJhcC12dWUvYm9vdHN0cmFwLXZ1ZS9pc3N1ZXMvMjQxMFxuXG5cbiAgICAgICAgdmFyIHByaW1hcnlLZXkgPSB0aGlzLnByaW1hcnlLZXk7XG4gICAgICAgIHZhciBwcmltYXJ5S2V5VmFsdWUgPSB0b1N0cmluZyQxKGdldChpdGVtLCBwcmltYXJ5S2V5KSkgfHwgbnVsbDtcbiAgICAgICAgdmFyIHJvd0tleSA9IHByaW1hcnlLZXlWYWx1ZSB8fCB0b1N0cmluZyQxKHJvd0luZGV4KTsgLy8gSWYgcHJpbWFyeSBrZXkgaXMgcHJvdmlkZWQsIHVzZSBpdCB0byBnZW5lcmF0ZSBhIHVuaXF1ZSBJRCBvbiBlYWNoIHRib2R5ID4gdHJcbiAgICAgICAgLy8gSW4gdGhlIGZvcm1hdCBvZiAne3RhYmxlSWR9X19yb3dfe3ByaW1hcnlLZXlWYWx1ZX0nXG5cbiAgICAgICAgdmFyIHJvd0lkID0gcHJpbWFyeUtleVZhbHVlID8gdGhpcy5zYWZlSWQoXCJfcm93X1wiLmNvbmNhdChwcmltYXJ5S2V5VmFsdWUpKSA6IG51bGw7IC8vIFNlbGVjdGFibGUgY2xhc3NlcyBhbmQgYXR0cmlidXRlc1xuXG4gICAgICAgIHZhciBzZWxlY3RhYmxlQ2xhc3NlcyA9IHRoaXMuc2VsZWN0YWJsZVJvd0NsYXNzZXMgPyB0aGlzLnNlbGVjdGFibGVSb3dDbGFzc2VzKHJvd0luZGV4KSA6IHt9O1xuICAgICAgICB2YXIgc2VsZWN0YWJsZUF0dHJzID0gdGhpcy5zZWxlY3RhYmxlUm93QXR0cnMgPyB0aGlzLnNlbGVjdGFibGVSb3dBdHRycyhyb3dJbmRleCkgOiB7fTsgLy8gQWRkaXRpb25hbCBjbGFzc2VzIGFuZCBhdHRyaWJ1dGVzXG5cbiAgICAgICAgdmFyIHVzZXJUckNsYXNzZXMgPSBpc0Z1bmN0aW9uKHRoaXMudGJvZHlUckNsYXNzKSA/IHRoaXMudGJvZHlUckNsYXNzKGl0ZW0sICdyb3cnKSA6IHRoaXMudGJvZHlUckNsYXNzO1xuICAgICAgICB2YXIgdXNlclRyQXR0cnMgPSBpc0Z1bmN0aW9uKHRoaXMudGJvZHlUckF0dHIpID8gdGhpcy50Ym9keVRyQXR0cihpdGVtLCAncm93JykgOiB0aGlzLnRib2R5VHJBdHRyOyAvLyBBZGQgdGhlIGl0ZW0gcm93XG5cbiAgICAgICAgJHJvd3MucHVzaChoKEJUciwge1xuICAgICAgICAgIGtleTogXCJfX2ItdGFibGUtcm93LVwiLmNvbmNhdChyb3dLZXksIFwiX19cIiksXG4gICAgICAgICAgcmVmOiAnaXRlbVJvd3MnLFxuICAgICAgICAgIHJlZkluRm9yOiB0cnVlLFxuICAgICAgICAgIGNsYXNzOiBbdXNlclRyQ2xhc3Nlcywgc2VsZWN0YWJsZUNsYXNzZXMsIHJvd1Nob3dEZXRhaWxzID8gJ2ItdGFibGUtaGFzLWRldGFpbHMnIDogJyddLFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB2YXJpYW50OiBpdGVtLl9yb3dWYXJpYW50IHx8IG51bGxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF0dHJzOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICBpZDogcm93SWRcbiAgICAgICAgICB9LCB1c2VyVHJBdHRycywge1xuICAgICAgICAgICAgLy8gVXNlcnMgY2Fubm90IG92ZXJyaWRlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlc1xuICAgICAgICAgICAgdGFiaW5kZXg6IGhhc1Jvd0NsaWNrSGFuZGxlciA/ICcwJyA6IG51bGwsXG4gICAgICAgICAgICAnZGF0YS1wayc6IHByaW1hcnlLZXlWYWx1ZSB8fCBudWxsLFxuICAgICAgICAgICAgJ2FyaWEtZGV0YWlscyc6IGRldGFpbHNJZCxcbiAgICAgICAgICAgICdhcmlhLW93bnMnOiBkZXRhaWxzSWQsXG4gICAgICAgICAgICAnYXJpYS1yb3dpbmRleCc6IGFyaWFSb3dJbmRleFxuICAgICAgICAgIH0sIHNlbGVjdGFibGVBdHRycyksXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIC8vIE5vdGU6IFRoZXNlIGV2ZW50cyBhcmUgbm90IEExMVkgZnJpZW5kbHkhXG4gICAgICAgICAgICBtb3VzZWVudGVyOiB0aGlzLnJvd0hvdmVyZWQsXG4gICAgICAgICAgICBtb3VzZWxlYXZlOiB0aGlzLnJvd1VuaG92ZXJlZFxuICAgICAgICAgIH1cbiAgICAgICAgfSwgJHRkcykpOyAvLyBSb3cgRGV0YWlscyBzbG90XG5cbiAgICAgICAgaWYgKHJvd1Nob3dEZXRhaWxzKSB7XG4gICAgICAgICAgdmFyIGRldGFpbHNTY29wZSA9IHtcbiAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICBpbmRleDogcm93SW5kZXgsXG4gICAgICAgICAgICBmaWVsZHM6IGZpZWxkcyxcbiAgICAgICAgICAgIHRvZ2dsZURldGFpbHM6IHRoaXMudG9nZ2xlRGV0YWlsc0ZhY3RvcnkoaGFzRGV0YWlsc1Nsb3QsIGl0ZW0pXG4gICAgICAgICAgfTsgLy8gSWYgdGFibGUgc3VwcG9ydHMgc2VsZWN0YWJsZSBtb2RlLCB0aGVuIGFkZCBpbiB0aGUgZm9sbG93aW5nIHNjb3BlXG4gICAgICAgICAgLy8gdGhpcy5zdXBwb3J0c1NlbGVjdGFibGVSb3dzIHdpbGwgYmUgdW5kZWZpbmVkIGlmIG1peGluIGlzbid0IGxvYWRlZFxuXG4gICAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNTZWxlY3RhYmxlUm93cykge1xuICAgICAgICAgICAgZGV0YWlsc1Njb3BlLnJvd1NlbGVjdGVkID0gdGhpcy5pc1Jvd1NlbGVjdGVkKHJvd0luZGV4KTtcblxuICAgICAgICAgICAgZGV0YWlsc1Njb3BlLnNlbGVjdFJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5zZWxlY3RSb3cocm93SW5kZXgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZGV0YWlsc1Njb3BlLnVuc2VsZWN0Um93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLnVuc2VsZWN0Um93KHJvd0luZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSAvLyBSZW5kZXIgdGhlIGRldGFpbHMgc2xvdCBpbiBhIFREXG5cblxuICAgICAgICAgIHZhciAkZGV0YWlscyA9IGgoQlRkLCB7XG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICBjb2xzcGFuOiBmaWVsZHMubGVuZ3RoXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3M6IHRoaXMuZGV0YWlsc1RkQ2xhc3NcbiAgICAgICAgICB9LCBbdGhpcy5ub3JtYWxpemVTbG90KGRldGFpbHNTbG90TmFtZSwgZGV0YWlsc1Njb3BlKV0pOyAvLyBBZGQgYSBoaWRkZW4gcm93IHRvIGtlZXAgdGFibGUgcm93IHN0cmlwaW5nIGNvbnNpc3RlbnQgd2hlbiBkZXRhaWxzIHNob3dpbmdcbiAgICAgICAgICAvLyBPbmx5IGFkZGVkIGlmIHRoZSB0YWJsZSBpcyBzdHJpcGVkXG5cbiAgICAgICAgICBpZiAodGFibGVTdHJpcGVkKSB7XG4gICAgICAgICAgICAkcm93cy5wdXNoKCAvLyBXZSBkb24ndCB1c2UgYEJUcmAgaGVyZSBhcyB3ZSBkb24ndCBuZWVkIHRoZSBleHRyYSBmdW5jdGlvbmFsaXR5XG4gICAgICAgICAgICBoKCd0cicsIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9fYi10YWJsZS1kZXRhaWxzLXN0cmlwZV9fXCIuY29uY2F0KHJvd0tleSksXG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAnZC1ub25lJyxcbiAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbidcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0gLy8gQWRkIHRoZSBhY3R1YWwgZGV0YWlscyByb3dcblxuXG4gICAgICAgICAgdmFyIHVzZXJEZXRhaWxzVHJDbGFzc2VzID0gaXNGdW5jdGlvbih0aGlzLnRib2R5VHJDbGFzcykgPyB0aGlzLnRib2R5VHJDbGFzcyhpdGVtLCBkZXRhaWxzU2xvdE5hbWUpIDogdGhpcy50Ym9keVRyQ2xhc3M7XG4gICAgICAgICAgdmFyIHVzZXJEZXRhaWxzVHJBdHRycyA9IGlzRnVuY3Rpb24odGhpcy50Ym9keVRyQXR0cikgPyB0aGlzLnRib2R5VHJBdHRyKGl0ZW0sIGRldGFpbHNTbG90TmFtZSkgOiB0aGlzLnRib2R5VHJBdHRyO1xuICAgICAgICAgICRyb3dzLnB1c2goaChCVHIsIHtcbiAgICAgICAgICAgIGtleTogXCJfX2ItdGFibGUtZGV0YWlsc19fXCIuY29uY2F0KHJvd0tleSksXG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ2ItdGFibGUtZGV0YWlscycsXG4gICAgICAgICAgICBjbGFzczogW3VzZXJEZXRhaWxzVHJDbGFzc2VzXSxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgIHZhcmlhbnQ6IGl0ZW0uX3Jvd1ZhcmlhbnQgfHwgbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF0dHJzOiBfb2JqZWN0U3ByZWFkMih7fSwgdXNlckRldGFpbHNUckF0dHJzLCB7XG4gICAgICAgICAgICAgIC8vIFVzZXJzIGNhbm5vdCBvdmVycmlkZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgaWQ6IGRldGFpbHNJZCxcbiAgICAgICAgICAgICAgdGFiaW5kZXg6ICctMSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSwgWyRkZXRhaWxzXSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc0RldGFpbHNTbG90KSB7XG4gICAgICAgICAgLy8gT25seSBhZGQgdGhlIHBsYWNlaG9sZGVyIGlmIGEgdGhlIHRhYmxlIGhhcyBhIHJvdy1kZXRhaWxzIHNsb3QgZGVmaW5lZCAoYnV0IG5vdCBzaG93bilcbiAgICAgICAgICAkcm93cy5wdXNoKGgoKSk7XG5cbiAgICAgICAgICBpZiAodGFibGVTdHJpcGVkKSB7XG4gICAgICAgICAgICAvLyBBZGQgZXh0cmEgcGxhY2Vob2xkZXIgaWYgdGFibGUgaXMgc3RyaXBlZFxuICAgICAgICAgICAgJHJvd3MucHVzaChoKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBSZXR1cm4gdGhlIHJvdyhzKVxuXG5cbiAgICAgICAgcmV0dXJuICRyb3dzO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgcHJvcHMkWSA9IF9vYmplY3RTcHJlYWQyKHt9LCBwcm9wcyRYLCB7XG4gICAgdGJvZHlDbGFzczoge1xuICAgICAgdHlwZTogW1N0cmluZywgQXJyYXksIE9iamVjdF0gLy8gZGVmYXVsdDogdW5kZWZpbmVkXG5cbiAgICB9XG4gIH0pO1xuXG4gIHZhciB0Ym9keU1peGluID0ge1xuICAgIG1peGluczogW3Rib2R5Um93TWl4aW5dLFxuICAgIHByb3BzOiBwcm9wcyRZLFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIC8vIEhlbHBlciBtZXRob2RzXG4gICAgICBnZXRUYm9keVRyczogZnVuY3Rpb24gZ2V0VGJvZHlUcnMoKSB7XG4gICAgICAgIC8vIFJldHVybnMgYWxsIHRoZSBpdGVtIFRSIGVsZW1lbnRzIChleGNsdWRlcyBkZXRhaWwgYW5kIHNwYWNlciByb3dzKVxuICAgICAgICAvLyBgdGhpcy4kcmVmcy5pdGVtUm93c2AgaXMgYW4gYXJyYXkgb2YgaXRlbSBUUiBjb21wb25lbnRzL2VsZW1lbnRzXG4gICAgICAgIC8vIFJvd3Mgc2hvdWxkIGFsbCBiZSBCLVRSIGNvbXBvbmVudHMsIGJ1dCB3ZSBtYXAgdG8gVFIgZWxlbWVudHNcbiAgICAgICAgLy8gQWxzbyBub3RlIHRoYXQgYHRoaXMuJHJlZnMuaXRlbVJvd3NgIG1heSBub3QgYWx3YXlzIGJlIGluIGRvY3VtZW50IG9yZGVyXG4gICAgICAgIHZhciByZWZzID0gdGhpcy4kcmVmcyB8fCB7fTtcbiAgICAgICAgdmFyIHRib2R5ID0gcmVmcy50Ym9keSA/IHJlZnMudGJvZHkuJGVsIHx8IHJlZnMudGJvZHkgOiBudWxsO1xuICAgICAgICB2YXIgdHJzID0gKHJlZnMuaXRlbVJvd3MgfHwgW10pLm1hcChmdW5jdGlvbiAodHIpIHtcbiAgICAgICAgICByZXR1cm4gdHIuJGVsIHx8IHRyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRib2R5ICYmIHRib2R5LmNoaWxkcmVuICYmIHRib2R5LmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgdHJzICYmIHRycy5sZW5ndGggPiAwID8gZnJvbSh0Ym9keS5jaGlsZHJlbikuZmlsdGVyKGZ1bmN0aW9uICh0cikge1xuICAgICAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKHRycywgdHIpO1xuICAgICAgICB9KSA6IFtdO1xuICAgICAgfSxcbiAgICAgIGdldFRib2R5VHJJbmRleDogZnVuY3Rpb24gZ2V0VGJvZHlUckluZGV4KGVsKSB7XG4gICAgICAgIC8vIFJldHVybnMgaW5kZXggb2YgYSBwYXJ0aWN1bGFyIFRCT0RZIGl0ZW0gVFJcbiAgICAgICAgLy8gV2Ugc2V0IGB0cnVlYCBvbiBjbG9zZXN0IHRvIGluY2x1ZGUgc2VsZiBpbiByZXN1bHRcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2hvdWxkIG5vdCBub3JtYWxseSBoYXBwZW4gKi9cbiAgICAgICAgaWYgKCFpc0VsZW1lbnQoZWwpKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyID0gZWwudGFnTmFtZSA9PT0gJ1RSJyA/IGVsIDogY2xvc2VzdCgndHInLCBlbCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0ciA/IHRoaXMuZ2V0VGJvZHlUcnMoKS5pbmRleE9mKHRyKSA6IC0xO1xuICAgICAgfSxcbiAgICAgIGVtaXRUYm9keVJvd0V2ZW50OiBmdW5jdGlvbiBlbWl0VGJvZHlSb3dFdmVudCh0eXBlLCBldnQpIHtcbiAgICAgICAgLy8gRW1pdHMgYSByb3cgZXZlbnQsIHdpdGggdGhlIGl0ZW0gb2JqZWN0LCByb3cgaW5kZXggYW5kIG9yaWdpbmFsIGV2ZW50XG4gICAgICAgIGlmICh0eXBlICYmIHRoaXMuaGFzTGlzdGVuZXIodHlwZSkgJiYgZXZ0ICYmIGV2dC50YXJnZXQpIHtcbiAgICAgICAgICB2YXIgcm93SW5kZXggPSB0aGlzLmdldFRib2R5VHJJbmRleChldnQudGFyZ2V0KTtcblxuICAgICAgICAgIGlmIChyb3dJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAvLyBUaGUgYXJyYXkgb2YgVFJzIGNvcnJlbGF0ZSB0byB0aGUgYGNvbXB1dGVkSXRlbXNgIGFycmF5XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuY29tcHV0ZWRJdGVtc1tyb3dJbmRleF07XG4gICAgICAgICAgICB0aGlzLiRlbWl0KHR5cGUsIGl0ZW0sIHJvd0luZGV4LCBldnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRib2R5Um93RXZ0U3RvcHBlZDogZnVuY3Rpb24gdGJvZHlSb3dFdnRTdG9wcGVkKGV2dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9wSWZCdXN5ICYmIHRoaXMuc3RvcElmQnVzeShldnQpO1xuICAgICAgfSxcbiAgICAgIC8vIERlbGVnYXRlZCByb3cgZXZlbnQgaGFuZGxlcnNcbiAgICAgIG9uVGJvZHlSb3dLZXlkb3duOiBmdW5jdGlvbiBvblRib2R5Um93S2V5ZG93bihldnQpIHtcbiAgICAgICAgLy8gS2V5Ym9hcmQgbmF2aWdhdGlvbiBhbmQgcm93IGNsaWNrIGVtdWxhdGlvblxuICAgICAgICB2YXIgdGFyZ2V0ID0gZXZ0LnRhcmdldDtcblxuICAgICAgICBpZiAodGhpcy50Ym9keVJvd0V2dFN0b3BwZWQoZXZ0KSB8fCB0YXJnZXQudGFnTmFtZSAhPT0gJ1RSJyB8fCB0YXJnZXQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgdGFyZ2V0LnRhYkluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgLy8gRWFybHkgZXhpdCBpZiBub3QgYW4gaXRlbSByb3cgVFJcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5Q29kZSA9IGV2dC5rZXlDb2RlO1xuXG4gICAgICAgIGlmIChhcnJheUluY2x1ZGVzKFtLRVlfQ09ERVMuRU5URVIsIEtFWV9DT0RFUy5TUEFDRV0sIGtleUNvZGUpKSB7XG4gICAgICAgICAgLy8gRW11bGF0ZWQgY2xpY2sgZm9yIGtleWJvYXJkIHVzZXJzLCB0cmFuc2ZlciB0byBjbGljayBoYW5kbGVyXG4gICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMub25UQm9keVJvd0NsaWNrZWQoZXZ0KTtcbiAgICAgICAgfSBlbHNlIGlmIChhcnJheUluY2x1ZGVzKFtLRVlfQ09ERVMuVVAsIEtFWV9DT0RFUy5ET1dOLCBLRVlfQ09ERVMuSE9NRSwgS0VZX0NPREVTLkVORF0sIGtleUNvZGUpKSB7XG4gICAgICAgICAgLy8gS2V5Ym9hcmQgbmF2aWdhdGlvblxuICAgICAgICAgIHZhciByb3dJbmRleCA9IHRoaXMuZ2V0VGJvZHlUckluZGV4KHRhcmdldCk7XG5cbiAgICAgICAgICBpZiAocm93SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgdHJzID0gdGhpcy5nZXRUYm9keVRycygpO1xuICAgICAgICAgICAgdmFyIHNoaWZ0ID0gZXZ0LnNoaWZ0S2V5O1xuXG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS0VZX0NPREVTLkhPTUUgfHwgc2hpZnQgJiYga2V5Q29kZSA9PT0gS0VZX0NPREVTLlVQKSB7XG4gICAgICAgICAgICAgIC8vIEZvY3VzIGZpcnN0IHJvd1xuICAgICAgICAgICAgICB0cnNbMF0uZm9jdXMoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gS0VZX0NPREVTLkVORCB8fCBzaGlmdCAmJiBrZXlDb2RlID09PSBLRVlfQ09ERVMuRE9XTikge1xuICAgICAgICAgICAgICAvLyBGb2N1cyBsYXN0IHJvd1xuICAgICAgICAgICAgICB0cnNbdHJzLmxlbmd0aCAtIDFdLmZvY3VzKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEtFWV9DT0RFUy5VUCAmJiByb3dJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gRm9jdXMgcHJldmlvdXMgcm93XG4gICAgICAgICAgICAgIHRyc1tyb3dJbmRleCAtIDFdLmZvY3VzKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEtFWV9DT0RFUy5ET1dOICYmIHJvd0luZGV4IDwgdHJzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgLy8gRm9jdXMgbmV4dCByb3dcbiAgICAgICAgICAgICAgdHJzW3Jvd0luZGV4ICsgMV0uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblRCb2R5Um93Q2xpY2tlZDogZnVuY3Rpb24gb25UQm9keVJvd0NsaWNrZWQoZXZ0KSB7XG4gICAgICAgIGlmICh0aGlzLnRib2R5Um93RXZ0U3RvcHBlZChldnQpKSB7XG4gICAgICAgICAgLy8gSWYgdGFibGUgaXMgYnVzeSwgdGhlbiBkb24ndCBwcm9wYWdhdGVcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsdGVyRXZlbnQoZXZ0KSB8fCB0ZXh0U2VsZWN0aW9uQWN0aXZlKHRoaXMuJGVsKSkge1xuICAgICAgICAgIC8vIENsaWNrZWQgb24gYSBub24tZGlzYWJsZWQgY29udHJvbCBzbyBpZ25vcmVcbiAgICAgICAgICAvLyBPciB1c2VyIGlzIHNlbGVjdGluZyB0ZXh0LCBzbyBpZ25vcmVcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXRUYm9keVJvd0V2ZW50KCdyb3ctY2xpY2tlZCcsIGV2dCk7XG4gICAgICB9LFxuICAgICAgb25UYm9keVJvd01pZGRsZU1vdXNlUm93Q2xpY2tlZDogZnVuY3Rpb24gb25UYm9keVJvd01pZGRsZU1vdXNlUm93Q2xpY2tlZChldnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRib2R5Um93RXZ0U3RvcHBlZChldnQpICYmIGV2dC53aGljaCA9PT0gMikge1xuICAgICAgICAgIHRoaXMuZW1pdFRib2R5Um93RXZlbnQoJ3Jvdy1taWRkbGUtY2xpY2tlZCcsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblRib2R5Um93Q29udGV4dG1lbnU6IGZ1bmN0aW9uIG9uVGJvZHlSb3dDb250ZXh0bWVudShldnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRib2R5Um93RXZ0U3RvcHBlZChldnQpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0VGJvZHlSb3dFdmVudCgncm93LWNvbnRleHRtZW51JywgZXZ0KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVGJvZHlSb3dEYmxDbGlja2VkOiBmdW5jdGlvbiBvblRib2R5Um93RGJsQ2xpY2tlZChldnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRib2R5Um93RXZ0U3RvcHBlZChldnQpICYmICFmaWx0ZXJFdmVudChldnQpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0VGJvZHlSb3dFdmVudCgncm93LWRibGNsaWNrZWQnLCBldnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gTm90ZTogUm93IGhvdmVyIGhhbmRsZXJzIGFyZSBoYW5kbGVkIGJ5IHRoZSB0Ym9keS1yb3cgbWl4aW5cbiAgICAgIC8vIEFzIG1vdXNlZW50ZXIvbW91c2VsZWF2ZSBldmVudHMgZG8gbm90IGJ1YmJsZVxuICAgICAgLy9cbiAgICAgIC8vIFJlbmRlciBIZWxwZXJcbiAgICAgIHJlbmRlclRib2R5OiBmdW5jdGlvbiByZW5kZXJUYm9keSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAvLyBSZW5kZXIgdGhlIHRib2R5IGVsZW1lbnQgYW5kIGNoaWxkcmVuXG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuY29tcHV0ZWRJdGVtczsgLy8gU2hvcnRjdXQgdG8gYGNyZWF0ZUVsZW1lbnRgIChjb3VsZCB1c2UgYHRoaXMuX2MoKWAgaW5zdGVhZClcblxuICAgICAgICB2YXIgaCA9IHRoaXMuJGNyZWF0ZUVsZW1lbnQ7XG4gICAgICAgIHZhciBoYXNSb3dDbGlja0hhbmRsZXIgPSB0aGlzLmhhc0xpc3RlbmVyKCdyb3ctY2xpY2tlZCcpIHx8IHRoaXMuaGFzU2VsZWN0YWJsZVJvd0NsaWNrOyAvLyBQcmVwYXJlIHRoZSB0Ym9keSByb3dzXG5cbiAgICAgICAgdmFyICRyb3dzID0gW107IC8vIEFkZCB0aGUgaXRlbSBkYXRhIHJvd3Mgb3IgdGhlIGJ1c3kgc2xvdFxuXG4gICAgICAgIHZhciAkYnVzeSA9IHRoaXMucmVuZGVyQnVzeSA/IHRoaXMucmVuZGVyQnVzeSgpIDogbnVsbDtcblxuICAgICAgICBpZiAoJGJ1c3kpIHtcbiAgICAgICAgICAvLyBJZiB0YWJsZSBpcyBidXN5IGFuZCBhIGJ1c3kgc2xvdCwgdGhlbiByZXR1cm4gb25seSB0aGUgYnVzeSBcInJvd1wiIGluZGljYXRvclxuICAgICAgICAgICRyb3dzLnB1c2goJGJ1c3kpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRhYmxlIGlzbid0IGJ1c3ksIG9yIHdlIGRvbid0IGhhdmUgYSBidXN5IHNsb3RcbiAgICAgICAgICAvLyBDcmVhdGUgYSBzbG90IGNhY2hlIGZvciBpbXByb3ZlZCBwZXJmb3JtYW5jZSB3aGVuIGxvb2tpbmcgdXAgY2VsbCBzbG90IG5hbWVzXG4gICAgICAgICAgLy8gVmFsdWVzIHdpbGwgYmUga2V5ZWQgYnkgdGhlIGZpZWxkJ3MgYGtleWAgYW5kIHdpbGwgc3RvcmUgdGhlIHNsb3QncyBuYW1lXG4gICAgICAgICAgLy8gU2xvdHMgY291bGQgYmUgZHluYW1pYyAoaS5lLiBgdi1pZmApLCBzbyB3ZSBtdXN0IGNvbXB1dGUgb24gZWFjaCByZW5kZXJcbiAgICAgICAgICAvLyBVc2VkIGJ5IHRib2R5LXJvdyBtaXhpbiByZW5kZXIgaGVscGVyXG4gICAgICAgICAgdmFyIGNhY2hlID0ge307XG4gICAgICAgICAgdmFyIGRlZmF1bHRTbG90TmFtZSA9IHRoaXMuaGFzTm9ybWFsaXplZFNsb3QoJ2NlbGwoKScpID8gJ2NlbGwoKScgOiBudWxsO1xuICAgICAgICAgIHRoaXMuY29tcHV0ZWRGaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBmaWVsZC5rZXk7XG4gICAgICAgICAgICB2YXIgZnVsbE5hbWUgPSBcImNlbGwoXCIuY29uY2F0KGtleSwgXCIpXCIpO1xuICAgICAgICAgICAgdmFyIGxvd2VyTmFtZSA9IFwiY2VsbChcIi5jb25jYXQoa2V5LnRvTG93ZXJDYXNlKCksIFwiKVwiKTtcbiAgICAgICAgICAgIGNhY2hlW2tleV0gPSBfdGhpcy5oYXNOb3JtYWxpemVkU2xvdChmdWxsTmFtZSkgPyBmdWxsTmFtZSA6IF90aGlzLmhhc05vcm1hbGl6ZWRTbG90KGxvd2VyTmFtZSkgPyBsb3dlck5hbWUgOiBkZWZhdWx0U2xvdE5hbWU7XG4gICAgICAgICAgfSk7IC8vIENyZWF0ZWQgYXMgYSBub24tcmVhY3RpdmUgcHJvcGVydHkgc28gdG8gbm90IHRyaWdnZXIgY29tcG9uZW50IHVwZGF0ZXNcbiAgICAgICAgICAvLyBNdXN0IGJlIGEgZnJlc2ggb2JqZWN0IGVhY2ggcmVuZGVyXG5cbiAgICAgICAgICB0aGlzLiRfYm9keUZpZWxkU2xvdE5hbWVDYWNoZSA9IGNhY2hlOyAvLyBBZGQgc3RhdGljIHRvcCByb3cgc2xvdCAoaGlkZGVuIGluIHZpc2libHkgc3RhY2tlZCBtb2RlXG4gICAgICAgICAgLy8gYXMgd2UgY2FuJ3QgY29udHJvbCBgZGF0YS1sYWJlbGAgYXR0cilcblxuICAgICAgICAgICRyb3dzLnB1c2godGhpcy5yZW5kZXJUb3BSb3cgPyB0aGlzLnJlbmRlclRvcFJvdygpIDogaCgpKTsgLy8gUmVuZGVyIHRoZSByb3dzXG5cbiAgICAgICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCByb3dJbmRleCkge1xuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBpbmRpdmlkdWFsIGl0ZW0gcm93IChyb3dzIGlmIGRldGFpbHMgc2xvdClcbiAgICAgICAgICAgICRyb3dzLnB1c2goX3RoaXMucmVuZGVyVGJvZHlSb3coaXRlbSwgcm93SW5kZXgpKTtcbiAgICAgICAgICB9KTsgLy8gRW1wdHkgaXRlbXMgLyBlbXB0eSBmaWx0ZXJlZCByb3cgc2xvdCAob25seSBzaG93cyBpZiBgaXRlbXMubGVuZ3RoIDwgMWApXG5cbiAgICAgICAgICAkcm93cy5wdXNoKHRoaXMucmVuZGVyRW1wdHkgPyB0aGlzLnJlbmRlckVtcHR5KCkgOiBoKCkpOyAvLyBTdGF0aWMgYm90dG9tIHJvdyBzbG90IChoaWRkZW4gaW4gdmlzaWJseSBzdGFja2VkIG1vZGVcbiAgICAgICAgICAvLyBhcyB3ZSBjYW4ndCBjb250cm9sIGBkYXRhLWxhYmVsYCBhdHRyKVxuXG4gICAgICAgICAgJHJvd3MucHVzaCh0aGlzLnJlbmRlckJvdHRvbVJvdyA/IHRoaXMucmVuZGVyQm90dG9tUm93KCkgOiBoKCkpO1xuICAgICAgICB9IC8vIE5vdGU6IHRoZXNlIGV2ZW50cyB3aWxsIG9ubHkgZW1pdCBpZiBhIGxpc3RlbmVyIGlzIHJlZ2lzdGVyZWRcblxuXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHtcbiAgICAgICAgICBhdXhjbGljazogdGhpcy5vblRib2R5Um93TWlkZGxlTW91c2VSb3dDbGlja2VkLFxuICAgICAgICAgIC8vIFRPRE86XG4gICAgICAgICAgLy8gICBQZXJoYXBzIHdlIGRvIHdhbnQgdG8gYXV0b21hdGljYWxseSBwcmV2ZW50IHRoZVxuICAgICAgICAgIC8vICAgZGVmYXVsdCBjb250ZXh0IG1lbnUgZnJvbSBzaG93aW5nIGlmIHRoZXJlIGlzIGFcbiAgICAgICAgICAvLyAgIGByb3ctY29udGV4dG1lbnVgIGxpc3RlbmVyIHJlZ2lzdGVyZWRcbiAgICAgICAgICBjb250ZXh0bWVudTogdGhpcy5vblRib2R5Um93Q29udGV4dG1lbnUsXG4gICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBldmVudChzKSBpcyBub3QgY29uc2lkZXJlZCBBMTFZIGZyaWVuZGx5XG4gICAgICAgICAgZGJsY2xpY2s6IHRoaXMub25UYm9keVJvd0RibENsaWNrZWQgLy8gSG92ZXIgZXZlbnRzIChgbW91c2VlbnRlcmAvYG1vdXNlbGVhdmVgKSBhcmUgaGFuZGxlZCBieSBgdGJvZHktcm93YCBtaXhpblxuXG4gICAgICAgIH07IC8vIEFkZCBpbiBjbGljay9rZXlkb3duIGxpc3RlbmVycyBpZiBuZWVkZWRcblxuICAgICAgICBpZiAoaGFzUm93Q2xpY2tIYW5kbGVyKSB7XG4gICAgICAgICAgaGFuZGxlcnMuY2xpY2sgPSB0aGlzLm9uVEJvZHlSb3dDbGlja2VkO1xuICAgICAgICAgIGhhbmRsZXJzLmtleWRvd24gPSB0aGlzLm9uVGJvZHlSb3dLZXlkb3duO1xuICAgICAgICB9IC8vIEFzc2VtYmxlIHJvd3MgaW50byB0aGUgdGJvZHlcblxuXG4gICAgICAgIHZhciAkdGJvZHkgPSBoKEJUYm9keSwge1xuICAgICAgICAgIHJlZjogJ3Rib2R5JyxcbiAgICAgICAgICBjbGFzczogdGhpcy50Ym9keUNsYXNzIHx8IG51bGwsXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIHRib2R5VHJhbnNpdGlvblByb3BzOiB0aGlzLnRib2R5VHJhbnNpdGlvblByb3BzLFxuICAgICAgICAgICAgdGJvZHlUcmFuc2l0aW9uSGFuZGxlcnM6IHRoaXMudGJvZHlUcmFuc2l0aW9uSGFuZGxlcnNcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIEJUYm9keSB0cmFuc2ZlcnMgYWxsIG5hdGl2ZSBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHJvb3QgZWxlbWVudFxuICAgICAgICAgIC8vIFRPRE86IE9ubHkgc2V0IHRoZSBoYW5kbGVycyBpZiB0aGUgdGFibGUgaXMgbm90IGJ1c3lcbiAgICAgICAgICBvbjogaGFuZGxlcnNcbiAgICAgICAgfSwgJHJvd3MpOyAvLyBSZXR1cm4gdGhlIGFzc2VtYmxlZCB0Ym9keVxuXG4gICAgICAgIHJldHVybiAkdGJvZHk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBlbXB0eU1peGluID0ge1xuICAgIHByb3BzOiB7XG4gICAgICBzaG93RW1wdHk6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBlbXB0eVRleHQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnVGhlcmUgYXJlIG5vIHJlY29yZHMgdG8gc2hvdydcbiAgICAgIH0sXG4gICAgICBlbXB0eUh0bWw6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICB9LFxuICAgICAgZW1wdHlGaWx0ZXJlZFRleHQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnVGhlcmUgYXJlIG5vIHJlY29yZHMgbWF0Y2hpbmcgeW91ciByZXF1ZXN0J1xuICAgICAgfSxcbiAgICAgIGVtcHR5RmlsdGVyZWRIdG1sOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgcmVuZGVyRW1wdHk6IGZ1bmN0aW9uIHJlbmRlckVtcHR5KCkge1xuICAgICAgICB2YXIgaCA9IHRoaXMuJGNyZWF0ZUVsZW1lbnQ7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuY29tcHV0ZWRJdGVtcztcbiAgICAgICAgdmFyICRlbXB0eTtcblxuICAgICAgICBpZiAodGhpcy5zaG93RW1wdHkgJiYgKCFpdGVtcyB8fCBpdGVtcy5sZW5ndGggPT09IDApICYmICEodGhpcy5jb21wdXRlZEJ1c3kgJiYgdGhpcy5oYXNOb3JtYWxpemVkU2xvdCgndGFibGUtYnVzeScpKSkge1xuICAgICAgICAgICRlbXB0eSA9IHRoaXMubm9ybWFsaXplU2xvdCh0aGlzLmlzRmlsdGVyZWQgPyAnZW1wdHlmaWx0ZXJlZCcgOiAnZW1wdHknLCB7XG4gICAgICAgICAgICBlbXB0eUZpbHRlcmVkSHRtbDogdGhpcy5lbXB0eUZpbHRlcmVkSHRtbCxcbiAgICAgICAgICAgIGVtcHR5RmlsdGVyZWRUZXh0OiB0aGlzLmVtcHR5RmlsdGVyZWRUZXh0LFxuICAgICAgICAgICAgZW1wdHlIdG1sOiB0aGlzLmVtcHR5SHRtbCxcbiAgICAgICAgICAgIGVtcHR5VGV4dDogdGhpcy5lbXB0eVRleHQsXG4gICAgICAgICAgICBmaWVsZHM6IHRoaXMuY29tcHV0ZWRGaWVsZHMsXG4gICAgICAgICAgICAvLyBOb3Qgc3VyZSB3aHkgdGhpcyBpcyBpbmNsdWRlZCwgYXMgaXQgd2lsbCBhbHdheXMgYmUgYW4gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgIGl0ZW1zOiB0aGlzLmNvbXB1dGVkSXRlbXNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghJGVtcHR5KSB7XG4gICAgICAgICAgICAkZW1wdHkgPSBoKCdkaXYnLCB7XG4gICAgICAgICAgICAgIGNsYXNzOiBbJ3RleHQtY2VudGVyJywgJ215LTInXSxcbiAgICAgICAgICAgICAgZG9tUHJvcHM6IHRoaXMuaXNGaWx0ZXJlZCA/IGh0bWxPclRleHQodGhpcy5lbXB0eUZpbHRlcmVkSHRtbCwgdGhpcy5lbXB0eUZpbHRlcmVkVGV4dCkgOiBodG1sT3JUZXh0KHRoaXMuZW1wdHlIdG1sLCB0aGlzLmVtcHR5VGV4dClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICRlbXB0eSA9IGgoQlRkLCB7XG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICBjb2xzcGFuOiB0aGlzLmNvbXB1dGVkRmllbGRzLmxlbmd0aCB8fCBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgW2goJ2RpdicsIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIHJvbGU6ICdhbGVydCcsXG4gICAgICAgICAgICAgICdhcmlhLWxpdmUnOiAncG9saXRlJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIFskZW1wdHldKV0pO1xuICAgICAgICAgICRlbXB0eSA9IGgoQlRyLCB7XG4gICAgICAgICAgICBrZXk6IHRoaXMuaXNGaWx0ZXJlZCA/ICdiLWVtcHR5LWZpbHRlcmVkLXJvdycgOiAnYi1lbXB0eS1yb3cnLFxuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICdiLXRhYmxlLWVtcHR5LXJvdycsXG4gICAgICAgICAgICBjbGFzczogW2lzRnVuY3Rpb24odGhpcy50Ym9keVRyQ2xhc3MpID8gdGhpcy50Ym9keVRyQ2xhc3MobnVsbCwgJ3Jvdy1lbXB0eScpIDogdGhpcy50Ym9keVRyQ2xhc3NdLFxuICAgICAgICAgICAgYXR0cnM6IGlzRnVuY3Rpb24odGhpcy50Ym9keVRyQXR0cikgPyB0aGlzLnRib2R5VHJBdHRyKG51bGwsICdyb3ctZW1wdHknKSA6IHRoaXMudGJvZHlUckF0dHJcbiAgICAgICAgICB9LCBbJGVtcHR5XSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJGVtcHR5IHx8IGgoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHNsb3ROYW1lID0gJ3RvcC1yb3cnO1xuICB2YXIgdG9wUm93TWl4aW4gPSB7XG4gICAgbWV0aG9kczoge1xuICAgICAgcmVuZGVyVG9wUm93OiBmdW5jdGlvbiByZW5kZXJUb3BSb3coKSB7XG4gICAgICAgIHZhciBoID0gdGhpcy4kY3JlYXRlRWxlbWVudDsgLy8gQWRkIHN0YXRpYyBUb3AgUm93IHNsb3QgKGhpZGRlbiBpbiB2aXNpYmx5IHN0YWNrZWQgbW9kZSBhcyB3ZSBjYW4ndCBjb250cm9sIHRoZSBkYXRhLWxhYmVsKVxuICAgICAgICAvLyBJZiBpbiAqYWx3YXlzKiBzdGFja2VkIG1vZGUsIHdlIGRvbid0IGJvdGhlciByZW5kZXJpbmcgdGhlIHJvd1xuXG4gICAgICAgIGlmICghdGhpcy5oYXNOb3JtYWxpemVkU2xvdChzbG90TmFtZSkgfHwgdGhpcy5zdGFja2VkID09PSB0cnVlIHx8IHRoaXMuc3RhY2tlZCA9PT0gJycpIHtcbiAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuY29tcHV0ZWRGaWVsZHM7XG4gICAgICAgIHJldHVybiBoKEJUciwge1xuICAgICAgICAgIGtleTogJ2ItdG9wLXJvdycsXG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICdiLXRhYmxlLXRvcC1yb3cnLFxuICAgICAgICAgIGNsYXNzOiBbaXNGdW5jdGlvbih0aGlzLnRib2R5VHJDbGFzcykgPyB0aGlzLnRib2R5VHJDbGFzcyhudWxsLCAncm93LXRvcCcpIDogdGhpcy50Ym9keVRyQ2xhc3NdLFxuICAgICAgICAgIGF0dHJzOiBpc0Z1bmN0aW9uKHRoaXMudGJvZHlUckF0dHIpID8gdGhpcy50Ym9keVRyQXR0cihudWxsLCAncm93LXRvcCcpIDogdGhpcy50Ym9keVRyQXR0clxuICAgICAgICB9LCBbdGhpcy5ub3JtYWxpemVTbG90KHNsb3ROYW1lLCB7XG4gICAgICAgICAgY29sdW1uczogZmllbGRzLmxlbmd0aCxcbiAgICAgICAgICBmaWVsZHM6IGZpZWxkc1xuICAgICAgICB9KV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgc2xvdE5hbWUkMSA9ICdib3R0b20tcm93JztcbiAgdmFyIGJvdHRvbVJvd01peGluID0ge1xuICAgIG1ldGhvZHM6IHtcbiAgICAgIHJlbmRlckJvdHRvbVJvdzogZnVuY3Rpb24gcmVuZGVyQm90dG9tUm93KCkge1xuICAgICAgICB2YXIgaCA9IHRoaXMuJGNyZWF0ZUVsZW1lbnQ7IC8vIFN0YXRpYyBib3R0b20gcm93IHNsb3QgKGhpZGRlbiBpbiB2aXNpYmx5IHN0YWNrZWQgbW9kZSBhcyB3ZSBjYW4ndCBjb250cm9sIHRoZSBkYXRhLWxhYmVsKVxuICAgICAgICAvLyBJZiBpbiAqYWx3YXlzKiBzdGFja2VkIG1vZGUsIHdlIGRvbid0IGJvdGhlciByZW5kZXJpbmcgdGhlIHJvd1xuXG4gICAgICAgIGlmICghdGhpcy5oYXNOb3JtYWxpemVkU2xvdChzbG90TmFtZSQxKSB8fCB0aGlzLnN0YWNrZWQgPT09IHRydWUgfHwgdGhpcy5zdGFja2VkID09PSAnJykge1xuICAgICAgICAgIHJldHVybiBoKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmllbGRzID0gdGhpcy5jb21wdXRlZEZpZWxkcztcbiAgICAgICAgcmV0dXJuIGgoQlRyLCB7XG4gICAgICAgICAga2V5OiAnYi1ib3R0b20tcm93JyxcbiAgICAgICAgICBzdGF0aWNDbGFzczogJ2ItdGFibGUtYm90dG9tLXJvdycsXG4gICAgICAgICAgY2xhc3M6IFtpc0Z1bmN0aW9uKHRoaXMudGJvZHlUckNsYXNzKSA/IHRoaXMudGJvZHlUckNsYXNzKG51bGwsICdyb3ctYm90dG9tJykgOiB0aGlzLnRib2R5VHJDbGFzc10sXG4gICAgICAgICAgYXR0cnM6IGlzRnVuY3Rpb24odGhpcy50Ym9keVRyQXR0cikgPyB0aGlzLnRib2R5VHJBdHRyKG51bGwsICdyb3ctYm90dG9tJykgOiB0aGlzLnRib2R5VHJBdHRyXG4gICAgICAgIH0sIHRoaXMubm9ybWFsaXplU2xvdChzbG90TmFtZSQxLCB7XG4gICAgICAgICAgY29sdW1uczogZmllbGRzLmxlbmd0aCxcbiAgICAgICAgICBmaWVsZHM6IGZpZWxkc1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBidXN5U2xvdE5hbWUgPSAndGFibGUtYnVzeSc7XG4gIHZhciBidXN5TWl4aW4gPSB7XG4gICAgcHJvcHM6IHtcbiAgICAgIGJ1c3k6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbEJ1c3k6IGZhbHNlXG4gICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGNvbXB1dGVkQnVzeTogZnVuY3Rpb24gY29tcHV0ZWRCdXN5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idXN5IHx8IHRoaXMubG9jYWxCdXN5O1xuICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgIGxvY2FsQnVzeTogZnVuY3Rpb24gbG9jYWxCdXN5KG5ld1ZhbCwgb2xkVmFsKSB7XG4gICAgICAgIGlmIChuZXdWYWwgIT09IG9sZFZhbCkge1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTpidXN5JywgbmV3VmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgLy8gRXZlbnQgaGFuZGxlciBoZWxwZXJcbiAgICAgIHN0b3BJZkJ1c3k6IGZ1bmN0aW9uIHN0b3BJZkJ1c3koZXZ0KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXB1dGVkQnVzeSkge1xuICAgICAgICAgIC8vIElmIHRhYmxlIGlzIGJ1c3kgKHZpYSBwcm92aWRlcikgdGhlbiBkb24ndCBwcm9wYWdhdGVcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgLy8gUmVuZGVyIHRoZSBidXN5IGluZGljYXRvciBvciByZXR1cm4gYG51bGxgIGlmIG5vdCBidXN5XG4gICAgICByZW5kZXJCdXN5OiBmdW5jdGlvbiByZW5kZXJCdXN5KCkge1xuICAgICAgICB2YXIgaCA9IHRoaXMuJGNyZWF0ZUVsZW1lbnQ7IC8vIFJldHVybiBhIGJ1c3kgaW5kaWNhdG9yIHJvdywgb3IgYG51bGxgIGlmIG5vdCBidXN5XG5cbiAgICAgICAgaWYgKHRoaXMuY29tcHV0ZWRCdXN5ICYmIHRoaXMuaGFzTm9ybWFsaXplZFNsb3QoYnVzeVNsb3ROYW1lKSkge1xuICAgICAgICAgIC8vIFNob3cgdGhlIGJ1c3kgc2xvdFxuICAgICAgICAgIHJldHVybiBoKEJUciwge1xuICAgICAgICAgICAga2V5OiAndGFibGUtYnVzeS1zbG90JyxcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAnYi10YWJsZS1idXN5LXNsb3QnLFxuICAgICAgICAgICAgY2xhc3M6IFtpc0Z1bmN0aW9uKHRoaXMudGJvZHlUckNsYXNzKSA/IHRoaXMudGJvZHlUckNsYXNzKG51bGwsIGJ1c3lTbG90TmFtZSkgOiB0aGlzLnRib2R5VHJDbGFzc10sXG4gICAgICAgICAgICBhdHRyczogaXNGdW5jdGlvbih0aGlzLnRib2R5VHJBdHRyKSA/IHRoaXMudGJvZHlUckF0dHIobnVsbCwgYnVzeVNsb3ROYW1lKSA6IHRoaXMudGJvZHlUckF0dHJcbiAgICAgICAgICB9LCBbaChCVGQsIHtcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgIGNvbHNwYW46IHRoaXMuY29tcHV0ZWRGaWVsZHMubGVuZ3RoIHx8IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBbdGhpcy5ub3JtYWxpemVTbG90KGJ1c3lTbG90TmFtZSldKV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdlIHJldHVybiBgbnVsbGAgaGVyZSBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgaWYgd2UgbmVlZCB0b1xuICAgICAgICAgIC8vIHJlbmRlciB0aGUgdGFibGUgaXRlbXMgcm93cyBvciBub3RcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgc2VsZWN0YWJsZU1peGluID0ge1xuICAgIHByb3BzOiB7XG4gICAgICBzZWxlY3RhYmxlOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc2VsZWN0TW9kZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICdtdWx0aScsXG4gICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHZhbCkge1xuICAgICAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKFsncmFuZ2UnLCAnbXVsdGknLCAnc2luZ2xlJ10sIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZFZhcmlhbnQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKCdCVGFibGUnLCAnc2VsZWN0ZWRWYXJpYW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBub1NlbGVjdE9uQ2xpY2s6IHtcbiAgICAgICAgLy8gRGlzYWJsZSB1c2Ugb2YgY2xpY2sgaGFuZGxlcnMgZm9yIHJvdyBzZWxlY3Rpb25cbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RlZFJvd3M6IFtdLFxuICAgICAgICBzZWxlY3RlZExhc3RSb3c6IC0xXG4gICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGlzU2VsZWN0YWJsZTogZnVuY3Rpb24gaXNTZWxlY3RhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RhYmxlICYmIHRoaXMuc2VsZWN0TW9kZTtcbiAgICAgIH0sXG4gICAgICBoYXNTZWxlY3RhYmxlUm93Q2xpY2s6IGZ1bmN0aW9uIGhhc1NlbGVjdGFibGVSb3dDbGljaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTZWxlY3RhYmxlICYmICF0aGlzLm5vU2VsZWN0T25DbGljaztcbiAgICAgIH0sXG4gICAgICBzdXBwb3J0c1NlbGVjdGFibGVSb3dzOiBmdW5jdGlvbiBzdXBwb3J0c1NlbGVjdGFibGVSb3dzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RhYmxlSGFzU2VsZWN0aW9uOiBmdW5jdGlvbiBzZWxlY3RhYmxlSGFzU2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NlbGVjdGFibGUgJiYgdGhpcy5zZWxlY3RlZFJvd3MgJiYgdGhpcy5zZWxlY3RlZFJvd3MubGVuZ3RoID4gMCAmJiB0aGlzLnNlbGVjdGVkUm93cy5zb21lKGlkZW50aXR5KTtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RhYmxlSXNNdWx0aVNlbGVjdDogZnVuY3Rpb24gc2VsZWN0YWJsZUlzTXVsdGlTZWxlY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2VsZWN0YWJsZSAmJiBhcnJheUluY2x1ZGVzKFsncmFuZ2UnLCAnbXVsdGknXSwgdGhpcy5zZWxlY3RNb2RlKTtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RhYmxlVGFibGVDbGFzc2VzOiBmdW5jdGlvbiBzZWxlY3RhYmxlVGFibGVDbGFzc2VzKCkge1xuICAgICAgICB2YXIgX3JlZjtcblxuICAgICAgICByZXR1cm4gX3JlZiA9IHtcbiAgICAgICAgICAnYi10YWJsZS1zZWxlY3RhYmxlJzogdGhpcy5pc1NlbGVjdGFibGVcbiAgICAgICAgfSwgX2RlZmluZVByb3BlcnR5KF9yZWYsIFwiYi10YWJsZS1zZWxlY3QtXCIuY29uY2F0KHRoaXMuc2VsZWN0TW9kZSksIHRoaXMuaXNTZWxlY3RhYmxlKSwgX2RlZmluZVByb3BlcnR5KF9yZWYsICdiLXRhYmxlLXNlbGVjdGluZycsIHRoaXMuc2VsZWN0YWJsZUhhc1NlbGVjdGlvbiksIF9kZWZpbmVQcm9wZXJ0eShfcmVmLCAnYi10YWJsZS1zZWxlY3RhYmxlLW5vLWNsaWNrJywgdGhpcy5pc1NlbGVjdGFibGUgJiYgIXRoaXMuaGFzU2VsZWN0YWJsZVJvd0NsaWNrKSwgX3JlZjtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RhYmxlVGFibGVBdHRyczogZnVuY3Rpb24gc2VsZWN0YWJsZVRhYmxlQXR0cnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgICAvLyAgIFNob3VsZCB0aGlzIGF0dHJpYnV0ZSBub3QgYmUgaW5jbHVkZWQgd2hlbiBuby1zZWxlY3Qtb24tY2xpY2sgaXMgc2V0XG4gICAgICAgICAgLy8gICBzaW5jZSB0aGlzIGF0dHJpYnV0ZSBpbXBsaWVzIGtleWJvYXJkIG5hdmlnYXRpb24/XG4gICAgICAgICAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogIXRoaXMuaXNTZWxlY3RhYmxlID8gbnVsbCA6IHRoaXMuc2VsZWN0YWJsZUlzTXVsdGlTZWxlY3QgPyAndHJ1ZScgOiAnZmFsc2UnXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgY29tcHV0ZWRJdGVtczogZnVuY3Rpb24gY29tcHV0ZWRJdGVtcyhuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICAvLyBSZXNldCBmb3Igc2VsZWN0YWJsZVxuICAgICAgICB2YXIgZXF1YWwgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGFibGUgJiYgdGhpcy5zZWxlY3RlZFJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIFF1aWNrIGNoZWNrIGFnYWluc3QgYXJyYXkgbGVuZ3RoXG4gICAgICAgICAgZXF1YWwgPSBpc0FycmF5KG5ld1ZhbCkgJiYgaXNBcnJheShvbGRWYWwpICYmIG5ld1ZhbC5sZW5ndGggPT09IG9sZFZhbC5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgZXF1YWwgJiYgaSA8IG5ld1ZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgdGhlIGZpcnN0IG5vbi1sb29zZWx5IGVxdWFsIHJvdywgYWZ0ZXIgaWdub3JpbmcgcmVzZXJ2ZWQgZmllbGRzXG4gICAgICAgICAgICBlcXVhbCA9IGxvb3NlRXF1YWwoc2FuaXRpemVSb3cobmV3VmFsW2ldKSwgc2FuaXRpemVSb3cob2xkVmFsW2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlcXVhbCkge1xuICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2VsZWN0YWJsZTogZnVuY3Rpb24gc2VsZWN0YWJsZShuZXdWYWwpIHtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGVkKCk7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uSGFuZGxlcnMobmV3VmFsKTtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RNb2RlOiBmdW5jdGlvbiBzZWxlY3RNb2RlKCkge1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0ZWQoKTtcbiAgICAgIH0sXG4gICAgICBoYXNTZWxlY3RhYmxlUm93Q2xpY2s6IGZ1bmN0aW9uIGhhc1NlbGVjdGFibGVSb3dDbGljayhuZXdWYWwpIHtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGVkKCk7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uSGFuZGxlcnMoIW5ld1ZhbCk7XG4gICAgICB9LFxuICAgICAgc2VsZWN0ZWRSb3dzOiBmdW5jdGlvbiBzZWxlY3RlZFJvd3MoX3NlbGVjdGVkUm93cywgb2xkVmFsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3RhYmxlICYmICFsb29zZUVxdWFsKF9zZWxlY3RlZFJvd3MsIG9sZFZhbCkpIHtcbiAgICAgICAgICB2YXIgaXRlbXMgPSBbXTsgLy8gYC5mb3JFYWNoKClgIHNraXBzIG92ZXIgbm9uLWV4aXN0ZW50IGluZGljZXMgKG9uIHNwYXJzZSBhcnJheXMpXG5cbiAgICAgICAgICBfc2VsZWN0ZWRSb3dzLmZvckVhY2goZnVuY3Rpb24gKHYsIGlkeCkge1xuICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgaXRlbXMucHVzaChfdGhpcy5jb21wdXRlZEl0ZW1zW2lkeF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy4kZW1pdCgncm93LXNlbGVjdGVkJywgaXRlbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVNb3VudDogZnVuY3Rpb24gYmVmb3JlTW91bnQoKSB7XG4gICAgICAvLyBTZXQgdXAgaGFuZGxlcnMgaWYgbmVlZGVkXG4gICAgICBpZiAodGhpcy5pc1NlbGVjdGFibGUpIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25IYW5kbGVycyh0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIC8vIFB1YmxpYyBtZXRob2RzXG4gICAgICBzZWxlY3RSb3c6IGZ1bmN0aW9uIHNlbGVjdFJvdyhpbmRleCkge1xuICAgICAgICAvLyBTZWxlY3QgYSBwYXJ0aWN1bGFyIHJvdyAoaW5kZXhlZCBiYXNlZCBvbiBjb21wdXRlZEl0ZW1zKVxuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGFibGUgJiYgaXNOdW1iZXIoaW5kZXgpICYmIGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLmNvbXB1dGVkSXRlbXMubGVuZ3RoICYmICF0aGlzLmlzUm93U2VsZWN0ZWQoaW5kZXgpKSB7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkUm93cyA9IHRoaXMuc2VsZWN0YWJsZUlzTXVsdGlTZWxlY3QgPyB0aGlzLnNlbGVjdGVkUm93cy5zbGljZSgpIDogW107XG4gICAgICAgICAgc2VsZWN0ZWRSb3dzW2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZExhc3RDbGlja2VkID0gLTE7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZFJvd3MgPSBzZWxlY3RlZFJvd3M7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bnNlbGVjdFJvdzogZnVuY3Rpb24gdW5zZWxlY3RSb3coaW5kZXgpIHtcbiAgICAgICAgLy8gVW4tc2VsZWN0IGEgcGFydGljdWxhciByb3cgKGluZGV4ZWQgYmFzZWQgb24gYGNvbXB1dGVkSXRlbXNgKVxuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGFibGUgJiYgaXNOdW1iZXIoaW5kZXgpICYmIHRoaXMuaXNSb3dTZWxlY3RlZChpbmRleCkpIHtcbiAgICAgICAgICB2YXIgc2VsZWN0ZWRSb3dzID0gdGhpcy5zZWxlY3RlZFJvd3Muc2xpY2UoKTtcbiAgICAgICAgICBzZWxlY3RlZFJvd3NbaW5kZXhdID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZExhc3RDbGlja2VkID0gLTE7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZFJvd3MgPSBzZWxlY3RlZFJvd3M7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZWxlY3RBbGxSb3dzOiBmdW5jdGlvbiBzZWxlY3RBbGxSb3dzKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5jb21wdXRlZEl0ZW1zLmxlbmd0aDtcblxuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGFibGUgJiYgbGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRMYXN0Q2xpY2tlZCA9IC0xO1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRSb3dzID0gdGhpcy5zZWxlY3RhYmxlSXNNdWx0aVNlbGVjdCA/IHJhbmdlKGxlbmd0aCkubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0pIDogW3RydWVdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXNSb3dTZWxlY3RlZDogZnVuY3Rpb24gaXNSb3dTZWxlY3RlZChpbmRleCkge1xuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgYSByb3cgaXMgc2VsZWN0ZWQgKGluZGV4ZWQgYmFzZWQgb24gYGNvbXB1dGVkSXRlbXNgKVxuICAgICAgICByZXR1cm4gISEoaXNOdW1iZXIoaW5kZXgpICYmIHRoaXMuc2VsZWN0ZWRSb3dzW2luZGV4XSk7XG4gICAgICB9LFxuICAgICAgY2xlYXJTZWxlY3RlZDogZnVuY3Rpb24gY2xlYXJTZWxlY3RlZCgpIHtcbiAgICAgICAgLy8gQ2xlYXIgYW55IGFjdGl2ZSBzZWxlY3RlZCByb3cocylcbiAgICAgICAgdGhpcy5zZWxlY3RlZExhc3RDbGlja2VkID0gLTE7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRSb3dzID0gW107XG4gICAgICB9LFxuICAgICAgLy8gSW50ZXJuYWwgcHJpdmF0ZSBtZXRob2RzXG4gICAgICBzZWxlY3RhYmxlUm93Q2xhc3NlczogZnVuY3Rpb24gc2VsZWN0YWJsZVJvd0NsYXNzZXMoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3RhYmxlICYmIHRoaXMuaXNSb3dTZWxlY3RlZChpbmRleCkpIHtcbiAgICAgICAgICB2YXIgdmFyaWFudCA9IHRoaXMuc2VsZWN0ZWRWYXJpYW50O1xuICAgICAgICAgIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgICAgJ2ItdGFibGUtcm93LXNlbGVjdGVkJzogdHJ1ZVxuICAgICAgICAgIH0sIFwiXCIuY29uY2F0KHRoaXMuZGFyayA/ICdiZycgOiAndGFibGUnLCBcIi1cIikuY29uY2F0KHZhcmlhbnQpLCB2YXJpYW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZWxlY3RhYmxlUm93QXR0cnM6IGZ1bmN0aW9uIHNlbGVjdGFibGVSb3dBdHRycyhpbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogIXRoaXMuaXNTZWxlY3RhYmxlID8gbnVsbCA6IHRoaXMuaXNSb3dTZWxlY3RlZChpbmRleCkgPyAndHJ1ZScgOiAnZmFsc2UnXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgc2V0U2VsZWN0aW9uSGFuZGxlcnM6IGZ1bmN0aW9uIHNldFNlbGVjdGlvbkhhbmRsZXJzKG9uKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvbiAmJiAhdGhpcy5ub1NlbGVjdE9uQ2xpY2sgPyAnJG9uJyA6ICckb2ZmJzsgLy8gSGFuZGxlIHJvdy1jbGlja2VkIGV2ZW50XG5cbiAgICAgICAgdGhpc1ttZXRob2RdKCdyb3ctY2xpY2tlZCcsIHRoaXMuc2VsZWN0aW9uSGFuZGxlcik7IC8vIENsZWFyIHNlbGVjdGlvbiBvbiBmaWx0ZXIsIHBhZ2luYXRpb24sIGFuZCBzb3J0IGNoYW5nZXNcblxuICAgICAgICB0aGlzW21ldGhvZF0oJ2ZpbHRlcmVkJywgdGhpcy5jbGVhclNlbGVjdGVkKTtcbiAgICAgICAgdGhpc1ttZXRob2RdKCdjb250ZXh0LWNoYW5nZWQnLCB0aGlzLmNsZWFyU2VsZWN0ZWQpO1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uIHNlbGVjdGlvbkhhbmRsZXIoaXRlbSwgaW5kZXgsIGV2dCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHNob3VsZCBuZXZlciBoYXBwZW4gKi9cbiAgICAgICAgaWYgKCF0aGlzLmlzU2VsZWN0YWJsZSB8fCB0aGlzLm5vU2VsZWN0T25DbGljaykge1xuICAgICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRhYmxlIGlzIG5vdCBpbiBzZWxlY3RhYmxlIG1vZGVcbiAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0ZWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZWN0TW9kZSA9IHRoaXMuc2VsZWN0TW9kZTtcbiAgICAgICAgdmFyIHNlbGVjdGVkUm93cyA9IHRoaXMuc2VsZWN0ZWRSb3dzLnNsaWNlKCk7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9ICFzZWxlY3RlZFJvd3NbaW5kZXhdOyAvLyBOb3RlICdtdWx0aScgbW9kZSBuZWVkcyBubyBzcGVjaWFsIGV2ZW50IGhhbmRsaW5nXG5cbiAgICAgICAgaWYgKHNlbGVjdE1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgc2VsZWN0ZWRSb3dzID0gW107XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0TW9kZSA9PT0gJ3JhbmdlJykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkTGFzdFJvdyA+IC0xICYmIGV2dC5zaGlmdEtleSkge1xuICAgICAgICAgICAgLy8gcmFuZ2VcbiAgICAgICAgICAgIGZvciAodmFyIGlkeCA9IE1hdGgubWluKHRoaXMuc2VsZWN0ZWRMYXN0Um93LCBpbmRleCk7IGlkeCA8PSBNYXRoLm1heCh0aGlzLnNlbGVjdGVkTGFzdFJvdywgaW5kZXgpOyBpZHgrKykge1xuICAgICAgICAgICAgICBzZWxlY3RlZFJvd3NbaWR4XSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEoZXZ0LmN0cmxLZXkgfHwgZXZ0Lm1ldGFLZXkpKSB7XG4gICAgICAgICAgICAgIC8vIENsZWFyIHJhbmdlIHNlbGVjdGlvbiBpZiBhbnlcbiAgICAgICAgICAgICAgc2VsZWN0ZWRSb3dzID0gW107XG4gICAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZExhc3RSb3cgPSBzZWxlY3RlZCA/IGluZGV4IDogLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZWN0ZWRSb3dzW2luZGV4XSA9IHNlbGVjdGVkO1xuICAgICAgICB0aGlzLnNlbGVjdGVkUm93cyA9IHNlbGVjdGVkUm93cztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHByb3ZpZGVyTWl4aW4gPSB7XG4gICAgbWl4aW5zOiBbbGlzdGVuT25Sb290TWl4aW5dLFxuICAgIHByb3BzOiB7XG4gICAgICAvLyBQcm9wIG92ZXJyaWRlKHMpXG4gICAgICBpdGVtczoge1xuICAgICAgICAvLyBBZGRzIGluICdGdW5jdGlvbicgc3VwcG9ydFxuICAgICAgICB0eXBlOiBbQXJyYXksIEZ1bmN0aW9uXSxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQWRkaXRpb25hbCBwcm9wc1xuICAgICAgbm9Qcm92aWRlclBhZ2luZzoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIG5vUHJvdmlkZXJTb3J0aW5nOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgbm9Qcm92aWRlckZpbHRlcmluZzoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGFwaVVybDoge1xuICAgICAgICAvLyBQYXNzdGhyb3VnaCBwcm9wLiBQYXNzZWQgdG8gdGhlIGNvbnRleHQgb2JqZWN0LiBOb3QgdXNlZCBieSBiLXRhYmxlIGRpcmVjdGx5XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBoYXNQcm92aWRlcjogZnVuY3Rpb24gaGFzUHJvdmlkZXIoKSB7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHRoaXMuaXRlbXMpO1xuICAgICAgfSxcbiAgICAgIHByb3ZpZGVyVHJpZ2dlckNvbnRleHQ6IGZ1bmN0aW9uIHByb3ZpZGVyVHJpZ2dlckNvbnRleHQoKSB7XG4gICAgICAgIC8vIFVzZWQgdG8gdHJpZ2dlciB0aGUgcHJvdmlkZXIgZnVuY3Rpb24gdmlhIGEgd2F0Y2hlci4gT25seSB0aGUgZmllbGRzIHRoYXRcbiAgICAgICAgLy8gYXJlIG5lZWRlZCBmb3IgdHJpZ2dlcmluZyBhIHByb3ZpZGVyIHVwZGF0ZSBhcmUgaW5jbHVkZWQuIE5vdGUgdGhhdCB0aGVcbiAgICAgICAgLy8gcmVndWxhciB0aGlzLmNvbnRleHQgaXMgc2VudCB0byB0aGUgcHJvdmlkZXIgZHVyaW5nIGZldGNoZXMgdGhvdWdoLCBhcyB0aGV5XG4gICAgICAgIC8vIG1heSBuZWVkIGFsbCB0aGUgcHJvcCBpbmZvLlxuICAgICAgICB2YXIgY3R4ID0ge1xuICAgICAgICAgIGFwaVVybDogdGhpcy5hcGlVcmwsXG4gICAgICAgICAgZmlsdGVyOiBudWxsLFxuICAgICAgICAgIHNvcnRCeTogbnVsbCxcbiAgICAgICAgICBzb3J0RGVzYzogbnVsbCxcbiAgICAgICAgICBwZXJQYWdlOiBudWxsLFxuICAgICAgICAgIGN1cnJlbnRQYWdlOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCF0aGlzLm5vUHJvdmlkZXJGaWx0ZXJpbmcpIHtcbiAgICAgICAgICAvLyBFaXRoZXIgYSBzdHJpbmcsIG9yIGNvdWxkIGJlIGFuIG9iamVjdCBvciBhcnJheS5cbiAgICAgICAgICBjdHguZmlsdGVyID0gdGhpcy5sb2NhbEZpbHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5ub1Byb3ZpZGVyU29ydGluZykge1xuICAgICAgICAgIGN0eC5zb3J0QnkgPSB0aGlzLmxvY2FsU29ydEJ5O1xuICAgICAgICAgIGN0eC5zb3J0RGVzYyA9IHRoaXMubG9jYWxTb3J0RGVzYztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5ub1Byb3ZpZGVyUGFnaW5nKSB7XG4gICAgICAgICAgY3R4LnBlclBhZ2UgPSB0aGlzLnBlclBhZ2U7XG4gICAgICAgICAgY3R4LmN1cnJlbnRQYWdlID0gdGhpcy5jdXJyZW50UGFnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9uZShjdHgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgIC8vIFByb3ZpZGVyIHVwZGF0ZSB0cmlnZ2VyaW5nXG4gICAgICBpdGVtczogZnVuY3Rpb24gaXRlbXMobmV3VmFsKSB7XG4gICAgICAgIC8vIElmIGEgbmV3IHByb3ZpZGVyIGhhcyBiZWVuIHNwZWNpZmllZCwgdHJpZ2dlciBhbiB1cGRhdGVcbiAgICAgICAgaWYgKHRoaXMuaGFzUHJvdmlkZXIgfHwgaXNGdW5jdGlvbihuZXdWYWwpKSB7XG4gICAgICAgICAgdGhpcy4kbmV4dFRpY2sodGhpcy5fcHJvdmlkZXJVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvdmlkZXJUcmlnZ2VyQ29udGV4dDogZnVuY3Rpb24gcHJvdmlkZXJUcmlnZ2VyQ29udGV4dChuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICAvLyBUcmlnZ2VyIHRoZSBwcm92aWRlciB0byB1cGRhdGUgYXMgdGhlIHJlbGV2YW50IGNvbnRleHQgdmFsdWVzIGhhdmUgY2hhbmdlZC5cbiAgICAgICAgaWYgKCFsb29zZUVxdWFsKG5ld1ZhbCwgb2xkVmFsKSkge1xuICAgICAgICAgIHRoaXMuJG5leHRUaWNrKHRoaXMuX3Byb3ZpZGVyVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIENhbGwgdGhlIGl0ZW1zIHByb3ZpZGVyIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHRoaXMuaGFzUHJvdmlkZXIgJiYgKCF0aGlzLmxvY2FsSXRlbXMgfHwgdGhpcy5sb2NhbEl0ZW1zLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgLy8gRmV0Y2ggb24gbW91bnQgaWYgbG9jYWxJdGVtcyBpcyBlbXB0eVxuICAgICAgICB0aGlzLl9wcm92aWRlclVwZGF0ZSgpO1xuICAgICAgfSAvLyBMaXN0ZW4gZm9yIGdsb2JhbCBtZXNzYWdlcyB0byB0ZWxsIHVzIHRvIGZvcmNlIHJlZnJlc2ggdGhlIHRhYmxlXG5cblxuICAgICAgdGhpcy5saXN0ZW5PblJvb3QoJ2J2OjpyZWZyZXNoOjp0YWJsZScsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoaWQgPT09IF90aGlzLmlkIHx8IGlkID09PSBfdGhpcykge1xuICAgICAgICAgIF90aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgICAvLyBQdWJsaWMgTWV0aG9kOiBGb3JjZSBhIHJlZnJlc2ggb2YgdGhlIHByb3ZpZGVyIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuJG9mZigncmVmcmVzaGVkJywgdGhpcy5yZWZyZXNoKTtcblxuICAgICAgICBpZiAodGhpcy5jb21wdXRlZEJ1c3kpIHtcbiAgICAgICAgICAvLyBDYW4ndCBmb3JjZSBhbiB1cGRhdGUgd2hlbiBmb3JjZWQgYnVzeSBieSB1c2VyIChidXN5IHByb3AgPT09IHRydWUpXG4gICAgICAgICAgaWYgKHRoaXMubG9jYWxCdXN5ICYmIHRoaXMuaGFzUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIC8vIEJ1dCBpZiBwcm92aWRlciBydW5uaW5nIChsb2NhbEJ1c3kpLCByZS1zY2hlZHVsZSByZWZyZXNoIG9uY2UgYHJlZnJlc2hlZGAgZW1pdHRlZFxuICAgICAgICAgICAgdGhpcy4kb24oJ3JlZnJlc2hlZCcsIHRoaXMucmVmcmVzaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3RlZCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaGFzUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKHRoaXMuX3Byb3ZpZGVyVXBkYXRlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHRoaXMubG9jYWxJdGVtcyA9IGlzQXJyYXkodGhpcy5pdGVtcykgPyB0aGlzLml0ZW1zLnNsaWNlKCkgOiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBQcm92aWRlciByZWxhdGVkIG1ldGhvZHNcbiAgICAgIF9wcm92aWRlclNldExvY2FsOiBmdW5jdGlvbiBfcHJvdmlkZXJTZXRMb2NhbChpdGVtcykge1xuICAgICAgICB0aGlzLmxvY2FsSXRlbXMgPSBpc0FycmF5KGl0ZW1zKSA/IGl0ZW1zLnNsaWNlKCkgOiBbXTtcbiAgICAgICAgdGhpcy5sb2NhbEJ1c3kgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kZW1pdCgncmVmcmVzaGVkJyk7IC8vIE5ldyByb290IGVtaXRcblxuICAgICAgICBpZiAodGhpcy5pZCkge1xuICAgICAgICAgIHRoaXMuZW1pdE9uUm9vdCgnYnY6OnRhYmxlOjpyZWZyZXNoZWQnLCB0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9wcm92aWRlclVwZGF0ZTogZnVuY3Rpb24gX3Byb3ZpZGVyVXBkYXRlKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAvLyBSZWZyZXNoIHRoZSBwcm92aWRlciBmdW5jdGlvbiBpdGVtcy5cbiAgICAgICAgaWYgKCF0aGlzLmhhc1Byb3ZpZGVyKSB7XG4gICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBubyBwcm92aWRlclxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBJZiB0YWJsZSBpcyBidXN5LCB3YWl0IHVudGlsIHJlZnJlc2hlZCBiZWZvcmUgY2FsbGluZyBhZ2FpblxuXG5cbiAgICAgICAgaWYgKHRoaXMuY29tcHV0ZWRCdXN5KSB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgYSBuZXcgcmVmcmVzaCBvbmNlIGByZWZyZXNoZWRgIGlzIGVtaXR0ZWRcbiAgICAgICAgICB0aGlzLiRuZXh0VGljayh0aGlzLnJlZnJlc2gpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTZXQgaW50ZXJuYWwgYnVzeSBzdGF0ZVxuXG5cbiAgICAgICAgdGhpcy5sb2NhbEJ1c3kgPSB0cnVlOyAvLyBDYWxsIHByb3ZpZGVyIGZ1bmN0aW9uIHdpdGggY29udGV4dCBhbmQgb3B0aW9uYWwgY2FsbGJhY2sgYWZ0ZXIgRE9NIGlzIGZ1bGx5IHVwZGF0ZWRcblxuICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENhbGwgcHJvdmlkZXIgZnVuY3Rpb24gcGFzc2luZyBpdCB0aGUgY29udGV4dCBhbmQgb3B0aW9uYWwgY2FsbGJhY2tcbiAgICAgICAgICAgIHZhciBkYXRhID0gX3RoaXMyLml0ZW1zKF90aGlzMi5jb250ZXh0LCBfdGhpczIuX3Byb3ZpZGVyU2V0TG9jYWwpO1xuXG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKGRhdGEpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3ZpZGVyIHJldHVybmVkIFByb21pc2VcbiAgICAgICAgICAgICAgZGF0YS50aGVuKGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgICAgICAgICAgIC8vIFByb3ZpZGVyIHJlc29sdmVkIHdpdGggaXRlbXNcbiAgICAgICAgICAgICAgICBfdGhpczIuX3Byb3ZpZGVyU2V0TG9jYWwoaXRlbXMpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAvLyBQcm92aWRlciByZXR1cm5lZCBBcnJheSBkYXRhXG4gICAgICAgICAgICAgIF90aGlzMi5fcHJvdmlkZXJTZXRMb2NhbChkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAoX3RoaXMyLml0ZW1zLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIG51bWJlciBvZiBhcmd1bWVudHMgcHJvdmlkZXIgZnVuY3Rpb24gcmVxdWVzdGVkXG4gICAgICAgICAgICAgICAgLy8gUHJvdmlkZXIgbm90IHVzaW5nIGNhbGxiYWNrIChkaWRuJ3QgcmVxdWVzdCBzZWNvbmQgYXJndW1lbnQpLCBzbyB3ZSBjbGVhclxuICAgICAgICAgICAgICAgIC8vIGJ1c3kgc3RhdGUgYXMgbW9zdCBsaWtlbHkgdGhlcmUgd2FzIGFuIGVycm9yIGluIHRoZSBwcm92aWRlciBmdW5jdGlvblxuXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICB3YXJuKFwiUHJvdmlkZXIgZnVuY3Rpb24gZGlkbid0IHJlcXVlc3QgY2FsbGJhY2sgYW5kIGRpZCBub3QgcmV0dXJuIGEgcHJvbWlzZSBvciBkYXRhLlwiLCAnQlRhYmxlJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMyLmxvY2FsQnVzeSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSlcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFByb3ZpZGVyIGZ1bmN0aW9uIGJvcmtlZCBvbiB1cywgc28gd2Ugc3BldyBvdXQgYSB3YXJuaW5nXG4gICAgICAgICAgICAvLyBhbmQgY2xlYXIgdGhlIGJ1c3kgc3RhdGVcbiAgICAgICAgICAgIHdhcm4oXCJQcm92aWRlciBmdW5jdGlvbiBlcnJvciBbXCIuY29uY2F0KGUubmFtZSwgXCJdIFwiKS5jb25jYXQoZS5tZXNzYWdlLCBcIi5cIiksICdCVGFibGUnKTtcbiAgICAgICAgICAgIF90aGlzMi5sb2NhbEJ1c3kgPSBmYWxzZTtcblxuICAgICAgICAgICAgX3RoaXMyLiRvZmYoJ3JlZnJlc2hlZCcsIF90aGlzMi5yZWZyZXNoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBJbmNsdWRlcyBhbGwgbWFpbiB0YWJsZSBzdHlsaW5nIG9wdGlvbnNcblxuICB2YXIgdGFibGVSZW5kZXJlck1peGluID0ge1xuICAgIC8vIERvbid0IHBsYWNlIGF0dHJpYnV0ZXMgb24gcm9vdCBlbGVtZW50IGF1dG9tYXRpY2FsbHksXG4gICAgLy8gYXMgdGFibGUgY291bGQgYmUgd3JhcHBlZCBpbiByZXNwb25zaXZlIGA8ZGl2PmBcbiAgICBpbmhlcml0QXR0cnM6IGZhbHNlLFxuICAgIHByb3ZpZGU6IGZ1bmN0aW9uIHByb3ZpZGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBidlRhYmxlOiB0aGlzXG4gICAgICB9O1xuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIHN0cmlwZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBib3JkZXJlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGJvcmRlcmxlc3M6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBvdXRsaW5lZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGRhcms6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHNtYWxsOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZml4ZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICByZXNwb25zaXZlOiB7XG4gICAgICAgIHR5cGU6IFtCb29sZWFuLCBTdHJpbmddLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHN0aWNreUhlYWRlcjoge1xuICAgICAgICAvLyBJZiBhIHN0cmluZywgaXQgaXMgYXNzdW1lZCB0byBiZSB0aGUgdGFibGUgYG1heC1oZWlnaHRgIHZhbHVlXG4gICAgICAgIHR5cGU6IFtCb29sZWFuLCBTdHJpbmddLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIG5vQm9yZGVyQ29sbGFwc2U6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBjYXB0aW9uVG9wOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgdGFibGVWYXJpYW50OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHRhYmxlQ2xhc3M6IHtcbiAgICAgICAgdHlwZTogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAvLyBMYXlvdXQgcmVsYXRlZCBjb21wdXRlZCBwcm9wc1xuICAgICAgaXNSZXNwb25zaXZlOiBmdW5jdGlvbiBpc1Jlc3BvbnNpdmUoKSB7XG4gICAgICAgIHZhciByZXNwb25zaXZlID0gdGhpcy5yZXNwb25zaXZlID09PSAnJyA/IHRydWUgOiB0aGlzLnJlc3BvbnNpdmU7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU3RhY2tlZCA/IGZhbHNlIDogcmVzcG9uc2l2ZTtcbiAgICAgIH0sXG4gICAgICBpc1N0aWNreUhlYWRlcjogZnVuY3Rpb24gaXNTdGlja3lIZWFkZXIoKSB7XG4gICAgICAgIHZhciBzdGlja3lIZWFkZXIgPSB0aGlzLnN0aWNreUhlYWRlciA9PT0gJycgPyB0cnVlIDogdGhpcy5zdGlja3lIZWFkZXI7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU3RhY2tlZCA/IGZhbHNlIDogc3RpY2t5SGVhZGVyO1xuICAgICAgfSxcbiAgICAgIHdyYXBwZXJDbGFzc2VzOiBmdW5jdGlvbiB3cmFwcGVyQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmlzU3RpY2t5SGVhZGVyID8gJ2ItdGFibGUtc3RpY2t5LWhlYWRlcicgOiAnJywgdGhpcy5pc1Jlc3BvbnNpdmUgPT09IHRydWUgPyAndGFibGUtcmVzcG9uc2l2ZScgOiB0aGlzLmlzUmVzcG9uc2l2ZSA/IFwidGFibGUtcmVzcG9uc2l2ZS1cIi5jb25jYXQodGhpcy5yZXNwb25zaXZlKSA6ICcnXS5maWx0ZXIoaWRlbnRpdHkpO1xuICAgICAgfSxcbiAgICAgIHdyYXBwZXJTdHlsZXM6IGZ1bmN0aW9uIHdyYXBwZXJTdHlsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU3RpY2t5SGVhZGVyICYmICFpc0Jvb2xlYW4odGhpcy5pc1N0aWNreUhlYWRlcikgPyB7XG4gICAgICAgICAgbWF4SGVpZ2h0OiB0aGlzLmlzU3RpY2t5SGVhZGVyXG4gICAgICAgIH0gOiB7fTtcbiAgICAgIH0sXG4gICAgICB0YWJsZUNsYXNzZXM6IGZ1bmN0aW9uIHRhYmxlQ2xhc3NlcygpIHtcbiAgICAgICAgdmFyIGhvdmVyID0gdGhpcy5pc1RhYmxlU2ltcGxlID8gdGhpcy5ob3ZlciA6IHRoaXMuaG92ZXIgJiYgdGhpcy5jb21wdXRlZEl0ZW1zLmxlbmd0aCA+IDAgJiYgIXRoaXMuY29tcHV0ZWRCdXN5O1xuICAgICAgICByZXR1cm4gWy8vIFVzZXIgc3VwcGxpZWQgY2xhc3Nlc1xuICAgICAgICB0aGlzLnRhYmxlQ2xhc3MsIC8vIFN0eWxpbmcgY2xhc3Nlc1xuICAgICAgICB7XG4gICAgICAgICAgJ3RhYmxlLXN0cmlwZWQnOiB0aGlzLnN0cmlwZWQsXG4gICAgICAgICAgJ3RhYmxlLWhvdmVyJzogaG92ZXIsXG4gICAgICAgICAgJ3RhYmxlLWRhcmsnOiB0aGlzLmRhcmssXG4gICAgICAgICAgJ3RhYmxlLWJvcmRlcmVkJzogdGhpcy5ib3JkZXJlZCxcbiAgICAgICAgICAndGFibGUtYm9yZGVybGVzcyc6IHRoaXMuYm9yZGVybGVzcyxcbiAgICAgICAgICAndGFibGUtc20nOiB0aGlzLnNtYWxsLFxuICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlIGItdGFibGUgY3VzdG9tIHN0eWxlc1xuICAgICAgICAgIGJvcmRlcjogdGhpcy5vdXRsaW5lZCxcbiAgICAgICAgICAnYi10YWJsZS1maXhlZCc6IHRoaXMuZml4ZWQsXG4gICAgICAgICAgJ2ItdGFibGUtY2FwdGlvbi10b3AnOiB0aGlzLmNhcHRpb25Ub3AsXG4gICAgICAgICAgJ2ItdGFibGUtbm8tYm9yZGVyLWNvbGxhcHNlJzogdGhpcy5ub0JvcmRlckNvbGxhcHNlXG4gICAgICAgIH0sIHRoaXMudGFibGVWYXJpYW50ID8gXCJcIi5jb25jYXQodGhpcy5kYXJrID8gJ2JnJyA6ICd0YWJsZScsIFwiLVwiKS5jb25jYXQodGhpcy50YWJsZVZhcmlhbnQpIDogJycsIC8vIFN0YWNrZWQgdGFibGUgY2xhc3Nlc1xuICAgICAgICB0aGlzLnN0YWNrZWRUYWJsZUNsYXNzZXMsIC8vIFNlbGVjdGFibGUgY2xhc3Nlc1xuICAgICAgICB0aGlzLnNlbGVjdGFibGVUYWJsZUNsYXNzZXNdO1xuICAgICAgfSxcbiAgICAgIHRhYmxlQXR0cnM6IGZ1bmN0aW9uIHRhYmxlQXR0cnMoKSB7XG4gICAgICAgIC8vIFByZXNlcnZlIHVzZXIgc3VwcGxpZWQgYXJpYS1kZXNjcmliZWRieSwgaWYgcHJvdmlkZWQgaW4gYCRhdHRyc2BcbiAgICAgICAgdmFyIGFkYiA9IFsodGhpcy4kYXR0cnMgfHwge30pWydhcmlhLWRlc2NyaWJlZGJ5J10sIHRoaXMuY2FwdGlvbklkXS5maWx0ZXIoaWRlbnRpdHkpLmpvaW4oJyAnKSB8fCBudWxsO1xuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmNvbXB1dGVkSXRlbXM7XG4gICAgICAgIHZhciBmaWx0ZXJlZEl0ZW1zID0gdGhpcy5maWx0ZXJlZEl0ZW1zO1xuICAgICAgICB2YXIgZmllbGRzID0gdGhpcy5jb21wdXRlZEZpZWxkcztcbiAgICAgICAgdmFyIHNlbGVjdGFibGVBdHRycyA9IHRoaXMuc2VsZWN0YWJsZVRhYmxlQXR0cnMgfHwge307XG4gICAgICAgIHZhciBhcmlhQXR0cnMgPSB0aGlzLmlzVGFibGVTaW1wbGUgPyB7fSA6IHtcbiAgICAgICAgICAnYXJpYS1idXN5JzogdGhpcy5jb21wdXRlZEJ1c3kgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgICAgICdhcmlhLWNvbGNvdW50JzogdG9TdHJpbmckMShmaWVsZHMubGVuZ3RoKSxcbiAgICAgICAgICAnYXJpYS1kZXNjcmliZWRieSc6IGFkYlxuICAgICAgICB9O1xuICAgICAgICB2YXIgcm93Q291bnQgPSBpdGVtcyAmJiBmaWx0ZXJlZEl0ZW1zICYmIGZpbHRlcmVkSXRlbXMubGVuZ3RoID4gaXRlbXMubGVuZ3RoID8gdG9TdHJpbmckMShmaWx0ZXJlZEl0ZW1zLmxlbmd0aCkgOiBudWxsO1xuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIC8vIFdlIHNldCBgYXJpYS1yb3djb3VudGAgYmVmb3JlIG1lcmdpbmcgaW4gYCRhdHRyc2AsXG4gICAgICAgICAgLy8gaW4gY2FzZSB1c2VyIGhhcyBzdXBwbGllZCB0aGVpciBvd25cbiAgICAgICAgICAnYXJpYS1yb3djb3VudCc6IHJvd0NvdW50XG4gICAgICAgIH0sIHRoaXMuJGF0dHJzLCB7XG4gICAgICAgICAgLy8gTm93IHdlIGNhbiBvdmVycmlkZSBhbnkgYCRhdHRyc2AgaGVyZVxuICAgICAgICAgIGlkOiB0aGlzLnNhZmVJZCgpLFxuICAgICAgICAgIHJvbGU6ICd0YWJsZSdcbiAgICAgICAgfSwgYXJpYUF0dHJzLCB7fSwgc2VsZWN0YWJsZUF0dHJzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHZhciAkY29udGVudCA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5pc1RhYmxlU2ltcGxlKSB7XG4gICAgICAgICRjb250ZW50LnB1c2godGhpcy5ub3JtYWxpemVTbG90KCdkZWZhdWx0JykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnVpbGQgdGhlIGA8Y2FwdGlvbj5gIChmcm9tIGNhcHRpb24gbWl4aW4pXG4gICAgICAgICRjb250ZW50LnB1c2godGhpcy5yZW5kZXJDYXB0aW9uID8gdGhpcy5yZW5kZXJDYXB0aW9uKCkgOiBudWxsKTsgLy8gQnVpbGQgdGhlIGA8Y29sZ3JvdXA+YFxuXG4gICAgICAgICRjb250ZW50LnB1c2godGhpcy5yZW5kZXJDb2xncm91cCA/IHRoaXMucmVuZGVyQ29sZ3JvdXAoKSA6IG51bGwpOyAvLyBCdWlsZCB0aGUgYDx0aGVhZD5gXG5cbiAgICAgICAgJGNvbnRlbnQucHVzaCh0aGlzLnJlbmRlclRoZWFkID8gdGhpcy5yZW5kZXJUaGVhZCgpIDogbnVsbCk7IC8vIEJ1aWxkIHRoZSBgPHRib2R5PmBcblxuICAgICAgICAkY29udGVudC5wdXNoKHRoaXMucmVuZGVyVGJvZHkgPyB0aGlzLnJlbmRlclRib2R5KCkgOiBudWxsKTsgLy8gQnVpbGQgdGhlIGA8dGZvb3Q+YFxuXG4gICAgICAgICRjb250ZW50LnB1c2godGhpcy5yZW5kZXJUZm9vdCA/IHRoaXMucmVuZGVyVGZvb3QoKSA6IG51bGwpO1xuICAgICAgfSAvLyBBc3NlbWJsZSBgPHRhYmxlPmBcblxuXG4gICAgICB2YXIgJHRhYmxlID0gaCgndGFibGUnLCB7XG4gICAgICAgIGtleTogJ2ItdGFibGUnLFxuICAgICAgICBzdGF0aWNDbGFzczogJ3RhYmxlIGItdGFibGUnLFxuICAgICAgICBjbGFzczogdGhpcy50YWJsZUNsYXNzZXMsXG4gICAgICAgIGF0dHJzOiB0aGlzLnRhYmxlQXR0cnNcbiAgICAgIH0sICRjb250ZW50LmZpbHRlcihpZGVudGl0eSkpOyAvLyBBZGQgcmVzcG9uc2l2ZS9zdGlja3kgd3JhcHBlciBpZiBuZWVkZWQgYW5kIHJldHVybiB0YWJsZVxuXG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVyQ2xhc3Nlcy5sZW5ndGggPiAwID8gaCgnZGl2Jywge1xuICAgICAgICBrZXk6ICd3cmFwJyxcbiAgICAgICAgY2xhc3M6IHRoaXMud3JhcHBlckNsYXNzZXMsXG4gICAgICAgIHN0eWxlOiB0aGlzLndyYXBwZXJTdHlsZXNcbiAgICAgIH0sIFskdGFibGVdKSA6ICR0YWJsZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQlRhYmxlID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQlRhYmxlJyxcbiAgICAvLyBPcmRlciBvZiBtaXhpbnMgaXMgaW1wb3J0YW50IVxuICAgIC8vIFRoZXkgYXJlIG1lcmdlZCBmcm9tIGZpcnN0IHRvIGxhc3QsIGZvbGxvd2VkIGJ5IHRoaXMgY29tcG9uZW50LlxuICAgIG1peGluczogWy8vIFJlcXVpcmVkIE1peGluc1xuICAgIGhhc0xpc3RlbmVyTWl4aW4sIGlkTWl4aW4sIG5vcm1hbGl6ZVNsb3RNaXhpbiwgaXRlbXNNaXhpbiwgdGFibGVSZW5kZXJlck1peGluLCBzdGFja2VkTWl4aW4sIHRoZWFkTWl4aW4sIHRmb290TWl4aW4sIHRib2R5TWl4aW4sIC8vIEZlYXR1cmVzIE1peGluc1xuICAgIHN0YWNrZWRNaXhpbiwgZmlsdGVyaW5nTWl4aW4sIHNvcnRpbmdNaXhpbiwgcGFnaW5hdGlvbk1peGluJDEsIGNhcHRpb25NaXhpbiwgY29sZ3JvdXBNaXhpbiwgc2VsZWN0YWJsZU1peGluLCBlbXB0eU1peGluLCB0b3BSb3dNaXhpbiwgYm90dG9tUm93TWl4aW4sIGJ1c3lNaXhpbiwgcHJvdmlkZXJNaXhpbl0gLy8gcmVuZGVyIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRhYmxlLXJlbmRlcmVyIG1peGluXG5cbiAgfSk7XG5cbiAgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQlRhYmxlTGl0ZSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JUYWJsZUxpdGUnLFxuICAgIC8vIE9yZGVyIG9mIG1peGlucyBpcyBpbXBvcnRhbnQhXG4gICAgLy8gVGhleSBhcmUgbWVyZ2VkIGZyb20gZmlyc3QgdG8gbGFzdCwgZm9sbG93ZWQgYnkgdGhpcyBjb21wb25lbnQuXG4gICAgbWl4aW5zOiBbLy8gUmVxdWlyZWQgbWl4aW5zXG4gICAgaGFzTGlzdGVuZXJNaXhpbiwgaWRNaXhpbiwgbm9ybWFsaXplU2xvdE1peGluLCBpdGVtc01peGluLCB0YWJsZVJlbmRlcmVyTWl4aW4sIHN0YWNrZWRNaXhpbiwgdGhlYWRNaXhpbiwgdGZvb3RNaXhpbiwgdGJvZHlNaXhpbiwgLy8gRmVhdHVyZXMgTWl4aW5zXG4gICAgLy8gVGhlc2UgYXJlIHByZXR0eSBsaWdodHdlaWdodCwgYW5kIGFyZSB1c2VmdWwgZm9yIGxpZ2h0d2VpZ2h0IHRhYmxlc1xuICAgIGNhcHRpb25NaXhpbiwgY29sZ3JvdXBNaXhpbl0gLy8gcmVuZGVyIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRhYmxlLXJlbmRlcmVyIG1peGluXG5cbiAgfSk7XG5cbiAgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQlRhYmxlU2ltcGxlID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQlRhYmxlU2ltcGxlJyxcbiAgICAvLyBPcmRlciBvZiBtaXhpbnMgaXMgaW1wb3J0YW50IVxuICAgIC8vIFRoZXkgYXJlIG1lcmdlZCBmcm9tIGZpcnN0IHRvIGxhc3QsIGZvbGxvd2VkIGJ5IHRoaXMgY29tcG9uZW50LlxuICAgIG1peGluczogWy8vIFJlcXVpcmVkIG1peGluc1xuICAgIGlkTWl4aW4sIG5vcm1hbGl6ZVNsb3RNaXhpbiwgdGFibGVSZW5kZXJlck1peGluLCAvLyBmZWF0dXJlIG1peGluXG4gICAgLy8gU3RhY2tlZCByZXF1aXJlcyBleHRyYSBoYW5kbGluZyBieSB1c2VycyB2aWFcbiAgICAvLyB0aGUgdGFibGUgY2VsbCBgc3RhY2tlZC1oZWFkaW5nYCBwcm9wXG4gICAgc3RhY2tlZE1peGluXSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgaXNUYWJsZVNpbXBsZTogZnVuY3Rpb24gaXNUYWJsZVNpbXBsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSAvLyByZW5kZXIgZnVuY3Rpb24gcHJvdmlkZWQgYnkgdGFibGUtcmVuZGVyZXIgbWl4aW5cblxuICB9KTtcblxuICB2YXIgVGFibGVMaXRlUGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBCVGFibGVMaXRlOiBCVGFibGVMaXRlXG4gICAgfVxuICB9KTtcbiAgdmFyIFRhYmxlU2ltcGxlUGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBCVGFibGVTaW1wbGU6IEJUYWJsZVNpbXBsZSxcbiAgICAgIEJUYm9keTogQlRib2R5LFxuICAgICAgQlRoZWFkOiBCVGhlYWQsXG4gICAgICBCVGZvb3Q6IEJUZm9vdCxcbiAgICAgIEJUcjogQlRyLFxuICAgICAgQlRkOiBCVGQsXG4gICAgICBCVGg6IEJUaFxuICAgIH1cbiAgfSk7XG4gIHZhciBUYWJsZVBsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgY29tcG9uZW50czoge1xuICAgICAgQlRhYmxlOiBCVGFibGVcbiAgICB9LFxuICAgIHBsdWdpbnM6IHtcbiAgICAgIFRhYmxlTGl0ZVBsdWdpbjogVGFibGVMaXRlUGx1Z2luLFxuICAgICAgVGFibGVTaW1wbGVQbHVnaW46IFRhYmxlU2ltcGxlUGx1Z2luXG4gICAgfVxuICB9KTtcblxuICB2YXIgbmF2UHJvcHMgPSBvbWl0KHByb3BzJEksIFsndGFicycsICdpc05hdkJhcicsICdjYXJkSGVhZGVyJ10pOyAvLyAtLSBVdGlscyAtLVxuICAvLyBGaWx0ZXIgZnVuY3Rpb24gdG8gZmlsdGVyIG91dCBkaXNhYmxlZCB0YWJzXG5cbiAgdmFyIG5vdERpc2FibGVkID0gZnVuY3Rpb24gbm90RGlzYWJsZWQodGFiKSB7XG4gICAgcmV0dXJuICF0YWIuZGlzYWJsZWQ7XG4gIH07IC8vIC0tLSBIZWxwZXIgY29tcG9uZW50cyAtLS1cbiAgLy8gQHZ1ZS9jb21wb25lbnRcblxuXG4gIHZhciBCVGFiQnV0dG9uSGVscGVyID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAnQlRhYkJ1dHRvbkhlbHBlcicsXG4gICAgaW5qZWN0OiB7XG4gICAgICBidlRhYnM6IHtcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgLy8gUmVmZXJlbmNlIHRvIHRoZSBjaGlsZCA8Yi10YWI+IGluc3RhbmNlXG4gICAgICB0YWI6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHRhYnM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KClcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlkOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIGNvbnRyb2xzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHRhYkluZGV4OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHBvc0luU2V0OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHNldFNpemU6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgbm9LZXlOYXY6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuJHJlZnMgJiYgdGhpcy4kcmVmcy5saW5rICYmIHRoaXMuJHJlZnMubGluay5mb2N1cykge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGluay5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFuZGxlRXZ0OiBmdW5jdGlvbiBoYW5kbGVFdnQoZXZ0KSB7XG4gICAgICAgIHZhciBzdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMudGFiLmRpc2FibGVkKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHlwZSA9IGV2dC50eXBlO1xuICAgICAgICB2YXIga2V5ID0gZXZ0LmtleUNvZGU7XG4gICAgICAgIHZhciBzaGlmdCA9IGV2dC5zaGlmdEtleTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2tleWRvd24nICYmIGtleSA9PT0gS0VZX0NPREVTLlNQQUNFKSB7XG4gICAgICAgICAgLy8gRm9yIEFSSUEgdGFicyB0aGUgU1BBQ0Uga2V5IHdpbGwgYWxzbyB0cmlnZ2VyIGEgY2xpY2svc2VsZWN0XG4gICAgICAgICAgLy8gRXZlbiB3aXRoIGtleWJvYXJkIG5hdmlnYXRpb24gZGlzYWJsZWQsIFNQQUNFIHNob3VsZCBcImNsaWNrXCIgdGhlIGJ1dHRvblxuICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Jvb3RzdHJhcC12dWUvYm9vdHN0cmFwLXZ1ZS9pc3N1ZXMvNDMyM1xuICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2tleWRvd24nICYmICF0aGlzLm5vS2V5TmF2KSB7XG4gICAgICAgICAgLy8gRm9yIGtleWJvYXJkIG5hdmlnYXRpb25cbiAgICAgICAgICBpZiAoa2V5ID09PSBLRVlfQ09ERVMuVVAgfHwga2V5ID09PSBLRVlfQ09ERVMuTEVGVCB8fCBrZXkgPT09IEtFWV9DT0RFUy5IT01FKSB7XG4gICAgICAgICAgICBzdG9wKCk7XG5cbiAgICAgICAgICAgIGlmIChzaGlmdCB8fCBrZXkgPT09IEtFWV9DT0RFUy5IT01FKSB7XG4gICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2ZpcnN0JywgZXZ0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3ByZXYnLCBldnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBLRVlfQ09ERVMuRE9XTiB8fCBrZXkgPT09IEtFWV9DT0RFUy5SSUdIVCB8fCBrZXkgPT09IEtFWV9DT0RFUy5FTkQpIHtcbiAgICAgICAgICAgIHN0b3AoKTtcblxuICAgICAgICAgICAgaWYgKHNoaWZ0IHx8IGtleSA9PT0gS0VZX0NPREVTLkVORCkge1xuICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdsYXN0JywgZXZ0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ25leHQnLCBldnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgdmFyIGxpbmsgPSBoKEJMaW5rLCB7XG4gICAgICAgIHJlZjogJ2xpbmsnLFxuICAgICAgICBzdGF0aWNDbGFzczogJ25hdi1saW5rJyxcbiAgICAgICAgY2xhc3M6IFt7XG4gICAgICAgICAgYWN0aXZlOiB0aGlzLnRhYi5sb2NhbEFjdGl2ZSAmJiAhdGhpcy50YWIuZGlzYWJsZWQsXG4gICAgICAgICAgZGlzYWJsZWQ6IHRoaXMudGFiLmRpc2FibGVkXG4gICAgICAgIH0sIHRoaXMudGFiLnRpdGxlTGlua0NsYXNzLCAvLyBBcHBseSA8Yi10YWJzPiBgYWN0aXZlTmF2SXRlbUNsYXNzYCBzdHlsZXMgd2hlbiB0aGUgdGFiIGlzIGFjdGl2ZVxuICAgICAgICB0aGlzLnRhYi5sb2NhbEFjdGl2ZSA/IHRoaXMuYnZUYWJzLmFjdGl2ZU5hdkl0ZW1DbGFzcyA6IG51bGxdLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGRpc2FibGVkOiB0aGlzLnRhYi5kaXNhYmxlZFxuICAgICAgICB9LFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHJvbGU6ICd0YWInLFxuICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgIC8vIFJvdmluZyB0YWIgaW5kZXggd2hlbiBrZXluYXYgZW5hYmxlZFxuICAgICAgICAgIHRhYmluZGV4OiB0aGlzLnRhYkluZGV4LFxuICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogdGhpcy50YWIubG9jYWxBY3RpdmUgJiYgIXRoaXMudGFiLmRpc2FibGVkID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgICAnYXJpYS1zZXRzaXplJzogdGhpcy5zZXRTaXplLFxuICAgICAgICAgICdhcmlhLXBvc2luc2V0JzogdGhpcy5wb3NJblNldCxcbiAgICAgICAgICAnYXJpYS1jb250cm9scyc6IHRoaXMuY29udHJvbHNcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBjbGljazogdGhpcy5oYW5kbGVFdnQsXG4gICAgICAgICAga2V5ZG93bjogdGhpcy5oYW5kbGVFdnRcbiAgICAgICAgfVxuICAgICAgfSwgW3RoaXMudGFiLm5vcm1hbGl6ZVNsb3QoJ3RpdGxlJykgfHwgdGhpcy50YWIudGl0bGVdKTtcbiAgICAgIHJldHVybiBoKCdsaScsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICduYXYtaXRlbScsXG4gICAgICAgIGNsYXNzOiBbdGhpcy50YWIudGl0bGVJdGVtQ2xhc3NdLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nXG4gICAgICAgIH1cbiAgICAgIH0sIFtsaW5rXSk7XG4gICAgfVxuICB9KTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQlRhYnMgPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCVGFicycsXG4gICAgbWl4aW5zOiBbaWRNaXhpbiwgbm9ybWFsaXplU2xvdE1peGluXSxcbiAgICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnZUYWJzOiB0aGlzXG4gICAgICB9O1xuICAgIH0sXG4gICAgbW9kZWw6IHtcbiAgICAgIHByb3A6ICd2YWx1ZScsXG4gICAgICBldmVudDogJ2lucHV0J1xuICAgIH0sXG4gICAgcHJvcHM6IF9vYmplY3RTcHJlYWQyKHt9LCBuYXZQcm9wcywge1xuICAgICAgdGFnOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ2RpdidcbiAgICAgIH0sXG4gICAgICBjYXJkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZW5kOiB7XG4gICAgICAgIC8vIFN5bm9ueW0gZm9yICdib3R0b20nXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgbm9GYWRlOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgbm9OYXZTdHlsZToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIG5vS2V5TmF2OiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgbGF6eToge1xuICAgICAgICAvLyBUaGlzIHByb3AgaXMgc25pZmZlZCBieSB0aGUgPGItdGFiPiBjaGlsZFxuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGNvbnRlbnRDbGFzczoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIG5hdkNsYXNzOiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgbmF2V3JhcHBlckNsYXNzOiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgYWN0aXZlTmF2SXRlbUNsYXNzOiB7XG4gICAgICAgIC8vIE9ubHkgYXBwbGllZCB0byB0aGUgY3VycmVudGx5IGFjdGl2ZSA8Yi1uYXYtaXRlbT5cbiAgICAgICAgdHlwZTogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBhY3RpdmVUYWJDbGFzczoge1xuICAgICAgICAvLyBPbmx5IGFwcGxpZWQgdG8gdGhlIGN1cnJlbnRseSBhY3RpdmUgPGItdGFiPlxuICAgICAgICAvLyBUaGlzIHByb3AgaXMgc25pZmZlZCBieSB0aGUgPGItdGFiPiBjaGlsZFxuICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSxcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIC8vIHYtbW9kZWxcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9XG4gICAgfSksXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHZhciB0YWJJZHggPSBwYXJzZUludCh0aGlzLnZhbHVlLCAxMCk7XG4gICAgICB0YWJJZHggPSBpc05hTih0YWJJZHgpID8gLTEgOiB0YWJJZHg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBJbmRleCBvZiBjdXJyZW50IHRhYlxuICAgICAgICBjdXJyZW50VGFiOiB0YWJJZHgsXG4gICAgICAgIC8vIEFycmF5IG9mIGRpcmVjdCBjaGlsZCA8Yi10YWI+IGluc3RhbmNlcywgaW4gRE9NIG9yZGVyXG4gICAgICAgIHRhYnM6IFtdLFxuICAgICAgICAvLyBBcnJheSBvZiBjaGlsZCBpbnN0YW5jZXMgcmVnaXN0ZXJlZCAoZm9yIHRyaWdnZXJpbmcgcmVhY3RpdmUgdXBkYXRlcylcbiAgICAgICAgcmVnaXN0ZXJlZFRhYnM6IFtdLFxuICAgICAgICAvLyBGbGFnIHRvIGtub3cgaWYgd2UgYXJlIG1vdW50ZWQgb3Igbm90XG4gICAgICAgIGlzTW91bnRlZDogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgZmFkZTogZnVuY3Rpb24gZmFkZSgpIHtcbiAgICAgICAgLy8gVGhpcyBjb21wdXRlZCBwcm9wIGlzIHNuaWZmZWQgYnkgdGhlIHRhYiBjaGlsZFxuICAgICAgICByZXR1cm4gIXRoaXMubm9GYWRlO1xuICAgICAgfSxcbiAgICAgIGxvY2FsTmF2Q2xhc3M6IGZ1bmN0aW9uIGxvY2FsTmF2Q2xhc3MoKSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuY2FyZCAmJiB0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgY2xhc3Nlcy5wdXNoKCdjYXJkLWhlYWRlcicsICdoLTEwMCcsICdib3JkZXItYm90dG9tLTAnLCAncm91bmRlZC0wJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW10uY29uY2F0KGNsYXNzZXMsIFt0aGlzLm5hdkNsYXNzXSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgY3VycmVudFRhYjogZnVuY3Rpb24gY3VycmVudFRhYihuZXdWYWwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7IC8vIEVuc3VyZSBvbmx5IG9uZSB0YWIgaXMgYWN0aXZlIGF0IG1vc3RcblxuICAgICAgICB0aGlzLnRhYnMuZm9yRWFjaChmdW5jdGlvbiAodGFiLCBpZHgpIHtcbiAgICAgICAgICBpZiAobmV3VmFsID09PSBpZHggJiYgIXRhYi5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGFiLmxvY2FsQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZGV4ID0gaWR4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YWIubG9jYWxBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBVcGRhdGUgdGhlIHYtbW9kZWxcblxuICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIGluZGV4KTtcbiAgICAgIH0sXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgaWYgKG5ld1ZhbCAhPT0gb2xkVmFsKSB7XG4gICAgICAgICAgbmV3VmFsID0gcGFyc2VJbnQobmV3VmFsLCAxMCk7XG4gICAgICAgICAgbmV3VmFsID0gaXNOYU4obmV3VmFsKSA/IC0xIDogbmV3VmFsO1xuICAgICAgICAgIG9sZFZhbCA9IHBhcnNlSW50KG9sZFZhbCwgMTApIHx8IDA7XG4gICAgICAgICAgdmFyIHRhYnMgPSB0aGlzLnRhYnM7XG5cbiAgICAgICAgICBpZiAodGFic1tuZXdWYWxdICYmICF0YWJzW25ld1ZhbF0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVUYWIodGFic1tuZXdWYWxdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJ5IG5leHQgb3IgcHJldiB0YWJzXG4gICAgICAgICAgICBpZiAobmV3VmFsIDwgb2xkVmFsKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJldmlvdXNUYWIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMubmV4dFRhYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyZWRUYWJzOiBmdW5jdGlvbiByZWdpc3RlcmVkVGFicygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAvLyBFYWNoIGItdGFiIHdpbGwgcmVnaXN0ZXIvdW5yZWdpc3RlciBpdHNlbGYuXG4gICAgICAgIC8vIFdlIHVzZSB0aGlzIHRvIGRldGVjdCB3aGVuIHRhYnMgYXJlIGFkZGVkL3JlbW92ZWRcbiAgICAgICAgLy8gdG8gdHJpZ2dlciB0aGUgdXBkYXRlIG9mIHRoZSB0YWJzLlxuICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVxdWVzdEFGKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZVRhYnMoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdGFiczogZnVuY3Rpb24gdGFicyhuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAvLyBJZiB0YWJzIGFkZGVkLCByZW1vdmVkLCBvciByZS1vcmRlcmVkLCB3ZSBlbWl0IGEgYGNoYW5nZWRgIGV2ZW50LlxuICAgICAgICAvLyBXZSB1c2UgYHRhYi5fdWlkYCBpbnN0ZWFkIG9mIGB0YWIuc2FmZUlkKClgLCBhcyB0aGUgbGF0ZXIgaXMgY2hhbmdlZFxuICAgICAgICAvLyBpbiBhIG5leHRUaWNrIGlmIG5vIGV4cGxpY2l0IElEIGlzIHByb3ZpZGVkLCBjYXVzaW5nIGR1cGxpY2F0ZSBlbWl0cy5cbiAgICAgICAgaWYgKCFsb29zZUVxdWFsKG5ld1ZhbC5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5fdWlkO1xuICAgICAgICB9KSwgb2xkVmFsLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0Ll91aWQ7XG4gICAgICAgIH0pKSkge1xuICAgICAgICAgIC8vIEluIGEgbmV4dFRpY2sgdG8gZW5zdXJlIGN1cnJlbnRUYWIgaGFzIGJlZW4gc2V0IGZpcnN0LlxuICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFdlIGVtaXQgc2hhbGxvdyBjb3BpZXMgb2YgdGhlIG5ldyBhbmQgb2xkIGFycmF5cyBvZiB0YWJzLCB0b1xuICAgICAgICAgICAgLy8gcHJldmVudCB1c2VycyBmcm9tIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBpbnRlcm5hbCBhcnJheXMuXG4gICAgICAgICAgICBfdGhpczIuJGVtaXQoJ2NoYW5nZWQnLCBuZXdWYWwuc2xpY2UoKSwgb2xkVmFsLnNsaWNlKCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXNNb3VudGVkOiBmdW5jdGlvbiBpc01vdW50ZWQobmV3VmFsKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIC8vIFRyaWdnZXIgYW4gdXBkYXRlIGFmdGVyIG1vdW50ZWQuICBOZWVkZWQgZm9yIHRhYnMgaW5zaWRlIGxhenkgbW9kYWxzLlxuICAgICAgICBpZiAobmV3VmFsKSB7XG4gICAgICAgICAgcmVxdWVzdEFGKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51cGRhdGVUYWJzKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gRW5hYmxlIG9yIGRpc2FibGUgdGhlIG9ic2VydmVyXG5cblxuICAgICAgICB0aGlzLnNldE9ic2VydmVyKG5ld1ZhbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciB0YWJJZHggPSBwYXJzZUludCh0aGlzLnZhbHVlLCAxMCk7XG4gICAgICB0aGlzLmN1cnJlbnRUYWIgPSBpc05hTih0YWJJZHgpID8gLTEgOiB0YWJJZHg7XG4gICAgICB0aGlzLl9idk9ic2VydmVyID0gbnVsbDsgLy8gRm9yIFNTUiBhbmQgdG8gbWFrZSBzdXJlIG9ubHkgYSBzaW5nbGUgdGFiIGlzIHNob3duIG9uIG1vdW50XG4gICAgICAvLyBXZSB3cmFwIHRoaXMgaW4gYSBgJG5leHRUaWNrKClgIHRvIGVuc3VyZSB0aGUgY2hpbGQgdGFicyBoYXZlIGJlZW4gY3JlYXRlZFxuXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNC51cGRhdGVUYWJzKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgLy8gQ2FsbCBgdXBkYXRlVGFicygpYCBqdXN0IGluIGNhc2UuLi5cbiAgICAgIHRoaXMudXBkYXRlVGFicygpO1xuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGbGFnIHdlIGFyZSBub3cgbW91bnRlZCBhbmQgdG8gc3dpdGNoIHRvIERPTSBmb3IgdGFiIHByb2JpbmcuXG4gICAgICAgIC8vIEFzIHRoaXMuJHNsb3RzLmRlZmF1bHQgYXBwZWFycyB0byBsaWUgYWJvdXQgY29tcG9uZW50IGluc3RhbmNlc1xuICAgICAgICAvLyBhZnRlciBiLXRhYnMgaXMgZGVzdHJveWVkIGFuZCByZS1pbnN0YW50aWF0ZWQuXG4gICAgICAgIC8vIEFuZCB0aGlzLiRjaGlsZHJlbiBkb2VzIG5vdCByZXNwZWN0IERPTSBvcmRlci5cbiAgICAgICAgX3RoaXM1LmlzTW91bnRlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlYWN0aXZhdGVkOiBmdW5jdGlvbiBkZWFjdGl2YXRlZCgpXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB7XG4gICAgICB0aGlzLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgIH0sXG4gICAgYWN0aXZhdGVkOiBmdW5jdGlvbiBhY3RpdmF0ZWQoKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHZhciB0YWJJZHggPSBwYXJzZUludCh0aGlzLnZhbHVlLCAxMCk7XG4gICAgICB0aGlzLmN1cnJlbnRUYWIgPSBpc05hTih0YWJJZHgpID8gLTEgOiB0YWJJZHg7XG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNi51cGRhdGVUYWJzKCk7XG5cbiAgICAgICAgX3RoaXM2LmlzTW91bnRlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgICB0aGlzLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQoKSB7XG4gICAgICAvLyBFbnN1cmUgbm8gcmVmZXJlbmNlcyB0byBjaGlsZCBpbnN0YW5jZXMgZXhpc3RcbiAgICAgIHRoaXMudGFicyA9IFtdO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgcmVnaXN0ZXJUYWI6IGZ1bmN0aW9uIHJlZ2lzdGVyVGFiKHRhYikge1xuICAgICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgICBpZiAoIWFycmF5SW5jbHVkZXModGhpcy5yZWdpc3RlcmVkVGFicywgdGFiKSkge1xuICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZFRhYnMucHVzaCh0YWIpO1xuICAgICAgICAgIHRhYi4kb25jZSgnaG9vazpkZXN0cm95ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczcudW5yZWdpc3RlclRhYih0YWIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdW5yZWdpc3RlclRhYjogZnVuY3Rpb24gdW5yZWdpc3RlclRhYih0YWIpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkVGFicyA9IHRoaXMucmVnaXN0ZXJlZFRhYnMuc2xpY2UoKS5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCAhPT0gdGFiO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzZXRPYnNlcnZlcjogZnVuY3Rpb24gc2V0T2JzZXJ2ZXIob24pIHtcbiAgICAgICAgLy8gRE9NIG9ic2VydmVyIGlzIG5lZWRlZCB0byBkZXRlY3QgY2hhbmdlcyBpbiBvcmRlciBvZiB0YWJzXG4gICAgICAgIGlmIChvbikge1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBubyBleGlzdGluZyBvYnNlcnZlciBydW5uaW5nXG4gICAgICAgICAgdGhpcy5zZXRPYnNlcnZlcihmYWxzZSk7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gdGVzdCBtdXRhdGlvbiBvYnNlcnZlciBpbiBKU0RPTSAqL1xuXG4gICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICAgICAgLy8gV2UgZGVsYXkgdGhlIHVwZGF0ZSB0byBlbnN1cmUgdGhhdCBgdGFiLnNhZmVJZCgpYCBoYXNcbiAgICAgICAgICAgIC8vIHVwZGF0ZWQgd2l0aCB0aGUgZmluYWwgSUQgdmFsdWUuXG4gICAgICAgICAgICBzZWxmLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3RBRihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVUYWJzKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTsgLy8gV2F0Y2ggZm9yIGNoYW5nZXMgdG8gPGItdGFiPiBzdWIgY29tcG9uZW50c1xuXG5cbiAgICAgICAgICB0aGlzLl9idk9ic2VydmVyID0gb2JzZXJ2ZURvbSh0aGlzLiRyZWZzLnRhYnNDb250YWluZXIsIGhhbmRsZXIsIHtcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgIHN1YnRyZWU6IGZhbHNlLFxuICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogWydpZCddXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2J2T2JzZXJ2ZXIgJiYgdGhpcy5fYnZPYnNlcnZlci5kaXNjb25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9idk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9idk9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldFRhYnM6IGZ1bmN0aW9uIGdldFRhYnMoKSB7XG4gICAgICAgIC8vIFdlIHVzZSByZWdpc3RlcmVkVGFicyBhcyB0aGUgc291cmNlIG9mIHRydXRoIGZvciBjaGlsZCB0YWIgY29tcG9uZW50cy4gQW5kIHdlXG4gICAgICAgIC8vIGZpbHRlciBvdXQgYW55IEJUYWIgY29tcG9uZW50cyB0aGF0IGFyZSBleHRlbmRlZCBCVGFiIHdpdGggYSByb290IGNoaWxkIEJUYWIuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ib290c3RyYXAtdnVlL2Jvb3RzdHJhcC12dWUvaXNzdWVzLzMyNjBcbiAgICAgICAgdmFyIHRhYnMgPSB0aGlzLnJlZ2lzdGVyZWRUYWJzLmZpbHRlcihmdW5jdGlvbiAodGFiKSB7XG4gICAgICAgICAgcmV0dXJuIHRhYi4kY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdC5faXNUYWI7XG4gICAgICAgICAgfSkubGVuZ3RoID09PSAwO1xuICAgICAgICB9KTsgLy8gRE9NIE9yZGVyIG9mIFRhYnNcblxuICAgICAgICB2YXIgb3JkZXIgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5pc01vdW50ZWQgJiYgdGFicy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gV2UgcmVseSBvbiB0aGUgRE9NIHdoZW4gbW91bnRlZCB0byBnZXQgdGhlICd0cnVlJyBvcmRlciBvZiB0aGUgYi10YWIgY2hpbGRyZW4uXG4gICAgICAgICAgLy8gcXVlcnlTZWxlY3RvckFsbCguLi4pIGFsd2F5cyByZXR1cm5zIGVsZW1lbnRzIGluIGRvY3VtZW50IG9yZGVyLCByZWdhcmRsZXNzIG9mXG4gICAgICAgICAgLy8gb3JkZXIgc3BlY2lmaWVkIGluIHRoZSBzZWxlY3Rvci5cbiAgICAgICAgICB2YXIgc2VsZWN0b3IgPSB0YWJzLm1hcChmdW5jdGlvbiAodGFiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIjXCIuY29uY2F0KHRhYi5zYWZlSWQoKSk7XG4gICAgICAgICAgfSkuam9pbignLCAnKTtcbiAgICAgICAgICBvcmRlciA9IHNlbGVjdEFsbChzZWxlY3RvciwgdGhpcy4kZWwpLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5pZDtcbiAgICAgICAgICB9KS5maWx0ZXIoaWRlbnRpdHkpO1xuICAgICAgICB9IC8vIFN0YWJsZSBzb3J0IGtlZXBzIHRoZSBvcmlnaW5hbCBvcmRlciBpZiBub3QgZm91bmQgaW4gdGhlXG4gICAgICAgIC8vIGBvcmRlcmAgYXJyYXksIHdoaWNoIHdpbGwgYmUgYW4gZW1wdHkgYXJyYXkgYmVmb3JlIG1vdW50LlxuXG5cbiAgICAgICAgcmV0dXJuIHN0YWJsZVNvcnQodGFicywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gb3JkZXIuaW5kZXhPZihhLnNhZmVJZCgpKSAtIG9yZGVyLmluZGV4T2YoYi5zYWZlSWQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIC8vIFVwZGF0ZSBsaXN0IG9mIDxiLXRhYj4gY2hpbGRyZW5cbiAgICAgIHVwZGF0ZVRhYnM6IGZ1bmN0aW9uIHVwZGF0ZVRhYnMoKSB7XG4gICAgICAgIC8vIFByb2JlIHRhYnNcbiAgICAgICAgdmFyIHRhYnMgPSB0aGlzLmdldFRhYnMoKTsgLy8gRmluZCAqbGFzdCogYWN0aXZlIG5vbi1kaXNhYmxlZCB0YWIgaW4gY3VycmVudCB0YWJzXG4gICAgICAgIC8vIFdlIHRydXN0IHRhYiBzdGF0ZSBvdmVyIGN1cnJlbnRUYWIsIGluIGNhc2UgdGFicyB3ZXJlIGFkZGVkL3JlbW92ZWQvcmUtb3JkZXJlZFxuXG4gICAgICAgIHZhciB0YWJJbmRleCA9IHRhYnMuaW5kZXhPZih0YWJzLnNsaWNlKCkucmV2ZXJzZSgpLmZpbmQoZnVuY3Rpb24gKHRhYikge1xuICAgICAgICAgIHJldHVybiB0YWIubG9jYWxBY3RpdmUgJiYgIXRhYi5kaXNhYmxlZDtcbiAgICAgICAgfSkpOyAvLyBFbHNlIHRyeSBzZXR0aW5nIHRvIGN1cnJlbnRUYWJcblxuICAgICAgICBpZiAodGFiSW5kZXggPCAwKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRUYWIgPSB0aGlzLmN1cnJlbnRUYWI7XG5cbiAgICAgICAgICBpZiAoY3VycmVudFRhYiA+PSB0YWJzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGxhc3QgdGFiIGJlaW5nIHJlbW92ZWQsIHNvIGZpbmQgdGhlIGxhc3Qgbm9uLWRpc2FibGVkIHRhYlxuICAgICAgICAgICAgdGFiSW5kZXggPSB0YWJzLmluZGV4T2YodGFicy5zbGljZSgpLnJldmVyc2UoKS5maW5kKG5vdERpc2FibGVkKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0YWJzW2N1cnJlbnRUYWJdICYmICF0YWJzW2N1cnJlbnRUYWJdLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAvLyBDdXJyZW50IHRhYiBpcyBub3QgZGlzYWJsZWRcbiAgICAgICAgICAgIHRhYkluZGV4ID0gY3VycmVudFRhYjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRWxzZSBmaW5kICpmaXJzdCogbm9uLWRpc2FibGVkIHRhYiBpbiBjdXJyZW50IHRhYnNcblxuXG4gICAgICAgIGlmICh0YWJJbmRleCA8IDApIHtcbiAgICAgICAgICB0YWJJbmRleCA9IHRhYnMuaW5kZXhPZih0YWJzLmZpbmQobm90RGlzYWJsZWQpKTtcbiAgICAgICAgfSAvLyBTZXQgdGhlIGN1cnJlbnQgdGFiIHN0YXRlIHRvIGFjdGl2ZVxuXG5cbiAgICAgICAgdGFicy5mb3JFYWNoKGZ1bmN0aW9uICh0YWIpIHtcbiAgICAgICAgICAvLyB0YWIubG9jYWxBY3RpdmUgPSBpZHggPT09IHRhYkluZGV4ICYmICF0YWIuZGlzYWJsZWRcbiAgICAgICAgICB0YWIubG9jYWxBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRhYnNbdGFiSW5kZXhdKSB7XG4gICAgICAgICAgdGFic1t0YWJJbmRleF0ubG9jYWxBY3RpdmUgPSB0cnVlO1xuICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgYXJyYXkgb2YgdGFiIGNoaWxkcmVuXG5cblxuICAgICAgICB0aGlzLnRhYnMgPSB0YWJzOyAvLyBTZXQgdGhlIGN1cnJlbnRUYWIgaW5kZXggKGNhbiBiZSAtMSBpZiBubyBub24tZGlzYWJsZWQgdGFicylcblxuICAgICAgICB0aGlzLmN1cnJlbnRUYWIgPSB0YWJJbmRleDtcbiAgICAgIH0sXG4gICAgICAvLyBGaW5kIGEgYnV0dG9uIHRoYXQgY29udHJvbHMgYSB0YWIsIGdpdmVuIHRoZSB0YWIgcmVmZXJlbmNlXG4gICAgICAvLyBSZXR1cm5zIHRoZSBidXR0b24gdm0gaW5zdGFuY2VcbiAgICAgIGdldEJ1dHRvbkZvclRhYjogZnVuY3Rpb24gZ2V0QnV0dG9uRm9yVGFiKHRhYikge1xuICAgICAgICByZXR1cm4gKHRoaXMuJHJlZnMuYnV0dG9ucyB8fCBbXSkuZmluZChmdW5jdGlvbiAoYnRuKSB7XG4gICAgICAgICAgcmV0dXJuIGJ0bi50YWIgPT09IHRhYjtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgLy8gRm9yY2UgYSBidXR0b24gdG8gcmUtcmVuZGVyIGl0cyBjb250ZW50LCBnaXZlbiBhIDxiLXRhYj4gaW5zdGFuY2VcbiAgICAgIC8vIENhbGxlZCBieSA8Yi10YWI+IG9uIGB1cGRhdGUoKWBcbiAgICAgIHVwZGF0ZUJ1dHRvbjogZnVuY3Rpb24gdXBkYXRlQnV0dG9uKHRhYikge1xuICAgICAgICB2YXIgYnV0dG9uID0gdGhpcy5nZXRCdXR0b25Gb3JUYWIodGFiKTtcblxuICAgICAgICBpZiAoYnV0dG9uICYmIGJ1dHRvbi4kZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgICBidXR0b24uJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBY3RpdmF0ZSBhIHRhYiBnaXZlbiBhIDxiLXRhYj4gaW5zdGFuY2VcbiAgICAgIC8vIEFsc28gYWNjZXNzZWQgYnkgPGItdGFiPlxuICAgICAgYWN0aXZhdGVUYWI6IGZ1bmN0aW9uIGFjdGl2YXRlVGFiKHRhYikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRhYikge1xuICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMudGFicy5pbmRleE9mKHRhYik7XG5cbiAgICAgICAgICBpZiAoIXRhYi5kaXNhYmxlZCAmJiBpbmRleCA+IC0xICYmIGluZGV4ICE9PSB0aGlzLmN1cnJlbnRUYWIpIHtcbiAgICAgICAgICAgIHZhciB0YWJFdnQgPSBuZXcgQnZFdmVudCgnYWN0aXZhdGUtdGFiJywge1xuICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2dWVUYXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgIGNvbXBvbmVudElkOiB0aGlzLnNhZmVJZCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQodGFiRXZ0LnR5cGUsIGluZGV4LCB0aGlzLmN1cnJlbnRUYWIsIHRhYkV2dCk7XG5cbiAgICAgICAgICAgIGlmICghdGFiRXZ0LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VGFiID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENvdWxkbid0IHNldCB0YWIsIHNvIGVuc3VyZSB2LW1vZGVsIGlzIHNldCB0byBgdGhpcy5jdXJyZW50VGFiYFxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgcmFyZWx5IGhhcHBlbiAqL1xuXG5cbiAgICAgICAgaWYgKCFyZXN1bHQgJiYgdGhpcy5jdXJyZW50VGFiICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB0aGlzLmN1cnJlbnRUYWIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICAvLyBEZWFjdGl2YXRlIGEgdGFiIGdpdmVuIGEgPGItdGFiPiBpbnN0YW5jZVxuICAgICAgLy8gQWNjZXNzZWQgYnkgPGItdGFiPlxuICAgICAgZGVhY3RpdmF0ZVRhYjogZnVuY3Rpb24gZGVhY3RpdmF0ZVRhYih0YWIpIHtcbiAgICAgICAgaWYgKHRhYikge1xuICAgICAgICAgIC8vIEZpbmQgZmlyc3Qgbm9uLWRpc2FibGVkIHRhYiB0aGF0IGlzbid0IHRoZSBvbmUgYmVpbmcgZGVhY3RpdmF0ZWRcbiAgICAgICAgICAvLyBJZiBubyB0YWJzIGFyZSBhdmFpbGFibGUsIHRoZW4gZG9uJ3QgZGVhY3RpdmF0ZSBjdXJyZW50IHRhYlxuICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlVGFiKHRoaXMudGFicy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ICE9PSB0YWI7XG4gICAgICAgICAgfSkuZmluZChub3REaXNhYmxlZCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgbmV2ZXIvcmFyZWx5IGhhcHBlbiAqL1xuXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIC8vIEZvY3VzIGEgdGFiIGJ1dHRvbiBnaXZlbiBpdHMgPGItdGFiPiBpbnN0YW5jZVxuICAgICAgZm9jdXNCdXR0b246IGZ1bmN0aW9uIGZvY3VzQnV0dG9uKHRhYikge1xuICAgICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgICAvLyBXcmFwIGluIGAkbmV4dFRpY2soKWAgdG8gZW5zdXJlIERPTSBoYXMgY29tcGxldGVkIHJlbmRlcmluZy91cGRhdGluZyBiZWZvcmUgZm9jdXNpbmdcbiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBidXR0b24gPSBfdGhpczguZ2V0QnV0dG9uRm9yVGFiKHRhYik7XG5cbiAgICAgICAgICBpZiAoYnV0dG9uICYmIGJ1dHRvbi5mb2N1cykge1xuICAgICAgICAgICAgYnV0dG9uLmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAvLyBFbWl0IGEgY2xpY2sgZXZlbnQgb24gYSBzcGVjaWZpZWQgPGItdGFiPiBjb21wb25lbnQgaW5zdGFuY2VcbiAgICAgIGVtaXRUYWJDbGljazogZnVuY3Rpb24gZW1pdFRhYkNsaWNrKHRhYiwgZXZ0KSB7XG4gICAgICAgIGlmIChpc0V2ZW50KGV2dCkgJiYgdGFiICYmIHRhYi4kZW1pdCAmJiAhdGFiLmRpc2FibGVkKSB7XG4gICAgICAgICAgdGFiLiRlbWl0KCdjbGljaycsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBDbGljayBoYW5kbGVyXG4gICAgICBjbGlja1RhYjogZnVuY3Rpb24gY2xpY2tUYWIodGFiLCBldnQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZVRhYih0YWIpO1xuICAgICAgICB0aGlzLmVtaXRUYWJDbGljayh0YWIsIGV2dCk7XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSB0byBmaXJzdCBub24tZGlzYWJsZWQgdGFiXG4gICAgICBmaXJzdFRhYjogZnVuY3Rpb24gZmlyc3RUYWIoZm9jdXMpIHtcbiAgICAgICAgdmFyIHRhYiA9IHRoaXMudGFicy5maW5kKG5vdERpc2FibGVkKTtcblxuICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZVRhYih0YWIpICYmIGZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c0J1dHRvbih0YWIpO1xuICAgICAgICAgIHRoaXMuZW1pdFRhYkNsaWNrKHRhYiwgZm9jdXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSB0byBwcmV2aW91cyBub24tZGlzYWJsZWQgdGFiXG4gICAgICBwcmV2aW91c1RhYjogZnVuY3Rpb24gcHJldmlvdXNUYWIoZm9jdXMpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IE1hdGgubWF4KHRoaXMuY3VycmVudFRhYiwgMCk7XG4gICAgICAgIHZhciB0YWIgPSB0aGlzLnRhYnMuc2xpY2UoMCwgY3VycmVudEluZGV4KS5yZXZlcnNlKCkuZmluZChub3REaXNhYmxlZCk7XG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdGVUYWIodGFiKSAmJiBmb2N1cykge1xuICAgICAgICAgIHRoaXMuZm9jdXNCdXR0b24odGFiKTtcbiAgICAgICAgICB0aGlzLmVtaXRUYWJDbGljayh0YWIsIGZvY3VzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgdG8gbmV4dCBub24tZGlzYWJsZWQgdGFiXG4gICAgICBuZXh0VGFiOiBmdW5jdGlvbiBuZXh0VGFiKGZvY3VzKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBNYXRoLm1heCh0aGlzLmN1cnJlbnRUYWIsIC0xKTtcbiAgICAgICAgdmFyIHRhYiA9IHRoaXMudGFicy5zbGljZShjdXJyZW50SW5kZXggKyAxKS5maW5kKG5vdERpc2FibGVkKTtcblxuICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZVRhYih0YWIpICYmIGZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c0J1dHRvbih0YWIpO1xuICAgICAgICAgIHRoaXMuZW1pdFRhYkNsaWNrKHRhYiwgZm9jdXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSB0byBsYXN0IG5vbi1kaXNhYmxlZCB0YWJcbiAgICAgIGxhc3RUYWI6IGZ1bmN0aW9uIGxhc3RUYWIoZm9jdXMpIHtcbiAgICAgICAgdmFyIHRhYiA9IHRoaXMudGFicy5zbGljZSgpLnJldmVyc2UoKS5maW5kKG5vdERpc2FibGVkKTtcblxuICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZVRhYih0YWIpICYmIGZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c0J1dHRvbih0YWIpO1xuICAgICAgICAgIHRoaXMuZW1pdFRhYkNsaWNrKHRhYiwgZm9jdXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgdmFyIHRhYnMgPSB0aGlzLnRhYnM7IC8vIEN1cnJlbnRseSBhY3RpdmUgdGFiXG5cbiAgICAgIHZhciBhY3RpdmVUYWIgPSB0YWJzLmZpbmQoZnVuY3Rpb24gKHRhYikge1xuICAgICAgICByZXR1cm4gdGFiLmxvY2FsQWN0aXZlICYmICF0YWIuZGlzYWJsZWQ7XG4gICAgICB9KTsgLy8gVGFiIGJ1dHRvbiB0byBhbGxvdyBmb2N1c2luZyB3aGVuIG5vIGFjdGl2ZSB0YWIgZm91bmQgKGtleW5hdiBvbmx5KVxuXG4gICAgICB2YXIgZmFsbGJhY2tUYWIgPSB0YWJzLmZpbmQoZnVuY3Rpb24gKHRhYikge1xuICAgICAgICByZXR1cm4gIXRhYi5kaXNhYmxlZDtcbiAgICAgIH0pOyAvLyBGb3IgZWFjaCA8Yi10YWI+IGZvdW5kIGNyZWF0ZSB0aGUgdGFiIGJ1dHRvbnNcblxuICAgICAgdmFyIGJ1dHRvbnMgPSB0YWJzLm1hcChmdW5jdGlvbiAodGFiLCBpbmRleCkge1xuICAgICAgICB2YXIgdGFiSW5kZXggPSBudWxsOyAvLyBFbnN1cmUgYXQgbGVhc3Qgb25lIHRhYiBidXR0b24gaXMgZm9jdXNhYmxlIHdoZW4ga2V5bmF2IGVuYWJsZWQgKGlmIHBvc3NpYmxlKVxuXG4gICAgICAgIGlmICghX3RoaXM5Lm5vS2V5TmF2KSB7XG4gICAgICAgICAgLy8gQnV0dG9ucyBhcmUgbm90IGluIHRhYiBpbmRleCB1bmxlc3MgYWN0aXZlLCBvciBhIGZhbGxiYWNrIHRhYlxuICAgICAgICAgIHRhYkluZGV4ID0gLTE7XG5cbiAgICAgICAgICBpZiAoYWN0aXZlVGFiID09PSB0YWIgfHwgIWFjdGl2ZVRhYiAmJiBmYWxsYmFja1RhYiA9PT0gdGFiKSB7XG4gICAgICAgICAgICAvLyBQbGFjZSB0YWIgYnV0dG9uIGluIHRhYiBzZXF1ZW5jZVxuICAgICAgICAgICAgdGFiSW5kZXggPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoKEJUYWJCdXR0b25IZWxwZXIsIHtcbiAgICAgICAgICBrZXk6IHRhYi5fdWlkIHx8IGluZGV4LFxuICAgICAgICAgIHJlZjogJ2J1dHRvbnMnLFxuICAgICAgICAgIC8vIE5lZWRlZCB0byBtYWtlIGB0aGlzLiRyZWZzLmJ1dHRvbnNgIGFuIGFycmF5XG4gICAgICAgICAgcmVmSW5Gb3I6IHRydWUsXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIHRhYjogdGFiLFxuICAgICAgICAgICAgdGFiczogdGFicyxcbiAgICAgICAgICAgIGlkOiB0YWIuY29udHJvbGxlZEJ5IHx8ICh0YWIuc2FmZUlkID8gdGFiLnNhZmVJZChcIl9CVl90YWJfYnV0dG9uX1wiKSA6IG51bGwpLFxuICAgICAgICAgICAgY29udHJvbHM6IHRhYi5zYWZlSWQgPyB0YWIuc2FmZUlkKCkgOiBudWxsLFxuICAgICAgICAgICAgdGFiSW5kZXg6IHRhYkluZGV4LFxuICAgICAgICAgICAgc2V0U2l6ZTogdGFicy5sZW5ndGgsXG4gICAgICAgICAgICBwb3NJblNldDogaW5kZXggKyAxLFxuICAgICAgICAgICAgbm9LZXlOYXY6IF90aGlzOS5ub0tleU5hdlxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljayhldnQpIHtcbiAgICAgICAgICAgICAgX3RoaXM5LmNsaWNrVGFiKHRhYiwgZXZ0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXJzdDogX3RoaXM5LmZpcnN0VGFiLFxuICAgICAgICAgICAgcHJldjogX3RoaXM5LnByZXZpb3VzVGFiLFxuICAgICAgICAgICAgbmV4dDogX3RoaXM5Lm5leHRUYWIsXG4gICAgICAgICAgICBsYXN0OiBfdGhpczkubGFzdFRhYlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gTmF2XG5cbiAgICAgIHZhciBuYXYgPSBoKEJOYXYsIHtcbiAgICAgICAgcmVmOiAnbmF2JyxcbiAgICAgICAgY2xhc3M6IHRoaXMubG9jYWxOYXZDbGFzcyxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICByb2xlOiAndGFibGlzdCcsXG4gICAgICAgICAgaWQ6IHRoaXMuc2FmZUlkKCdfQlZfdGFiX2NvbnRyb2xzXycpXG4gICAgICAgIH0sXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgZmlsbDogdGhpcy5maWxsLFxuICAgICAgICAgIGp1c3RpZmllZDogdGhpcy5qdXN0aWZpZWQsXG4gICAgICAgICAgYWxpZ246IHRoaXMuYWxpZ24sXG4gICAgICAgICAgdGFiczogIXRoaXMubm9OYXZTdHlsZSAmJiAhdGhpcy5waWxscyxcbiAgICAgICAgICBwaWxsczogIXRoaXMubm9OYXZTdHlsZSAmJiB0aGlzLnBpbGxzLFxuICAgICAgICAgIHZlcnRpY2FsOiB0aGlzLnZlcnRpY2FsLFxuICAgICAgICAgIHNtYWxsOiB0aGlzLnNtYWxsLFxuICAgICAgICAgIGNhcmRIZWFkZXI6IHRoaXMuY2FyZCAmJiAhdGhpcy52ZXJ0aWNhbFxuICAgICAgICB9XG4gICAgICB9LCBbdGhpcy5ub3JtYWxpemVTbG90KCd0YWJzLXN0YXJ0JykgfHwgaCgpLCBidXR0b25zLCB0aGlzLm5vcm1hbGl6ZVNsb3QoJ3RhYnMtZW5kJykgfHwgaCgpXSk7XG4gICAgICBuYXYgPSBoKCdkaXYnLCB7XG4gICAgICAgIGtleTogJ2J2LXRhYnMtbmF2JyxcbiAgICAgICAgY2xhc3M6IFt7XG4gICAgICAgICAgJ2NhcmQtaGVhZGVyJzogdGhpcy5jYXJkICYmICF0aGlzLnZlcnRpY2FsICYmICF0aGlzLmVuZCxcbiAgICAgICAgICAnY2FyZC1mb290ZXInOiB0aGlzLmNhcmQgJiYgIXRoaXMudmVydGljYWwgJiYgdGhpcy5lbmQsXG4gICAgICAgICAgJ2NvbC1hdXRvJzogdGhpcy52ZXJ0aWNhbFxuICAgICAgICB9LCB0aGlzLm5hdldyYXBwZXJDbGFzc11cbiAgICAgIH0sIFtuYXZdKTtcbiAgICAgIHZhciBlbXB0eSA9IGgoKTtcblxuICAgICAgaWYgKCF0YWJzIHx8IHRhYnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGVtcHR5ID0gaCgnZGl2Jywge1xuICAgICAgICAgIGtleTogJ2J2LWVtcHR5LXRhYicsXG4gICAgICAgICAgY2xhc3M6IFsndGFiLXBhbmUnLCAnYWN0aXZlJywge1xuICAgICAgICAgICAgJ2NhcmQtYm9keSc6IHRoaXMuY2FyZFxuICAgICAgICAgIH1dXG4gICAgICAgIH0sIHRoaXMubm9ybWFsaXplU2xvdCgnZW1wdHknKSk7XG4gICAgICB9IC8vIE1haW4gY29udGVudCBzZWN0aW9uXG5cblxuICAgICAgdmFyIGNvbnRlbnQgPSBoKCdkaXYnLCB7XG4gICAgICAgIHJlZjogJ3RhYnNDb250YWluZXInLFxuICAgICAgICBrZXk6ICdidi10YWJzLWNvbnRhaW5lcicsXG4gICAgICAgIHN0YXRpY0NsYXNzOiAndGFiLWNvbnRlbnQnLFxuICAgICAgICBjbGFzczogW3tcbiAgICAgICAgICBjb2w6IHRoaXMudmVydGljYWxcbiAgICAgICAgfSwgdGhpcy5jb250ZW50Q2xhc3NdLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiB0aGlzLnNhZmVJZCgnX0JWX3RhYl9jb250YWluZXJfJylcbiAgICAgICAgfVxuICAgICAgfSwgY29uY2F0KHRoaXMubm9ybWFsaXplU2xvdCgnZGVmYXVsdCcpLCBlbXB0eSkpOyAvLyBSZW5kZXIgZmluYWwgb3V0cHV0XG5cbiAgICAgIHJldHVybiBoKHRoaXMudGFnLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAndGFicycsXG4gICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgcm93OiB0aGlzLnZlcnRpY2FsLFxuICAgICAgICAgICduby1ndXR0ZXJzJzogdGhpcy52ZXJ0aWNhbCAmJiB0aGlzLmNhcmRcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBpZDogdGhpcy5zYWZlSWQoKVxuICAgICAgICB9XG4gICAgICB9LCBbdGhpcy5lbmQgPyBjb250ZW50IDogaCgpLCBbbmF2XSwgdGhpcy5lbmQgPyBoKCkgOiBjb250ZW50XSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgQlRhYiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ0JUYWInLFxuICAgIG1peGluczogW2lkTWl4aW4sIG5vcm1hbGl6ZVNsb3RNaXhpbl0sXG4gICAgaW5qZWN0OiB7XG4gICAgICBidlRhYnM6IHtcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgYWN0aXZlOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgdGFnOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ2RpdidcbiAgICAgIH0sXG4gICAgICBidXR0b25JZDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9LFxuICAgICAgdGl0bGU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSxcbiAgICAgIHRpdGxlSXRlbUNsYXNzOiB7XG4gICAgICAgIC8vIFNuaWZmZWQgYnkgdGFicy5qcyBhbmQgYWRkZWQgdG8gbmF2ICdsaS5uYXYtaXRlbSdcbiAgICAgICAgdHlwZTogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICB0aXRsZUxpbmtDbGFzczoge1xuICAgICAgICAvLyBTbmlmZmVkIGJ5IHRhYnMuanMgYW5kIGFkZGVkIHRvIG5hdiAnYS5uYXYtbGluaydcbiAgICAgICAgdHlwZTogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBkaXNhYmxlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIG5vQm9keToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGxhenk6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbEFjdGl2ZTogdGhpcy5hY3RpdmUgJiYgIXRoaXMuZGlzYWJsZWQsXG4gICAgICAgIHNob3c6IGZhbHNlXG4gICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIHRhYkNsYXNzZXM6IGZ1bmN0aW9uIHRhYkNsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgIGFjdGl2ZTogdGhpcy5sb2NhbEFjdGl2ZSxcbiAgICAgICAgICBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZCxcbiAgICAgICAgICAnY2FyZC1ib2R5JzogdGhpcy5idlRhYnMuY2FyZCAmJiAhdGhpcy5ub0JvZHlcbiAgICAgICAgfSwgLy8gQXBwbHkgPGItdGFicz4gYGFjdGl2ZVRhYkNsYXNzYCBzdHlsZXMgd2hlbiB0aGlzIHRhYiBpcyBhY3RpdmVcbiAgICAgICAgdGhpcy5sb2NhbEFjdGl2ZSA/IHRoaXMuYnZUYWJzLmFjdGl2ZVRhYkNsYXNzIDogbnVsbF07XG4gICAgICB9LFxuICAgICAgY29udHJvbGxlZEJ5OiBmdW5jdGlvbiBjb250cm9sbGVkQnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1dHRvbklkIHx8IHRoaXMuc2FmZUlkKCdfX0JWX3RhYl9idXR0b25fXycpO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkTm9GYWRlOiBmdW5jdGlvbiBjb21wdXRlZE5vRmFkZSgpIHtcbiAgICAgICAgcmV0dXJuICEodGhpcy5idlRhYnMuZmFkZSB8fCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWRMYXp5OiBmdW5jdGlvbiBjb21wdXRlZExhenkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ2VGFicy5sYXp5IHx8IHRoaXMubGF6eTtcbiAgICAgIH0sXG4gICAgICBfaXNUYWI6IGZ1bmN0aW9uIF9pc1RhYigpIHtcbiAgICAgICAgLy8gRm9yIHBhcmVudCBzbmlmZmluZyBvZiBjaGlsZFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICBsb2NhbEFjdGl2ZTogZnVuY3Rpb24gbG9jYWxBY3RpdmUobmV3VmFsKSB7XG4gICAgICAgIC8vIE1ha2UgJ2FjdGl2ZScgcHJvcCB3b3JrIHdpdGggYC5zeW5jYCBtb2RpZmllclxuICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6YWN0aXZlJywgbmV3VmFsKTtcbiAgICAgIH0sXG4gICAgICBhY3RpdmU6IGZ1bmN0aW9uIGFjdGl2ZShuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICBpZiAobmV3VmFsICE9PSBvbGRWYWwpIHtcbiAgICAgICAgICBpZiAobmV3VmFsKSB7XG4gICAgICAgICAgICAvLyBJZiBhY3RpdmF0ZWQgcG9zdCBtb3VudFxuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRlYWN0aXZhdGUoKSkge1xuICAgICAgICAgICAgICAvLyBUYWIgY291bGRuJ3QgYmUgZGVhY3RpdmF0ZWQsIHNvIHdlIHJlc2V0IHRoZSBzeW5jZWQgYWN0aXZlIHByb3BcbiAgICAgICAgICAgICAgLy8gRGVhY3RpdmF0aW9uIHdpbGwgZmFpbCBpZiBubyBvdGhlciB0YWJzIHRvIGFjdGl2YXRlXG4gICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTphY3RpdmUnLCB0aGlzLmxvY2FsQWN0aXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNhYmxlZDogZnVuY3Rpb24gZGlzYWJsZWQobmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgaWYgKG5ld1ZhbCAhPT0gb2xkVmFsKSB7XG4gICAgICAgICAgaWYgKG5ld1ZhbCAmJiB0aGlzLmxvY2FsQWN0aXZlICYmIHRoaXMuYnZUYWJzLmZpcnN0VGFiKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmJ2VGFicy5maXJzdFRhYigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgIC8vIEluZm9ybSBiLXRhYnMgb2Ygb3VyIHByZXNlbmNlXG4gICAgICB0aGlzLnJlZ2lzdGVyVGFiKCk7IC8vIEluaXRpYWxseSBzaG93IG9uIG1vdW50IGlmIGFjdGl2ZSBhbmQgbm90IGRpc2FibGVkXG5cbiAgICAgIHRoaXMuc2hvdyA9IHRoaXMubG9jYWxBY3RpdmU7XG4gICAgfSxcbiAgICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkKCkge1xuICAgICAgLy8gRm9yY2UgdGhlIHRhYiBidXR0b24gY29udGVudCB0byB1cGRhdGUgKHNpbmNlIHNsb3RzIGFyZSBub3QgcmVhY3RpdmUpXG4gICAgICAvLyBPbmx5IGRvbmUgaWYgd2UgaGF2ZSBhIHRpdGxlIHNsb3QsIGFzIHRoZSB0aXRsZSBwcm9wIGlzIHJlYWN0aXZlXG4gICAgICBpZiAodGhpcy5oYXNOb3JtYWxpemVkU2xvdCgndGl0bGUnKSAmJiB0aGlzLmJ2VGFicy51cGRhdGVCdXR0b24pIHtcbiAgICAgICAgdGhpcy5idlRhYnMudXBkYXRlQnV0dG9uKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQoKSB7XG4gICAgICAvLyBpbmZvcm0gYi10YWJzIG9mIG91ciBkZXBhcnR1cmVcbiAgICAgIHRoaXMudW5yZWdpc3RlclRhYigpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgLy8gUHJpdmF0ZSBtZXRob2RzXG4gICAgICByZWdpc3RlclRhYjogZnVuY3Rpb24gcmVnaXN0ZXJUYWIoKSB7XG4gICAgICAgIC8vIEluZm9ybSBgYi10YWJzYCBvZiBvdXIgcHJlc2VuY2VcbiAgICAgICAgdGhpcy5idlRhYnMucmVnaXN0ZXJUYWIgJiYgdGhpcy5idlRhYnMucmVnaXN0ZXJUYWIodGhpcyk7XG4gICAgICB9LFxuICAgICAgdW5yZWdpc3RlclRhYjogZnVuY3Rpb24gdW5yZWdpc3RlclRhYigpIHtcbiAgICAgICAgLy8gSW5mb3JtIGBiLXRhYnNgIG9mIG91ciBkZXBhcnR1cmVcbiAgICAgICAgdGhpcy5idlRhYnMudW5yZWdpc3RlclRhYiAmJiB0aGlzLmJ2VGFicy51bnJlZ2lzdGVyVGFiKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIC8vIFB1YmxpYyBtZXRob2RzXG4gICAgICBhY3RpdmF0ZTogZnVuY3Rpb24gYWN0aXZhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ2VGFicy5hY3RpdmF0ZVRhYiAmJiAhdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJ2VGFicy5hY3RpdmF0ZVRhYih0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb3QgaW5zaWRlIGEgPGItdGFicz4gY29tcG9uZW50IG9yIHRhYiBpcyBkaXNhYmxlZFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlYWN0aXZhdGU6IGZ1bmN0aW9uIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ2VGFicy5kZWFjdGl2YXRlVGFiICYmIHRoaXMubG9jYWxBY3RpdmUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5idlRhYnMuZGVhY3RpdmF0ZVRhYih0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb3QgaW5zaWRlIGEgPGItdGFicz4gY29tcG9uZW50IG9yIG5vdCBhY3RpdmUgdG8gYmVnaW4gd2l0aFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBoKHRoaXMudGFnLCB7XG4gICAgICAgIHJlZjogJ3BhbmVsJyxcbiAgICAgICAgc3RhdGljQ2xhc3M6ICd0YWItcGFuZScsXG4gICAgICAgIGNsYXNzOiB0aGlzLnRhYkNsYXNzZXMsXG4gICAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgICAgbmFtZTogJ3Nob3cnLFxuICAgICAgICAgIHJhd05hbWU6ICd2LXNob3cnLFxuICAgICAgICAgIHZhbHVlOiB0aGlzLmxvY2FsQWN0aXZlLFxuICAgICAgICAgIGV4cHJlc3Npb246ICdsb2NhbEFjdGl2ZSdcbiAgICAgICAgfV0sXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgcm9sZTogJ3RhYnBhbmVsJyxcbiAgICAgICAgICBpZDogdGhpcy5zYWZlSWQoKSxcbiAgICAgICAgICAnYXJpYS1oaWRkZW4nOiB0aGlzLmxvY2FsQWN0aXZlID8gJ2ZhbHNlJyA6ICd0cnVlJyxcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogdGhpcy5jb250cm9sbGVkQnkgfHwgbnVsbFxuICAgICAgICB9XG4gICAgICB9LCAvLyBSZW5kZXIgY29udGVudCBsYXppbHkgaWYgcmVxdWVzdGVkXG4gICAgICBbdGhpcy5sb2NhbEFjdGl2ZSB8fCAhdGhpcy5jb21wdXRlZExhenkgPyB0aGlzLm5vcm1hbGl6ZVNsb3QoJ2RlZmF1bHQnKSA6IGgoKV0pO1xuICAgICAgcmV0dXJuIGgoQlZUcmFuc2l0aW9uLCB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbW9kZTogJ291dC1pbicsXG4gICAgICAgICAgbm9GYWRlOiB0aGlzLmNvbXB1dGVkTm9GYWRlXG4gICAgICAgIH1cbiAgICAgIH0sIFtjb250ZW50XSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgVGFic1BsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgY29tcG9uZW50czoge1xuICAgICAgQlRhYnM6IEJUYWJzLFxuICAgICAgQlRhYjogQlRhYlxuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gX3R5cGVvZiQxKG9iaikge1xuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgX3R5cGVvZiQxID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIF90eXBlb2YkMSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfdHlwZW9mJDEob2JqKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheSQxKGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMkMShhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkkMShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCQxKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMkMShhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgICAgcmV0dXJuIGFycjI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheSQxKGl0ZXIpIHtcbiAgICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkJDEoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICB9XG5cbiAgdmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuICBmdW5jdGlvbiBmcmVlemUkMShpdGVtKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkgfHwgX3R5cGVvZiQxKGl0ZW0pID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoaXRlbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgZnVuY3Rpb24gY29tYmluZVBhc3NlbmdlcnModHJhbnNwb3J0cykge1xuICAgIHZhciBzbG90UHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiB0cmFuc3BvcnRzLnJlZHVjZShmdW5jdGlvbiAocGFzc2VuZ2VycywgdHJhbnNwb3J0KSB7XG4gICAgICB2YXIgdGVtcCA9IHRyYW5zcG9ydC5wYXNzZW5nZXJzWzBdO1xuICAgICAgdmFyIG5ld1Bhc3NlbmdlcnMgPSB0eXBlb2YgdGVtcCA9PT0gJ2Z1bmN0aW9uJyA/IHRlbXAoc2xvdFByb3BzKSA6IHRyYW5zcG9ydC5wYXNzZW5nZXJzO1xuICAgICAgcmV0dXJuIHBhc3NlbmdlcnMuY29uY2F0KG5ld1Bhc3NlbmdlcnMpO1xuICAgIH0sIFtdKTtcbiAgfVxuICBmdW5jdGlvbiBzdGFibGVTb3J0JDEoYXJyYXksIGNvbXBhcmVGbikge1xuICAgIHJldHVybiBhcnJheS5tYXAoZnVuY3Rpb24gKHYsIGlkeCkge1xuICAgICAgcmV0dXJuIFtpZHgsIHZdO1xuICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBjb21wYXJlRm4oYVsxXSwgYlsxXSkgfHwgYVswXSAtIGJbMF07XG4gICAgfSkubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gY1sxXTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBwaWNrKG9iaiwga2V5cykge1xuICAgIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBhY2Nba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIHZhciB0cmFuc3BvcnRzID0ge307XG4gIHZhciB0YXJnZXRzID0ge307XG4gIHZhciBzb3VyY2VzID0ge307XG4gIHZhciBXb3JtaG9sZSA9IFZ1ZS5leHRlbmQoe1xuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFuc3BvcnRzOiB0cmFuc3BvcnRzLFxuICAgICAgICB0YXJnZXRzOiB0YXJnZXRzLFxuICAgICAgICBzb3VyY2VzOiBzb3VyY2VzLFxuICAgICAgICB0cmFja0luc3RhbmNlczogaW5Ccm93c2VyXG4gICAgICB9O1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgb3BlbjogZnVuY3Rpb24gb3Blbih0cmFuc3BvcnQpIHtcbiAgICAgICAgaWYgKCFpbkJyb3dzZXIpIHJldHVybjtcbiAgICAgICAgdmFyIHRvID0gdHJhbnNwb3J0LnRvLFxuICAgICAgICAgICAgZnJvbSA9IHRyYW5zcG9ydC5mcm9tLFxuICAgICAgICAgICAgcGFzc2VuZ2VycyA9IHRyYW5zcG9ydC5wYXNzZW5nZXJzLFxuICAgICAgICAgICAgX3RyYW5zcG9ydCRvcmRlciA9IHRyYW5zcG9ydC5vcmRlcixcbiAgICAgICAgICAgIG9yZGVyID0gX3RyYW5zcG9ydCRvcmRlciA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfdHJhbnNwb3J0JG9yZGVyO1xuICAgICAgICBpZiAoIXRvIHx8ICFmcm9tIHx8ICFwYXNzZW5nZXJzKSByZXR1cm47XG4gICAgICAgIHZhciBuZXdUcmFuc3BvcnQgPSB7XG4gICAgICAgICAgdG86IHRvLFxuICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgcGFzc2VuZ2VyczogZnJlZXplJDEocGFzc2VuZ2VycyksXG4gICAgICAgICAgb3JkZXI6IG9yZGVyXG4gICAgICAgIH07XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy50cmFuc3BvcnRzKTtcblxuICAgICAgICBpZiAoa2V5cy5pbmRleE9mKHRvKSA9PT0gLTEpIHtcbiAgICAgICAgICBWdWUuc2V0KHRoaXMudHJhbnNwb3J0cywgdG8sIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLiRfZ2V0VHJhbnNwb3J0SW5kZXgobmV3VHJhbnNwb3J0KTsgLy8gQ29weWluZyB0aGUgYXJyYXkgaGVyZSBzbyB0aGF0IHRoZSBQb3J0YWxUYXJnZXQgY2hhbmdlIGV2ZW50IHdpbGwgYWN0dWFsbHkgY29udGFpbiB0d28gZGlzdGluY3QgYXJyYXlzXG5cbiAgICAgICAgdmFyIG5ld1RyYW5zcG9ydHMgPSB0aGlzLnRyYW5zcG9ydHNbdG9dLnNsaWNlKDApO1xuXG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgbmV3VHJhbnNwb3J0cy5wdXNoKG5ld1RyYW5zcG9ydCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3VHJhbnNwb3J0c1tjdXJyZW50SW5kZXhdID0gbmV3VHJhbnNwb3J0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmFuc3BvcnRzW3RvXSA9IHN0YWJsZVNvcnQkMShuZXdUcmFuc3BvcnRzLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKHRyYW5zcG9ydCkge1xuICAgICAgICB2YXIgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgICB2YXIgdG8gPSB0cmFuc3BvcnQudG8sXG4gICAgICAgICAgICBmcm9tID0gdHJhbnNwb3J0LmZyb207XG4gICAgICAgIGlmICghdG8gfHwgIWZyb20gJiYgZm9yY2UgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCF0aGlzLnRyYW5zcG9ydHNbdG9dKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgdGhpcy50cmFuc3BvcnRzW3RvXSA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuJF9nZXRUcmFuc3BvcnRJbmRleCh0cmFuc3BvcnQpO1xuXG4gICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIC8vIENvcHlpbmcgdGhlIGFycmF5IGhlcmUgc28gdGhhdCB0aGUgUG9ydGFsVGFyZ2V0IGNoYW5nZSBldmVudCB3aWxsIGFjdHVhbGx5IGNvbnRhaW4gdHdvIGRpc3RpbmN0IGFycmF5c1xuICAgICAgICAgICAgdmFyIG5ld1RyYW5zcG9ydHMgPSB0aGlzLnRyYW5zcG9ydHNbdG9dLnNsaWNlKDApO1xuICAgICAgICAgICAgbmV3VHJhbnNwb3J0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnRzW3RvXSA9IG5ld1RyYW5zcG9ydHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJUYXJnZXQ6IGZ1bmN0aW9uIHJlZ2lzdGVyVGFyZ2V0KHRhcmdldCwgdm0sIGZvcmNlKSB7XG4gICAgICAgIGlmICghaW5Ccm93c2VyKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHRoaXMudHJhY2tJbnN0YW5jZXMgJiYgIWZvcmNlICYmIHRoaXMudGFyZ2V0c1t0YXJnZXRdKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiW3BvcnRhbC12dWVdOiBUYXJnZXQgXCIuY29uY2F0KHRhcmdldCwgXCIgYWxyZWFkeSBleGlzdHNcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kc2V0KHRoaXMudGFyZ2V0cywgdGFyZ2V0LCBPYmplY3QuZnJlZXplKFt2bV0pKTtcbiAgICAgIH0sXG4gICAgICB1bnJlZ2lzdGVyVGFyZ2V0OiBmdW5jdGlvbiB1bnJlZ2lzdGVyVGFyZ2V0KHRhcmdldCkge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy50YXJnZXRzLCB0YXJnZXQpO1xuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyU291cmNlOiBmdW5jdGlvbiByZWdpc3RlclNvdXJjZShzb3VyY2UsIHZtLCBmb3JjZSkge1xuICAgICAgICBpZiAoIWluQnJvd3NlcikgcmV0dXJuO1xuXG4gICAgICAgIGlmICh0aGlzLnRyYWNrSW5zdGFuY2VzICYmICFmb3JjZSAmJiB0aGlzLnNvdXJjZXNbc291cmNlXSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIltwb3J0YWwtdnVlXTogc291cmNlIFwiLmNvbmNhdChzb3VyY2UsIFwiIGFscmVhZHkgZXhpc3RzXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnNvdXJjZXMsIHNvdXJjZSwgT2JqZWN0LmZyZWV6ZShbdm1dKSk7XG4gICAgICB9LFxuICAgICAgdW5yZWdpc3RlclNvdXJjZTogZnVuY3Rpb24gdW5yZWdpc3RlclNvdXJjZShzb3VyY2UpIHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuc291cmNlcywgc291cmNlKTtcbiAgICAgIH0sXG4gICAgICBoYXNUYXJnZXQ6IGZ1bmN0aW9uIGhhc1RhcmdldCh0bykge1xuICAgICAgICByZXR1cm4gISEodGhpcy50YXJnZXRzW3RvXSAmJiB0aGlzLnRhcmdldHNbdG9dWzBdKTtcbiAgICAgIH0sXG4gICAgICBoYXNTb3VyY2U6IGZ1bmN0aW9uIGhhc1NvdXJjZSh0bykge1xuICAgICAgICByZXR1cm4gISEodGhpcy5zb3VyY2VzW3RvXSAmJiB0aGlzLnNvdXJjZXNbdG9dWzBdKTtcbiAgICAgIH0sXG4gICAgICBoYXNDb250ZW50Rm9yOiBmdW5jdGlvbiBoYXNDb250ZW50Rm9yKHRvKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMudHJhbnNwb3J0c1t0b10gJiYgISF0aGlzLnRyYW5zcG9ydHNbdG9dLmxlbmd0aDtcbiAgICAgIH0sXG4gICAgICAvLyBJbnRlcm5hbFxuICAgICAgJF9nZXRUcmFuc3BvcnRJbmRleDogZnVuY3Rpb24gJF9nZXRUcmFuc3BvcnRJbmRleChfcmVmKSB7XG4gICAgICAgIHZhciB0byA9IF9yZWYudG8sXG4gICAgICAgICAgICBmcm9tID0gX3JlZi5mcm9tO1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy50cmFuc3BvcnRzW3RvXSkge1xuICAgICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydHNbdG9dW2ldLmZyb20gPT09IGZyb20pIHtcbiAgICAgICAgICAgIHJldHVybiAraTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIHdvcm1ob2xlID0gbmV3IFdvcm1ob2xlKHRyYW5zcG9ydHMpO1xuXG4gIHZhciBfaWQgPSAxO1xuICB2YXIgUG9ydGFsID0gVnVlLmV4dGVuZCh7XG4gICAgbmFtZTogJ3BvcnRhbCcsXG4gICAgcHJvcHM6IHtcbiAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICAgIH0sXG4gICAgICBuYW1lOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhfaWQrKyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcmRlcjoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgIH0sXG4gICAgICBzbGltOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICAgIH0sXG4gICAgICBzbG90UHJvcHM6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0YWc6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnRElWJ1xuICAgICAgfSxcbiAgICAgIHRvOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB3b3JtaG9sZS5yZWdpc3RlclNvdXJjZShfdGhpcy5uYW1lLCBfdGhpcyk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zZW5kVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkKCkge1xuICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZW5kVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgd29ybWhvbGUudW5yZWdpc3RlclNvdXJjZSh0aGlzLm5hbWUpO1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgIHRvOiBmdW5jdGlvbiB0byhuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgJiYgb2xkVmFsdWUgIT09IG5ld1ZhbHVlICYmIHRoaXMuY2xlYXIob2xkVmFsdWUpO1xuICAgICAgICB0aGlzLnNlbmRVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcih0YXJnZXQpIHtcbiAgICAgICAgdmFyIGNsb3NlciA9IHtcbiAgICAgICAgICBmcm9tOiB0aGlzLm5hbWUsXG4gICAgICAgICAgdG86IHRhcmdldCB8fCB0aGlzLnRvXG4gICAgICAgIH07XG4gICAgICAgIHdvcm1ob2xlLmNsb3NlKGNsb3Nlcik7XG4gICAgICB9LFxuICAgICAgbm9ybWFsaXplU2xvdHM6IGZ1bmN0aW9uIG5vcm1hbGl6ZVNsb3RzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc2NvcGVkU2xvdHMuZGVmYXVsdCA/IFt0aGlzLiRzY29wZWRTbG90cy5kZWZhdWx0XSA6IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgICB9LFxuICAgICAgbm9ybWFsaXplT3duQ2hpbGRyZW46IGZ1bmN0aW9uIG5vcm1hbGl6ZU93bkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicgPyBjaGlsZHJlbih0aGlzLnNsb3RQcm9wcykgOiBjaGlsZHJlbjtcbiAgICAgIH0sXG4gICAgICBzZW5kVXBkYXRlOiBmdW5jdGlvbiBzZW5kVXBkYXRlKCkge1xuICAgICAgICB2YXIgc2xvdENvbnRlbnQgPSB0aGlzLm5vcm1hbGl6ZVNsb3RzKCk7XG5cbiAgICAgICAgaWYgKHNsb3RDb250ZW50KSB7XG4gICAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHtcbiAgICAgICAgICAgIGZyb206IHRoaXMubmFtZSxcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICAgICAgcGFzc2VuZ2VyczogX3RvQ29uc3VtYWJsZUFycmF5JDEoc2xvdENvbnRlbnQpLFxuICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXJcbiAgICAgICAgICB9O1xuICAgICAgICAgIHdvcm1ob2xlLm9wZW4odHJhbnNwb3J0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgdGhpcy4kc2NvcGVkU2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICAgIHZhciBUYWcgPSB0aGlzLnRhZztcblxuICAgICAgaWYgKGNoaWxkcmVuICYmIHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA8PSAxICYmIHRoaXMuc2xpbSA/IHRoaXMubm9ybWFsaXplT3duQ2hpbGRyZW4oY2hpbGRyZW4pWzBdIDogaChUYWcsIFt0aGlzLm5vcm1hbGl6ZU93bkNoaWxkcmVuKGNoaWxkcmVuKV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpbSA/IGgoKSA6IGgoVGFnLCB7XG4gICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICd2LXBvcnRhbCc6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGtleTogJ3YtcG9ydGFsLXBsYWNlaG9sZGVyJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBQb3J0YWxUYXJnZXQgPSBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiAncG9ydGFsVGFyZ2V0JyxcbiAgICBwcm9wczoge1xuICAgICAgbXVsdGlwbGU6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBuYW1lOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgIH0sXG4gICAgICBzbGltOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc2xvdFByb3BzOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGFnOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ2RpdidcbiAgICAgIH0sXG4gICAgICB0cmFuc2l0aW9uOiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIE9iamVjdCwgRnVuY3Rpb25dXG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhbnNwb3J0czogd29ybWhvbGUudHJhbnNwb3J0cyxcbiAgICAgICAgZmlyc3RSZW5kZXI6IHRydWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB3b3JtaG9sZS5yZWdpc3RlclRhcmdldChfdGhpcy5uYW1lLCBfdGhpcyk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICBvd25UcmFuc3BvcnRzOiBmdW5jdGlvbiBvd25UcmFuc3BvcnRzKCkge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0aGlzLmNoaWxkcmVuKCkubGVuZ3RoID4gMCk7XG4gICAgICB9LFxuICAgICAgbmFtZTogZnVuY3Rpb24gbmFtZShuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICAvKipcclxuICAgICAgICAgKiBUT0RPXHJcbiAgICAgICAgICogVGhpcyBzaG91bGQgd2FybiBhcyB3ZWxsIC4uLlxyXG4gICAgICAgICAqL1xuICAgICAgICB3b3JtaG9sZS51bnJlZ2lzdGVyVGFyZ2V0KG9sZFZhbCk7XG4gICAgICAgIHdvcm1ob2xlLnJlZ2lzdGVyVGFyZ2V0KG5ld1ZhbCwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIG9ubHkgd2hlbiB3ZSBoYXZlIGEgdHJhbnNpdGlvbiwgYmVjYXVzZSBpdCBjYXVzZXMgYSByZS1yZW5kZXJcbiAgICAgICAgICBfdGhpczIuZmlyc3RSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgd29ybWhvbGUudW5yZWdpc3RlclRhcmdldCh0aGlzLm5hbWUpO1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIG93blRyYW5zcG9ydHM6IGZ1bmN0aW9uIG93blRyYW5zcG9ydHMoKSB7XG4gICAgICAgIHZhciB0cmFuc3BvcnRzID0gdGhpcy50cmFuc3BvcnRzW3RoaXMubmFtZV0gfHwgW107XG5cbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmFuc3BvcnRzLmxlbmd0aCA9PT0gMCA/IFtdIDogW3RyYW5zcG9ydHNbdHJhbnNwb3J0cy5sZW5ndGggLSAxXV07XG4gICAgICB9LFxuICAgICAgcGFzc2VuZ2VyczogZnVuY3Rpb24gcGFzc2VuZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVQYXNzZW5nZXJzKHRoaXMub3duVHJhbnNwb3J0cywgdGhpcy5zbG90UHJvcHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgLy8gY2FuJ3QgYmUgYSBjb21wdXRlZCBwcm9wIGJlY2F1c2UgaXQgaGFzIHRvIFwicmVhY3RcIiB0byAkc2xvdCBjaGFuZ2VzLlxuICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXNzZW5nZXJzLmxlbmd0aCAhPT0gMCA/IHRoaXMucGFzc2VuZ2VycyA6IHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQgPyB0aGlzLiRzY29wZWRTbG90cy5kZWZhdWx0KHRoaXMuc2xvdFByb3BzKSA6IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgICB9LFxuICAgICAgLy8gY2FuJ3QgYmUgYSBjb21wdXRlZCBwcm9wIGJlY2F1c2UgaXQgaGFzIHRvIFwicmVhY3RcIiB0byB0aGlzLmNoaWxkcmVuKCkuXG4gICAgICBub1dyYXBwZXI6IGZ1bmN0aW9uIG5vV3JhcHBlcigpIHtcbiAgICAgICAgdmFyIG5vV3JhcHBlciA9IHRoaXMuc2xpbSAmJiAhdGhpcy50cmFuc2l0aW9uO1xuXG4gICAgICAgIGlmIChub1dyYXBwZXIgJiYgdGhpcy5jaGlsZHJlbigpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1twb3J0YWwtdnVlXTogUG9ydGFsVGFyZ2V0IHdpdGggYHNsaW1gIG9wdGlvbiByZWNlaXZlZCBtb3JlIHRoYW4gb25lIGNoaWxkIGVsZW1lbnQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9XcmFwcGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgdmFyIG5vV3JhcHBlciA9IHRoaXMubm9XcmFwcGVyKCk7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCk7XG4gICAgICB2YXIgVGFnID0gdGhpcy50cmFuc2l0aW9uIHx8IHRoaXMudGFnO1xuICAgICAgcmV0dXJuIG5vV3JhcHBlciA/IGNoaWxkcmVuWzBdIDogdGhpcy5zbGltICYmICFUYWcgPyBoKCkgOiBoKFRhZywge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSB0cmFuc2l0aW9uIGNvbXBvbmVudCwgcGFzcyB0aGUgdGFnIGlmIGl0IGV4aXN0c1xuICAgICAgICAgIHRhZzogdGhpcy50cmFuc2l0aW9uICYmIHRoaXMudGFnID8gdGhpcy50YWcgOiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAndnVlLXBvcnRhbC10YXJnZXQnOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBfaWQkMSA9IDA7XG4gIHZhciBwb3J0YWxQcm9wcyA9IFsnZGlzYWJsZWQnLCAnbmFtZScsICdvcmRlcicsICdzbGltJywgJ3Nsb3RQcm9wcycsICd0YWcnLCAndG8nXTtcbiAgdmFyIHRhcmdldFByb3BzID0gWydtdWx0aXBsZScsICd0cmFuc2l0aW9uJ107XG4gIHZhciBNb3VudGluZ1BvcnRhbCA9IFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdNb3VudGluZ1BvcnRhbCcsXG4gICAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgICBwcm9wczoge1xuICAgICAgYXBwZW5kOiB7XG4gICAgICAgIHR5cGU6IFtCb29sZWFuLCBTdHJpbmddXG4gICAgICB9LFxuICAgICAgYmFpbDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuXG4gICAgICB9LFxuICAgICAgbW91bnRUbzoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICB9LFxuICAgICAgLy8gUG9ydGFsXG4gICAgICBkaXNhYmxlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuXG4gICAgICB9LFxuICAgICAgLy8gbmFtZSBmb3IgdGhlIHBvcnRhbFxuICAgICAgbmFtZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiAnbW91bnRlZF8nICsgU3RyaW5nKF9pZCQxKyspO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb3JkZXI6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICBkZWZhdWx0OiAwXG4gICAgICB9LFxuICAgICAgc2xpbToge1xuICAgICAgICB0eXBlOiBCb29sZWFuXG4gICAgICB9LFxuICAgICAgc2xvdFByb3BzOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGFnOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ0RJVidcbiAgICAgIH0sXG4gICAgICAvLyBuYW1lIGZvciB0aGUgdGFyZ2V0XG4gICAgICB0bzoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcoTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwMDAwMDApKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFRhcmdldFxuICAgICAgbXVsdGlwbGU6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICB0YXJnZXRTbGltOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICAgIH0sXG4gICAgICB0YXJnZXRTbG90UHJvcHM6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0YXJnZXRUYWc6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnZGl2J1xuICAgICAgfSxcbiAgICAgIHRyYW5zaXRpb246IHtcbiAgICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0LCBGdW5jdGlvbl1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgICAgdmFyIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLm1vdW50VG8pO1xuXG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbcG9ydGFsLXZ1ZV06IE1vdW50IFBvaW50ICdcIi5jb25jYXQodGhpcy5tb3VudFRvLCBcIicgbm90IGZvdW5kIGluIGRvY3VtZW50XCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLiRwcm9wczsgLy8gVGFyZ2V0IGFscmVhZHkgZXhpc3RzXG5cbiAgICAgIGlmICh3b3JtaG9sZS50YXJnZXRzW3Byb3BzLm5hbWVdKSB7XG4gICAgICAgIGlmIChwcm9wcy5iYWlsKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiW3BvcnRhbC12dWVdOiBUYXJnZXQgXCIuY29uY2F0KHByb3BzLm5hbWUsIFwiIGlzIGFscmVhZHkgbW91bnRlZC5cXG4gICAgICAgIEFib3J0aW5nIGJlY2F1c2UgJ2JhaWw6IHRydWUnIGlzIHNldFwiKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wb3J0YWxUYXJnZXQgPSB3b3JtaG9sZS50YXJnZXRzW3Byb3BzLm5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXBwZW5kID0gcHJvcHMuYXBwZW5kO1xuXG4gICAgICBpZiAoYXBwZW5kKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGFwcGVuZCA9PT0gJ3N0cmluZycgPyBhcHBlbmQgOiAnRElWJztcbiAgICAgICAgdmFyIG1vdW50RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChtb3VudEVsKTtcbiAgICAgICAgZWwgPSBtb3VudEVsO1xuICAgICAgfSAvLyBnZXQgcHJvcHMgZm9yIHRhcmdldCBmcm9tICRwcm9wc1xuICAgICAgLy8gd2UgaGF2ZSB0byByZW5hbWUgYSBmZXcgb2YgdGhlbVxuXG5cbiAgICAgIHZhciBfcHJvcHMgPSBwaWNrKHRoaXMuJHByb3BzLCB0YXJnZXRQcm9wcyk7XG5cbiAgICAgIF9wcm9wcy5zbGltID0gdGhpcy50YXJnZXRTbGltO1xuICAgICAgX3Byb3BzLnRhZyA9IHRoaXMudGFyZ2V0VGFnO1xuICAgICAgX3Byb3BzLnNsb3RQcm9wcyA9IHRoaXMudGFyZ2V0U2xvdFByb3BzO1xuICAgICAgX3Byb3BzLm5hbWUgPSB0aGlzLnRvO1xuICAgICAgdGhpcy5wb3J0YWxUYXJnZXQgPSBuZXcgUG9ydGFsVGFyZ2V0KHtcbiAgICAgICAgZWw6IGVsLFxuICAgICAgICBwYXJlbnQ6IHRoaXMuJHBhcmVudCB8fCB0aGlzLFxuICAgICAgICBwcm9wc0RhdGE6IF9wcm9wc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMucG9ydGFsVGFyZ2V0O1xuXG4gICAgICBpZiAodGhpcy5hcHBlbmQpIHtcbiAgICAgICAgdmFyIGVsID0gdGFyZ2V0LiRlbDtcbiAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC4kZGVzdHJveSgpO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgaWYgKCF0aGlzLnBvcnRhbFRhcmdldCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbcG9ydGFsLXZ1ZV0gVGFyZ2V0IHdhc24ndCBtb3VudGVkXCIpO1xuICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgfSAvLyBpZiB0aGVyZSdzIG5vIFwibWFudWFsXCIgc2NvcGVkIHNsb3QsIHNvIHdlIGNyZWF0ZSBhIDxQb3J0YWw+IG91cnNlbHZlc1xuXG5cbiAgICAgIGlmICghdGhpcy4kc2NvcGVkU2xvdHMubWFudWFsKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHBpY2sodGhpcy4kcHJvcHMsIHBvcnRhbFByb3BzKTtcbiAgICAgICAgcmV0dXJuIGgoUG9ydGFsLCB7XG4gICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgIGF0dHJzOiB0aGlzLiRhdHRycyxcbiAgICAgICAgICBvbjogdGhpcy4kbGlzdGVuZXJzLFxuICAgICAgICAgIHNjb3BlZFNsb3RzOiB0aGlzLiRzY29wZWRTbG90c1xuICAgICAgICB9LCB0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICAgIH0gLy8gZWxzZSwgd2UgcmVuZGVyIHRoZSBzY29wZWQgc2xvdFxuXG5cbiAgICAgIHZhciBjb250ZW50ID0gdGhpcy4kc2NvcGVkU2xvdHMubWFudWFsKHtcbiAgICAgICAgdG86IHRoaXMudG9cbiAgICAgIH0pOyAvLyBpZiB1c2VyIHVzZWQgPHRlbXBsYXRlPiBmb3IgdGhlIHNjb3BlZCBzbG90XG4gICAgICAvLyBjb250ZW50IHdpbGwgYmUgYW4gYXJyYXlcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkpIHtcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnRbMF07XG4gICAgICB9XG5cbiAgICAgIGlmICghY29udGVudCkgcmV0dXJuIGgoKTtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIE5BTUUkQyA9ICdCVG9hc3Rlcic7XG4gIHZhciBwcm9wcyRaID0ge1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBhcmlhTGl2ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRDLCAnYXJpYUxpdmUnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFyaWFBdG9taWM6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkQywgJ2FyaWFBdG9taWMnKTtcbiAgICAgIH0gLy8gQWxsb3dlZDogJ3RydWUnIG9yICdmYWxzZScgb3IgbnVsbFxuXG4gICAgfSxcbiAgICByb2xlOiB7XG4gICAgICAvLyBBcmlhIHJvbGVcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkQywgJ3JvbGUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICB0cmFuc2l0aW9uOiB7XG4gICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nLCBPYmplY3RdLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gICAgKi9cblxuICB9OyAvLyBAdnVlL2NvbXBvbmVudFxuXG4gIHZhciBEZWZhdWx0VHJhbnNpdGlvbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgVnVlLmV4dGVuZCh7XG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIFRyYW5zaXRpb24gY2xhc3NlcyBiYXNlIG5hbWVcbiAgICAgICAgbmFtZTogJ2ItdG9hc3RlcidcbiAgICAgIH07XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBvbkFmdGVyRW50ZXI6IGZ1bmN0aW9uIG9uQWZ0ZXJFbnRlcihlbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIC8vIEhhbmRsZSBidWcgd2hlcmUgZW50ZXItdG8gY2xhc3MgaXMgbm90IHJlbW92ZWQuXG4gICAgICAgIC8vIEJ1ZyBpcyByZWxhdGVkIHRvIHBvcnRhbC12dWUgYW5kIHRyYW5zaXRpb24tZ3JvdXBzLlxuICAgICAgICByZXF1ZXN0QUYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGVsLCBcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1lbnRlci10b1wiKSk7IC8vIFRoZSAqLW1vdmUgY2xhc3MgaXMgYWxzbyBzdHVjayBvbiBlbGVtZW50cyB0aGF0IG1vdmVkLFxuICAgICAgICAgIC8vIGJ1dCB0aGVyZSBhcmUgbm8gamF2YXNjcmlwdCBob29rcyB0byBoYW5kbGUgYWZ0ZXIgbW92ZS5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICByZXR1cm4gaCgndHJhbnNpdGlvbi1ncm91cCcsIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICB0YWc6ICdkaXYnLFxuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZVxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGFmdGVyRW50ZXI6IHRoaXMub25BZnRlckVudGVyXG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIH1cbiAgfSk7IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgdmFyIEJUb2FzdGVyID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiBOQU1FJEMsXG4gICAgcHJvcHM6IHByb3BzJFosXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIFdlIGRvbid0IHJlbmRlciBvbiBTU1Igb3IgaWYgYSBhbiBleGlzdGluZyB0YXJnZXQgZm91bmRcbiAgICAgICAgZG9SZW5kZXI6IGZhbHNlLFxuICAgICAgICBkZWFkOiBmYWxzZSxcbiAgICAgICAgLy8gVG9hc3RlciBuYW1lcyBjYW5ub3QgY2hhbmdlIG9uY2UgY3JlYXRlZFxuICAgICAgICBzdGF0aWNOYW1lOiB0aGlzLm5hbWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBiZWZvcmVNb3VudDogZnVuY3Rpb24gYmVmb3JlTW91bnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5zdGF0aWNOYW1lID0gdGhpcy5uYW1lO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cbiAgICAgIGlmICh3b3JtaG9sZS5oYXNUYXJnZXQodGhpcy5zdGF0aWNOYW1lKSkge1xuICAgICAgICB3YXJuKFwiQSBcXFwiPHBvcnRhbC10YXJnZXQ+XFxcIiB3aXRoIG5hbWUgXFxcIlwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiXFxcIiBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQuXCIpLCAnQlRvYXN0ZXInKTtcbiAgICAgICAgdGhpcy5kZWFkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZG9SZW5kZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLiRvbmNlKCdob29rOmJlZm9yZURlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gTGV0IHRvYXN0cyBtYWRlIHdpdGggYHRoaXMuJGJ2VG9hc3QudG9hc3QoKWAga25vdyB0aGF0IHRoaXMgdG9hc3RlclxuICAgICAgICAgIC8vIGlzIGJlaW5nIGRlc3Ryb3llZCBhbmQgc2hvdWxkIHNob3VsZCBhbHNvIGRlc3Ryb3kvaGlkZSB0aGVtc2VsdmVzXG4gICAgICAgICAgX3RoaXMyLiRyb290LiRlbWl0KCdidjo6dG9hc3Rlcjo6ZGVzdHJveWVkJywgX3RoaXMyLnN0YXRpY05hbWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkKCkge1xuICAgICAgLy8gUmVtb3ZlIGZyb20gRE9NIGlmIG5lZWRlZFxuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIHRlc3QgKi9cbiAgICAgIGlmICh0aGlzLiRlbCAmJiB0aGlzLiRlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuJGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy4kZWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgdmFyICR0b2FzdGVyID0gaCgnZGl2Jywge1xuICAgICAgICBjbGFzczogWydkLW5vbmUnLCB7XG4gICAgICAgICAgJ2ItZGVhZC10b2FzdGVyJzogdGhpcy5kZWFkXG4gICAgICAgIH1dXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuZG9SZW5kZXIpIHtcbiAgICAgICAgdmFyICR0YXJnZXQgPSBoKFBvcnRhbFRhcmdldCwge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiAnYi10b2FzdGVyLXNsb3QnLFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLnN0YXRpY05hbWUsXG4gICAgICAgICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgICAgIHRhZzogJ2RpdicsXG4gICAgICAgICAgICBzbGltOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIHRyYW5zaXRpb246IHRoaXMudHJhbnNpdGlvbiB8fCBEZWZhdWx0VHJhbnNpdGlvblxuICAgICAgICAgICAgdHJhbnNpdGlvbjogRGVmYXVsdFRyYW5zaXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAkdG9hc3RlciA9IGgoJ2RpdicsIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogJ2ItdG9hc3RlcicsXG4gICAgICAgICAgY2xhc3M6IFt0aGlzLnN0YXRpY05hbWVdLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5zdGF0aWNOYW1lLFxuICAgICAgICAgICAgcm9sZTogdGhpcy5yb2xlIHx8IG51bGwsXG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBudWxsIHRvIG1ha2Ugc3VyZSBhdHRyaWJ1dGUgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgJ2FyaWEtbGl2ZSc6IHRoaXMuYXJpYUxpdmUsXG4gICAgICAgICAgICAnYXJpYS1hdG9taWMnOiB0aGlzLmFyaWFBdG9taWNcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFskdGFyZ2V0XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkdG9hc3RlcjtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBOQU1FJEQgPSAnQlRvYXN0JztcbiAgdmFyIE1JTl9EVVJBVElPTiA9IDEwMDA7IC8vIC0tLSBQcm9wcyAtLS1cblxuICB2YXIgcHJvcHMkXyA9IHtcbiAgICBpZDoge1xuICAgICAgLy8gRXZlbiB0aG91Z2ggdGhlIElEIHByb3AgaXMgcHJvdmlkZWQgYnkgaWRNaXhpbiwgd2VcbiAgICAgIC8vIGFkZCBpdCBoZXJlIGZvciAkYnZUb2FzdCBwcm9wcyBmaWx0ZXJpbmdcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIHRpdGxlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICB0b2FzdGVyOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJEQsICd0b2FzdGVyJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2aXNpYmxlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHZhcmlhbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUkRCwgJ3ZhcmlhbnQnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzU3RhdHVzOiB7XG4gICAgICAvLyBTd2l0Y2hlcyByb2xlIHRvICdzdGF0dXMnIGFuZCBhcmlhLWxpdmUgdG8gJ3BvbGl0ZSdcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgYXBwZW5kVG9hc3Q6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgbm9BdXRvSGlkZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBhdXRvSGlkZURlbGF5OiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRELCAnYXV0b0hpZGVEZWxheScpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbm9DbG9zZUJ1dHRvbjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBub0ZhZGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgbm9Ib3ZlclBhdXNlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHNvbGlkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHRvYXN0Q2xhc3M6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIE9iamVjdCwgQXJyYXldLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRELCAndG9hc3RDbGFzcycpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGVhZGVyQ2xhc3M6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIE9iamVjdCwgQXJyYXldLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnRDb25maWcoTkFNRSRELCAnaGVhZGVyQ2xhc3MnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGJvZHlDbGFzczoge1xuICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0LCBBcnJheV0sXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudENvbmZpZyhOQU1FJEQsICdib2R5Q2xhc3MnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhyZWY6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIHRvOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgc3RhdGljOiB7XG4gICAgICAvLyBSZW5kZXIgdGhlIHRvYXN0IGluIHBsYWNlLCByYXRoZXIgdGhhbiBpbiBhIHBvcnRhbC10YXJnZXRcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfTsgLy8gQHZ1ZS9jb21wb25lbnRcblxuICB2YXIgQlRvYXN0ID1cbiAgLyojX19QVVJFX18qL1xuICBWdWUuZXh0ZW5kKHtcbiAgICBuYW1lOiBOQU1FJEQsXG4gICAgbWl4aW5zOiBbaWRNaXhpbiwgbGlzdGVuT25Sb290TWl4aW4sIG5vcm1hbGl6ZVNsb3RNaXhpbiwgc2NvcGVkU3R5bGVBdHRyc01peGluXSxcbiAgICBpbmhlcml0QXR0cnM6IGZhbHNlLFxuICAgIG1vZGVsOiB7XG4gICAgICBwcm9wOiAndmlzaWJsZScsXG4gICAgICBldmVudDogJ2NoYW5nZSdcbiAgICB9LFxuICAgIHByb3BzOiBwcm9wcyRfLFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgICAgICBkb1JlbmRlcjogZmFsc2UsXG4gICAgICAgIGxvY2FsU2hvdzogZmFsc2UsXG4gICAgICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2UsXG4gICAgICAgIGlzSGlkaW5nOiBmYWxzZSxcbiAgICAgICAgb3JkZXI6IDAsXG4gICAgICAgIHRpbWVyOiBudWxsLFxuICAgICAgICBkaXNtaXNzU3RhcnRlZDogMCxcbiAgICAgICAgcmVzdW1lRGlzbWlzczogMFxuICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBiVG9hc3RDbGFzc2VzOiBmdW5jdGlvbiBiVG9hc3RDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHtcbiAgICAgICAgICAnYi10b2FzdC1zb2xpZCc6IHRoaXMuc29saWQsXG4gICAgICAgICAgJ2ItdG9hc3QtYXBwZW5kJzogdGhpcy5hcHBlbmRUb2FzdCxcbiAgICAgICAgICAnYi10b2FzdC1wcmVwZW5kJzogIXRoaXMuYXBwZW5kVG9hc3RcbiAgICAgICAgfSwgXCJiLXRvYXN0LVwiLmNvbmNhdCh0aGlzLnZhcmlhbnQpLCB0aGlzLnZhcmlhbnQpO1xuICAgICAgfSxcbiAgICAgIHNsb3RTY29wZTogZnVuY3Rpb24gc2xvdFNjb3BlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhpZGU6IHRoaXMuaGlkZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkRHVyYXRpb246IGZ1bmN0aW9uIGNvbXB1dGVkRHVyYXRpb24oKSB7XG4gICAgICAgIC8vIE1pbmltdW0gc3VwcG9ydGVkIGR1cmF0aW9uIGlzIDEgc2Vjb25kXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0b0ludGVnZXIodGhpcy5hdXRvSGlkZURlbGF5KSB8fCAwLCBNSU5fRFVSQVRJT04pO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkVG9hc3RlcjogZnVuY3Rpb24gY29tcHV0ZWRUb2FzdGVyKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMudG9hc3Rlcik7XG4gICAgICB9LFxuICAgICAgdHJhbnNpdGlvbkhhbmRsZXJzOiBmdW5jdGlvbiB0cmFuc2l0aW9uSGFuZGxlcnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYmVmb3JlRW50ZXI6IHRoaXMub25CZWZvcmVFbnRlcixcbiAgICAgICAgICBhZnRlckVudGVyOiB0aGlzLm9uQWZ0ZXJFbnRlcixcbiAgICAgICAgICBiZWZvcmVMZWF2ZTogdGhpcy5vbkJlZm9yZUxlYXZlLFxuICAgICAgICAgIGFmdGVyTGVhdmU6IHRoaXMub25BZnRlckxlYXZlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgdmlzaWJsZTogZnVuY3Rpb24gdmlzaWJsZShuZXdWYWwpIHtcbiAgICAgICAgbmV3VmFsID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcbiAgICAgIH0sXG4gICAgICBsb2NhbFNob3c6IGZ1bmN0aW9uIGxvY2FsU2hvdyhuZXdWYWwpIHtcbiAgICAgICAgaWYgKG5ld1ZhbCAhPT0gdGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgbmV3VmFsKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRvYXN0ZXI6IGZ1bmN0aW9uIHRvYXN0ZXIoKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHtcbiAgICAgICAgLy8gSWYgdG9hc3RlciB0YXJnZXQgY2hhbmdlZCwgbWFrZSBzdXJlIHRvYXN0ZXIgZXhpc3RzXG4gICAgICAgIHRoaXMuJG5leHRUaWNrKHRoaXMuZW5zdXJlVG9hc3Rlcik7XG4gICAgICB9LFxuICAgICAgc3RhdGljOiBmdW5jdGlvbiBfc3RhdGljKG5ld1ZhbClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB7XG4gICAgICAgIC8vIElmIHN0YXRpYyBjaGFuZ2VzIHRvIHRydWUsIGFuZCB0aGUgdG9hc3QgaXMgc2hvd2luZyxcbiAgICAgICAgLy8gZW5zdXJlIHRoZSB0b2FzdGVyIHRhcmdldCBleGlzdHNcbiAgICAgICAgaWYgKG5ld1ZhbCAmJiB0aGlzLmxvY2FsU2hvdykge1xuICAgICAgICAgIHRoaXMuZW5zdXJlVG9hc3RlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMudmlzaWJsZSkge1xuICAgICAgICAgIHJlcXVlc3RBRihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zaG93KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBMaXN0ZW4gZm9yIGdsb2JhbCAkcm9vdCBzaG93IGV2ZW50c1xuXG4gICAgICB0aGlzLmxpc3Rlbk9uUm9vdCgnYnY6OnNob3c6OnRvYXN0JywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChpZCA9PT0gX3RoaXMuc2FmZUlkKCkpIHtcbiAgICAgICAgICBfdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBMaXN0ZW4gZm9yIGdsb2JhbCAkcm9vdCBoaWRlIGV2ZW50c1xuXG4gICAgICB0aGlzLmxpc3Rlbk9uUm9vdCgnYnY6OmhpZGU6OnRvYXN0JywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmICghaWQgfHwgaWQgPT09IF90aGlzLnNhZmVJZCgpKSB7XG4gICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gTWFrZSBzdXJlIHdlIGhpZGUgd2hlbiB0b2FzdGVyIGlzIGRlc3Ryb3llZFxuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIHRlc3QgKi9cblxuICAgICAgdGhpcy5saXN0ZW5PblJvb3QoJ2J2Ojp0b2FzdGVyOjpkZXN0cm95ZWQnLCBmdW5jdGlvbiAodG9hc3Rlcikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAodG9hc3RlciA9PT0gX3RoaXMuY29tcHV0ZWRUb2FzdGVyKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgIHRoaXMuY2xlYXJEaXNtaXNzVGltZXIoKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHNob3c6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5sb2NhbFNob3cpIHtcbiAgICAgICAgICB0aGlzLmVuc3VyZVRvYXN0ZXIoKTtcbiAgICAgICAgICB2YXIgc2hvd0V2dCA9IHRoaXMuYnVpbGRFdmVudCgnc2hvdycpO1xuICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KHNob3dFdnQpO1xuICAgICAgICAgIHRoaXMuZGlzbWlzc1N0YXJ0ZWQgPSB0aGlzLnJlc3VtZURpc21pc3MgPSAwO1xuICAgICAgICAgIHRoaXMub3JkZXIgPSBEYXRlLm5vdygpICogKHRoaXMuYXBwZW5kVG9hc3QgPyAxIDogLTEpO1xuICAgICAgICAgIHRoaXMuaXNIaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmRvUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBXZSBzaG93IHRoZSB0b2FzdCBhZnRlciB3ZSBoYXZlIHJlbmRlcmVkIHRoZSBwb3J0YWwgYW5kIGItdG9hc3Qgd3JhcHBlclxuICAgICAgICAgICAgLy8gc28gdGhhdCBzY3JlZW4gcmVhZGVycyB3aWxsIHByb3Blcmx5IGFubm91bmNlIHRoZSB0b2FzdFxuICAgICAgICAgICAgcmVxdWVzdEFGKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLmxvY2FsU2hvdyA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLmxvY2FsU2hvdykge1xuICAgICAgICAgIHZhciBoaWRlRXZ0ID0gdGhpcy5idWlsZEV2ZW50KCdoaWRlJyk7XG4gICAgICAgICAgdGhpcy5lbWl0RXZlbnQoaGlkZUV2dCk7XG4gICAgICAgICAgdGhpcy5zZXRIb3ZlckhhbmRsZXIoZmFsc2UpO1xuICAgICAgICAgIHRoaXMuZGlzbWlzc1N0YXJ0ZWQgPSB0aGlzLnJlc3VtZURpc21pc3MgPSAwO1xuICAgICAgICAgIHRoaXMuY2xlYXJEaXNtaXNzVGltZXIoKTtcbiAgICAgICAgICB0aGlzLmlzSGlkaW5nID0gdHJ1ZTtcbiAgICAgICAgICByZXF1ZXN0QUYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmxvY2FsU2hvdyA9IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYnVpbGRFdmVudDogZnVuY3Rpb24gYnVpbGRFdmVudCh0eXBlKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdkV2ZW50KHR5cGUsIF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMuJGVsIHx8IG51bGwsXG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogbnVsbFxuICAgICAgICB9LCBvcHRpb25zLCB7XG4gICAgICAgICAgdnVlVGFyZ2V0OiB0aGlzLFxuICAgICAgICAgIGNvbXBvbmVudElkOiB0aGlzLnNhZmVJZCgpXG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBlbWl0RXZlbnQ6IGZ1bmN0aW9uIGVtaXRFdmVudChidkV2dCkge1xuICAgICAgICB2YXIgdHlwZSA9IGJ2RXZ0LnR5cGU7XG4gICAgICAgIHRoaXMuJHJvb3QuJGVtaXQoXCJidjo6dG9hc3Q6XCIuY29uY2F0KHR5cGUpLCBidkV2dCk7XG4gICAgICAgIHRoaXMuJGVtaXQodHlwZSwgYnZFdnQpO1xuICAgICAgfSxcbiAgICAgIGVuc3VyZVRvYXN0ZXI6IGZ1bmN0aW9uIGVuc3VyZVRvYXN0ZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRpYykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghd29ybWhvbGUuaGFzVGFyZ2V0KHRoaXMuY29tcHV0ZWRUb2FzdGVyKSkge1xuICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgICAgdmFyIHRvYXN0ZXIgPSBuZXcgQlRvYXN0ZXIoe1xuICAgICAgICAgICAgcGFyZW50OiB0aGlzLiRyb290LFxuICAgICAgICAgICAgcHJvcHNEYXRhOiB7XG4gICAgICAgICAgICAgIG5hbWU6IHRoaXMuY29tcHV0ZWRUb2FzdGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdG9hc3Rlci4kbW91bnQoZGl2KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN0YXJ0RGlzbWlzc1RpbWVyOiBmdW5jdGlvbiBzdGFydERpc21pc3NUaW1lcigpIHtcbiAgICAgICAgdGhpcy5jbGVhckRpc21pc3NUaW1lcigpO1xuXG4gICAgICAgIGlmICghdGhpcy5ub0F1dG9IaWRlKSB7XG4gICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5oaWRlLCB0aGlzLnJlc3VtZURpc21pc3MgfHwgdGhpcy5jb21wdXRlZER1cmF0aW9uKTtcbiAgICAgICAgICB0aGlzLmRpc21pc3NTdGFydGVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB0aGlzLnJlc3VtZURpc21pc3MgPSAwO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2xlYXJEaXNtaXNzVGltZXI6IGZ1bmN0aW9uIGNsZWFyRGlzbWlzc1RpbWVyKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIHNldEhvdmVySGFuZGxlcjogZnVuY3Rpb24gc2V0SG92ZXJIYW5kbGVyKG9uKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuJHJlZnNbJ2ItdG9hc3QnXTtcbiAgICAgICAgZXZlbnRPbk9mZihvbiwgZWwsICdtb3VzZWVudGVyJywgdGhpcy5vblBhdXNlLCBFVkVOVF9PUFRJT05TX05PX0NBUFRVUkUpO1xuICAgICAgICBldmVudE9uT2ZmKG9uLCBlbCwgJ21vdXNlbGVhdmUnLCB0aGlzLm9uVW5QYXVzZSwgRVZFTlRfT1BUSU9OU19OT19DQVBUVVJFKTtcbiAgICAgIH0sXG4gICAgICBvblBhdXNlOiBmdW5jdGlvbiBvblBhdXNlKCkge1xuICAgICAgICAvLyBEZXRlcm1pbmUgdGltZSByZW1haW5pbmcsIGFuZCB0aGVuIHBhdXNlIHRpbWVyXG4gICAgICAgIGlmICh0aGlzLm5vQXV0b0hpZGUgfHwgdGhpcy5ub0hvdmVyUGF1c2UgfHwgIXRoaXMudGltZXIgfHwgdGhpcy5yZXN1bWVEaXNtaXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhc3NlZCA9IERhdGUubm93KCkgLSB0aGlzLmRpc21pc3NTdGFydGVkO1xuXG4gICAgICAgIGlmIChwYXNzZWQgPiAwKSB7XG4gICAgICAgICAgdGhpcy5jbGVhckRpc21pc3NUaW1lcigpO1xuICAgICAgICAgIHRoaXMucmVzdW1lRGlzbWlzcyA9IE1hdGgubWF4KHRoaXMuY29tcHV0ZWREdXJhdGlvbiAtIHBhc3NlZCwgTUlOX0RVUkFUSU9OKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVW5QYXVzZTogZnVuY3Rpb24gb25VblBhdXNlKCkge1xuICAgICAgICAvLyBSZXN0YXJ0IHRpbWVyIHdpdGggbWF4IG9mIHRpbWUgcmVtYWluaW5nIG9yIDEgc2Vjb25kXG4gICAgICAgIGlmICh0aGlzLm5vQXV0b0hpZGUgfHwgdGhpcy5ub0hvdmVyUGF1c2UgfHwgIXRoaXMucmVzdW1lRGlzbWlzcykge1xuICAgICAgICAgIHRoaXMucmVzdW1lRGlzbWlzcyA9IHRoaXMuZGlzbWlzc1N0YXJ0ZWQgPSAwO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhcnREaXNtaXNzVGltZXIoKTtcbiAgICAgIH0sXG4gICAgICBvbkxpbmtDbGljazogZnVuY3Rpb24gb25MaW5rQ2xpY2soKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIC8vIFdlIGRlbGF5IHRoZSBjbG9zZSB0byBhbGxvdyB0aW1lIGZvciB0aGVcbiAgICAgICAgLy8gYnJvd3NlciB0byBwcm9jZXNzIHRoZSBsaW5rIGNsaWNrXG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXF1ZXN0QUYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM0LmhpZGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25CZWZvcmVFbnRlcjogZnVuY3Rpb24gb25CZWZvcmVFbnRlcigpIHtcbiAgICAgICAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIG9uQWZ0ZXJFbnRlcjogZnVuY3Rpb24gb25BZnRlckVudGVyKCkge1xuICAgICAgICB0aGlzLmlzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgaGlkZGVuRXZ0ID0gdGhpcy5idWlsZEV2ZW50KCdzaG93bicpO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChoaWRkZW5FdnQpO1xuICAgICAgICB0aGlzLnN0YXJ0RGlzbWlzc1RpbWVyKCk7XG4gICAgICAgIHRoaXMuc2V0SG92ZXJIYW5kbGVyKHRydWUpO1xuICAgICAgfSxcbiAgICAgIG9uQmVmb3JlTGVhdmU6IGZ1bmN0aW9uIG9uQmVmb3JlTGVhdmUoKSB7XG4gICAgICAgIHRoaXMuaXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBvbkFmdGVyTGVhdmU6IGZ1bmN0aW9uIG9uQWZ0ZXJMZWF2ZSgpIHtcbiAgICAgICAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcmRlciA9IDA7XG4gICAgICAgIHRoaXMucmVzdW1lRGlzbWlzcyA9IHRoaXMuZGlzbWlzc1N0YXJ0ZWQgPSAwO1xuICAgICAgICB2YXIgaGlkZGVuRXZ0ID0gdGhpcy5idWlsZEV2ZW50KCdoaWRkZW4nKTtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoaGlkZGVuRXZ0KTtcbiAgICAgICAgdGhpcy5kb1JlbmRlciA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIG1ha2VUb2FzdDogZnVuY3Rpb24gbWFrZVRvYXN0KGgpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgLy8gUmVuZGVyIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB0aGUgdG9hc3RcbiAgICAgICAgLy8gQXNzZW1ibGUgdGhlIGhlYWRlciBjb250ZW50XG4gICAgICAgIHZhciAkaGVhZGVyQ29udGVudCA9IFtdO1xuICAgICAgICB2YXIgJHRpdGxlID0gdGhpcy5ub3JtYWxpemVTbG90KCd0b2FzdC10aXRsZScsIHRoaXMuc2xvdFNjb3BlKTtcblxuICAgICAgICBpZiAoJHRpdGxlKSB7XG4gICAgICAgICAgJGhlYWRlckNvbnRlbnQucHVzaCgkdGl0bGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudGl0bGUpIHtcbiAgICAgICAgICAkaGVhZGVyQ29udGVudC5wdXNoKGgoJ3N0cm9uZycsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAnbXItMidcbiAgICAgICAgICB9LCB0aGlzLnRpdGxlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubm9DbG9zZUJ1dHRvbikge1xuICAgICAgICAgICRoZWFkZXJDb250ZW50LnB1c2goaChCQnV0dG9uQ2xvc2UsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAnbWwtYXV0byBtYi0xJyxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljaygpIHtcbiAgICAgICAgICAgICAgICBfdGhpczUuaGlkZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IC8vIEFzc2VtYmxlIHRoZSBoZWFkZXIgKGlmIG5lZWRlZClcblxuXG4gICAgICAgIHZhciAkaGVhZGVyID0gaCgpO1xuXG4gICAgICAgIGlmICgkaGVhZGVyQ29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgJGhlYWRlciA9IGgoJ2hlYWRlcicsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndG9hc3QtaGVhZGVyJyxcbiAgICAgICAgICAgIGNsYXNzOiB0aGlzLmhlYWRlckNsYXNzXG4gICAgICAgICAgfSwgJGhlYWRlckNvbnRlbnQpO1xuICAgICAgICB9IC8vIFRvYXN0IGJvZHlcblxuXG4gICAgICAgIHZhciBpc0xpbmsgPSB0aGlzLmhyZWYgfHwgdGhpcy50bztcbiAgICAgICAgdmFyICRib2R5ID0gaChpc0xpbmsgPyBCTGluayA6ICdkaXYnLCB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICd0b2FzdC1ib2R5JyxcbiAgICAgICAgICBjbGFzczogdGhpcy5ib2R5Q2xhc3MsXG4gICAgICAgICAgcHJvcHM6IGlzTGluayA/IHtcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICAgICAgaHJlZjogdGhpcy5ocmVmXG4gICAgICAgICAgfSA6IHt9LFxuICAgICAgICAgIG9uOiBpc0xpbmsgPyB7XG4gICAgICAgICAgICBjbGljazogdGhpcy5vbkxpbmtDbGlja1xuICAgICAgICAgIH0gOiB7fVxuICAgICAgICB9LCBbdGhpcy5ub3JtYWxpemVTbG90KCdkZWZhdWx0JywgdGhpcy5zbG90U2NvcGUpIHx8IGgoKV0pOyAvLyBCdWlsZCB0aGUgdG9hc3RcblxuICAgICAgICB2YXIgJHRvYXN0ID0gaCgnZGl2Jywge1xuICAgICAgICAgIGtleTogXCJ0b2FzdC1cIi5jb25jYXQodGhpcy5fdWlkKSxcbiAgICAgICAgICByZWY6ICd0b2FzdCcsXG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICd0b2FzdCcsXG4gICAgICAgICAgY2xhc3M6IHRoaXMudG9hc3RDbGFzcyxcbiAgICAgICAgICBhdHRyczogX29iamVjdFNwcmVhZDIoe30sIHRoaXMuJGF0dHJzLCB7XG4gICAgICAgICAgICB0YWJpbmRleDogJzAnLFxuICAgICAgICAgICAgaWQ6IHRoaXMuc2FmZUlkKClcbiAgICAgICAgICB9KVxuICAgICAgICB9LCBbJGhlYWRlciwgJGJvZHldKTtcbiAgICAgICAgcmV0dXJuICR0b2FzdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIGlmICghdGhpcy5kb1JlbmRlciB8fCAhdGhpcy5pc01vdW50ZWQpIHtcbiAgICAgICAgcmV0dXJuIGgoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBcImItdG9hc3QtXCIuY29uY2F0KHRoaXMuX3VpZCk7IC8vIElmIHNjb3BlZCBzdHlsZXMgYXJlIGFwcGxpZWQgYW5kIHRoZSB0b2FzdCBpcyBub3Qgc3RhdGljLFxuICAgICAgLy8gbWFrZSBzdXJlIHRoZSBzY29wZWQgc3R5bGUgZGF0YSBhdHRyaWJ1dGUgaXMgYXBwbGllZFxuXG4gICAgICB2YXIgc2NvcGVkU3R5bGVBdHRycyA9ICF0aGlzLnN0YXRpYyA/IHRoaXMuc2NvcGVkU3R5bGVBdHRycyA6IHt9O1xuICAgICAgcmV0dXJuIGgoUG9ydGFsLCB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB0bzogdGhpcy5jb21wdXRlZFRvYXN0ZXIsXG4gICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgc2xpbTogdHJ1ZSxcbiAgICAgICAgICBkaXNhYmxlZDogdGhpcy5zdGF0aWNcbiAgICAgICAgfVxuICAgICAgfSwgW2goJ2RpdicsIHtcbiAgICAgICAga2V5OiBuYW1lLFxuICAgICAgICByZWY6ICdiLXRvYXN0JyxcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdiLXRvYXN0JyxcbiAgICAgICAgY2xhc3M6IHRoaXMuYlRvYXN0Q2xhc3NlcyxcbiAgICAgICAgYXR0cnM6IF9vYmplY3RTcHJlYWQyKHt9LCBzY29wZWRTdHlsZUF0dHJzLCB7XG4gICAgICAgICAgaWQ6IHRoaXMuc2FmZUlkKCdfdG9hc3Rfb3V0ZXInKSxcbiAgICAgICAgICByb2xlOiB0aGlzLmlzSGlkaW5nID8gbnVsbCA6IHRoaXMuaXNTdGF0dXMgPyAnc3RhdHVzJyA6ICdhbGVydCcsXG4gICAgICAgICAgJ2FyaWEtbGl2ZSc6IHRoaXMuaXNIaWRpbmcgPyBudWxsIDogdGhpcy5pc1N0YXR1cyA/ICdwb2xpdGUnIDogJ2Fzc2VydGl2ZScsXG4gICAgICAgICAgJ2FyaWEtYXRvbWljJzogdGhpcy5pc0hpZGluZyA/IG51bGwgOiAndHJ1ZSdcbiAgICAgICAgfSlcbiAgICAgIH0sIFtoKEJWVHJhbnNpdGlvbiwge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIG5vRmFkZTogdGhpcy5ub0ZhZGVcbiAgICAgICAgfSxcbiAgICAgICAgb246IHRoaXMudHJhbnNpdGlvbkhhbmRsZXJzXG4gICAgICB9LCBbdGhpcy5sb2NhbFNob3cgPyB0aGlzLm1ha2VUb2FzdChoKSA6IGgoKV0pXSldKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBQUk9QX05BTUUkMyA9ICckYnZUb2FzdCc7XG4gIHZhciBQUk9QX05BTUVfUFJJViQxID0gJ19idl9fdG9hc3QnOyAvLyBCYXNlIHRvYXN0IHByb3BzIHRoYXQgYXJlIGFsbG93ZWRcbiAgLy8gU29tZSBtYXkgYmUgaWdub3JlZCBvciBvdmVycmlkZGVuIG9uIHNvbWUgbWVzc2FnZSBib3hlc1xuICAvLyBQcm9wIElEIGlzIGFsbG93ZWQsIGJ1dCByZWFsbHkgb25seSBzaG91bGQgYmUgdXNlZCBmb3IgdGVzdGluZ1xuICAvLyBXZSBuZWVkIHRvIGFkZCBpdCBpbiBleHBsaWNpdGx5IGFzIGl0IGNvbWVzIGZyb20gdGhlIGBpZE1peGluYFxuXG4gIHZhciBCQVNFX1BST1BTJDEgPSBbJ2lkJ10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShrZXlzKG9taXQocHJvcHMkXywgWydzdGF0aWMnLCAndmlzaWJsZSddKSkpKTsgLy8gTWFwIHByb3AgbmFtZXMgdG8gdG9hc3Qgc2xvdCBuYW1lc1xuXG4gIHZhciBwcm9wc1RvU2xvdHMkMSA9IHtcbiAgICB0b2FzdENvbnRlbnQ6ICdkZWZhdWx0JyxcbiAgICB0aXRsZTogJ3RvYXN0LXRpdGxlJ1xuICB9OyAvLyAtLS0gVXRpbGl0eSBtZXRob2RzIC0tLVxuICAvLyBNZXRob2QgdG8gZmlsdGVyIG9ubHkgcmVjb2duaXplZCBwcm9wcyB0aGF0IGFyZSBub3QgdW5kZWZpbmVkXG5cbiAgdmFyIGZpbHRlck9wdGlvbnMkMSA9IGZ1bmN0aW9uIGZpbHRlck9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBCQVNFX1BST1BTJDEucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBrZXkpIHtcbiAgICAgIGlmICghaXNVbmRlZmluZWQob3B0aW9uc1trZXldKSkge1xuICAgICAgICBtZW1vW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIHt9KTtcbiAgfTsgLy8gTWV0aG9kIHRvIGluc3RhbGwgYCRidlRvYXN0YCBWTSBpbmplY3Rpb25cblxuXG4gIHZhciBwbHVnaW4kMSA9IGZ1bmN0aW9uIHBsdWdpbihWdWUpIHtcbiAgICAvLyBDcmVhdGUgYSBwcml2YXRlIHN1Yi1jb21wb25lbnQgY29uc3RydWN0b3IgdGhhdFxuICAgIC8vIGV4dGVuZHMgQlRvYXN0IGFuZCBzZWxmLWRlc3RydWN0cyBhZnRlciBoaWRkZW5cbiAgICAvLyBAdnVlL2NvbXBvbmVudFxuICAgIHZhciBCVG9hc3RQb3AgPSBWdWUuZXh0ZW5kKHtcbiAgICAgIG5hbWU6ICdCVG9hc3RQb3AnLFxuICAgICAgZXh0ZW5kczogQlRvYXN0LFxuICAgICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQoKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBub3QgaW4gZG9jdW1lbnQgYW55IG1vcmVcbiAgICAgICAgaWYgKHRoaXMuJGVsICYmIHRoaXMuJGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICB0aGlzLiRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuJGVsKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpczsgLy8gU2VsZiBkZXN0cnVjdCBoYW5kbGVyXG5cbiAgICAgICAgdmFyIGhhbmRsZURlc3Ryb3kgPSBmdW5jdGlvbiBoYW5kbGVEZXN0cm95KCkge1xuICAgICAgICAgIC8vIEVuc3VyZSB0aGUgdG9hc3QgaGFzIGJlZW4gZm9yY2UgaGlkZGVuXG4gICAgICAgICAgc2VsZi5sb2NhbFNob3cgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmRvUmVuZGVyID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBJbiBhIGByZXF1ZXN0QUYoKWAgdG8gcmVsZWFzZSBjb250cm9sIGJhY2sgdG8gYXBwbGljYXRpb25cbiAgICAgICAgICAgICAgLy8gYW5kIHRvIGFsbG93IHRoZSBwb3J0YWwtdGFyZ2V0IHRpbWUgdG8gcmVtb3ZlIHRoZSBjb250ZW50XG4gICAgICAgICAgICAgIHJlcXVlc3RBRihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi4kZGVzdHJveSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9OyAvLyBTZWxmIGRlc3RydWN0IGlmIHBhcmVudCBkZXN0cm95ZWRcblxuXG4gICAgICAgIHRoaXMuJHBhcmVudC4kb25jZSgnaG9vazpkZXN0cm95ZWQnLCBoYW5kbGVEZXN0cm95KTsgLy8gU2VsZiBkZXN0cnVjdCBhZnRlciBoaWRkZW5cblxuICAgICAgICB0aGlzLiRvbmNlKCdoaWRkZW4nLCBoYW5kbGVEZXN0cm95KTsgLy8gU2VsZiBkZXN0cnVjdCB3aGVuIHRvYXN0ZXIgaXMgZGVzdHJveWVkXG5cbiAgICAgICAgdGhpcy5saXN0ZW5PblJvb3QoJ2J2Ojp0b2FzdGVyOjpkZXN0cm95ZWQnLCBmdW5jdGlvbiAodG9hc3Rlcikge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBoYXJkIHRvIHRlc3QgKi9cbiAgICAgICAgICBpZiAodG9hc3RlciA9PT0gc2VsZi50b2FzdGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVEZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTsgLy8gUHJpdmF0ZSBtZXRob2QgdG8gZ2VuZXJhdGUgdGhlIG9uLWRlbWFuZCB0b2FzdFxuXG4gICAgdmFyIG1ha2VUb2FzdCA9IGZ1bmN0aW9uIG1ha2VUb2FzdChwcm9wcywgJHBhcmVudCkge1xuICAgICAgaWYgKHdhcm5Ob3RDbGllbnQoUFJPUF9OQU1FJDMpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGBCVG9hc3RQb3BgIGNvbXBvbmVudFxuXG5cbiAgICAgIHZhciB0b2FzdCA9IG5ldyBCVG9hc3RQb3Aoe1xuICAgICAgICAvLyBXZSBzZXQgcGFyZW50IGFzIHRoZSBsb2NhbCBWTSBzbyB0aGVzZSB0b2FzdHMgY2FuIGVtaXQgZXZlbnRzIG9uIHRoZVxuICAgICAgICAvLyBhcHAgYCRyb290YCwgYW5kIGl0IGVuc3VyZXMgYEJUb2FzdGAgaXMgZGVzdHJveWVkIHdoZW4gcGFyZW50IGlzIGRlc3Ryb3llZFxuICAgICAgICBwYXJlbnQ6ICRwYXJlbnQsXG4gICAgICAgIHByb3BzRGF0YTogX29iamVjdFNwcmVhZDIoe30sIGZpbHRlck9wdGlvbnMkMShnZXRDb21wb25lbnRDb25maWcoJ0JUb2FzdCcpIHx8IHt9KSwge30sIG9taXQocHJvcHMsIGtleXMocHJvcHNUb1Nsb3RzJDEpKSwge1xuICAgICAgICAgIC8vIFByb3BzIHRoYXQgY2FuJ3QgYmUgb3ZlcnJpZGRlblxuICAgICAgICAgIHN0YXRpYzogZmFsc2UsXG4gICAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfSk7IC8vIENvbnZlcnQgY2VydGFpbiBwcm9wcyB0byBzbG90c1xuXG4gICAgICBrZXlzKHByb3BzVG9TbG90cyQxKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgLy8gQ2FuIGJlIGEgc3RyaW5nLCBvciBhcnJheSBvZiBWTm9kZXNcbiAgICAgICAgICBpZiAocHJvcCA9PT0gJ3RpdGxlJyAmJiBpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgdGl0bGUgaWYgaXQgaXMgYSBzdHJpbmcsIHdlIHdyYXAgaW4gYSA8c3Ryb25nPlxuICAgICAgICAgICAgdmFsdWUgPSBbJHBhcmVudC4kY3JlYXRlRWxlbWVudCgnc3Ryb25nJywge1xuICAgICAgICAgICAgICBjbGFzczogJ21yLTInXG4gICAgICAgICAgICB9LCB2YWx1ZSldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvYXN0LiRzbG90c1twcm9wc1RvU2xvdHMkMVtwcm9wXV0gPSBjb25jYXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gQ3JlYXRlIGEgbW91bnQgcG9pbnQgKGEgRElWKSBhbmQgbW91bnQgaXQgKHdoaWNoIHRyaWdnZXJzIHRoZSBzaG93KVxuXG4gICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICB0b2FzdC4kbW91bnQoZGl2KTtcbiAgICB9OyAvLyBEZWNsYXJlIEJ2VG9hc3QgaW5zdGFuY2UgcHJvcGVydHkgY2xhc3NcblxuXG4gICAgdmFyIEJ2VG9hc3QgPVxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBCdlRvYXN0KHZtKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdlRvYXN0KTtcblxuICAgICAgICAvLyBBc3NpZ24gdGhlIG5ldyBwcm9wZXJ0aWVzIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgYXNzaWduKHRoaXMsIHtcbiAgICAgICAgICBfdm06IHZtLFxuICAgICAgICAgIF9yb290OiB2bS4kcm9vdFxuICAgICAgICB9KTsgLy8gU2V0IHRoZXNlIHByb3BlcnRpZXMgYXMgcmVhZC1vbmx5IGFuZCBub24tZW51bWVyYWJsZVxuXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgIF92bTogcmVhZG9ubHlEZXNjcmlwdG9yKCksXG4gICAgICAgICAgX3Jvb3Q6IHJlYWRvbmx5RGVzY3JpcHRvcigpXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyAtLS0gUHVibGljIEluc3RhbmNlIG1ldGhvZHMgLS0tXG4gICAgICAvLyBPcGVucyBhIHVzZXIgZGVmaW5lZCB0b2FzdCBhbmQgcmV0dXJucyBpbW1lZGlhdGVseVxuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhCdlRvYXN0LCBbe1xuICAgICAgICBrZXk6IFwidG9hc3RcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvYXN0KGNvbnRlbnQpIHtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICBpZiAoIWNvbnRlbnQgfHwgd2Fybk5vdENsaWVudChQUk9QX05BTUUkMykpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWFrZVRvYXN0KF9vYmplY3RTcHJlYWQyKHt9LCBmaWx0ZXJPcHRpb25zJDEob3B0aW9ucyksIHtcbiAgICAgICAgICAgIHRvYXN0Q29udGVudDogY29udGVudFxuICAgICAgICAgIH0pLCB0aGlzLl92bSk7XG4gICAgICAgIH0gLy8gc2hvd3MgYSBgPGItdG9hc3Q+YCBjb21wb25lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIElEXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNob3dcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coaWQpIHtcbiAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QuJGVtaXQoJ2J2OjpzaG93Ojp0b2FzdCcsIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gSGlkZSBhIHRvYXN0IHdpdGggc3BlY2lmaWVkIElELCBvciBpZiBub3QgSUQgYWxsIHRvYXN0c1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJoaWRlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICAgIHZhciBpZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcblxuICAgICAgICAgIHRoaXMuX3Jvb3QuJGVtaXQoJ2J2OjpoaWRlOjp0b2FzdCcsIGlkKTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gQnZUb2FzdDtcbiAgICB9KCk7IC8vIEFkZCBvdXIgaW5zdGFuY2UgbWl4aW5cblxuXG4gICAgVnVlLm1peGluKHtcbiAgICAgIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlKCkge1xuICAgICAgICAvLyBCZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIGAkcm9vdGAgZm9yIGAkZW1pdHNgLCBhbmQgVk0gZm9yIHBhcmVudGluZyxcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBjcmVhdGUgYSBmcmVzaCBpbnN0YW5jZSBvZiBgQnZUb2FzdGAgZm9yIGVhY2ggVk1cbiAgICAgICAgdGhpc1tQUk9QX05BTUVfUFJJViQxXSA9IG5ldyBCdlRvYXN0KHRoaXMpO1xuICAgICAgfVxuICAgIH0pOyAvLyBEZWZpbmUgb3VyIHJlYWQtb25seSBgJGJ2VG9hc3RgIGluc3RhbmNlIHByb3BlcnR5XG4gICAgLy8gUGxhY2VkIGluIGFuIGlmIGp1c3QgaW4gY2FzZSBpbiBITVIgbW9kZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcblxuICAgIGlmICghVnVlLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShQUk9QX05BTUUkMykpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsIFBST1BfTkFNRSQzLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgaWYgKCF0aGlzIHx8ICF0aGlzW1BST1BfTkFNRV9QUklWJDFdKSB7XG4gICAgICAgICAgICB3YXJuKFwiXFxcIlwiLmNvbmNhdChQUk9QX05BTUUkMywgXCJcXFwiIG11c3QgYmUgYWNjZXNzZWQgZnJvbSBhIFZ1ZSBpbnN0YW5jZSBcXFwidGhpc1xcXCIgY29udGV4dC5cIiksICdCVG9hc3QnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpc1tQUk9QX05BTUVfUFJJViQxXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBCVlRvYXN0UGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBwbHVnaW5zOiB7XG4gICAgICBwbHVnaW46IHBsdWdpbiQxXG4gICAgfVxuICB9KTtcblxuICB2YXIgVG9hc3RQbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIEJUb2FzdDogQlRvYXN0LFxuICAgICAgQlRvYXN0ZXI6IEJUb2FzdGVyXG4gICAgfSxcbiAgICAvLyAkYnZUb2FzdCBpbmplY3Rpb25cbiAgICBwbHVnaW5zOiB7XG4gICAgICBCVlRvYXN0UGx1Z2luOiBCVlRvYXN0UGx1Z2luXG4gICAgfVxuICB9KTtcblxuICB2YXIgQlZfVE9PTFRJUCA9ICdfX0JWX1Rvb2x0aXBfXyc7IC8vIERlZmF1bHQgdHJpZ2dlclxuXG4gIHZhciBEZWZhdWx0VHJpZ2dlciQxID0gJ2hvdmVyIGZvY3VzJzsgLy8gVmFsaWQgZXZlbnQgdHJpZ2dlcnNcblxuICB2YXIgdmFsaWRUcmlnZ2VycyQxID0ge1xuICAgIGZvY3VzOiB0cnVlLFxuICAgIGhvdmVyOiB0cnVlLFxuICAgIGNsaWNrOiB0cnVlLFxuICAgIGJsdXI6IHRydWUsXG4gICAgbWFudWFsOiB0cnVlXG4gIH07IC8vIERpcmVjdGl2ZSBtb2RpZmllciB0ZXN0IHJlZ3VsYXIgZXhwcmVzc2lvbnMuIFByZS1jb21waWxlIGZvciBwZXJmb3JtYW5jZVxuXG4gIHZhciBodG1sUkUkMSA9IC9eaHRtbCQvaTtcbiAgdmFyIG5vbmludGVyYWN0aXZlUkUgPSAvXm5vbmludGVyYWN0aXZlJC9pO1xuICB2YXIgbm9GYWRlUkUkMSA9IC9ebm9mYWRlJC9pO1xuICB2YXIgcGxhY2VtZW50UkUkMSA9IC9eKGF1dG98dG9wKGxlZnR8cmlnaHQpP3xib3R0b20obGVmdHxyaWdodCk/fGxlZnQodG9wfGJvdHRvbSk/fHJpZ2h0KHRvcHxib3R0b20pPykkL2k7XG4gIHZhciBib3VuZGFyeVJFJDEgPSAvXih3aW5kb3d8dmlld3BvcnR8c2Nyb2xsUGFyZW50KSQvaTtcbiAgdmFyIGRlbGF5UkUkMSA9IC9eZFxcZCskL2k7XG4gIHZhciBkZWxheVNob3dSRSQxID0gL15kc1xcZCskL2k7XG4gIHZhciBkZWxheUhpZGVSRSQxID0gL15kaFxcZCskL2k7XG4gIHZhciBvZmZzZXRSRSQxID0gL15vLT9cXGQrJC9pO1xuICB2YXIgdmFyaWFudFJFJDEgPSAvXnYtLiskL2k7XG4gIHZhciBzcGFjZXNSRSQxID0gL1xccysvOyAvLyBCdWlsZCBhIFRvb2x0aXAgY29uZmlnIGJhc2VkIG9uIGJpbmRpbmdzIChpZiBhbnkpXG4gIC8vIEFyZ3VtZW50cyBhbmQgbW9kaWZpZXJzIHRha2UgcHJlY2VkZW5jZSBvdmVyIHBhc3NlZCB2YWx1ZSBjb25maWcgb2JqZWN0XG5cbiAgdmFyIHBhcnNlQmluZGluZ3MkMSA9IGZ1bmN0aW9uIHBhcnNlQmluZGluZ3MoYmluZGluZ3MsIHZub2RlKVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbm90IGVhc3kgdG8gdGVzdCAqL1xuICB7XG4gICAgLy8gV2Ugc3RhcnQgb3V0IHdpdGggYSBiYXNpYyBjb25maWdcbiAgICB2YXIgTkFNRSA9ICdCVG9vbHRpcCc7IC8vIERlZmF1bHQgY29uZmlnXG5cbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgIHRyaWdnZXI6ICcnLFxuICAgICAgLy8gRGVmYXVsdCBzZXQgYmVsb3cgaWYgbmVlZGVkXG4gICAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgICAgZmFsbGJhY2tQbGFjZW1lbnQ6ICdmbGlwJyxcbiAgICAgIGNvbnRhaW5lcjogZmFsc2UsXG4gICAgICAvLyBEZWZhdWx0IG9mIGJvZHlcbiAgICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIGlkOiBudWxsLFxuICAgICAgaHRtbDogZmFsc2UsXG4gICAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgIGRlbGF5OiBnZXRDb21wb25lbnRDb25maWcoTkFNRSwgJ2RlbGF5JyksXG4gICAgICBib3VuZGFyeTogU3RyaW5nKGdldENvbXBvbmVudENvbmZpZyhOQU1FLCAnYm91bmRhcnknKSksXG4gICAgICBib3VuZGFyeVBhZGRpbmc6IHBhcnNlSW50KGdldENvbXBvbmVudENvbmZpZyhOQU1FLCAnYm91bmRhcnlQYWRkaW5nJyksIDEwKSB8fCAwLFxuICAgICAgdmFyaWFudDogZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUsICd2YXJpYW50JyksXG4gICAgICBjdXN0b21DbGFzczogZ2V0Q29tcG9uZW50Q29uZmlnKE5BTUUsICdjdXN0b21DbGFzcycpXG4gICAgfTsgLy8gUHJvY2VzcyBgYmluZGluZ3MudmFsdWVgXG5cbiAgICBpZiAoaXNTdHJpbmcoYmluZGluZ3MudmFsdWUpIHx8IGlzTnVtYmVyKGJpbmRpbmdzLnZhbHVlKSkge1xuICAgICAgLy8gVmFsdWUgaXMgdG9vbHRpcCBjb250ZW50IChIVE1MIG9wdGlvbmFsbHkgc3VwcG9ydGVkKVxuICAgICAgY29uZmlnLnRpdGxlID0gYmluZGluZ3MudmFsdWU7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKGJpbmRpbmdzLnZhbHVlKSkge1xuICAgICAgLy8gVGl0bGUgZ2VuZXJhdG9yIGZ1bmN0aW9uXG4gICAgICBjb25maWcudGl0bGUgPSBiaW5kaW5ncy52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoYmluZGluZ3MudmFsdWUpKSB7XG4gICAgICAvLyBWYWx1ZSBpcyBjb25maWcgb2JqZWN0LCBzbyBtZXJnZVxuICAgICAgY29uZmlnID0gX29iamVjdFNwcmVhZDIoe30sIGNvbmZpZywge30sIGJpbmRpbmdzLnZhbHVlKTtcbiAgICB9IC8vIElmIHRpdGxlIGlzIG5vdCBwcm92aWRlZCwgdHJ5IHRpdGxlIGF0dHJpYnV0ZVxuXG5cbiAgICBpZiAoaXNVbmRlZmluZWQoY29uZmlnLnRpdGxlKSkge1xuICAgICAgLy8gVHJ5IGF0dHJpYnV0ZVxuICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhIHx8IHt9O1xuICAgICAgY29uZmlnLnRpdGxlID0gZGF0YS5hdHRycyAmJiAhaXNVbmRlZmluZWRPck51bGwoZGF0YS5hdHRycy50aXRsZSkgPyBkYXRhLmF0dHJzLnRpdGxlIDogdW5kZWZpbmVkO1xuICAgIH0gLy8gTm9ybWFsaXplIGRlbGF5XG5cblxuICAgIGlmICghaXNQbGFpbk9iamVjdChjb25maWcuZGVsYXkpKSB7XG4gICAgICBjb25maWcuZGVsYXkgPSB7XG4gICAgICAgIHNob3c6IHBhcnNlSW50KGNvbmZpZy5kZWxheSwgMTApIHx8IDAsXG4gICAgICAgIGhpZGU6IHBhcnNlSW50KGNvbmZpZy5kZWxheSwgMTApIHx8IDBcbiAgICAgIH07XG4gICAgfSAvLyBJZiBhcmd1bWVudCwgYXNzdW1lIGVsZW1lbnQgSUQgb2YgY29udGFpbmVyIGVsZW1lbnRcblxuXG4gICAgaWYgKGJpbmRpbmdzLmFyZykge1xuICAgICAgLy8gRWxlbWVudCBJRCBzcGVjaWZpZWQgYXMgYXJnXG4gICAgICAvLyBXZSBtdXN0IHByZXBlbmQgJyMnIHRvIGJlY29tZSBhIENTUyBzZWxlY3RvclxuICAgICAgY29uZmlnLmNvbnRhaW5lciA9IFwiI1wiLmNvbmNhdChiaW5kaW5ncy5hcmcpO1xuICAgIH0gLy8gUHJvY2VzcyBtb2RpZmllcnNcblxuXG4gICAga2V5cyhiaW5kaW5ncy5tb2RpZmllcnMpLmZvckVhY2goZnVuY3Rpb24gKG1vZCkge1xuICAgICAgaWYgKGh0bWxSRSQxLnRlc3QobW9kKSkge1xuICAgICAgICAvLyBUaXRsZSBhbGxvd3MgSFRNTFxuICAgICAgICBjb25maWcuaHRtbCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG5vbmludGVyYWN0aXZlUkUudGVzdChtb2QpKSB7XG4gICAgICAgIC8vIE5vbmludGVyYWN0aXZlXG4gICAgICAgIGNvbmZpZy5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChub0ZhZGVSRSQxLnRlc3QobW9kKSkge1xuICAgICAgICAvLyBObyBhbmltYXRpb25cbiAgICAgICAgY29uZmlnLmFuaW1hdGlvbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChwbGFjZW1lbnRSRSQxLnRlc3QobW9kKSkge1xuICAgICAgICAvLyBQbGFjZW1lbnQgb2YgdG9vbHRpcFxuICAgICAgICBjb25maWcucGxhY2VtZW50ID0gbW9kO1xuICAgICAgfSBlbHNlIGlmIChib3VuZGFyeVJFJDEudGVzdChtb2QpKSB7XG4gICAgICAgIC8vIEJvdW5kYXJ5IG9mIHRvb2x0aXBcbiAgICAgICAgbW9kID0gbW9kID09PSAnc2Nyb2xscGFyZW50JyA/ICdzY3JvbGxQYXJlbnQnIDogbW9kO1xuICAgICAgICBjb25maWcuYm91bmRhcnkgPSBtb2Q7XG4gICAgICB9IGVsc2UgaWYgKGRlbGF5UkUkMS50ZXN0KG1vZCkpIHtcbiAgICAgICAgLy8gRGVsYXkgdmFsdWVcbiAgICAgICAgdmFyIGRlbGF5ID0gcGFyc2VJbnQobW9kLnNsaWNlKDEpLCAxMCkgfHwgMDtcbiAgICAgICAgY29uZmlnLmRlbGF5LnNob3cgPSBkZWxheTtcbiAgICAgICAgY29uZmlnLmRlbGF5LmhpZGUgPSBkZWxheTtcbiAgICAgIH0gZWxzZSBpZiAoZGVsYXlTaG93UkUkMS50ZXN0KG1vZCkpIHtcbiAgICAgICAgLy8gRGVsYXkgc2hvdyB2YWx1ZVxuICAgICAgICBjb25maWcuZGVsYXkuc2hvdyA9IHBhcnNlSW50KG1vZC5zbGljZSgyKSwgMTApIHx8IDA7XG4gICAgICB9IGVsc2UgaWYgKGRlbGF5SGlkZVJFJDEudGVzdChtb2QpKSB7XG4gICAgICAgIC8vIERlbGF5IGhpZGUgdmFsdWVcbiAgICAgICAgY29uZmlnLmRlbGF5LmhpZGUgPSBwYXJzZUludChtb2Quc2xpY2UoMiksIDEwKSB8fCAwO1xuICAgICAgfSBlbHNlIGlmIChvZmZzZXRSRSQxLnRlc3QobW9kKSkge1xuICAgICAgICAvLyBPZmZzZXQgdmFsdWUsIG5lZ2F0aXZlIGFsbG93ZWRcbiAgICAgICAgY29uZmlnLm9mZnNldCA9IHBhcnNlSW50KG1vZC5zbGljZSgxKSwgMTApIHx8IDA7XG4gICAgICB9IGVsc2UgaWYgKHZhcmlhbnRSRSQxLnRlc3QobW9kKSkge1xuICAgICAgICAvLyBWYXJpYW50XG4gICAgICAgIGNvbmZpZy52YXJpYW50ID0gbW9kLnNsaWNlKDIpIHx8IG51bGw7XG4gICAgICB9XG4gICAgfSk7IC8vIFNwZWNpYWwgaGFuZGxpbmcgb2YgZXZlbnQgdHJpZ2dlciBtb2RpZmllcnMgdHJpZ2dlciBpc1xuICAgIC8vIGEgc3BhY2Ugc2VwYXJhdGVkIGxpc3RcblxuICAgIHZhciBzZWxlY3RlZFRyaWdnZXJzID0ge307IC8vIFBhcnNlIGN1cnJlbnQgY29uZmlnIG9iamVjdCB0cmlnZ2VyXG5cbiAgICBjb25jYXQoY29uZmlnLnRyaWdnZXIgfHwgJycpLmZpbHRlcihpZGVudGl0eSkuam9pbignICcpLnRyaW0oKS50b0xvd2VyQ2FzZSgpLnNwbGl0KHNwYWNlc1JFJDEpLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgIGlmICh2YWxpZFRyaWdnZXJzJDFbdHJpZ2dlcl0pIHtcbiAgICAgICAgc2VsZWN0ZWRUcmlnZ2Vyc1t0cmlnZ2VyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7IC8vIFBhcnNlIG1vZGlmaWVycyBmb3IgdHJpZ2dlcnNcblxuICAgIGtleXMoYmluZGluZ3MubW9kaWZpZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgIG1vZCA9IG1vZC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAodmFsaWRUcmlnZ2VycyQxW21vZF0pIHtcbiAgICAgICAgLy8gSWYgbW9kaWZpZXIgaXMgYSB2YWxpZCB0cmlnZ2VyXG4gICAgICAgIHNlbGVjdGVkVHJpZ2dlcnNbbW9kXSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7IC8vIFNhbml0aXplIHRyaWdnZXJzXG5cbiAgICBjb25maWcudHJpZ2dlciA9IGtleXMoc2VsZWN0ZWRUcmlnZ2Vycykuam9pbignICcpO1xuXG4gICAgaWYgKGNvbmZpZy50cmlnZ2VyID09PSAnYmx1cicpIHtcbiAgICAgIC8vIEJsdXIgYnkgaXRzZWxmIGlzIHVzZWxlc3MsIHNvIGNvbnZlcnQgaXQgdG8gJ2ZvY3VzJ1xuICAgICAgY29uZmlnLnRyaWdnZXIgPSAnZm9jdXMnO1xuICAgIH1cblxuICAgIGlmICghY29uZmlnLnRyaWdnZXIpIHtcbiAgICAgIC8vIFVzZSBkZWZhdWx0IHRyaWdnZXJcbiAgICAgIGNvbmZpZy50cmlnZ2VyID0gRGVmYXVsdFRyaWdnZXIkMTtcbiAgICB9IC8vIFJldHVybiB0aGUgY29uZmlnXG5cblxuICAgIHJldHVybiBjb25maWc7XG4gIH07IC8vIEFkZC91cGRhdGUgVG9vbHRpcCBvbiBvdXIgZWxlbWVudFxuXG5cbiAgdmFyIGFwcGx5VG9vbHRpcCA9IGZ1bmN0aW9uIGFwcGx5VG9vbHRpcChlbCwgYmluZGluZ3MsIHZub2RlKSB7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvbmZpZyA9IHBhcnNlQmluZGluZ3MkMShiaW5kaW5ncywgdm5vZGUpO1xuXG4gICAgaWYgKCFlbFtCVl9UT09MVElQXSkge1xuICAgICAgdmFyICRwYXJlbnQgPSB2bm9kZS5jb250ZXh0O1xuICAgICAgZWxbQlZfVE9PTFRJUF0gPSBuZXcgQlZUb29sdGlwKHtcbiAgICAgICAgcGFyZW50OiAkcGFyZW50LFxuICAgICAgICAvLyBBZGQgdGhlIHBhcmVudCdzIHNjb3BlZCBzdHlsZSBhdHRyaWJ1dGUgZGF0YVxuICAgICAgICBfc2NvcGVJZDogZ2V0U2NvcGVJZCgkcGFyZW50LCB1bmRlZmluZWQpXG4gICAgICB9KTtcbiAgICAgIGVsW0JWX1RPT0xUSVBdLl9fYnZfcHJldl9kYXRhX18gPSB7fTtcbiAgICAgIGVsW0JWX1RPT0xUSVBdLiRvbignc2hvdycsIGZ1bmN0aW9uICgpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZm9yIG5vdyAqL1xuICAgICAge1xuICAgICAgICAvLyBCZWZvcmUgc2hvd2luZyB0aGUgdG9vbHRpcCwgd2UgdXBkYXRlIHRoZSB0aXRsZSBpZiBpdCBpcyBhIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGNvbmZpZy50aXRsZSkpIHtcbiAgICAgICAgICBlbFtCVl9UT09MVElQXS51cGRhdGVEYXRhKHtcbiAgICAgICAgICAgIHRpdGxlOiBjb25maWcudGl0bGUoZWwpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgdGl0bGU6IGNvbmZpZy50aXRsZSxcbiAgICAgIHRyaWdnZXJzOiBjb25maWcudHJpZ2dlcixcbiAgICAgIHBsYWNlbWVudDogY29uZmlnLnBsYWNlbWVudCxcbiAgICAgIGZhbGxiYWNrUGxhY2VtZW50OiBjb25maWcuZmFsbGJhY2tQbGFjZW1lbnQsXG4gICAgICB2YXJpYW50OiBjb25maWcudmFyaWFudCxcbiAgICAgIGN1c3RvbUNsYXNzOiBjb25maWcuY3VzdG9tQ2xhc3MsXG4gICAgICBjb250YWluZXI6IGNvbmZpZy5jb250YWluZXIsXG4gICAgICBib3VuZGFyeTogY29uZmlnLmJvdW5kYXJ5LFxuICAgICAgZGVsYXk6IGNvbmZpZy5kZWxheSxcbiAgICAgIG9mZnNldDogY29uZmlnLm9mZnNldCxcbiAgICAgIG5vRmFkZTogIWNvbmZpZy5hbmltYXRpb24sXG4gICAgICBpZDogY29uZmlnLmlkLFxuICAgICAgaW50ZXJhY3RpdmU6IGNvbmZpZy5pbnRlcmFjdGl2ZSxcbiAgICAgIGRpc2FibGVkOiBjb25maWcuZGlzYWJsZWQsXG4gICAgICBodG1sOiBjb25maWcuaHRtbFxuICAgIH07XG4gICAgdmFyIG9sZERhdGEgPSBlbFtCVl9UT09MVElQXS5fX2J2X3ByZXZfZGF0YV9fO1xuICAgIGVsW0JWX1RPT0xUSVBdLl9fYnZfcHJldl9kYXRhX18gPSBkYXRhO1xuXG4gICAgaWYgKCFsb29zZUVxdWFsKGRhdGEsIG9sZERhdGEpKSB7XG4gICAgICAvLyBXZSBvbmx5IHVwZGF0ZSB0aGUgaW5zdGFuY2UgaWYgZGF0YSBoYXMgY2hhbmdlZFxuICAgICAgdmFyIG5ld0RhdGEgPSB7XG4gICAgICAgIHRhcmdldDogZWxcbiAgICAgIH07XG4gICAgICBrZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgLy8gV2Ugb25seSBwYXNzIGRhdGEgcHJvcGVydGllcyB0aGF0IGhhdmUgY2hhbmdlZFxuICAgICAgICBpZiAoZGF0YVtwcm9wXSAhPT0gb2xkRGF0YVtwcm9wXSkge1xuICAgICAgICAgIC8vIGlmIHRpdGxlIGlzIGEgZnVuY3Rpb24sIHdlIGV4ZWN1dGUgaXQgaGVyZVxuICAgICAgICAgIG5ld0RhdGFbcHJvcF0gPSBwcm9wID09PSAndGl0bGUnICYmIGlzRnVuY3Rpb24oZGF0YVtwcm9wXSkgPyBkYXRhW3Byb3BdKGVsKSA6IGRhdGFbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWxbQlZfVE9PTFRJUF0udXBkYXRlRGF0YShuZXdEYXRhKTtcbiAgICB9XG4gIH07IC8vIFJlbW92ZSBUb29sdGlwIG9uIG91ciBlbGVtZW50XG5cblxuICB2YXIgcmVtb3ZlVG9vbHRpcCA9IGZ1bmN0aW9uIHJlbW92ZVRvb2x0aXAoZWwpIHtcbiAgICBpZiAoZWxbQlZfVE9PTFRJUF0pIHtcbiAgICAgIGVsW0JWX1RPT0xUSVBdLiRkZXN0cm95KCk7XG4gICAgICBlbFtCVl9UT09MVElQXSA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVsZXRlIGVsW0JWX1RPT0xUSVBdO1xuICB9OyAvLyBFeHBvcnQgb3VyIGRpcmVjdGl2ZVxuXG5cbiAgdmFyIFZCVG9vbHRpcCA9IHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKGVsLCBiaW5kaW5ncywgdm5vZGUpIHtcbiAgICAgIGFwcGx5VG9vbHRpcChlbCwgYmluZGluZ3MsIHZub2RlKTtcbiAgICB9LFxuICAgIC8vIFdlIHVzZSBgY29tcG9uZW50VXBkYXRlZGAgaGVyZSBpbnN0ZWFkIG9mIGB1cGRhdGVgLCBhcyB0aGUgZm9ybWVyXG4gICAgLy8gd2FpdHMgdW50aWwgdGhlIGNvbnRhaW5pbmcgY29tcG9uZW50IGFuZCBjaGlsZHJlbiBoYXZlIGZpbmlzaGVkIHVwZGF0aW5nXG4gICAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZ3MsIHZub2RlKSB7XG4gICAgICAvLyBQZXJmb3JtZWQgaW4gYSBgJG5leHRUaWNrKClgIHRvIHByZXZlbnQgcmVuZGVyIHVwZGF0ZSBsb29wc1xuICAgICAgdm5vZGUuY29udGV4dC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBhcHBseVRvb2x0aXAoZWwsIGJpbmRpbmdzLCB2bm9kZSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKGVsKSB7XG4gICAgICByZW1vdmVUb29sdGlwKGVsKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIFZCVG9vbHRpcFBsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgVkJUb29sdGlwOiBWQlRvb2x0aXBcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBUb29sdGlwUGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBCVG9vbHRpcDogQlRvb2x0aXBcbiAgICB9LFxuICAgIHBsdWdpbnM6IHtcbiAgICAgIFZCVG9vbHRpcFBsdWdpbjogVkJUb29sdGlwUGx1Z2luXG4gICAgfVxuICB9KTtcblxuICB2YXIgY29tcG9uZW50c1BsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgcGx1Z2luczoge1xuICAgICAgQWxlcnRQbHVnaW46IEFsZXJ0UGx1Z2luLFxuICAgICAgQmFkZ2VQbHVnaW46IEJhZGdlUGx1Z2luLFxuICAgICAgQnJlYWRjcnVtYlBsdWdpbjogQnJlYWRjcnVtYlBsdWdpbixcbiAgICAgIEJ1dHRvblBsdWdpbjogQnV0dG9uUGx1Z2luLFxuICAgICAgQnV0dG9uR3JvdXBQbHVnaW46IEJ1dHRvbkdyb3VwUGx1Z2luLFxuICAgICAgQnV0dG9uVG9vbGJhclBsdWdpbjogQnV0dG9uVG9vbGJhclBsdWdpbixcbiAgICAgIENhbGVuZGFyUGx1Z2luOiBDYWxlbmRhclBsdWdpbixcbiAgICAgIENhcmRQbHVnaW46IENhcmRQbHVnaW4sXG4gICAgICBDYXJvdXNlbFBsdWdpbjogQ2Fyb3VzZWxQbHVnaW4sXG4gICAgICBDb2xsYXBzZVBsdWdpbjogQ29sbGFwc2VQbHVnaW4sXG4gICAgICBEcm9wZG93blBsdWdpbjogRHJvcGRvd25QbHVnaW4sXG4gICAgICBFbWJlZFBsdWdpbjogRW1iZWRQbHVnaW4sXG4gICAgICBGb3JtUGx1Z2luOiBGb3JtUGx1Z2luLFxuICAgICAgRm9ybUNoZWNrYm94UGx1Z2luOiBGb3JtQ2hlY2tib3hQbHVnaW4sXG4gICAgICBGb3JtRGF0ZXBpY2tlclBsdWdpbjogRm9ybURhdGVwaWNrZXJQbHVnaW4sXG4gICAgICBGb3JtRmlsZVBsdWdpbjogRm9ybUZpbGVQbHVnaW4sXG4gICAgICBGb3JtR3JvdXBQbHVnaW46IEZvcm1Hcm91cFBsdWdpbixcbiAgICAgIEZvcm1JbnB1dFBsdWdpbjogRm9ybUlucHV0UGx1Z2luLFxuICAgICAgRm9ybVJhZGlvUGx1Z2luOiBGb3JtUmFkaW9QbHVnaW4sXG4gICAgICBGb3JtU2VsZWN0UGx1Z2luOiBGb3JtU2VsZWN0UGx1Z2luLFxuICAgICAgRm9ybVNwaW5idXR0b25QbHVnaW46IEZvcm1TcGluYnV0dG9uUGx1Z2luLFxuICAgICAgRm9ybVRhZ3NQbHVnaW46IEZvcm1UYWdzUGx1Z2luLFxuICAgICAgRm9ybVRleHRhcmVhUGx1Z2luOiBGb3JtVGV4dGFyZWFQbHVnaW4sXG4gICAgICBJbWFnZVBsdWdpbjogSW1hZ2VQbHVnaW4sXG4gICAgICBJbnB1dEdyb3VwUGx1Z2luOiBJbnB1dEdyb3VwUGx1Z2luLFxuICAgICAgSnVtYm90cm9uUGx1Z2luOiBKdW1ib3Ryb25QbHVnaW4sXG4gICAgICBMYXlvdXRQbHVnaW46IExheW91dFBsdWdpbixcbiAgICAgIExpbmtQbHVnaW46IExpbmtQbHVnaW4sXG4gICAgICBMaXN0R3JvdXBQbHVnaW46IExpc3RHcm91cFBsdWdpbixcbiAgICAgIE1lZGlhUGx1Z2luOiBNZWRpYVBsdWdpbixcbiAgICAgIE1vZGFsUGx1Z2luOiBNb2RhbFBsdWdpbixcbiAgICAgIE5hdlBsdWdpbjogTmF2UGx1Z2luLFxuICAgICAgTmF2YmFyUGx1Z2luOiBOYXZiYXJQbHVnaW4sXG4gICAgICBQYWdpbmF0aW9uUGx1Z2luOiBQYWdpbmF0aW9uUGx1Z2luLFxuICAgICAgUGFnaW5hdGlvbk5hdlBsdWdpbjogUGFnaW5hdGlvbk5hdlBsdWdpbixcbiAgICAgIFBvcG92ZXJQbHVnaW46IFBvcG92ZXJQbHVnaW4sXG4gICAgICBQcm9ncmVzc1BsdWdpbjogUHJvZ3Jlc3NQbHVnaW4sXG4gICAgICBTcGlubmVyUGx1Z2luOiBTcGlubmVyUGx1Z2luLFxuICAgICAgVGFibGVQbHVnaW46IFRhYmxlUGx1Z2luLFxuICAgICAgVGFic1BsdWdpbjogVGFic1BsdWdpbixcbiAgICAgIFRvYXN0UGx1Z2luOiBUb2FzdFBsdWdpbixcbiAgICAgIFRvb2x0aXBQbHVnaW46IFRvb2x0aXBQbHVnaW5cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBWQkhvdmVyUGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICBWQkhvdmVyOiBWQkhvdmVyXG4gICAgfVxuICB9KTtcblxuICB2YXIgVkJNb2RhbFBsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgVkJNb2RhbDogVkJNb2RhbFxuICAgIH1cbiAgfSk7XG5cbiAgLypcbiAgICogQ29uc3RhbnRzIC8gRGVmYXVsdHNcbiAgICovXG5cbiAgdmFyIE5BTUUkRSA9ICd2LWItc2Nyb2xsc3B5JztcbiAgdmFyIEFDVElWQVRFX0VWRU5UID0gJ2J2OjpzY3JvbGxzcHk6OmFjdGl2YXRlJztcbiAgdmFyIERlZmF1bHQgPSB7XG4gICAgZWxlbWVudDogJ2JvZHknLFxuICAgIG9mZnNldDogMTAsXG4gICAgbWV0aG9kOiAnYXV0bycsXG4gICAgdGhyb3R0bGU6IDc1XG4gIH07XG4gIHZhciBEZWZhdWx0VHlwZSA9IHtcbiAgICBlbGVtZW50OiAnKHN0cmluZ3xlbGVtZW50fGNvbXBvbmVudCknLFxuICAgIG9mZnNldDogJ251bWJlcicsXG4gICAgbWV0aG9kOiAnc3RyaW5nJyxcbiAgICB0aHJvdHRsZTogJ251bWJlcidcbiAgfTtcbiAgdmFyIENsYXNzTmFtZSA9IHtcbiAgICBEUk9QRE9XTl9JVEVNOiAnZHJvcGRvd24taXRlbScsXG4gICAgQUNUSVZFOiAnYWN0aXZlJ1xuICB9O1xuICB2YXIgU2VsZWN0b3IkMiA9IHtcbiAgICBBQ1RJVkU6ICcuYWN0aXZlJyxcbiAgICBOQVZfTElTVF9HUk9VUDogJy5uYXYsIC5saXN0LWdyb3VwJyxcbiAgICBOQVZfTElOS1M6ICcubmF2LWxpbmsnLFxuICAgIE5BVl9JVEVNUzogJy5uYXYtaXRlbScsXG4gICAgTElTVF9JVEVNUzogJy5saXN0LWdyb3VwLWl0ZW0nLFxuICAgIERST1BET1dOOiAnLmRyb3Bkb3duLCAuZHJvcHVwJyxcbiAgICBEUk9QRE9XTl9JVEVNUzogJy5kcm9wZG93bi1pdGVtJyxcbiAgICBEUk9QRE9XTl9UT0dHTEU6ICcuZHJvcGRvd24tdG9nZ2xlJ1xuICB9O1xuICB2YXIgT2Zmc2V0TWV0aG9kID0ge1xuICAgIE9GRlNFVDogJ29mZnNldCcsXG4gICAgUE9TSVRJT046ICdwb3NpdGlvbidcbiAgfTsgLy8gSFJFRnMgbXVzdCBlbmQgd2l0aCBhIGhhc2ggZm9sbG93ZWQgYnkgYXQgbGVhc3Qgb25lIG5vbi1oYXNoIGNoYXJhY3Rlci5cbiAgLy8gSFJFRnMgaW4gdGhlIGxpbmtzIGFyZSBhc3N1bWVkIHRvIHBvaW50IHRvIG5vbi1leHRlcm5hbCBsaW5rcy5cbiAgLy8gQ29tcGFyaXNvbiB0byB0aGUgY3VycmVudCBwYWdlIGJhc2UgVVJMIGlzIG5vdCBwZXJmb3JtZWQhXG5cbiAgdmFyIEhSRUZfUkVHRVggPSAvXi4qKCNbXiNdKykkLzsgLy8gVHJhbnNpdGlvbiBFdmVudHNcblxuICB2YXIgVHJhbnNpdGlvbkVuZEV2ZW50cyQxID0gWyd3ZWJraXRUcmFuc2l0aW9uRW5kJywgJ3RyYW5zaXRpb25lbmQnLCAnb3RyYW5zaXRpb25lbmQnLCAnb1RyYW5zaXRpb25FbmQnXTtcbiAgLypcbiAgICogVXRpbGl0eSBNZXRob2RzXG4gICAqL1xuICAvLyBCZXR0ZXIgdmFyIHR5cGUgZGV0ZWN0aW9uXG5cbiAgdmFyIHRvVHlwZSQxID0gZnVuY3Rpb24gdG9UeXBlKG9iailcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCBlYXN5IHRvIHRlc3QgKi9cbiAge1xuICAgIHJldHVybiB0b1N0cmluZyhvYmopLm1hdGNoKC9cXHMoW2EtekEtWl0rKS8pWzFdLnRvTG93ZXJDYXNlKCk7XG4gIH07IC8vIENoZWNrIGNvbmZpZyBwcm9wZXJ0aWVzIGZvciBleHBlY3RlZCB0eXBlc1xuXG5cbiAgdmFyIHR5cGVDaGVja0NvbmZpZyA9IGZ1bmN0aW9uIHR5cGVDaGVja0NvbmZpZyhjb21wb25lbnROYW1lLCBjb25maWcsIGNvbmZpZ1R5cGVzKVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbm90IGVhc3kgdG8gdGVzdCAqL1xuICB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gY29uZmlnVHlwZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlnVHlwZXMsIHByb3BlcnR5KSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IGNvbmZpZ1R5cGVzW3Byb3BlcnR5XTtcbiAgICAgICAgdmFyIHZhbHVlID0gY29uZmlnW3Byb3BlcnR5XTtcbiAgICAgICAgdmFyIHZhbHVlVHlwZSA9IHZhbHVlICYmIGlzRWxlbWVudCh2YWx1ZSkgPyAnZWxlbWVudCcgOiB0b1R5cGUkMSh2YWx1ZSk7IC8vIGhhbmRsZSBWdWUgaW5zdGFuY2VzXG5cbiAgICAgICAgdmFsdWVUeXBlID0gdmFsdWUgJiYgdmFsdWUuX2lzVnVlID8gJ2NvbXBvbmVudCcgOiB2YWx1ZVR5cGU7XG5cbiAgICAgICAgaWYgKCFuZXcgUmVnRXhwKGV4cGVjdGVkVHlwZXMpLnRlc3QodmFsdWVUeXBlKSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgd2FybihcIlwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcIjogT3B0aW9uIFxcXCJcIikuY29uY2F0KHByb3BlcnR5LCBcIlxcXCIgcHJvdmlkZWQgdHlwZSBcXFwiXCIpLmNvbmNhdCh2YWx1ZVR5cGUsIFwiXFxcIiBidXQgZXhwZWN0ZWQgdHlwZSBcXFwiXCIpLmNvbmNhdChleHBlY3RlZFR5cGVzLCBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCBlYXN5IHRvIHRlc3QgKi9cblxuXG4gIHZhciBTY3JvbGxTcHlcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCBlYXN5IHRvIHRlc3QgKi9cbiAgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxTcHkoZWxlbWVudCwgY29uZmlnLCAkcm9vdCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNjcm9sbFNweSk7XG5cbiAgICAgIC8vIFRoZSBlbGVtZW50IHdlIGFjdGl2YXRlIGxpbmtzIGluXG4gICAgICB0aGlzLiRlbCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLiRzY3JvbGxlciA9IG51bGw7XG4gICAgICB0aGlzLiRzZWxlY3RvciA9IFtTZWxlY3RvciQyLk5BVl9MSU5LUywgU2VsZWN0b3IkMi5MSVNUX0lURU1TLCBTZWxlY3RvciQyLkRST1BET1dOX0lURU1TXS5qb2luKCcsJyk7XG4gICAgICB0aGlzLiRvZmZzZXRzID0gW107XG4gICAgICB0aGlzLiR0YXJnZXRzID0gW107XG4gICAgICB0aGlzLiRhY3RpdmVUYXJnZXQgPSBudWxsO1xuICAgICAgdGhpcy4kc2Nyb2xsSGVpZ2h0ID0gMDtcbiAgICAgIHRoaXMuJHJlc2l6ZVRpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy4kb2JzX3Njcm9sbGVyID0gbnVsbDtcbiAgICAgIHRoaXMuJG9ic190YXJnZXRzID0gbnVsbDtcbiAgICAgIHRoaXMuJHJvb3QgPSAkcm9vdCB8fCBudWxsO1xuICAgICAgdGhpcy4kY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMudXBkYXRlQ29uZmlnKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFNjcm9sbFNweSwgW3tcbiAgICAgIGtleTogXCJ1cGRhdGVDb25maWdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDb25maWcoY29uZmlnLCAkcm9vdCkge1xuICAgICAgICBpZiAodGhpcy4kc2Nyb2xsZXIpIHtcbiAgICAgICAgICAvLyBKdXN0IGluIGNhc2Ugb3V0IHNjcm9sbCBlbGVtZW50IGhhcyBjaGFuZ2VkXG4gICAgICAgICAgdGhpcy51bmxpc3RlbigpO1xuICAgICAgICAgIHRoaXMuJHNjcm9sbGVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjZmcgPSBfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LCB7fSwgY29uZmlnKTtcblxuICAgICAgICBpZiAoJHJvb3QpIHtcbiAgICAgICAgICB0aGlzLiRyb290ID0gJHJvb3Q7XG4gICAgICAgIH1cblxuICAgICAgICB0eXBlQ2hlY2tDb25maWcodGhpcy5jb25zdHJ1Y3Rvci5OYW1lLCBjZmcsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpO1xuICAgICAgICB0aGlzLiRjb25maWcgPSBjZmc7XG5cbiAgICAgICAgaWYgKHRoaXMuJHJvb3QpIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgdGhpcy4kcm9vdC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5saXN0ZW4oKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxpc3RlbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnVubGlzdGVuKCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiRyZXNpemVUaW1lb3V0KTtcbiAgICAgICAgdGhpcy4kcmVzaXplVGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgICAgICAgdGhpcy4kY29uZmlnID0gbnVsbDtcbiAgICAgICAgdGhpcy4kc2Nyb2xsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLiRzZWxlY3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuJG9mZnNldHMgPSBudWxsO1xuICAgICAgICB0aGlzLiR0YXJnZXRzID0gbnVsbDtcbiAgICAgICAgdGhpcy4kYWN0aXZlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4kc2Nyb2xsSGVpZ2h0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibGlzdGVuXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBzY3JvbGxlciA9IHRoaXMuZ2V0U2Nyb2xsZXIoKTtcblxuICAgICAgICBpZiAoc2Nyb2xsZXIgJiYgc2Nyb2xsZXIudGFnTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgICAgICAgZXZlbnRPbihzY3JvbGxlciwgJ3Njcm9sbCcsIHRoaXMsIEVWRU5UX09QVElPTlNfTk9fQ0FQVFVSRSk7XG4gICAgICAgIH1cblxuICAgICAgICBldmVudE9uKHdpbmRvdywgJ3Njcm9sbCcsIHRoaXMsIEVWRU5UX09QVElPTlNfTk9fQ0FQVFVSRSk7XG4gICAgICAgIGV2ZW50T24od2luZG93LCAncmVzaXplJywgdGhpcywgRVZFTlRfT1BUSU9OU19OT19DQVBUVVJFKTtcbiAgICAgICAgZXZlbnRPbih3aW5kb3csICdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMsIEVWRU5UX09QVElPTlNfTk9fQ0FQVFVSRSk7XG4gICAgICAgIFRyYW5zaXRpb25FbmRFdmVudHMkMS5mb3JFYWNoKGZ1bmN0aW9uIChldnROYW1lKSB7XG4gICAgICAgICAgZXZlbnRPbih3aW5kb3csIGV2dE5hbWUsIF90aGlzLCBFVkVOVF9PUFRJT05TX05PX0NBUFRVUkUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRPYnNlcnZlcnModHJ1ZSk7IC8vIFNjaGVkdWxlIGEgcmVmcmVzaFxuXG4gICAgICAgIHRoaXMuaGFuZGxlRXZlbnQoJ3JlZnJlc2gnKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidW5saXN0ZW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1bmxpc3RlbigpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHNjcm9sbGVyID0gdGhpcy5nZXRTY3JvbGxlcigpO1xuICAgICAgICB0aGlzLnNldE9ic2VydmVycyhmYWxzZSk7XG5cbiAgICAgICAgaWYgKHNjcm9sbGVyICYmIHNjcm9sbGVyLnRhZ05hbWUgIT09ICdCT0RZJykge1xuICAgICAgICAgIGV2ZW50T2ZmKHNjcm9sbGVyLCAnc2Nyb2xsJywgdGhpcywgRVZFTlRfT1BUSU9OU19OT19DQVBUVVJFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50T2ZmKHdpbmRvdywgJ3Njcm9sbCcsIHRoaXMsIEVWRU5UX09QVElPTlNfTk9fQ0FQVFVSRSk7XG4gICAgICAgIGV2ZW50T2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMsIEVWRU5UX09QVElPTlNfTk9fQ0FQVFVSRSk7XG4gICAgICAgIGV2ZW50T2ZmKHdpbmRvdywgJ29yaWVudGF0aW9uY2hhbmdlJywgdGhpcywgRVZFTlRfT1BUSU9OU19OT19DQVBUVVJFKTtcbiAgICAgICAgVHJhbnNpdGlvbkVuZEV2ZW50cyQxLmZvckVhY2goZnVuY3Rpb24gKGV2dE5hbWUpIHtcbiAgICAgICAgICBldmVudE9mZih3aW5kb3csIGV2dE5hbWUsIF90aGlzMiwgRVZFTlRfT1BUSU9OU19OT19DQVBUVVJFKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldE9ic2VydmVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9ic2VydmVycyhvbikge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAvLyBXZSBvYnNlcnZlIGJvdGggdGhlIHNjcm9sbGVyIGZvciBjb250ZW50IGNoYW5nZXMsIGFuZCB0aGUgdGFyZ2V0IGxpbmtzXG4gICAgICAgIGlmICh0aGlzLiRvYnNfc2Nyb2xsZXIpIHtcbiAgICAgICAgICB0aGlzLiRvYnNfc2Nyb2xsZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIHRoaXMuJG9ic19zY3JvbGxlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy4kb2JzX3RhcmdldHMpIHtcbiAgICAgICAgICB0aGlzLiRvYnNfdGFyZ2V0cy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgdGhpcy4kb2JzX3RhcmdldHMgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9uKSB7XG4gICAgICAgICAgdGhpcy4kb2JzX3RhcmdldHMgPSBvYnNlcnZlRG9tKHRoaXMuJGVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuaGFuZGxlRXZlbnQoJ211dGF0aW9uJyk7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFsnaHJlZiddXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy4kb2JzX3Njcm9sbGVyID0gb2JzZXJ2ZURvbSh0aGlzLmdldFNjcm9sbGVyKCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5oYW5kbGVFdmVudCgnbXV0YXRpb24nKTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFsnaWQnLCAnc3R5bGUnLCAnY2xhc3MnXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIEdlbmVyYWwgZXZlbnQgaGFuZGxlclxuXG4gICAgfSwge1xuICAgICAga2V5OiBcImhhbmRsZUV2ZW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZ0KSB7XG4gICAgICAgIHZhciB0eXBlID0gaXNTdHJpbmcoZXZ0KSA/IGV2dCA6IGV2dC50eXBlO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHJlc2l6ZVRocm90dGxlID0gZnVuY3Rpb24gcmVzaXplVGhyb3R0bGUoKSB7XG4gICAgICAgICAgaWYgKCFzZWxmLiRyZXNpemVUaW1lb3V0KSB7XG4gICAgICAgICAgICBzZWxmLiRyZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHNlbGYucmVmcmVzaCgpO1xuICAgICAgICAgICAgICBzZWxmLnByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgc2VsZi4kcmVzaXplVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9LCBzZWxmLiRjb25maWcudGhyb3R0bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3Njcm9sbCcpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuJG9ic19zY3JvbGxlcikge1xuICAgICAgICAgICAgLy8gSnVzdCBpbiBjYXNlIHdlIGFyZSBhZGRlZCB0byB0aGUgRE9NIGJlZm9yZSB0aGUgc2Nyb2xsIHRhcmdldCBpc1xuICAgICAgICAgICAgLy8gV2UgcmUtaW5zdGFudGlhdGUgb3VyIGxpc3RlbmVycywganVzdCBpbiBjYXNlXG4gICAgICAgICAgICB0aGlzLmxpc3RlbigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucHJvY2VzcygpO1xuICAgICAgICB9IGVsc2UgaWYgKC8ocmVzaXplfG9yaWVudGF0aW9uY2hhbmdlfG11dGF0aW9ufHJlZnJlc2gpLy50ZXN0KHR5cGUpKSB7XG4gICAgICAgICAgLy8gUG9zdHBvbmUgdGhlc2UgZXZlbnRzIGJ5IHRocm90dGxlIHRpbWVcbiAgICAgICAgICByZXNpemVUaHJvdHRsZSgpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJlZnJlc2ggdGhlIGxpc3Qgb2YgdGFyZ2V0IGxpbmtzIG9uIHRoZSBlbGVtZW50IHdlIGFyZSBhcHBsaWVkIHRvXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVmcmVzaFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBzY3JvbGxlciA9IHRoaXMuZ2V0U2Nyb2xsZXIoKTtcblxuICAgICAgICBpZiAoIXNjcm9sbGVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF1dG9NZXRob2QgPSBzY3JvbGxlciAhPT0gc2Nyb2xsZXIud2luZG93ID8gT2Zmc2V0TWV0aG9kLlBPU0lUSU9OIDogT2Zmc2V0TWV0aG9kLk9GRlNFVDtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMuJGNvbmZpZy5tZXRob2QgPT09ICdhdXRvJyA/IGF1dG9NZXRob2QgOiB0aGlzLiRjb25maWcubWV0aG9kO1xuICAgICAgICB2YXIgbWV0aG9kRm4gPSBtZXRob2QgPT09IE9mZnNldE1ldGhvZC5QT1NJVElPTiA/IHBvc2l0aW9uIDogb2Zmc2V0O1xuICAgICAgICB2YXIgb2Zmc2V0QmFzZSA9IG1ldGhvZCA9PT0gT2Zmc2V0TWV0aG9kLlBPU0lUSU9OID8gdGhpcy5nZXRTY3JvbGxUb3AoKSA6IDA7XG4gICAgICAgIHRoaXMuJG9mZnNldHMgPSBbXTtcbiAgICAgICAgdGhpcy4kdGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLiRzY3JvbGxIZWlnaHQgPSB0aGlzLmdldFNjcm9sbEhlaWdodCgpOyAvLyBGaW5kIGFsbCB0aGUgdW5pcXVlIGxpbmsgSFJFRnMgdGhhdCB3ZSB3aWxsIGNvbnRyb2xcblxuICAgICAgICBzZWxlY3RBbGwodGhpcy4kc2VsZWN0b3IsIHRoaXMuJGVsKSAvLyBHZXQgSFJFRiB2YWx1ZVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgcmV0dXJuIGdldEF0dHIobGluaywgJ2hyZWYnKTtcbiAgICAgICAgfSkgLy8gRmlsdGVyIG91dCBIUkVGcyB0aGF0IGRvIG5vdCBtYXRjaCBvdXIgUmVnRXhwXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGhyZWYpIHtcbiAgICAgICAgICByZXR1cm4gaHJlZiAmJiBIUkVGX1JFR0VYLnRlc3QoaHJlZiB8fCAnJyk7XG4gICAgICAgIH0pIC8vIEZpbmQgYWxsIGVsZW1lbnRzIHdpdGggSUQgdGhhdCBtYXRjaCBIUkVGIGhhc2hcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoaHJlZikge1xuICAgICAgICAgIC8vIENvbnZlcnQgSFJFRiBpbnRvIGFuIElEIChpbmNsdWRpbmcgIyBhdCBiZWdpbm5pbmcpXG4gICAgICAgICAgdmFyIGlkID0gaHJlZi5yZXBsYWNlKEhSRUZfUkVHRVgsICckMScpLnRyaW0oKTtcblxuICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gLy8gRmluZCB0aGUgZWxlbWVudCB3aXRoIHRoZSBJRCBzcGVjaWZpZWQgYnkgaWRcblxuXG4gICAgICAgICAgdmFyIGVsID0gc2VsZWN0KGlkLCBzY3JvbGxlcik7XG5cbiAgICAgICAgICBpZiAoZWwgJiYgaXNWaXNpYmxlKGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgb2Zmc2V0OiBwYXJzZUludChtZXRob2RGbihlbCkudG9wLCAxMCkgKyBvZmZzZXRCYXNlLFxuICAgICAgICAgICAgICB0YXJnZXQ6IGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbikgLy8gU29ydCB0aGVtIGJ5IHRoZWlyIG9mZnNldHMgKHNtYWxsZXN0IGZpcnN0KVxuICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLm9mZnNldCAtIGIub2Zmc2V0O1xuICAgICAgICB9KSAvLyByZWNvcmQgb25seSB1bmlxdWUgdGFyZ2V0cy9vZmZzZXRzXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGl0ZW0pIHtcbiAgICAgICAgICBpZiAoIW1lbW9baXRlbS50YXJnZXRdKSB7XG4gICAgICAgICAgICBfdGhpczQuJG9mZnNldHMucHVzaChpdGVtLm9mZnNldCk7XG5cbiAgICAgICAgICAgIF90aGlzNC4kdGFyZ2V0cy5wdXNoKGl0ZW0udGFyZ2V0KTtcblxuICAgICAgICAgICAgbWVtb1tpdGVtLnRhcmdldF0gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9LCB7fSk7IC8vIFJldHVybiB0aGlzIGZvciBlYXN5IGNoYWluaW5nXG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IC8vIEhhbmRsZSBhY3RpdmF0aW5nL2NsZWFyaW5nXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJvY2Vzc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLmdldFNjcm9sbFRvcCgpICsgdGhpcy4kY29uZmlnLm9mZnNldDtcbiAgICAgICAgdmFyIHNjcm9sbEhlaWdodCA9IHRoaXMuZ2V0U2Nyb2xsSGVpZ2h0KCk7XG4gICAgICAgIHZhciBtYXhTY3JvbGwgPSB0aGlzLiRjb25maWcub2Zmc2V0ICsgc2Nyb2xsSGVpZ2h0IC0gdGhpcy5nZXRPZmZzZXRIZWlnaHQoKTtcblxuICAgICAgICBpZiAodGhpcy4kc2Nyb2xsSGVpZ2h0ICE9PSBzY3JvbGxIZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY3JvbGxUb3AgPj0gbWF4U2Nyb2xsKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuJHRhcmdldHNbdGhpcy4kdGFyZ2V0cy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIGlmICh0aGlzLiRhY3RpdmVUYXJnZXQgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZSh0YXJnZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLiRhY3RpdmVUYXJnZXQgJiYgc2Nyb2xsVG9wIDwgdGhpcy4kb2Zmc2V0c1swXSAmJiB0aGlzLiRvZmZzZXRzWzBdID4gMCkge1xuICAgICAgICAgIHRoaXMuJGFjdGl2ZVRhcmdldCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLiRvZmZzZXRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIHZhciBpc0FjdGl2ZVRhcmdldCA9IHRoaXMuJGFjdGl2ZVRhcmdldCAhPT0gdGhpcy4kdGFyZ2V0c1tpXSAmJiBzY3JvbGxUb3AgPj0gdGhpcy4kb2Zmc2V0c1tpXSAmJiAoaXNVbmRlZmluZWQodGhpcy4kb2Zmc2V0c1tpICsgMV0pIHx8IHNjcm9sbFRvcCA8IHRoaXMuJG9mZnNldHNbaSArIDFdKTtcblxuICAgICAgICAgIGlmIChpc0FjdGl2ZVRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZSh0aGlzLiR0YXJnZXRzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0U2Nyb2xsZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY3JvbGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuJHNjcm9sbGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHNjcm9sbGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNjcm9sbGVyID0gdGhpcy4kY29uZmlnLmVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKCFzY3JvbGxlcikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRWxlbWVudChzY3JvbGxlci4kZWwpKSB7XG4gICAgICAgICAgc2Nyb2xsZXIgPSBzY3JvbGxlci4kZWw7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoc2Nyb2xsZXIpKSB7XG4gICAgICAgICAgc2Nyb2xsZXIgPSBzZWxlY3Qoc2Nyb2xsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzY3JvbGxlcikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kc2Nyb2xsZXIgPSBzY3JvbGxlci50YWdOYW1lID09PSAnQk9EWScgPyB3aW5kb3cgOiBzY3JvbGxlcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNjcm9sbGVyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRTY3JvbGxUb3BcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY3JvbGxUb3AoKSB7XG4gICAgICAgIHZhciBzY3JvbGxlciA9IHRoaXMuZ2V0U2Nyb2xsZXIoKTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbGVyID09PSB3aW5kb3cgPyBzY3JvbGxlci5wYWdlWU9mZnNldCA6IHNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0U2Nyb2xsSGVpZ2h0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxlcigpLnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldE9mZnNldEhlaWdodFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9mZnNldEhlaWdodCgpIHtcbiAgICAgICAgdmFyIHNjcm9sbGVyID0gdGhpcy5nZXRTY3JvbGxlcigpO1xuICAgICAgICByZXR1cm4gc2Nyb2xsZXIgPT09IHdpbmRvdyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IGdldEJDUihzY3JvbGxlcikuaGVpZ2h0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhY3RpdmF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFjdGl2YXRlKHRhcmdldCkge1xuICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICB0aGlzLiRhY3RpdmVUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuY2xlYXIoKTsgLy8gR3JhYiB0aGUgbGlzdCBvZiB0YXJnZXQgbGlua3MgKDxhIGhyZWY9XCJ7JHRhcmdldH1cIj4pXG5cbiAgICAgICAgdmFyIGxpbmtzID0gc2VsZWN0QWxsKHRoaXMuJHNlbGVjdG9yIC8vIFNwbGl0IG91dCB0aGUgYmFzZSBzZWxlY3RvcnNcbiAgICAgICAgLnNwbGl0KCcsJykgLy8gTWFwIHRvIGEgc2VsZWN0b3IgdGhhdCBtYXRjaGVzIGxpbmtzIHdpdGggSFJFRiBlbmRpbmcgaW4gdGhlIElEIChpbmNsdWRpbmcgJyMnKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChzZWxlY3RvciwgXCJbaHJlZiQ9XFxcIlwiKS5jb25jYXQodGFyZ2V0LCBcIlxcXCJdXCIpO1xuICAgICAgICB9KSAvLyBKb2luIGJhY2sgaW50byBhIHNpbmdsZSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgLmpvaW4oJywnKSwgdGhpcy4kZWwpO1xuICAgICAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgaWYgKGhhc0NsYXNzKGxpbmssIENsYXNzTmFtZS5EUk9QRE9XTl9JVEVNKSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGRyb3Bkb3duIGl0ZW0sIHNvIGZpbmQgdGhlIC5kcm9wZG93bi10b2dnbGUgYW5kIHNldCBpdHMgc3RhdGVcbiAgICAgICAgICAgIHZhciBkcm9wZG93biA9IGNsb3Nlc3QoU2VsZWN0b3IkMi5EUk9QRE9XTiwgbGluayk7XG5cbiAgICAgICAgICAgIGlmIChkcm9wZG93bikge1xuICAgICAgICAgICAgICBfdGhpczUuc2V0QWN0aXZlU3RhdGUoc2VsZWN0KFNlbGVjdG9yJDIuRFJPUERPV05fVE9HR0xFLCBkcm9wZG93biksIHRydWUpO1xuICAgICAgICAgICAgfSAvLyBBbHNvIHNldCB0aGlzIGxpbmsncyBzdGF0ZVxuXG5cbiAgICAgICAgICAgIF90aGlzNS5zZXRBY3RpdmVTdGF0ZShsaW5rLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2V0IHRyaWdnZXJlZCBsaW5rIGFzIGFjdGl2ZVxuICAgICAgICAgICAgX3RoaXM1LnNldEFjdGl2ZVN0YXRlKGxpbmssIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hlcyhsaW5rLnBhcmVudEVsZW1lbnQsIFNlbGVjdG9yJDIuTkFWX0lURU1TKSkge1xuICAgICAgICAgICAgICAvLyBIYW5kbGUgbmF2LWxpbmsgaW5zaWRlIG5hdi1pdGVtLCBhbmQgc2V0IG5hdi1pdGVtIGFjdGl2ZVxuICAgICAgICAgICAgICBfdGhpczUuc2V0QWN0aXZlU3RhdGUobGluay5wYXJlbnRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgIH0gLy8gU2V0IHRyaWdnZXJlZCBsaW5rcyBwYXJlbnRzIGFzIGFjdGl2ZVxuICAgICAgICAgICAgLy8gV2l0aCBib3RoIDx1bD4gYW5kIDxuYXY+IG1hcmt1cCBhIHBhcmVudCBpcyB0aGUgcHJldmlvdXMgc2libGluZyBvZiBhbnkgbmF2IGFuY2VzdG9yXG5cblxuICAgICAgICAgICAgdmFyIGVsID0gbGluaztcblxuICAgICAgICAgICAgd2hpbGUgKGVsKSB7XG4gICAgICAgICAgICAgIGVsID0gY2xvc2VzdChTZWxlY3RvciQyLk5BVl9MSVNUX0dST1VQLCBlbCk7XG4gICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gZWwgPyBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIDogbnVsbDtcblxuICAgICAgICAgICAgICBpZiAoc2libGluZyAmJiBtYXRjaGVzKHNpYmxpbmcsIFwiXCIuY29uY2F0KFNlbGVjdG9yJDIuTkFWX0xJTktTLCBcIiwgXCIpLmNvbmNhdChTZWxlY3RvciQyLkxJU1RfSVRFTVMpKSkge1xuICAgICAgICAgICAgICAgIF90aGlzNS5zZXRBY3RpdmVTdGF0ZShzaWJsaW5nLCB0cnVlKTtcbiAgICAgICAgICAgICAgfSAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlIHdoZXJlIG5hdi1saW5rIGlzIGluc2lkZSBhIG5hdi1pdGVtXG5cblxuICAgICAgICAgICAgICBpZiAoc2libGluZyAmJiBtYXRjaGVzKHNpYmxpbmcsIFNlbGVjdG9yJDIuTkFWX0lURU1TKSkge1xuICAgICAgICAgICAgICAgIF90aGlzNS5zZXRBY3RpdmVTdGF0ZShzZWxlY3QoU2VsZWN0b3IkMi5OQVZfTElOS1MsIHNpYmxpbmcpLCB0cnVlKTsgLy8gQWRkIGFjdGl2ZSBzdGF0ZSB0byBuYXYtaXRlbSBhcyB3ZWxsXG5cblxuICAgICAgICAgICAgICAgIF90aGlzNS5zZXRBY3RpdmVTdGF0ZShzaWJsaW5nLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIFNpZ25hbCBldmVudCB0byB2aWEgJHJvb3QsIHBhc3NpbmcgSUQgb2YgYWN0aXZhdGVkIHRhcmdldCBhbmQgcmVmZXJlbmNlIHRvIGFycmF5IG9mIGxpbmtzXG5cbiAgICAgICAgaWYgKGxpbmtzICYmIGxpbmtzLmxlbmd0aCA+IDAgJiYgdGhpcy4kcm9vdCkge1xuICAgICAgICAgIHRoaXMuJHJvb3QuJGVtaXQoQUNUSVZBVEVfRVZFTlQsIHRhcmdldCwgbGlua3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsZWFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIHNlbGVjdEFsbChcIlwiLmNvbmNhdCh0aGlzLiRzZWxlY3RvciwgXCIsIFwiKS5jb25jYXQoU2VsZWN0b3IkMi5OQVZfSVRFTVMpLCB0aGlzLiRlbCkuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIHJldHVybiBoYXNDbGFzcyhlbCwgQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNi5zZXRBY3RpdmVTdGF0ZShlbCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0QWN0aXZlU3RhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBY3RpdmVTdGF0ZShlbCwgYWN0aXZlKSB7XG4gICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICAgYWRkQ2xhc3MoZWwsIENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGVsLCBDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcIk5hbWVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gTkFNRSRFO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJEZWZhdWx0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIERlZmF1bHQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIkRlZmF1bHRUeXBlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIERlZmF1bHRUeXBlO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTY3JvbGxTcHk7XG4gIH0oKTtcblxuICB2YXIgQlZfU0NST0xMU1BZID0gJ19fQlZfU2Nyb2xsU3B5X18nOyAvLyBQcmUtY29tcGlsZWQgcmVndWxhciBleHByZXNzaW9uc1xuXG4gIHZhciBvbmx5RGlnaXRzUkUgPSAvXlxcZCskLztcbiAgdmFyIG9mZnNldFJFJDIgPSAvXihhdXRvfHBvc2l0aW9ufG9mZnNldCkkLzsgLy8gQnVpbGQgYSBTY3JvbGxTcHkgY29uZmlnIGJhc2VkIG9uIGJpbmRpbmdzIChpZiBhbnkpXG4gIC8vIEFyZ3VtZW50cyBhbmQgbW9kaWZpZXJzIHRha2UgcHJlY2VkZW5jZSBvdmVyIHBhc3NlZCB2YWx1ZSBjb25maWcgb2JqZWN0XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCBlYXN5IHRvIHRlc3QgKi9cblxuICB2YXIgcGFyc2VCaW5kaW5ncyQyID0gZnVuY3Rpb24gcGFyc2VCaW5kaW5ncyhiaW5kaW5ncylcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCBlYXN5IHRvIHRlc3QgKi9cbiAge1xuICAgIHZhciBjb25maWcgPSB7fTsgLy8gSWYgYXJndW1lbnQsIGFzc3VtZSBlbGVtZW50IElEXG5cbiAgICBpZiAoYmluZGluZ3MuYXJnKSB7XG4gICAgICAvLyBFbGVtZW50IElEIHNwZWNpZmllZCBhcyBhcmdcbiAgICAgIC8vIFdlIG11c3QgcHJlcGVuZCAnIycgdG8gYmVjb21lIGEgQ1NTIHNlbGVjdG9yXG4gICAgICBjb25maWcuZWxlbWVudCA9IFwiI1wiLmNvbmNhdChiaW5kaW5ncy5hcmcpO1xuICAgIH0gLy8gUHJvY2VzcyBtb2RpZmllcnNcblxuXG4gICAga2V5cyhiaW5kaW5ncy5tb2RpZmllcnMpLmZvckVhY2goZnVuY3Rpb24gKG1vZCkge1xuICAgICAgaWYgKG9ubHlEaWdpdHNSRS50ZXN0KG1vZCkpIHtcbiAgICAgICAgLy8gT2Zmc2V0IHZhbHVlXG4gICAgICAgIGNvbmZpZy5vZmZzZXQgPSBwYXJzZUludChtb2QsIDEwKTtcbiAgICAgIH0gZWxzZSBpZiAob2Zmc2V0UkUkMi50ZXN0KG1vZCkpIHtcbiAgICAgICAgLy8gT2Zmc2V0IG1ldGhvZFxuICAgICAgICBjb25maWcubWV0aG9kID0gbW9kO1xuICAgICAgfVxuICAgIH0pOyAvLyBQcm9jZXNzIHZhbHVlXG5cbiAgICBpZiAoaXNTdHJpbmcoYmluZGluZ3MudmFsdWUpKSB7XG4gICAgICAvLyBWYWx1ZSBpcyBhIENTUyBJRCBvciBzZWxlY3RvclxuICAgICAgY29uZmlnLmVsZW1lbnQgPSBiaW5kaW5ncy52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGJpbmRpbmdzLnZhbHVlKSkge1xuICAgICAgLy8gVmFsdWUgaXMgb2Zmc2V0XG4gICAgICBjb25maWcub2Zmc2V0ID0gTWF0aC5yb3VuZChiaW5kaW5ncy52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChiaW5kaW5ncy52YWx1ZSkpIHtcbiAgICAgIC8vIFZhbHVlIGlzIGNvbmZpZyBvYmplY3RcbiAgICAgIC8vIEZpbHRlciB0aGUgb2JqZWN0IGJhc2VkIG9uIG91ciBzdXBwb3J0ZWQgY29uZmlnIG9wdGlvbnNcbiAgICAgIGtleXMoYmluZGluZ3MudmFsdWUpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gISFTY3JvbGxTcHkuRGVmYXVsdFR5cGVba107XG4gICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGNvbmZpZ1trXSA9IGJpbmRpbmdzLnZhbHVlW2tdO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfTsgLy8gQWRkIG9yIHVwZGF0ZSBTY3JvbGxTcHkgb24gb3VyIGVsZW1lbnRcblxuXG4gIHZhciBhcHBseVNjcm9sbHNweSA9IGZ1bmN0aW9uIGFwcGx5U2Nyb2xsc3B5KGVsLCBiaW5kaW5ncywgdm5vZGUpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBub3QgZWFzeSB0byB0ZXN0ICovXG4gIHtcbiAgICBpZiAoIWlzQnJvd3Nlcikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29uZmlnID0gcGFyc2VCaW5kaW5ncyQyKGJpbmRpbmdzKTtcblxuICAgIGlmIChlbFtCVl9TQ1JPTExTUFldKSB7XG4gICAgICBlbFtCVl9TQ1JPTExTUFldLnVwZGF0ZUNvbmZpZyhjb25maWcsIHZub2RlLmNvbnRleHQuJHJvb3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbFtCVl9TQ1JPTExTUFldID0gbmV3IFNjcm9sbFNweShlbCwgY29uZmlnLCB2bm9kZS5jb250ZXh0LiRyb290KTtcbiAgICB9XG4gIH07IC8vIFJlbW92ZSBTY3JvbGxTcHkgb24gb3VyIGVsZW1lbnRcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbm90IGVhc3kgdG8gdGVzdCAqL1xuXG5cbiAgdmFyIHJlbW92ZVNjcm9sbHNweSA9IGZ1bmN0aW9uIHJlbW92ZVNjcm9sbHNweShlbClcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCBlYXN5IHRvIHRlc3QgKi9cbiAge1xuICAgIGlmIChlbFtCVl9TQ1JPTExTUFldKSB7XG4gICAgICBlbFtCVl9TQ1JPTExTUFldLmRpc3Bvc2UoKTtcbiAgICAgIGVsW0JWX1NDUk9MTFNQWV0gPSBudWxsO1xuICAgICAgZGVsZXRlIGVsW0JWX1NDUk9MTFNQWV07XG4gICAgfVxuICB9O1xuICAvKlxuICAgKiBFeHBvcnQgb3VyIGRpcmVjdGl2ZVxuICAgKi9cblxuXG4gIHZhciBWQlNjcm9sbHNweSA9IHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKGVsLCBiaW5kaW5ncywgdm5vZGUpXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCBlYXN5IHRvIHRlc3QgKi9cbiAgICB7XG4gICAgICBhcHBseVNjcm9sbHNweShlbCwgYmluZGluZ3MsIHZub2RlKTtcbiAgICB9LFxuICAgIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZChlbCwgYmluZGluZ3MsIHZub2RlKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBub3QgZWFzeSB0byB0ZXN0ICovXG4gICAge1xuICAgICAgYXBwbHlTY3JvbGxzcHkoZWwsIGJpbmRpbmdzLCB2bm9kZSk7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShlbCwgYmluZGluZ3MsIHZub2RlKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBub3QgZWFzeSB0byB0ZXN0ICovXG4gICAge1xuICAgICAgaWYgKGJpbmRpbmdzLnZhbHVlICE9PSBiaW5kaW5ncy5vbGRWYWx1ZSkge1xuICAgICAgICBhcHBseVNjcm9sbHNweShlbCwgYmluZGluZ3MsIHZub2RlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmdzLCB2bm9kZSlcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbm90IGVhc3kgdG8gdGVzdCAqL1xuICAgIHtcbiAgICAgIGlmIChiaW5kaW5ncy52YWx1ZSAhPT0gYmluZGluZ3Mub2xkVmFsdWUpIHtcbiAgICAgICAgYXBwbHlTY3JvbGxzcHkoZWwsIGJpbmRpbmdzLCB2bm9kZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZChlbClcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbm90IGVhc3kgdG8gdGVzdCAqL1xuICAgIHtcbiAgICAgIHJlbW92ZVNjcm9sbHNweShlbCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBWQlNjcm9sbHNweVBsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgVkJTY3JvbGxzcHk6IFZCU2Nyb2xsc3B5XG4gICAgfVxuICB9KTtcblxuICB2YXIgVkJUb2dnbGVQbHVnaW4gPVxuICAvKiNfX1BVUkVfXyovXG4gIHBsdWdpbkZhY3Rvcnkoe1xuICAgIGRpcmVjdGl2ZXM6IHtcbiAgICAgIFZCVG9nZ2xlOiBWQlRvZ2dsZVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIFZCVmlzaWJsZVBsdWdpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgcGx1Z2luRmFjdG9yeSh7XG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgVkJWaXNpYmxlOiBWQlZpc2libGVcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBkaXJlY3RpdmVzUGx1Z2luID1cbiAgLyojX19QVVJFX18qL1xuICBwbHVnaW5GYWN0b3J5KHtcbiAgICBwbHVnaW5zOiB7XG4gICAgICBWQkhvdmVyUGx1Z2luOiBWQkhvdmVyUGx1Z2luLFxuICAgICAgVkJNb2RhbFBsdWdpbjogVkJNb2RhbFBsdWdpbixcbiAgICAgIFZCUG9wb3ZlclBsdWdpbjogVkJQb3BvdmVyUGx1Z2luLFxuICAgICAgVkJTY3JvbGxzcHlQbHVnaW46IFZCU2Nyb2xsc3B5UGx1Z2luLFxuICAgICAgVkJUb2dnbGVQbHVnaW46IFZCVG9nZ2xlUGx1Z2luLFxuICAgICAgVkJUb29sdGlwUGx1Z2luOiBWQlRvb2x0aXBQbHVnaW4sXG4gICAgICBWQlZpc2libGVQbHVnaW46IFZCVmlzaWJsZVBsdWdpblxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIFJYX0lDT05fUFJFRklYID0gL15CSWNvbi87IC8vIEhlbHBlciBCSWNvbiBjb21wb25lbnRcbiAgLy8gUmVxdWlyZXMgdGhlIHJlcXVlc3RlZCBpY29uIGNvbXBvbmVudCB0byBiZSBpbnN0YWxsZWRcblxuICB2YXIgQkljb24gPVxuICAvKiNfX1BVUkVfXyovXG4gIFZ1ZS5leHRlbmQoe1xuICAgIG5hbWU6ICdCSWNvbicsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczogX29iamVjdFNwcmVhZDIoe1xuICAgICAgaWNvbjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH1cbiAgICB9LCBjb21tb25JY29uUHJvcHMsIHtcbiAgICAgIHN0YWNrZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH1cbiAgICB9KSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfcmVmKSB7XG4gICAgICB2YXIgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgcGFyZW50ID0gX3JlZi5wYXJlbnQ7XG4gICAgICB2YXIgaWNvbiA9IHBhc2NhbENhc2UodHJpbShwcm9wcy5pY29uIHx8ICcnKSkucmVwbGFjZShSWF9JQ09OX1BSRUZJWCwgJycpO1xuICAgICAgdmFyIGljb25OYW1lID0gXCJCSWNvblwiLmNvbmNhdChpY29uKTsgLy8gSWYgcGFyZW50IGNvbnRleHQgZXhpc3RzLCB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGljb24gaGFzIGJlZW4gcmVnaXN0ZXJlZFxuICAgICAgLy8gRWl0aGVyIGxvY2FsbHkgaW4gdGhlIHBhcmVudCBjb21wb25lbnQsIG9yIGdsb2JhbGx5IGF0IHRoZSBgJHJvb3RgIGxldmVsXG4gICAgICAvLyBJZiBub3QgcmVnaXN0ZXJlZCwgd2UgcmVuZGVyIGEgYmxhbmsgaWNvblxuXG4gICAgICB2YXIgY29tcG9uZW50cyA9ICgocGFyZW50IHx8IHt9KS4kb3B0aW9ucyB8fCB7fSkuY29tcG9uZW50cztcbiAgICAgIHZhciBjb21wb25lbnRSZWZPck5hbWUgPSBpY29uICYmIGNvbXBvbmVudHMgPyBjb21wb25lbnRzW2ljb25OYW1lXSB8fCBCSWNvbkJsYW5rIDogaWNvbiA/IGljb25OYW1lIDogQkljb25CbGFuaztcbiAgICAgIHJldHVybiBoKGNvbXBvbmVudFJlZk9yTmFtZSwgYShkYXRhLCB7XG4gICAgICAgIHByb3BzOiBfb2JqZWN0U3ByZWFkMih7fSwgcHJvcHMsIHtcbiAgICAgICAgICBpY29uOiBudWxsXG4gICAgICAgIH0pXG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgTkFNRSRGID0gJ0Jvb3RzdHJhcFZ1ZSc7IC8vIC0tLSBCb290c3RyYXBWdWUgaW5zdGFsbGVyIC0tLVxuXG4gIHZhciBpbnN0YWxsID1cbiAgLyojX19QVVJFX18qL1xuICBpbnN0YWxsRmFjdG9yeSh7XG4gICAgcGx1Z2luczoge1xuICAgICAgY29tcG9uZW50c1BsdWdpbjogY29tcG9uZW50c1BsdWdpbixcbiAgICAgIGRpcmVjdGl2ZXNQbHVnaW46IGRpcmVjdGl2ZXNQbHVnaW5cbiAgICB9XG4gIH0pOyAvLyAtLS0gQm9vdHN0cmFwVnVlIHBsdWdpbiAtLS1cblxuICB2YXIgQm9vdHN0cmFwVnVlID1cbiAgLyojX19QVVJFX18qL1xuICB7XG4gICAgaW5zdGFsbDogaW5zdGFsbCxcbiAgICBOQU1FOiBOQU1FJEZcbiAgfTsgLy8gLS0tIE5hbWVkIGV4cG9ydHMgZm9yIEJ2Q29uZmlnUGx1Z2luIC0tLVxuXG4gIC8vIE1haW4gZW50cnkgcG9pbnQgZm9yIHRoZSBicm93c2VyIGJ1aWxkXG5cbiAgdnVlVXNlKEJvb3RzdHJhcFZ1ZSk7XG5cbiAgcmV0dXJuIEJvb3RzdHJhcFZ1ZTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb3RzdHJhcC12dWUuanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bootstrap-vue/dist/bootstrap-vue.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/vue/dist/vue.esm.js":
/*!******************************************!*\
  !*** ./node_modules/vue/dist/vue.esm.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * Vue.js v2.6.12\n * (c) 2014-2020 Evan You\n * Released under the MIT License.\n */\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n// These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive.\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    // $flow-disable-line\n    typeof value === 'symbol' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\nvar _toString = Object.prototype.toString;\n\nfunction toRawType (value) {\n  return _toString.call(value).slice(8, -1)\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\nfunction isPromise (val) {\n  return (\n    isDef(val) &&\n    typeof val.then === 'function' &&\n    typeof val.catch === 'function'\n  )\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if an attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n/**\n * Remove an item from an array.\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether an object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n});\n\n/**\n * Simple bind polyfill for environments that do not support it,\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n * since native bind is now performant enough in most browsers.\n * But removing it would mean breaking code that was able to run in\n * PhantomJS 1.x, so this must be kept for backward compatibility.\n */\n\n/* istanbul ignore next */\nfunction polyfillBind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n\n  boundFn._length = fn.length;\n  return boundFn\n}\n\nfunction nativeBind (fn, ctx) {\n  return fn.bind(ctx)\n}\n\nvar bind = Function.prototype.bind\n  ? nativeBind\n  : polyfillBind;\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/* eslint-disable no-unused-vars */\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/* eslint-enable no-unused-vars */\n\n/**\n * Return the same value.\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a string containing static keys from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime()\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured',\n  'serverPrefetch'\n];\n\n/*  */\n\n\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"development\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"development\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Perform updates asynchronously. Intended to be used by Vue Test Utils\n   * This will significantly reduce performance if set to false.\n   */\n  async: true,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = new RegExp((\"[^\" + (unicodeRegExp.source) + \".$_\\\\d]\"));\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\nvar isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\nvar isPhantomJS = UA && /phantomjs/.test(UA);\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/);\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && !inWeex && typeof __webpack_require__.g !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = __webpack_require__.g['process'] && __webpack_require__.g['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */ // $flow-disable-line\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = /*@__PURE__*/(function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = (noop); // work around flow check\nvar formatComponentName = (noop);\n\nif (true) {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var options = typeof vm === 'function' && vm.cid != null\n      ? vm.options\n      : vm._isVue\n        ? vm.$options || vm.constructor.options\n        : vm;\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  if ( true && !config.async) {\n    // subs aren't sorted in scheduler if not running async\n    // we need to sort them now to make sure they fire in correct\n    // order\n    subs.sort(function (a, b) { return a.id - b.id; });\n  }\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (target) {\n  targetStack.push(target);\n  Dep.target = target;\n}\n\nfunction popTarget () {\n  targetStack.pop();\n  Dep.target = targetStack[targetStack.length - 1];\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: { configurable: true } };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(),\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.asyncMeta = vnode.asyncMeta;\n  cloned.isCloned = true;\n  return cloned\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\n\nvar methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n];\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\nvar shouldObserve = true;\n\nfunction toggleObserving (value) {\n  shouldObserve = value;\n}\n\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    if (hasProto) {\n      protoAugment(value, arrayMethods);\n    } else {\n      copyAugment(value, arrayMethods, arrayKeys);\n    }\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through all properties and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment a target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment a target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key];\n  }\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if ( true && customSetter) {\n        customSetter();\n      }\n      // #7981: for accessor properties without setter\n      if (getter && !setter) { return }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if ( true &&\n    (isUndef(target) || isPrimitive(target))\n  ) {\n    warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n     true && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if ( true &&\n    (isUndef(target) || isPrimitive(target))\n  ) {\n    warn((\"Cannot delete reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n     true && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (true) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n\n  var keys = hasSymbol\n    ? Reflect.ownKeys(from)\n    : Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    // in case the object is already observed...\n    if (key === '__ob__') { continue }\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (\n      toVal !== fromVal &&\n      isPlainObject(toVal) &&\n      isPlainObject(fromVal)\n    ) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n      )\n    }\n  } else {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm, vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm, vm)\n        : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n       true && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn(parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  var res = childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal;\n  return res\n    ? dedupeHooks(res)\n    : res\n}\n\nfunction dedupeHooks (hooks) {\n  var res = [];\n  for (var i = 0; i < hooks.length; i++) {\n    if (res.indexOf(hooks[i]) === -1) {\n      res.push(hooks[i]);\n    }\n  }\n  return res\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  var res = Object.create(parentVal || null);\n  if (childVal) {\n     true && assertObjectType(key, childVal, vm);\n    return extend(res, childVal)\n  } else {\n    return res\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (true) {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key$1] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  if (childVal && \"development\" !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName (name) {\n  if (!new RegExp((\"^[a-zA-Z][\\\\-\\\\.0-9_\" + (unicodeRegExp.source) + \"]*$\")).test(name)) {\n    warn(\n      'Invalid component name: \"' + name + '\". Component names ' +\n      'should conform to valid custom element name in html5 specification.'\n    );\n  }\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn(\n      'Do not use built-in or reserved HTML elements as component ' +\n      'id: ' + name\n    );\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options, vm) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (true) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  } else if (true) {\n    warn(\n      \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(props)) + \".\",\n      vm\n    );\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options, vm) {\n  var inject = options.inject;\n  if (!inject) { return }\n  var normalized = options.inject = {};\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = { from: inject[i] };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val)\n        ? extend({ from: key }, val)\n        : { from: val };\n    }\n  } else if (true) {\n    warn(\n      \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(inject)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def$$1 = dirs[key];\n      if (typeof def$$1 === 'function') {\n        dirs[key] = { bind: def$$1, update: def$$1 };\n      }\n    }\n  }\n}\n\nfunction assertObjectType (name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\n      \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n      \"but got \" + (toRawType(value)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (true) {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child);\n\n  // Apply extends and mixins on the child options,\n  // but only if it is a raw options object that isn't\n  // the result of another mergeOptions call.\n  // Only merged options has the _base property.\n  if (!child._base) {\n    if (child.extends) {\n      parent = mergeOptions(parent, child.extends, vm);\n    }\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n  }\n\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if ( true && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\n\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // boolean casting\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      var stringIndex = getTypeIndex(String, prop.type);\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n  if (\n    true\n  ) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if ( true && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n\n  if (!valid) {\n    warn(\n      getInvalidTypeMessage(name, value, expectedTypes),\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isSameType (a, b) {\n  return getType(a) === getType(b)\n}\n\nfunction getTypeIndex (type, expectedTypes) {\n  if (!Array.isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1\n  }\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i\n    }\n  }\n  return -1\n}\n\nfunction getInvalidTypeMessage (name, value, expectedTypes) {\n  var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n    \" Expected \" + (expectedTypes.map(capitalize).join(', '));\n  var expectedType = expectedTypes[0];\n  var receivedType = toRawType(value);\n  var expectedValue = styleValue(value, expectedType);\n  var receivedValue = styleValue(value, receivedType);\n  // check if we need to specify expected value\n  if (expectedTypes.length === 1 &&\n      isExplicable(expectedType) &&\n      !isBoolean(expectedType, receivedType)) {\n    message += \" with value \" + expectedValue;\n  }\n  message += \", got \" + receivedType + \" \";\n  // check if we need to specify received value\n  if (isExplicable(receivedType)) {\n    message += \"with value \" + receivedValue + \".\";\n  }\n  return message\n}\n\nfunction styleValue (value, type) {\n  if (type === 'String') {\n    return (\"\\\"\" + value + \"\\\"\")\n  } else if (type === 'Number') {\n    return (\"\" + (Number(value)))\n  } else {\n    return (\"\" + value)\n  }\n}\n\nfunction isExplicable (value) {\n  var explicitTypes = ['string', 'number', 'boolean'];\n  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })\n}\n\nfunction isBoolean () {\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n  // See: https://github.com/vuejs/vuex/issues/1505\n  pushTarget();\n  try {\n    if (vm) {\n      var cur = vm;\n      while ((cur = cur.$parent)) {\n        var hooks = cur.$options.errorCaptured;\n        if (hooks) {\n          for (var i = 0; i < hooks.length; i++) {\n            try {\n              var capture = hooks[i].call(cur, err, vm, info) === false;\n              if (capture) { return }\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n    globalHandleError(err, vm, info);\n  } finally {\n    popTarget();\n  }\n}\n\nfunction invokeWithErrorHandling (\n  handler,\n  context,\n  args,\n  vm,\n  info\n) {\n  var res;\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context);\n    if (res && !res._isVue && isPromise(res) && !res._handled) {\n      res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n      // issue #9511\n      // avoid catch triggering multiple times when nested calls\n      res._handled = true;\n    }\n  } catch (e) {\n    handleError(e, vm, info);\n  }\n  return res\n}\n\nfunction globalHandleError (err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info)\n    } catch (e) {\n      // if the user intentionally throws the original error in the handler,\n      // do not log it twice\n      if (e !== err) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n  }\n  logError(err, vm, info);\n}\n\nfunction logError (err, vm, info) {\n  if (true) {\n    warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n  }\n  /* istanbul ignore else */\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err\n  }\n}\n\n/*  */\n\nvar isUsingMicroTask = false;\n\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks () {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\n// Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\nvar timerFunc;\n\n// The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  timerFunc = function () {\n    p.then(flushCallbacks);\n    // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n  isUsingMicroTask = true;\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  var counter = 1;\n  var observer = new MutationObserver(flushCallbacks);\n  var textNode = document.createTextNode(String(counter));\n  observer.observe(textNode, {\n    characterData: true\n  });\n  timerFunc = function () {\n    counter = (counter + 1) % 2;\n    textNode.data = String(counter);\n  };\n  isUsingMicroTask = true;\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Technically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  // Fallback to setTimeout.\n  timerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\nfunction nextTick (cb, ctx) {\n  var _resolve;\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    })\n  }\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (true) {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      // perf.clearMeasures(name)\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (true) {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      'referenced during render. Make sure that this property is reactive, ' +\n      'either in the data option, or for class-based components, by ' +\n      'initializing the property. ' +\n      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n      target\n    );\n  };\n\n  var warnReservedPrefix = function (target, key) {\n    warn(\n      \"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" +\n      'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n      'prevent conflicts with Vue internals. ' +\n      'See: https://vuejs.org/v2/api/#data',\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' && isNative(Proxy);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) ||\n        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));\n      if (!has && !isAllowed) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar seenObjects = new _Set();\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse (val) {\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns, vm) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n      }\n    } else {\n      // return handler return value for single handlers\n      return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\")\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  createOnceHandler,\n  vm\n) {\n  var name, def$$1, cur, old, event;\n  for (name in on) {\n    def$$1 = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n       true && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur, vm);\n      }\n      if (isTrue(event.once)) {\n        cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n      }\n      add(event.name, cur, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (true) {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    lastIndex = res.length - 1;\n    last = res[lastIndex];\n    //  nested\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n          c.shift();\n        }\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (true) {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {}\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n      ? Reflect.ownKeys(inject)\n      : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      // #6574 in case the inject object is observed...\n      if (key === '__ob__') { continue }\n      var provideKey = inject[key].from;\n      var source = vm;\n      while (source) {\n        if (source._provided && hasOwn(source._provided, provideKey)) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function'\n            ? provideDefault.call(vm)\n            : provideDefault;\n        } else if (true) {\n          warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n        }\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\n\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  if (!children || !children.length) {\n    return {}\n  }\n  var slots = {};\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.fnContext === context) &&\n      data && data.slot != null\n    ) {\n      var name = data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  }\n  // ignore slots that contains only whitespace\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return (node.isComment && !node.asyncFactory) || node.text === ' '\n}\n\n/*  */\n\nfunction normalizeScopedSlots (\n  slots,\n  normalSlots,\n  prevSlots\n) {\n  var res;\n  var hasNormalSlots = Object.keys(normalSlots).length > 0;\n  var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n  var key = slots && slots.$key;\n  if (!slots) {\n    res = {};\n  } else if (slots._normalized) {\n    // fast path 1: child component re-render only, parent did not change\n    return slots._normalized\n  } else if (\n    isStable &&\n    prevSlots &&\n    prevSlots !== emptyObject &&\n    key === prevSlots.$key &&\n    !hasNormalSlots &&\n    !prevSlots.$hasNormal\n  ) {\n    // fast path 2: stable scoped slots w/ no normal slots to proxy,\n    // only need to normalize once\n    return prevSlots\n  } else {\n    res = {};\n    for (var key$1 in slots) {\n      if (slots[key$1] && key$1[0] !== '$') {\n        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n      }\n    }\n  }\n  // expose normal slots on scopedSlots\n  for (var key$2 in normalSlots) {\n    if (!(key$2 in res)) {\n      res[key$2] = proxyNormalSlot(normalSlots, key$2);\n    }\n  }\n  // avoriaz seems to mock a non-extensible $scopedSlots object\n  // and when that is passed down this would cause an error\n  if (slots && Object.isExtensible(slots)) {\n    (slots)._normalized = res;\n  }\n  def(res, '$stable', isStable);\n  def(res, '$key', key);\n  def(res, '$hasNormal', hasNormalSlots);\n  return res\n}\n\nfunction normalizeScopedSlot(normalSlots, key, fn) {\n  var normalized = function () {\n    var res = arguments.length ? fn.apply(null, arguments) : fn({});\n    res = res && typeof res === 'object' && !Array.isArray(res)\n      ? [res] // single vnode\n      : normalizeChildren(res);\n    return res && (\n      res.length === 0 ||\n      (res.length === 1 && res[0].isComment) // #9658\n    ) ? undefined\n      : res\n  };\n  // this is a slot using the new v-slot syntax without scope. although it is\n  // compiled as a scoped slot, render fn users would expect it to be present\n  // on this.$slots because the usage is semantically a normal slot.\n  if (fn.proxy) {\n    Object.defineProperty(normalSlots, key, {\n      get: normalized,\n      enumerable: true,\n      configurable: true\n    });\n  }\n  return normalized\n}\n\nfunction proxyNormalSlot(slots, key) {\n  return function () { return slots[key]; }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    if (hasSymbol && val[Symbol.iterator]) {\n      ret = [];\n      var iterator = val[Symbol.iterator]();\n      var result = iterator.next();\n      while (!result.done) {\n        ret.push(render(result.value, ret.length));\n        result = iterator.next();\n      }\n    } else {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n  }\n  if (!isDef(ret)) {\n    ret = [];\n  }\n  (ret)._isVList = true;\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      if ( true && !isObject(bindObject)) {\n        warn(\n          'slot v-bind without argument expects an Object',\n          this\n        );\n      }\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    nodes = this.$slots[name] || fallback;\n  }\n\n  var target = props && props.slot;\n  if (target) {\n    return this.$createElement('template', { slot: target }, nodes)\n  } else {\n    return nodes\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\nfunction isKeyNotMatch (expect, actual) {\n  if (Array.isArray(expect)) {\n    return expect.indexOf(actual) === -1\n  } else {\n    return expect !== actual\n  }\n}\n\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInKeyCode,\n  eventKeyName,\n  builtInKeyName\n) {\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName)\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n       true && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        var camelizedKey = camelize(key);\n        var hyphenatedKey = hyphenate(key);\n        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n  if (tree && !isInFor) {\n    return tree\n  }\n  // otherwise, render a fresh tree.\n  tree = cached[index] = this.$options.staticRenderFns[index].call(\n    this._renderProxy,\n    null,\n    this // for render fns generated for functional component templates\n  );\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n       true && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res,\n  // the following are added in 2.6\n  hasDynamicKeys,\n  contentHashKey\n) {\n  res = res || { $stable: !hasDynamicKeys };\n  for (var i = 0; i < fns.length; i++) {\n    var slot = fns[i];\n    if (Array.isArray(slot)) {\n      resolveScopedSlots(slot, res, hasDynamicKeys);\n    } else if (slot) {\n      // marker for reverse proxying v-slot without scope on this.$slots\n      if (slot.proxy) {\n        slot.fn.proxy = true;\n      }\n      res[slot.key] = slot.fn;\n    }\n  }\n  if (contentHashKey) {\n    (res).$key = contentHashKey;\n  }\n  return res\n}\n\n/*  */\n\nfunction bindDynamicKeys (baseObj, values) {\n  for (var i = 0; i < values.length; i += 2) {\n    var key = values[i];\n    if (typeof key === 'string' && key) {\n      baseObj[values[i]] = values[i + 1];\n    } else if ( true && key !== '' && key !== null) {\n      // null is a special value for explicitly removing a binding\n      warn(\n        (\"Invalid value for dynamic directive argument (expected string or null): \" + key),\n        this\n      );\n    }\n  }\n  return baseObj\n}\n\n// helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\nfunction prependModifier (value, symbol) {\n  return typeof value === 'string' ? symbol + value : value\n}\n\n/*  */\n\nfunction installRenderHelpers (target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n  target._d = bindDynamicKeys;\n  target._p = prependModifier;\n}\n\n/*  */\n\nfunction FunctionalRenderContext (\n  data,\n  props,\n  children,\n  parent,\n  Ctor\n) {\n  var this$1 = this;\n\n  var options = Ctor.options;\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var contextVm;\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent);\n    // $flow-disable-line\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent;\n    // $flow-disable-line\n    parent = parent._original;\n  }\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n  this.slots = function () {\n    if (!this$1.$slots) {\n      normalizeScopedSlots(\n        data.scopedSlots,\n        this$1.$slots = resolveSlots(children, parent)\n      );\n    }\n    return this$1.$slots\n  };\n\n  Object.defineProperty(this, 'scopedSlots', ({\n    enumerable: true,\n    get: function get () {\n      return normalizeScopedSlots(data.scopedSlots, this.slots())\n    }\n  }));\n\n  // support for compiled functional template\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options;\n    // pre-resolve slots for renderSlot()\n    this.$slots = this.slots();\n    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n      if (vnode && !Array.isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n      return vnode\n    };\n  } else {\n    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  contextVm,\n  children\n) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n\n  var renderContext = new FunctionalRenderContext(\n    data,\n    props,\n    children,\n    contextVm,\n    Ctor\n  );\n\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\n  } else if (Array.isArray(vnode)) {\n    var vnodes = normalizeChildren(vnode) || [];\n    var res = new Array(vnodes.length);\n    for (var i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n    }\n    return res\n  }\n}\n\nfunction cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  var clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n  if (true) {\n    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n  }\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n  return clone\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n\n// inline hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (vnode, hydrating) {\n    if (\n      vnode.componentInstance &&\n      !vnode.componentInstance._isDestroyed &&\n      vnode.data.keepAlive\n    ) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (true) {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // install component management hooks onto the placeholder node\n  installComponentHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n) {\n  var options = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent: parent\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnode.componentOptions.Ctor(options)\n}\n\nfunction installComponentHooks (data) {\n  var hooks = data.hook || (data.hook = {});\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var existing = hooks[key];\n    var toMerge = componentVNodeHooks[key];\n    if (existing !== toMerge && !(existing && existing._merged)) {\n      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n    }\n  }\n}\n\nfunction mergeHook$1 (f1, f2) {\n  var merged = function (a, b) {\n    // flow complains about extra args which is why we use any\n    f1(a, b);\n    f2(a, b);\n  };\n  merged._merged = true;\n  return merged\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input'\n  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  var existing = on[event];\n  var callback = data.model.callback;\n  if (isDef(existing)) {\n    if (\n      Array.isArray(existing)\n        ? existing.indexOf(callback) === -1\n        : existing !== callback\n    ) {\n      on[event] = [callback].concat(existing);\n    }\n  } else {\n    on[event] = callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n     true && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if ( true &&\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n  ) {\n    {\n      warn(\n        'Avoid using non-primitive value as key, ' +\n        'use string/number value instead.',\n        context\n      );\n    }\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      if ( true && isDef(data) && isDef(data.nativeOn)) {\n        warn(\n          (\"The .native modifier for v-on is only valid on components but it was used on <\" + tag + \">.\"),\n          context\n        );\n      }\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) { applyNS(vnode, ns); }\n    if (isDef(data)) { registerDeepBindings(data); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns, force) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && (\n        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n}\n\n// ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\nfunction registerDeepBindings (data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null; // v-once cached trees\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  if (true) {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {}\n}\n\nvar currentRenderingInstance = null;\n\nfunction renderMixin (Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(\n        _parentVnode.data.scopedSlots,\n        vm.$slots,\n        vm.$scopedSlots\n      );\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      // There's no need to maintain a stack because all render fns are called\n      // separately from one another. Nested component's render fns are called\n      // when parent component is patched.\n      currentRenderingInstance = vm;\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if ( true && vm.$options.renderError) {\n        try {\n          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n        } catch (e) {\n          handleError(e, vm, \"renderError\");\n          vnode = vm._vnode;\n        }\n      } else {\n        vnode = vm._vnode;\n      }\n    } finally {\n      currentRenderingInstance = null;\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0];\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if ( true && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (\n    comp.__esModule ||\n    (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n  ) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  var owner = currentRenderingInstance;\n  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n    // already pending\n    factory.owners.push(owner);\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (owner && !isDef(factory.owners)) {\n    var owners = factory.owners = [owner];\n    var sync = true;\n    var timerLoading = null;\n    var timerTimeout = null\n\n    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });\n\n    var forceRender = function (renderCompleted) {\n      for (var i = 0, l = owners.length; i < l; i++) {\n        (owners[i]).$forceUpdate();\n      }\n\n      if (renderCompleted) {\n        owners.length = 0;\n        if (timerLoading !== null) {\n          clearTimeout(timerLoading);\n          timerLoading = null;\n        }\n        if (timerTimeout !== null) {\n          clearTimeout(timerTimeout);\n          timerTimeout = null;\n        }\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender(true);\n      } else {\n        owners.length = 0;\n      }\n    });\n\n    var reject = once(function (reason) {\n       true && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender(true);\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (isPromise(res)) {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isPromise(res.component)) {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            timerLoading = setTimeout(function () {\n              timerLoading = null;\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender(false);\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          timerTimeout = setTimeout(function () {\n            timerTimeout = null;\n            if (isUndef(factory.resolved)) {\n              reject(\n                 true\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : 0\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn) {\n  target.$on(event, fn);\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction createOnceHandler (event, fn) {\n  var _target = target;\n  return function onceHandler () {\n    var res = fn.apply(null, arguments);\n    if (res !== null) {\n      _target.$off(event, onceHandler);\n    }\n  }\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n  target = undefined;\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        vm.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        vm.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (!fn) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (true) {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      var info = \"event handler for \\\"\" + event + \"\\\"\";\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction setActiveInstance(vm) {\n  var prevActiveInstance = activeInstance;\n  activeInstance = vm;\n  return function () {\n    activeInstance = prevActiveInstance;\n  }\n}\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var restoreActiveInstance = setActiveInstance(vm);\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    restoreActiveInstance();\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // release circular reference (#6759)\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (true) {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if ( true && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((\"vue \" + name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, {\n    before: function before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate');\n      }\n    }\n  }, true /* isRenderWatcher */);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (true) {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren.\n\n  // check if there are dynamic scopedSlots (hand-written or compiled but with\n  // dynamic slot names). Static scoped slots compiled from template has the\n  // \"$stable\" marker.\n  var newScopedSlots = parentVnode.data.scopedSlots;\n  var oldScopedSlots = vm.$scopedSlots;\n  var hasDynamicScopedSlot = !!(\n    (newScopedSlots && !newScopedSlots.$stable) ||\n    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)\n  );\n\n  // Any static slot children from the parent may have changed during parent's\n  // update. Dynamic scoped slots may also have changed. In such cases, a forced\n  // update is necessary to ensure correctness.\n  var needsForceUpdate = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    hasDynamicScopedSlot\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      var propOptions = vm.$options.props; // wtf flow?\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n    toggleObserving(true);\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  listeners = listeners || emptyObject;\n  var oldListeners = vm.$options._parentListeners;\n  vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, oldListeners);\n\n  // resolve slots + force update if has children\n  if (needsForceUpdate) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (true) {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  var handlers = vm.$options[hook];\n  var info = hook + \" hook\";\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n  popTarget();\n}\n\n/*  */\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (true) {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n// Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\nvar currentFlushTimestamp = 0;\n\n// Async edge case fix requires storing an event listener's attach timestamp.\nvar getNow = Date.now;\n\n// Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\nif (inBrowser && !isIE) {\n  var performance = window.performance;\n  if (\n    performance &&\n    typeof performance.now === 'function' &&\n    getNow() > document.createEvent('Event').timeStamp\n  ) {\n    // if the event timestamp, although evaluated AFTER the Date.now(), is\n    // smaller than it, it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listener timestamps as\n    // well.\n    getNow = function () { return performance.now(); };\n  }\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  currentFlushTimestamp = getNow();\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    if (watcher.before) {\n      watcher.before();\n    }\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if ( true && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n\n      if ( true && !config.async) {\n        flushSchedulerQueue();\n        return\n      }\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\n\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options,\n  isRenderWatcher\n) {\n  this.vm = vm;\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n    this.before = options.before;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  true\n    ? expOrFn.toString()\n    : 0;\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = noop;\n       true && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this.deps[i];\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n  var i = this.deps.length;\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n    this.active = false;\n  }\n};\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (true) {\n      var hyphenatedKey = hyphenate(key);\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (!isRoot && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {}\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  toggleObserving(true);\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n     true && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (true) {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n       true && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n  try {\n    return data.call(vm, vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  } finally {\n    popTarget();\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if ( true && getter == null) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      );\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (true) {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (\n  target,\n  key,\n  userDef\n) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : createGetterInvoker(userDef);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : createGetterInvoker(userDef.get)\n      : noop;\n    sharedPropertyDefinition.set = userDef.set || noop;\n  }\n  if ( true &&\n      sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction createGetterInvoker(fn) {\n  return function computedGetter () {\n    return fn.call(this, this)\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    if (true) {\n      if (typeof methods[key] !== 'function') {\n        warn(\n          \"Method \\\"\" + key + \"\\\" has type \\\"\" + (typeof methods[key]) + \"\\\" in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n      if ((key in vm) && isReserved(key)) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n          \"Avoid defining component methods that start with _ or $.\"\n        );\n      }\n    }\n    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  expOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(expOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (true) {\n    dataDef.set = function () {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      try {\n        cb.call(vm, watcher.value);\n      } catch (error) {\n        handleError(error, vm, (\"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\"));\n      }\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nvar uid$3 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$3++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if ( true && config.performance && mark) {\n      startTag = \"vue-perf-start:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (true) {\n      initProxy(vm);\n    } else {}\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if ( true && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = latest[key];\n    }\n  }\n  return modified\n}\n\nfunction Vue (options) {\n  if ( true &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nrenderMixin(Vue);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if ( true && name) {\n      validateComponentName(name);\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if ( true && type === 'component') {\n          validateComponentName(id);\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\n\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (\n  cache,\n  key,\n  keys,\n  current\n) {\n  var cached$$1 = cache[key];\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n\n  destroyed: function destroyed () {\n    for (var key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys);\n    }\n  },\n\n  mounted: function mounted () {\n    var this$1 = this;\n\n    this.$watch('include', function (val) {\n      pruneCache(this$1, function (name) { return matches(val, name); });\n    });\n    this.$watch('exclude', function (val) {\n      pruneCache(this$1, function (name) { return !matches(val, name); });\n    });\n  },\n\n  render: function render () {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n      if (\n        // not included\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance;\n        // make current key freshest\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key);\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n    return vnode || (slot && slot[0])\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (true) {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  // 2.6 explicit observable API\n  Vue.observable = function (obj) {\n    observe(obj);\n    return obj\n  };\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\n\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\n\nVue.version = '2.6.12';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\nvar convertEnumeratedValue = function (key, value) {\n  return isFalsyAttrValue(value) || value === 'false'\n    ? 'false'\n    // allow arbitrary string value for contenteditable\n    : key === 'contenteditable' && isValidContentEditableValue(value)\n      ? value\n      : 'true'\n};\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n       true && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope (node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!isDef(key)) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1 (vnode, inVPre) {\n    return (\n      !inVPre &&\n      !vnode.ns &&\n      !(\n        config.ignoredElements.length &&\n        config.ignoredElements.some(function (ignore) {\n          return isRegExp(ignore)\n            ? ignore.test(vnode.tag)\n            : ignore === vnode.tag\n        })\n      ) &&\n      config.isUnknownElement(vnode.tag)\n    )\n  }\n\n  var creatingElmInVPre = 0;\n\n  function createElm (\n    vnode,\n    insertedVnodeQueue,\n    parentElm,\n    refElm,\n    nested,\n    ownerArray,\n    index\n  ) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (true) {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if ( true && data && data.pre) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        insert(parentElm, vnode.elm, refElm);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (nodeOps.parentNode(ref$$1) === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (true) {\n        checkDuplicateKeys(children);\n      }\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      var ancestor = vnode;\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n        ancestor = ancestor.parent;\n      }\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      i !== vnode.fnContext &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    if (true) {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys (children) {\n    var seenKeys = {};\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\n            (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n            vnode.context\n          );\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld (node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) { return i }\n    }\n  }\n\n  function patchVnode (\n    oldVnode,\n    vnode,\n    insertedVnodeQueue,\n    ownerArray,\n    index,\n    removeOnly\n  ) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (true) {\n          checkDuplicateKeys(ch);\n        }\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || (data && data.pre);\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    // assert node match\n    if (true) {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false\n      }\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if ( true &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n              return false\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if ( true &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n              return false\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        var fullInvoke = false;\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || (\n        !isUnknownElement$$1(vnode, inVPre) &&\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (true) {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm = nodeOps.parentNode(oldElm);\n\n        // create new node\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        // destroy old node\n        if (isDef(parentElm)) {\n          removeVnodes([oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      dir.oldArg = oldDir.arg;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    // $flow-disable-line\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  // $flow-disable-line\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n  /* istanbul ignore if */\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n        ? 'true'\n        : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, convertEnumeratedValue(key, value));\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr (el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n    /* istanbul ignore if */\n    if (\n      isIE && !isIE9 &&\n      el.tagName === 'TEXTAREA' &&\n      key === 'placeholder' && value !== '' && !el.__ieph\n    ) {\n      var blocker = function (e) {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n      el.addEventListener('input', blocker);\n      // $flow-disable-line\n      el.__ieph = true; /* IE placeholder patched */\n    }\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args))\n  }\n}\n\n/*  */\n\n\n\n/* eslint-disable no-unused-vars */\nfunction baseWarn (msg, range) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n/* eslint-enable no-unused-vars */\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value, range, dynamic) {\n  (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n  el.plain = false;\n}\n\nfunction addAttr (el, name, value, range, dynamic) {\n  var attrs = dynamic\n    ? (el.dynamicAttrs || (el.dynamicAttrs = []))\n    : (el.attrs || (el.attrs = []));\n  attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n  el.plain = false;\n}\n\n// add a raw attr (use this in preTransforms)\nfunction addRawAttr (el, name, value, range) {\n  el.attrsMap[name] = value;\n  el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  isDynamicArg,\n  modifiers,\n  range\n) {\n  (el.directives || (el.directives = [])).push(rangeSetItem({\n    name: name,\n    rawName: rawName,\n    value: value,\n    arg: arg,\n    isDynamicArg: isDynamicArg,\n    modifiers: modifiers\n  }, range));\n  el.plain = false;\n}\n\nfunction prependModifierMarker (symbol, name, dynamic) {\n  return dynamic\n    ? (\"_p(\" + name + \",\\\"\" + symbol + \"\\\")\")\n    : symbol + name // mark the event as captured\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn,\n  range,\n  dynamic\n) {\n  modifiers = modifiers || emptyObject;\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n     true && warn &&\n    modifiers.prevent && modifiers.passive\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.',\n      range\n    );\n  }\n\n  // normalize click.right and click.middle since they don't actually fire\n  // this is technically browser-specific, but at least for now browsers are\n  // the only target envs that have right/middle clicks.\n  if (modifiers.right) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'contextmenu';\n      delete modifiers.right;\n    }\n  } else if (modifiers.middle) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'mouseup';\n    }\n  }\n\n  // check capture modifier\n  if (modifiers.capture) {\n    delete modifiers.capture;\n    name = prependModifierMarker('!', name, dynamic);\n  }\n  if (modifiers.once) {\n    delete modifiers.once;\n    name = prependModifierMarker('~', name, dynamic);\n  }\n  /* istanbul ignore if */\n  if (modifiers.passive) {\n    delete modifiers.passive;\n    name = prependModifierMarker('&', name, dynamic);\n  }\n\n  var events;\n  if (modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n\n  var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\n  if (modifiers !== emptyObject) {\n    newHandler.modifiers = modifiers;\n  }\n\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n\n  el.plain = false;\n}\n\nfunction getRawBindingAttr (\n  el,\n  name\n) {\n  return el.rawAttrsMap[':' + name] ||\n    el.rawAttrsMap['v-bind:' + name] ||\n    el.rawAttrsMap[name]\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\n// note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\nfunction getAndRemoveAttr (\n  el,\n  name,\n  removeFromMap\n) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  if (removeFromMap) {\n    delete el.attrsMap[name];\n  }\n  return val\n}\n\nfunction getAndRemoveAttrByRegex (\n  el,\n  name\n) {\n  var list = el.attrsList;\n  for (var i = 0, l = list.length; i < l; i++) {\n    var attr = list[i];\n    if (name.test(attr.name)) {\n      list.splice(i, 1);\n      return attr\n    }\n  }\n}\n\nfunction rangeSetItem (\n  item,\n  range\n) {\n  if (range) {\n    if (range.start != null) {\n      item.start = range.start;\n    }\n    if (range.end != null) {\n      item.end = range.end;\n    }\n  }\n  return item\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n      \"? \" + baseValueExpression + \".trim()\" +\n      \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: JSON.stringify(value),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var res = parseModel(value);\n  if (res.key === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n  }\n}\n\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\nvar len, str, chr, index$1, expressionPos, expressionEndPos;\n\n\n\nfunction parseModel (val) {\n  // Fix https://github.com/vuejs/vue/pull/7730\n  // allow v-model=\"obj.val \" (trailing whitespace)\n  val = val.trim();\n  len = val.length;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    index$1 = val.lastIndexOf('.');\n    if (index$1 > -1) {\n      return {\n        exp: val.slice(0, index$1),\n        key: '\"' + val.slice(index$1 + 1) + '\"'\n      }\n    } else {\n      return {\n        exp: val,\n        key: null\n      }\n    }\n  }\n\n  str = val;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.slice(0, expressionPos),\n    key: val.slice(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (true) {\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\",\n        el.rawAttrsMap['v-model']\n      );\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (true) {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.',\n      el.rawAttrsMap['v-model']\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n    \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n      trueValueBinding === 'true'\n        ? (\":(\" + value + \")\")\n        : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n    )\n  );\n  addHandler(el, 'change',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$el.checked){$$i<0&&(\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \")}\" +\n      \"else{$$i>-1&&(\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \")}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n\n  // warn if v-bind:value conflicts with v-model\n  // except for inputs with v-bind:type\n  if (true) {\n    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (value$1 && !typeBinding) {\n      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n      warn$1(\n        binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" +\n        'because the latter already expands to a value binding internally',\n        el.rawAttrsMap[binding]\n      );\n    }\n  }\n\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n  /* istanbul ignore if */\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler$1 (event, handler, capture) {\n  var _target = target$1; // save current target element in closure\n  return function onceHandler () {\n    var res = handler.apply(null, arguments);\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  }\n}\n\n// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n// implementation and does not fire microtasks in between event propagation, so\n// safe to exclude.\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\nfunction add$1 (\n  name,\n  handler,\n  capture,\n  passive\n) {\n  // async edge case #6566: inner click event triggers patch, event handler\n  // attached to outer element during patch, and triggered again. This\n  // happens because browsers fire microtask ticks between event propagation.\n  // the solution is simple: we save the timestamp when a handler is attached,\n  // and the handler would only fire if the event passed to it was fired\n  // AFTER it was attached.\n  if (useMicrotaskFix) {\n    var attachedTimestamp = currentFlushTimestamp;\n    var original = handler;\n    handler = original._wrapper = function (e) {\n      if (\n        // no bubbling, should always fire.\n        // this is just a safety net in case event.timeStamp is unreliable in\n        // certain weird environments...\n        e.target === e.currentTarget ||\n        // event is fired after handler attachment\n        e.timeStamp >= attachedTimestamp ||\n        // bail for environments that have buggy event.timeStamp implementations\n        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n        // #9681 QtWebEngine event.timeStamp is negative value\n        e.timeStamp <= 0 ||\n        // #9448 bail if event is fired in another document in a multi-page\n        // electron/nw.js app, since event.timeStamp will be using a different\n        // starting reference\n        e.target.ownerDocument !== document\n      ) {\n        return original.apply(this, arguments)\n      }\n    };\n  }\n  target$1.addEventListener(\n    name,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  name,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(\n    name,\n    handler._wrapper || handler,\n    capture\n  );\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nvar svgContainer;\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (!(key in props)) {\n      elm[key] = '';\n    }\n  }\n\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n      // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value' && elm.tagName !== 'PROGRESS') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n      // IE doesn't support innerHTML for SVG elements\n      svgContainer = svgContainer || document.createElement('div');\n      svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n      var svg = svgContainer.firstChild;\n      while (elm.firstChild) {\n        elm.removeChild(elm.firstChild);\n      }\n      while (svg.firstChild) {\n        elm.appendChild(svg.firstChild);\n      }\n    } else if (\n      // skip the update if old and new VDOM state is the same.\n      // `value` is handled separately because the DOM value may be temporarily\n      // out of sync with VDOM state due to focus, composition and modifiers.\n      // This  #4521 by skipping the unnecessary `checked` update.\n      cur !== oldProps[key]\n    ) {\n      // some property updates can throw\n      // e.g. `value` on <progress> w/ non-finite value\n      try {\n        elm[key] = cur;\n      } catch (e) {}\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (elm, checkVal) {\n  return (!elm.composing && (\n    elm.tagName === 'OPTION' ||\n    isNotInFocusAndDirty(elm, checkVal) ||\n    isDirtyWithModifiers(elm, checkVal)\n  ))\n}\n\nfunction isNotInFocusAndDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isDirtyWithModifiers (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers)) {\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal)\n    }\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim()\n    }\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (\n        childNode && childNode.data &&\n        (styleData = normalizeStyleData(childNode.data))\n      ) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\nvar whitespaceRE = /\\s+/;\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser\n  ? window.requestAnimationFrame\n    ? window.requestAnimationFrame.bind(window)\n    : setTimeout\n  : /* istanbul ignore next */ function (fn) { return fn(); };\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  // JSDOM may return undefined for transition properties\n  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\nfunction toMs (s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    context = transitionNode.context;\n    transitionNode = transitionNode.parent;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if ( true && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb)) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if ( true && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show && el.parentNode) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted (el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd);\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n     true && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  return options.every(function (o) { return !looseEqual(o, value); })\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (!value === !oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n\n/*  */\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\n\nvar isVShowDirective = function (d) { return d.name === 'show'; };\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(isNotTextNode);\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if ( true && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if ( true &&\n      mode && mode !== 'in-out' && mode !== 'out-in'\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  beforeMount: function beforeMount () {\n    var this$1 = this;\n\n    var update = this._update;\n    this._update = function (vnode, hydrating) {\n      var restoreActiveInstance = setActiveInstance(this$1);\n      // force removing pass\n      this$1.__patch__(\n        this$1._vnode,\n        this$1.kept,\n        false, // hydrating\n        true // removeOnly (!important, avoids unnecessary moves)\n      );\n      this$1._vnode = this$1.kept;\n      restoreActiveInstance();\n      update.call(this$1, vnode, hydrating);\n    };\n  },\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (true) {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n    this._reflow = document.body.offsetHeight;\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (e && e.target !== el) {\n            return\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents);\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nif (inBrowser) {\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if (\n        true\n      ) {\n        console[console.info ? 'info' : 'log'](\n          'Download the Vue Devtools extension for a better development experience:\\n' +\n          'https://github.com/vuejs/vue-devtools'\n        );\n      }\n    }\n    if ( true &&\n      config.productionTip !== false &&\n      typeof console !== 'undefined'\n    ) {\n      console[console.info ? 'info' : 'log'](\n        \"You are running Vue in development mode.\\n\" +\n        \"Make sure to turn on production mode when deploying for production.\\n\" +\n        \"See more tips at https://vuejs.org/guide/deployment.html\"\n      );\n    }\n  }, 0);\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\n\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var rawTokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, tokenValue;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    rawTokens.push({ '@binding': exp });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex));\n    tokens.push(JSON.stringify(tokenValue));\n  }\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if ( true && staticClass) {\n    var res = parseText(staticClass, options.delimiters);\n    if (res) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.',\n        el.rawAttrsMap['class']\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (true) {\n      var res = parseText(staticStyle, options.delimiters);\n      if (res) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.',\n          el.rawAttrsMap['style']\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode (html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent\n  }\n};\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n// Regular Expressions for parsing tags and attributes\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + (unicodeRegExp.source) + \"]*\";\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp((\"^<\" + qnameCapture));\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\nvar doctype = /^<!DOCTYPE [^>]+>/i;\n// #7298: escape - to avoid being passed as HTML comment when inlined in page\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/;\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n',\n  '&#9;': '\\t',\n  '&#39;': \"'\"\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n            }\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n            advance(1);\n          }\n          continue\n        }\n      }\n\n      var text = (void 0), rest = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (\n          !endTag.test(rest) &&\n          !startTagOpen.test(rest) &&\n          !comment.test(rest) &&\n          !conditionalComment.test(rest)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n      }\n\n      if (text) {\n        advance(text.length);\n      }\n\n      if (options.chars && text) {\n        options.chars(text, index - text.length, index);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if ( true && !stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"), { start: index + html.length });\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n        attr.start = index;\n        advance(attr[0].length);\n        attr.end = index;\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      var value = args[3] || args[4] || args[5] || '';\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n        ? options.shouldDecodeNewlinesForHref\n        : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n      if ( true && options.outputSourceRange) {\n        attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n        attrs[i].end = args.end;\n      }\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if ( true &&\n          (i > pos || !tagName) &&\n          options.warn\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\"),\n            { start: stack[i].start, end: stack[i].end }\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:|^#/;\nvar forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nvar stripParensRE = /^\\(|\\)$/g;\nvar dynamicArgRE = /^\\[.*\\]$/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^\\.|^v-bind:/;\nvar modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n\nvar slotRE = /^v-slot(:|$)|^#/;\n\nvar lineBreakRE = /[\\r\\n]/;\nvar whitespaceRE$1 = /\\s+/g;\n\nvar invalidAttributeRE = /[\\s\"'<>\\/=]/;\n\nvar decodeHTMLCached = cached(he.decode);\n\nvar emptySlotScopeToken = \"_empty_\";\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\nvar maybeComponent;\n\nfunction createASTElement (\n  tag,\n  attrs,\n  parent\n) {\n  return {\n    type: 1,\n    tag: tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    rawAttrsMap: {},\n    parent: parent,\n    children: []\n  }\n}\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  var isReservedTag = options.isReservedTag || no;\n  maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var whitespaceOption = options.whitespace;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg, range) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg, range);\n    }\n  }\n\n  function closeElement (element) {\n    trimEndingWhitespace(element);\n    if (!inVPre && !element.processed) {\n      element = processElement(element, options);\n    }\n    // tree management\n    if (!stack.length && element !== root) {\n      // allow root elements with v-if, v-else-if and v-else\n      if (root.if && (element.elseif || element.else)) {\n        if (true) {\n          checkRootConstraints(element);\n        }\n        addIfCondition(root, {\n          exp: element.elseif,\n          block: element\n        });\n      } else if (true) {\n        warnOnce(\n          \"Component template should contain exactly one root element. \" +\n          \"If you are using v-if on multiple elements, \" +\n          \"use v-else-if to chain them instead.\",\n          { start: element.start }\n        );\n      }\n    }\n    if (currentParent && !element.forbidden) {\n      if (element.elseif || element.else) {\n        processIfConditions(element, currentParent);\n      } else {\n        if (element.slotScope) {\n          // scoped slot\n          // keep it in the children list so that v-else(-if) conditions can\n          // find it as the prev node.\n          var name = element.slotTarget || '\"default\"'\n          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        }\n        currentParent.children.push(element);\n        element.parent = currentParent;\n      }\n    }\n\n    // final children cleanup\n    // filter out scoped slots\n    element.children = element.children.filter(function (c) { return !(c).slotScope; });\n    // remove trailing whitespace node again\n    trimEndingWhitespace(element);\n\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n    // apply post-transforms\n    for (var i = 0; i < postTransforms.length; i++) {\n      postTransforms[i](element, options);\n    }\n  }\n\n  function trimEndingWhitespace (el) {\n    // remove trailing whitespace node\n    if (!inPre) {\n      var lastNode;\n      while (\n        (lastNode = el.children[el.children.length - 1]) &&\n        lastNode.type === 3 &&\n        lastNode.text === ' '\n      ) {\n        el.children.pop();\n      }\n    }\n  }\n\n  function checkRootConstraints (el) {\n    if (el.tag === 'slot' || el.tag === 'template') {\n      warnOnce(\n        \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n        'contain multiple nodes.',\n        { start: el.start }\n      );\n    }\n    if (el.attrsMap.hasOwnProperty('v-for')) {\n      warnOnce(\n        'Cannot use v-for on stateful component root element because ' +\n        'it renders multiple elements.',\n        el.rawAttrsMap['v-for']\n      );\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    outputSourceRange: options.outputSourceRange,\n    start: function start (tag, attrs, unary, start$1, end) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = createASTElement(tag, attrs, currentParent);\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (true) {\n        if (options.outputSourceRange) {\n          element.start = start$1;\n          element.end = end;\n          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n            cumulated[attr.name] = attr;\n            return cumulated\n          }, {});\n        }\n        attrs.forEach(function (attr) {\n          if (invalidAttributeRE.test(attr.name)) {\n            warn$2(\n              \"Invalid dynamic argument expression: attribute names cannot contain \" +\n              \"spaces, quotes, <, >, / or =.\",\n              {\n                start: attr.start + attr.name.indexOf(\"[\"),\n                end: attr.start + attr.name.length\n              }\n            );\n          }\n        });\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n         true && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.',\n          { start: element.start }\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        element = preTransforms[i](element, options) || element;\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else if (!element.processed) {\n        // structural directives\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n      }\n\n      if (!root) {\n        root = element;\n        if (true) {\n          checkRootConstraints(root);\n        }\n      }\n\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        closeElement(element);\n      }\n    },\n\n    end: function end (tag, start, end$1) {\n      var element = stack[stack.length - 1];\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      if ( true && options.outputSourceRange) {\n        element.end = end$1;\n      }\n      closeElement(element);\n    },\n\n    chars: function chars (text, start, end) {\n      if (!currentParent) {\n        if (true) {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.',\n              { start: start }\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\"),\n              { start: start }\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      if (inPre || text.trim()) {\n        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n      } else if (!children.length) {\n        // remove the whitespace-only node right after an opening tag\n        text = '';\n      } else if (whitespaceOption) {\n        if (whitespaceOption === 'condense') {\n          // in condense mode, remove the whitespace node if it contains\n          // line break, otherwise condense to a single space\n          text = lineBreakRE.test(text) ? '' : ' ';\n        } else {\n          text = ' ';\n        }\n      } else {\n        text = preserveWhitespace ? ' ' : '';\n      }\n      if (text) {\n        if (!inPre && whitespaceOption === 'condense') {\n          // condense consecutive whitespaces into single space\n          text = text.replace(whitespaceRE$1, ' ');\n        }\n        var res;\n        var child;\n        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n          child = {\n            type: 2,\n            expression: res.expression,\n            tokens: res.tokens,\n            text: text\n          };\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          child = {\n            type: 3,\n            text: text\n          };\n        }\n        if (child) {\n          if ( true && options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n          children.push(child);\n        }\n      }\n    },\n    comment: function comment (text, start, end) {\n      // adding anything as a sibling to the root node is forbidden\n      // comments should still be allowed, but ignored\n      if (currentParent) {\n        var child = {\n          type: 3,\n          text: text,\n          isComment: true\n        };\n        if ( true && options.outputSourceRange) {\n          child.start = start;\n          child.end = end;\n        }\n        currentParent.children.push(child);\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var list = el.attrsList;\n  var len = list.length;\n  if (len) {\n    var attrs = el.attrs = new Array(len);\n    for (var i = 0; i < len; i++) {\n      attrs[i] = {\n        name: list[i].name,\n        value: JSON.stringify(list[i].value)\n      };\n      if (list[i].start != null) {\n        attrs[i].start = list[i].start;\n        attrs[i].end = list[i].end;\n      }\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processElement (\n  element,\n  options\n) {\n  processKey(element);\n\n  // determine whether this is a plain element after\n  // removing structural attributes\n  element.plain = (\n    !element.key &&\n    !element.scopedSlots &&\n    !element.attrsList.length\n  );\n\n  processRef(element);\n  processSlotContent(element);\n  processSlotOutlet(element);\n  processComponent(element);\n  for (var i = 0; i < transforms.length; i++) {\n    element = transforms[i](element, options) || element;\n  }\n  processAttrs(element);\n  return element\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (true) {\n      if (el.tag === 'template') {\n        warn$2(\n          \"<template> cannot be keyed. Place the key on real elements instead.\",\n          getRawBindingAttr(el, 'key')\n        );\n      }\n      if (el.for) {\n        var iterator = el.iterator2 || el.iterator1;\n        var parent = el.parent;\n        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n          warn$2(\n            \"Do not use v-for index as key on <transition-group> children, \" +\n            \"this is the same as not using keys.\",\n            getRawBindingAttr(el, 'key'),\n            true /* tip */\n          );\n        }\n      }\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var res = parseFor(exp);\n    if (res) {\n      extend(el, res);\n    } else if (true) {\n      warn$2(\n        (\"Invalid v-for expression: \" + exp),\n        el.rawAttrsMap['v-for']\n      );\n    }\n  }\n}\n\n\n\nfunction parseFor (exp) {\n  var inMatch = exp.match(forAliasRE);\n  if (!inMatch) { return }\n  var res = {};\n  res.for = inMatch[2].trim();\n  var alias = inMatch[1].trim().replace(stripParensRE, '');\n  var iteratorMatch = alias.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.alias = alias.replace(forIteratorRE, '').trim();\n    res.iterator1 = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.iterator2 = iteratorMatch[2].trim();\n    }\n  } else {\n    res.alias = alias;\n  }\n  return res\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (true) {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\",\n      el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if ( true && children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\",\n          children[i]\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\n// handle content being passed to a component as slot,\n// e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\nfunction processSlotContent (el) {\n  var slotScope;\n  if (el.tag === 'template') {\n    slotScope = getAndRemoveAttr(el, 'scope');\n    /* istanbul ignore if */\n    if ( true && slotScope) {\n      warn$2(\n        \"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\n        \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\n        \"can also be used on plain elements in addition to <template> to \" +\n        \"denote scoped slots.\",\n        el.rawAttrsMap['scope'],\n        true\n      );\n    }\n    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n  } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n    /* istanbul ignore if */\n    if ( true && el.attrsMap['v-for']) {\n      warn$2(\n        \"Ambiguous combined usage of slot-scope and v-for on <\" + (el.tag) + \"> \" +\n        \"(v-for takes higher priority). Use a wrapper <template> for the \" +\n        \"scoped slot to make it clearer.\",\n        el.rawAttrsMap['slot-scope'],\n        true\n      );\n    }\n    el.slotScope = slotScope;\n  }\n\n  // slot=\"xxx\"\n  var slotTarget = getBindingAttr(el, 'slot');\n  if (slotTarget) {\n    el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n    // preserve slot as an attribute for native shadow DOM compat\n    // only for non-scoped slots.\n    if (el.tag !== 'template' && !el.slotScope) {\n      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n    }\n  }\n\n  // 2.6 v-slot syntax\n  {\n    if (el.tag === 'template') {\n      // v-slot on <template>\n      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n      if (slotBinding) {\n        if (true) {\n          if (el.slotTarget || el.slotScope) {\n            warn$2(\n              \"Unexpected mixed usage of different slot syntaxes.\",\n              el\n            );\n          }\n          if (el.parent && !maybeComponent(el.parent)) {\n            warn$2(\n              \"<template v-slot> can only appear at the root level inside \" +\n              \"the receiving component\",\n              el\n            );\n          }\n        }\n        var ref = getSlotName(slotBinding);\n        var name = ref.name;\n        var dynamic = ref.dynamic;\n        el.slotTarget = name;\n        el.slotTargetDynamic = dynamic;\n        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n      }\n    } else {\n      // v-slot on component, denotes default slot\n      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n      if (slotBinding$1) {\n        if (true) {\n          if (!maybeComponent(el)) {\n            warn$2(\n              \"v-slot can only be used on components or <template>.\",\n              slotBinding$1\n            );\n          }\n          if (el.slotScope || el.slotTarget) {\n            warn$2(\n              \"Unexpected mixed usage of different slot syntaxes.\",\n              el\n            );\n          }\n          if (el.scopedSlots) {\n            warn$2(\n              \"To avoid scope ambiguity, the default slot should also use \" +\n              \"<template> syntax when there are other named slots.\",\n              slotBinding$1\n            );\n          }\n        }\n        // add the component's children to its default slot\n        var slots = el.scopedSlots || (el.scopedSlots = {});\n        var ref$1 = getSlotName(slotBinding$1);\n        var name$1 = ref$1.name;\n        var dynamic$1 = ref$1.dynamic;\n        var slotContainer = slots[name$1] = createASTElement('template', [], el);\n        slotContainer.slotTarget = name$1;\n        slotContainer.slotTargetDynamic = dynamic$1;\n        slotContainer.children = el.children.filter(function (c) {\n          if (!c.slotScope) {\n            c.parent = slotContainer;\n            return true\n          }\n        });\n        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;\n        // remove children as they are returned from scopedSlots now\n        el.children = [];\n        // mark el non-plain so data gets generated\n        el.plain = false;\n      }\n    }\n  }\n}\n\nfunction getSlotName (binding) {\n  var name = binding.name.replace(slotRE, '');\n  if (!name) {\n    if (binding.name[0] !== '#') {\n      name = 'default';\n    } else if (true) {\n      warn$2(\n        \"v-slot shorthand syntax requires a slot name.\",\n        binding\n      );\n    }\n  }\n  return dynamicArgRE.test(name)\n    // dynamic [name]\n    ? { name: name.slice(1, -1), dynamic: true }\n    // static name\n    : { name: (\"\\\"\" + name + \"\\\"\"), dynamic: false }\n}\n\n// handle <slot/> outlets\nfunction processSlotOutlet (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if ( true && el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\",\n        getRawBindingAttr(el, 'key')\n      );\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name.replace(dirRE, ''));\n      // support .foo shorthand syntax for the .prop modifier\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isDynamic = dynamicArgRE.test(name);\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n        if (\n           true &&\n          value.trim().length === 0\n        ) {\n          warn$2(\n            (\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\")\n          );\n        }\n        if (modifiers) {\n          if (modifiers.prop && !isDynamic) {\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel && !isDynamic) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            syncGen = genAssignmentCode(value, \"$event\");\n            if (!isDynamic) {\n              addHandler(\n                el,\n                (\"update:\" + (camelize(name))),\n                syncGen,\n                null,\n                false,\n                warn$2,\n                list[i]\n              );\n              if (hyphenate(name) !== camelize(name)) {\n                addHandler(\n                  el,\n                  (\"update:\" + (hyphenate(name))),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i]\n                );\n              }\n            } else {\n              // handler w/ dynamic event name\n              addHandler(\n                el,\n                (\"\\\"update:\\\"+(\" + name + \")\"),\n                syncGen,\n                null,\n                false,\n                warn$2,\n                list[i],\n                true // dynamic\n              );\n            }\n          }\n        }\n        if ((modifiers && modifiers.prop) || (\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n        )) {\n          addProp(el, name, value, list[i], isDynamic);\n        } else {\n          addAttr(el, name, value, list[i], isDynamic);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        isDynamic = dynamicArgRE.test(name);\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        isDynamic = false;\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n          if (dynamicArgRE.test(arg)) {\n            arg = arg.slice(1, -1);\n            isDynamic = true;\n          }\n        }\n        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n        if ( true && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (true) {\n        var res = parseText(value, delimiters);\n        if (res) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.',\n            list[i]\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value), list[i]);\n      // #6887 firefox doesn't update muted state if set via attribute\n      // even immediately after element creation\n      if (!el.component &&\n          name === 'muted' &&\n          platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n        addProp(el, name, 'true', list[i]);\n      }\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n       true &&\n      map[attrs[i].name] && !isIE && !isEdge\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\",\n        el.rawAttrsMap['v-model']\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nfunction preTransformNode (el, options) {\n  if (el.tag === 'input') {\n    var map = el.attrsMap;\n    if (!map['v-model']) {\n      return\n    }\n\n    var typeBinding;\n    if (map[':type'] || map['v-bind:type']) {\n      typeBinding = getBindingAttr(el, 'type');\n    }\n    if (!map.type && !typeBinding && map['v-bind']) {\n      typeBinding = \"(\" + (map['v-bind']) + \").type\";\n    }\n\n    if (typeBinding) {\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n      var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n      // 1. checkbox\n      var branch0 = cloneASTElement(el);\n      // process for on the main node\n      processFor(branch0);\n      addRawAttr(branch0, 'type', 'checkbox');\n      processElement(branch0, options);\n      branch0.processed = true; // prevent it from double-processed\n      branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n      addIfCondition(branch0, {\n        exp: branch0.if,\n        block: branch0\n      });\n      // 2. add radio else-if condition\n      var branch1 = cloneASTElement(el);\n      getAndRemoveAttr(branch1, 'v-for', true);\n      addRawAttr(branch1, 'type', 'radio');\n      processElement(branch1, options);\n      addIfCondition(branch0, {\n        exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n        block: branch1\n      });\n      // 3. other\n      var branch2 = cloneASTElement(el);\n      getAndRemoveAttr(branch2, 'v-for', true);\n      addRawAttr(branch2, ':type', typeBinding);\n      processElement(branch2, options);\n      addIfCondition(branch0, {\n        exp: ifCondition,\n        block: branch2\n      });\n\n      if (hasElse) {\n        branch0.else = true;\n      } else if (elseIfCondition) {\n        branch0.elseif = elseIfCondition;\n      }\n\n      return branch0\n    }\n  }\n}\n\nfunction cloneASTElement (el) {\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n}\n\nvar model$1 = {\n  preTransformNode: preTransformNode\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1,\n  model$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"), dir);\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"), dir);\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function(?:\\s+[\\w$]+)?\\s*\\(/;\nvar fnInvokeRE = /\\([^)]*?\\);*$/;\nvar simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n// KeyboardEvent.keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// KeyboardEvent.key aliases\nvar keyNames = {\n  // #7880: IE11 and Edge use `Esc` for Escape key name.\n  esc: ['Esc', 'Escape'],\n  tab: 'Tab',\n  enter: 'Enter',\n  // #9112: IE11 uses `Spacebar` for Space key name.\n  space: [' ', 'Spacebar'],\n  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n  up: ['Up', 'ArrowUp'],\n  left: ['Left', 'ArrowLeft'],\n  right: ['Right', 'ArrowRight'],\n  down: ['Down', 'ArrowDown'],\n  // #9112: IE11 uses `Del` for Delete key name.\n  'delete': ['Backspace', 'Delete', 'Del']\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative\n) {\n  var prefix = isNative ? 'nativeOn:' : 'on:';\n  var staticHandlers = \"\";\n  var dynamicHandlers = \"\";\n  for (var name in events) {\n    var handlerCode = genHandler(events[name]);\n    if (events[name] && events[name].dynamic) {\n      dynamicHandlers += name + \",\" + handlerCode + \",\";\n    } else {\n      staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n    }\n  }\n  staticHandlers = \"{\" + (staticHandlers.slice(0, -1)) + \"}\";\n  if (dynamicHandlers) {\n    return prefix + \"_d(\" + staticHandlers + \",[\" + (dynamicHandlers.slice(0, -1)) + \"])\"\n  } else {\n    return prefix + staticHandlers\n  }\n}\n\nfunction genHandler (handler) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n  if (!handler.modifiers) {\n    if (isMethodPath || isFunctionExpression) {\n      return handler.value\n    }\n    return (\"function($event){\" + (isFunctionInvocation ? (\"return \" + (handler.value)) : handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else if (key === 'exact') {\n        var modifiers = (handler.modifiers);\n        genModifierCode += genGuard(\n          ['ctrl', 'shift', 'alt', 'meta']\n            .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n            .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n            .join('||')\n        );\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? (\"return \" + (handler.value) + \"($event)\")\n      : isFunctionExpression\n        ? (\"return (\" + (handler.value) + \")($event)\")\n        : isFunctionInvocation\n          ? (\"return \" + (handler.value))\n          : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\n    // make sure the key filters only apply to KeyboardEvents\n    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n    // key events that do not have keyCode property...\n    \"if(!$event.type.indexOf('key')&&\" +\n    (keys.map(genFilterCode).join('&&')) + \")return null;\"\n  )\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var keyCode = keyCodes[key];\n  var keyName = keyNames[key];\n  return (\n    \"_k($event.keyCode,\" +\n    (JSON.stringify(key)) + \",\" +\n    (JSON.stringify(keyCode)) + \",\" +\n    \"$event.key,\" +\n    \"\" + (JSON.stringify(keyName)) +\n    \")\"\n  )\n}\n\n/*  */\n\nfunction on (el, dir) {\n  if ( true && dir.modifiers) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n\n\n\n\nvar CodegenState = function CodegenState (options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n  this.pre = false;\n};\n\n\n\nfunction generate (\n  ast,\n  options\n) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: state.staticRenderFns\n  }\n}\n\nfunction genElement (el, state) {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre;\n  }\n\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data;\n      if (!el.plain || (el.pre && state.maybeComponent(el))) {\n        data = genData$2(el, state);\n      }\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el, state) {\n  el.staticProcessed = true;\n  // Some elements (templates) need to behave differently inside of a v-pre\n  // node.  All pre nodes are static roots, so we can use this as a location to\n  // wrap a state change and reset it upon exiting the pre node.\n  var originalPreState = state.pre;\n  if (el.pre) {\n    state.pre = el.pre;\n  }\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n  state.pre = originalPreState;\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n       true && state.warn(\n        \"v-once can only be used inside v-for that is keyed. \",\n        el.rawAttrsMap['v-once']\n      );\n      return genElement(el, state)\n    }\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n  } else {\n    return genStatic(el, state)\n  }\n}\n\nfunction genIf (\n  el,\n  state,\n  altGen,\n  altEmpty\n) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n}\n\nfunction genIfConditions (\n  conditions,\n  state,\n  altGen,\n  altEmpty\n) {\n  if (!conditions.length) {\n    return altEmpty || '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return altGen\n      ? altGen(el, state)\n      : el.once\n        ? genOnce(el, state)\n        : genElement(el, state)\n  }\n}\n\nfunction genFor (\n  el,\n  state,\n  altGen,\n  altHelper\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if ( true &&\n    state.maybeComponent(el) &&\n    el.tag !== 'slot' &&\n    el.tag !== 'template' &&\n    !el.key\n  ) {\n    state.warn(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      el.rawAttrsMap['v-for'],\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + ((altGen || genElement)(el, state)) +\n    '})'\n}\n\nfunction genData$2 (el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:\" + (genProps(el.attrs)) + \",\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:\" + (genProps(el.props)) + \",\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  // only for non-scoped slots\n  if (el.slotTarget && !el.slotScope) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el, el.scopedSlots, state)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind dynamic argument wrap\n  // v-bind with dynamic arguments must be applied using the same v-bind object\n  // merge helper so that class/style/mustUseProp attrs are handled correctly.\n  if (el.dynamicAttrs) {\n    data = \"_b(\" + data + \",\\\"\" + (el.tag) + \"\\\",\" + (genProps(el.dynamicAttrs)) + \")\";\n  }\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data\n}\n\nfunction genDirectives (el, state) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\" + (dir.isDynamicArg ? dir.arg : (\"\\\"\" + (dir.arg) + \"\\\"\"))) : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el, state) {\n  var ast = el.children[0];\n  if ( true && (\n    el.children.length !== 1 || ast.type !== 1\n  )) {\n    state.warn(\n      'Inline-template components must have exactly one child element.',\n      { start: el.start }\n    );\n  }\n  if (ast && ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (\n  el,\n  slots,\n  state\n) {\n  // by default scoped slots are considered \"stable\", this allows child\n  // components with only scoped slots to skip forced updates from parent.\n  // but in some cases we have to bail-out of this optimization\n  // for example if the slot contains dynamic names, has v-if or v-for on them...\n  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n    var slot = slots[key];\n    return (\n      slot.slotTargetDynamic ||\n      slot.if ||\n      slot.for ||\n      containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n    )\n  });\n\n  // #9534: if a component with scoped slots is inside a conditional branch,\n  // it's possible for the same component to be reused but with different\n  // compiled slot content. To avoid that, we generate a unique key based on\n  // the generated code of all the slot contents.\n  var needsKey = !!el.if;\n\n  // OR when it is inside another scoped slot or v-for (the reactivity may be\n  // disconnected due to the intermediate scope variable)\n  // #9438, #9506\n  // TODO: this can be further optimized by properly analyzing in-scope bindings\n  // and skip force updating ones that do not actually use scope variables.\n  if (!needsForceUpdate) {\n    var parent = el.parent;\n    while (parent) {\n      if (\n        (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||\n        parent.for\n      ) {\n        needsForceUpdate = true;\n        break\n      }\n      if (parent.if) {\n        needsKey = true;\n      }\n      parent = parent.parent;\n    }\n  }\n\n  var generatedSlots = Object.keys(slots)\n    .map(function (key) { return genScopedSlot(slots[key], state); })\n    .join(',');\n\n  return (\"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? (\",null,false,\" + (hash(generatedSlots))) : \"\") + \")\")\n}\n\nfunction hash(str) {\n  var hash = 5381;\n  var i = str.length;\n  while(i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n  return hash >>> 0\n}\n\nfunction containsSlotChild (el) {\n  if (el.type === 1) {\n    if (el.tag === 'slot') {\n      return true\n    }\n    return el.children.some(containsSlotChild)\n  }\n  return false\n}\n\nfunction genScopedSlot (\n  el,\n  state\n) {\n  var isLegacySyntax = el.attrsMap['slot-scope'];\n  if (el.if && !el.ifProcessed && !isLegacySyntax) {\n    return genIf(el, state, genScopedSlot, \"null\")\n  }\n  if (el.for && !el.forProcessed) {\n    return genFor(el, state, genScopedSlot)\n  }\n  var slotScope = el.slotScope === emptySlotScopeToken\n    ? \"\"\n    : String(el.slotScope);\n  var fn = \"function(\" + slotScope + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? el.if && isLegacySyntax\n        ? (\"(\" + (el.if) + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n        : genChildren(el, state) || 'undefined'\n      : genElement(el, state)) + \"}\";\n  // reverse proxy v-slot without scope on this.$slots\n  var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n  return (\"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\")\n}\n\nfunction genChildren (\n  el,\n  state,\n  checkSkip,\n  altGenElement,\n  altGenNode\n) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      var normalizationType = checkSkip\n        ? state.maybeComponent(el$1) ? \",1\" : \",0\"\n        : \"\";\n      return (\"\" + ((altGenElement || genElement)(el$1, state)) + normalizationType)\n    }\n    var normalizationType$1 = checkSkip\n      ? getNormalizationType(children, state.maybeComponent)\n      : 0;\n    var gen = altGenNode || genNode;\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType$1 ? (\",\" + normalizationType$1) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (\n  children,\n  maybeComponent\n) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction genNode (node, state) {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } else if (node.type === 3 && node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genComment (comment) {\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n}\n\nfunction genSlot (el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs || el.dynamicAttrs\n    ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({\n        // slot props are camelized\n        name: camelize(attr.name),\n        value: attr.value,\n        dynamic: attr.dynamic\n      }); }))\n    : null;\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (\n  componentName,\n  el,\n  state\n) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var staticProps = \"\";\n  var dynamicProps = \"\";\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    var value = transformSpecialNewlines(prop.value);\n    if (prop.dynamic) {\n      dynamicProps += (prop.name) + \",\" + value + \",\";\n    } else {\n      staticProps += \"\\\"\" + (prop.name) + \"\\\":\" + value + \",\";\n    }\n  }\n  staticProps = \"{\" + (staticProps.slice(0, -1)) + \"}\";\n  if (dynamicProps) {\n    return (\"_d(\" + staticProps + \",[\" + (dynamicProps.slice(0, -1)) + \"])\")\n  } else {\n    return staticProps\n  }\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast, warn) {\n  if (ast) {\n    checkNode(ast, warn);\n  }\n}\n\nfunction checkNode (node, warn) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          var range = node.rawAttrsMap[name];\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), warn, range);\n          } else if (name === 'v-slot' || name[0] === '#') {\n            checkFunctionParameterExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], warn);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, warn, node);\n  }\n}\n\nfunction checkEvent (exp, text, warn, range) {\n  var stripped = exp.replace(stripStringRE, '');\n  var keywordMatch = stripped.match(unaryOperatorsRE);\n  if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {\n    warn(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim()),\n      range\n    );\n  }\n  checkExpression(exp, text, warn, range);\n}\n\nfunction checkFor (node, text, warn, range) {\n  checkExpression(node.for || '', text, warn, range);\n  checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n}\n\nfunction checkIdentifier (\n  ident,\n  type,\n  text,\n  warn,\n  range\n) {\n  if (typeof ident === 'string') {\n    try {\n      new Function((\"var \" + ident + \"=_\"));\n    } catch (e) {\n      warn((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())), range);\n    }\n  }\n}\n\nfunction checkExpression (exp, text, warn, range) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      warn(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim()),\n        range\n      );\n    } else {\n      warn(\n        \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n        \"    \" + exp + \"\\n\\n\" +\n        \"  Raw expression: \" + (text.trim()) + \"\\n\",\n        range\n      );\n    }\n  }\n}\n\nfunction checkFunctionParameterExpression (exp, text, warn, range) {\n  try {\n    new Function(exp, '');\n  } catch (e) {\n    warn(\n      \"invalid function parameter expression: \" + (e.message) + \" in\\n\\n\" +\n      \"    \" + exp + \"\\n\\n\" +\n      \"  Raw expression: \" + (text.trim()) + \"\\n\",\n      range\n    );\n  }\n}\n\n/*  */\n\nvar range = 2;\n\nfunction generateCodeFrame (\n  source,\n  start,\n  end\n) {\n  if ( start === void 0 ) start = 0;\n  if ( end === void 0 ) end = source.length;\n\n  var lines = source.split(/\\r?\\n/);\n  var count = 0;\n  var res = [];\n  for (var i = 0; i < lines.length; i++) {\n    count += lines[i].length + 1;\n    if (count >= start) {\n      for (var j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) { continue }\n        res.push((\"\" + (j + 1) + (repeat$1(\" \", 3 - String(j + 1).length)) + \"|  \" + (lines[j])));\n        var lineLength = lines[j].length;\n        if (j === i) {\n          // push underline\n          var pad = start - (count - lineLength) + 1;\n          var length = end > count ? lineLength - pad : end - start;\n          res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n        } else if (j > i) {\n          if (end > count) {\n            var length$1 = Math.min(end - count, lineLength);\n            res.push(\"   |  \" + repeat$1(\"^\", length$1));\n          }\n          count += lineLength + 1;\n        }\n      }\n      break\n    }\n  }\n  return res.join('\\n')\n}\n\nfunction repeat$1 (str, n) {\n  var result = '';\n  if (n > 0) {\n    while (true) { // eslint-disable-line\n      if (n & 1) { result += str; }\n      n >>>= 1;\n      if (n <= 0) { break }\n      str += str;\n    }\n  }\n  return result\n}\n\n/*  */\n\n\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompileToFunctionFn (compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = extend({}, options);\n    var warn$$1 = options.warn || warn;\n    delete options.warn;\n\n    /* istanbul ignore if */\n    if (true) {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn$$1(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (true) {\n      if (compiled.errors && compiled.errors.length) {\n        if (options.outputSourceRange) {\n          compiled.errors.forEach(function (e) {\n            warn$$1(\n              \"Error compiling template:\\n\\n\" + (e.msg) + \"\\n\\n\" +\n              generateCodeFrame(template, e.start, e.end),\n              vm\n            );\n          });\n        } else {\n          warn$$1(\n            \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n            compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n            vm\n          );\n        }\n      }\n      if (compiled.tips && compiled.tips.length) {\n        if (options.outputSourceRange) {\n          compiled.tips.forEach(function (e) { return tip(e.msg, vm); });\n        } else {\n          compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n        }\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors)\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (true) {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn$$1(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (cache[key] = res)\n  }\n}\n\n/*  */\n\nfunction createCompilerCreator (baseCompile) {\n  return function createCompiler (baseOptions) {\n    function compile (\n      template,\n      options\n    ) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n\n      var warn = function (msg, range, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        if ( true && options.outputSourceRange) {\n          // $flow-disable-line\n          var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n          warn = function (msg, range, tip) {\n            var data = { msg: msg };\n            if (range) {\n              if (range.start != null) {\n                data.start = range.start + leadingSpaceLength;\n              }\n              if (range.end != null) {\n                data.end = range.end + leadingSpaceLength;\n              }\n            }\n            (tip ? tips : errors).push(data);\n          };\n        }\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives || null),\n            options.directives\n          );\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      finalOptions.warn = warn;\n\n      var compiled = baseCompile(template.trim(), finalOptions);\n      if (true) {\n        detectErrors(compiled.ast, warn);\n      }\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  if (options.optimize !== false) {\n    optimize(ast, options);\n  }\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compile = ref$1.compile;\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nvar div;\nfunction getShouldDecode (href) {\n  div = div || document.createElement('div');\n  div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n  return div.innerHTML.indexOf('&#10;') > 0\n}\n\n// #3663: IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n// #6828: chrome encodes content in a[href]\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue.prototype.$mount;\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n     true && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if ( true && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (true) {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if ( true && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        outputSourceRange: \"development\" !== 'production',\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if ( true && config.performance && mark) {\n        mark('compile end');\n        measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue.compile = compileToFunctions;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Vue);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcz9hMDI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRCxzQkFBc0IsaUJBQWlCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlDQUFpQyxFQUFFO0FBQ3JGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBb0I7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLG9DQUFvQztBQUNwQztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBRVE7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxxQ0FBcUMsRUFBRTtBQUNwRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLHlDQUF5QyxFQUFFO0FBQy9FOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzREFBc0QsRUFBRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUNBQWlDO0FBQ25FLGNBQWMsNkJBQTZCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQ0FBaUM7QUFDbkUsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQyxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHVGQUF1RjtBQUM1RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQyxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLCtCQUErQjtBQUNsQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsb0JBQW9CLG9CQUFvQjtBQUN4QyxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CLHlCQUF5QjtBQUN6QjtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw2Q0FBNkM7QUFDOUU7QUFDQTtBQUNBLDZDQUE2Qyw0Q0FBNEM7O0FBRXpGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsTUFBTSxFQUdOO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQXFDO0FBQy9DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLDJDQUEyQyw4QkFBOEIsRUFBRTs7QUFFaEY7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFxQztBQUNyRDtBQUNBLG9CQUFvQixDQUFJO0FBQ3hCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLEtBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFxQztBQUN6RDtBQUNBLE1BQU0sQ0FBRTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QyxxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUJBQXlCO0FBQ3pCO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLE1BQU0sRUFFTjtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxVQUFVLElBQXFDO0FBQ3BEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsOEJBQThCO0FBQzlCLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQSxLQUFLLE1BQU0sRUFFTjtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFlBQVksS0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQywyQkFBMkIsRUFBRTtBQUN2RSxLQUFLO0FBQ0w7QUFDQSwwQ0FBMEMsNEJBQTRCLEVBQUU7QUFDeEUsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixzQkFBc0I7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxHQUFHO0FBQ0gseUNBQXlDO0FBQ3pDOztBQUVBLGlDQUFpQyx3Q0FBd0M7QUFDekU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxtQkFBbUI7QUFDM0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FB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QUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhOztBQUUzRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxLQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHFDQUFxQzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVDQUF1QyxFQUFFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyQ0FBMkMsRUFBRTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsOEJBQThCLEVBQUU7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsdUNBQXVDOztBQUV6RSxxQ0FBcUMsMEJBQTBCOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4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QTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxVQUFVLElBQXFDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLFVBQVUsSUFBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxVQUFVLEtBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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MkJBQTJCLGFBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLEdBQUcsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuZXNtLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWdWUuanMgdjIuNi4xMlxuICogKGMpIDIwMTQtMjAyMCBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8vIFRoZXNlIGhlbHBlcnMgcHJvZHVjZSBiZXR0ZXIgVk0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZy5cbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gIClcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSwgZS5nLiwgW29iamVjdCBPYmplY3RdLlxuICovXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gdG9SYXdUeXBlICh2YWx1ZSkge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiAoXG4gICAgaXNEZWYodmFsKSAmJlxuICAgIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWwuY2F0Y2ggPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IEFycmF5LmlzQXJyYXkodmFsKSB8fCAoaXNQbGFpbk9iamVjdCh2YWwpICYmIHZhbC50b1N0cmluZyA9PT0gX3RvU3RyaW5nKVxuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0LFxuICogZS5nLiwgUGhhbnRvbUpTIDEueC4gVGVjaG5pY2FsbHksIHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlXG4gKiBzaW5jZSBuYXRpdmUgYmluZCBpcyBub3cgcGVyZm9ybWFudCBlbm91Z2ggaW4gbW9zdCBicm93c2Vycy5cbiAqIEJ1dCByZW1vdmluZyBpdCB3b3VsZCBtZWFuIGJyZWFraW5nIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW5cbiAqIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBwb2x5ZmlsbEJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuZnVuY3Rpb24gbmF0aXZlQmluZCAoZm4sIGN0eCkge1xuICByZXR1cm4gZm4uYmluZChjdHgpXG59XG5cbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgPyBuYXRpdmVCaW5kXG4gIDogcG9seWZpbGxCaW5kO1xuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKS5cbiAqL1xuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmcgc3RhdGljIGtleXMgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBsb29zZWx5IGVxdWFsIHZhbHVlIGNhbiBiZVxuICogZm91bmQgaW4gdGhlIGFycmF5IChpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgdGhlIGFycmF5IG11c3RcbiAqIGNvbnRhaW4gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHNoYXBlKSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gKi9cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJyxcbiAgJ2Vycm9yQ2FwdHVyZWQnLFxuICAnc2VydmVyUHJlZmV0Y2gnXG5dO1xuXG4vKiAgKi9cblxuXG5cbnZhciBjb25maWcgPSAoe1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdXBkYXRlcyBhc3luY2hyb25vdXNseS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBieSBWdWUgVGVzdCBVdGlsc1xuICAgKiBUaGlzIHdpbGwgc2lnbmlmaWNhbnRseSByZWR1Y2UgcGVyZm9ybWFuY2UgaWYgc2V0IHRvIGZhbHNlLlxuICAgKi9cbiAgYXN5bmM6IHRydWUsXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG4vKipcbiAqIHVuaWNvZGUgbGV0dGVycyB1c2VkIGZvciBwYXJzaW5nIGh0bWwgdGFncywgY29tcG9uZW50IG5hbWVzIGFuZCBwcm9wZXJ0eSBwYXRocy5cbiAqIHVzaW5nIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc2VtYW50aWNzLXNjcmlwdGluZy5odG1sI3BvdGVudGlhbGN1c3RvbWVsZW1lbnRuYW1lXG4gKiBza2lwcGluZyBcXHUxMDAwMC1cXHVFRkZGRiBkdWUgdG8gaXQgZnJlZXppbmcgdXAgUGhhbnRvbUpTXG4gKi9cbnZhciB1bmljb2RlUmVnRXhwID0gL2EtekEtWlxcdTAwQjdcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDNGLVxcdTIwNDBcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkQvO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IG5ldyBSZWdFeHAoKFwiW15cIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIi4kX1xcXFxkXVwiKSk7XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBpbldlZXggPSB0eXBlb2YgV1hFbnZpcm9ubWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgISFXWEVudmlyb25tZW50LnBsYXRmb3JtO1xudmFyIHdlZXhQbGF0Zm9ybSA9IGluV2VleCAmJiBXWEVudmlyb25tZW50LnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSAoVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMCkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbnZhciBpc0lPUyA9IChVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpKSB8fCAod2VleFBsYXRmb3JtID09PSAnaW9zJyk7XG52YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcbnZhciBpc1BoYW50b21KUyA9IFVBICYmIC9waGFudG9tanMvLnRlc3QoVUEpO1xudmFyIGlzRkYgPSBVQSAmJiBVQS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pO1xuXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgIWluV2VleCAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXSAmJiBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyB0cmFjZSkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLmNpZCAhPSBudWxsXG4gICAgICA/IHZtLm9wdGlvbnNcbiAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgID8gdm0uJG9wdGlvbnMgfHwgdm0uY29uc3RydWN0b3Iub3B0aW9uc1xuICAgICAgICA6IHZtO1xuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgICB2YXIgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgdmFyIHRyZWUgPSBbXTtcbiAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7IHJldHVybiAoXCJcIiArIChpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XG4gICAgLy8gc3VicyBhcmVuJ3Qgc29ydGVkIGluIHNjaGVkdWxlciBpZiBub3QgcnVubmluZyBhc3luY1xuICAgIC8vIHdlIG5lZWQgdG8gc29ydCB0aGVtIG5vdyB0byBtYWtlIHN1cmUgdGhleSBmaXJlIGluIGNvcnJlY3RcbiAgICAvLyBvcmRlclxuICAgIHN1YnMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyBUaGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyBUaGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIG9ubHkgb25lIHdhdGNoZXJcbi8vIGNhbiBiZSBldmFsdWF0ZWQgYXQgYSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAodGFyZ2V0KSB7XG4gIHRhcmdldFN0YWNrLnB1c2godGFyZ2V0KTtcbiAgRGVwLnRhcmdldCA9IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgdGFyZ2V0U3RhY2sucG9wKCk7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFja1t0YXJnZXRTdGFjay5sZW5ndGggLSAxXTtcbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zLFxuICBhc3luY0ZhY3Rvcnlcbikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLmVsbSA9IGVsbTtcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbiAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSB0ZXh0O1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICAvLyAjNzk3NVxuICAgIC8vIGNsb25lIGNoaWxkcmVuIGFycmF5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGluIGNhc2Ugb2YgY2xvbmluZ1xuICAgIC8vIGEgY2hpbGQuXG4gICAgdm5vZGUuY2hpbGRyZW4gJiYgdm5vZGUuY2hpbGRyZW4uc2xpY2UoKSxcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgY2xvbmVkLmFzeW5jTWV0YSA9IHZub2RlLmFzeW5jTWV0YTtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1xuXG52YXIgbWV0aG9kc1RvUGF0Y2ggPSBbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dO1xuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5tZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcbiAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAqL1xudmFyIHNob3VsZE9ic2VydmUgPSB0cnVlO1xuXG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBpZiAoaGFzUHJvdG8pIHtcbiAgICAgIHByb3RvQXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29weUF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIHNob3VsZE9ic2VydmUgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXIsXG4gIHNoYWxsb3dcbikge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG4gIGlmICgoIWdldHRlciB8fCBzZXR0ZXIpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YWwgPSBvYmpba2V5XTtcbiAgfVxuXG4gIHZhciBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgLy8gIzc5ODE6IGZvciBhY2Nlc3NvciBwcm9wZXJ0aWVzIHdpdGhvdXQgc2V0dGVyXG4gICAgICBpZiAoZ2V0dGVyICYmICFzZXR0ZXIpIHsgcmV0dXJuIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxuICApIHtcbiAgICB3YXJuKChcIkNhbm5vdCBzZXQgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxuICApIHtcbiAgICB3YXJuKChcIkNhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuXG4gIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgPyBSZWZsZWN0Lm93bktleXMoZnJvbSlcbiAgICA6IE9iamVjdC5rZXlzKGZyb20pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgLy8gaW4gY2FzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgb2JzZXJ2ZWQuLi5cbiAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdG9WYWwgIT09IGZyb21WYWwgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QodG9WYWwpICYmXG4gICAgICBpc1BsYWluT2JqZWN0KGZyb21WYWwpXG4gICAgKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICB2YXIgcmVzID0gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsO1xuICByZXR1cm4gcmVzXG4gICAgPyBkZWR1cGVIb29rcyhyZXMpXG4gICAgOiByZXNcbn1cblxuZnVuY3Rpb24gZGVkdXBlSG9va3MgKGhvb2tzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyZXMuaW5kZXhPZihob29rc1tpXSkgPT09IC0xKSB7XG4gICAgICByZXMucHVzaChob29rc1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgaWYgKGNoaWxkVmFsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICByZXR1cm4gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG5cbkFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBXYXRjaGVycy5cbiAqXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgLy8gd29yayBhcm91bmQgRmlyZWZveCdzIE9iamVjdC5wcm90b3R5cGUud2F0Y2guLi5cbiAgaWYgKHBhcmVudFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgcGFyZW50VmFsID0gdW5kZWZpbmVkOyB9XG4gIGlmIChjaGlsZFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgY2hpbGRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSQxIGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXkkMV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5JDFdO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXkkMV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmluamVjdCA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICBpZiAoY2hpbGRWYWwgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBpZiAoY2hpbGRWYWwpIHsgZXh0ZW5kKHJldCwgY2hpbGRWYWwpOyB9XG4gIHJldHVybiByZXRcbn07XG5zdHJhdHMucHJvdmlkZSA9IG1lcmdlRGF0YU9yRm47XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZSAobmFtZSkge1xuICBpZiAoIW5ldyBSZWdFeHAoKFwiXlthLXpBLVpdW1xcXFwtXFxcXC4wLTlfXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCJdKiRcIikpLnRlc3QobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICdzaG91bGQgY29uZm9ybSB0byB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lIGluIGh0bWw1IHNwZWNpZmljYXRpb24uJ1xuICAgICk7XG4gIH1cbiAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICdpZDogJyArIG5hbWVcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucywgdm0pIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcInByb3BzXFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHByb3BzKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gIGlmICghaW5qZWN0KSB7IHJldHVybiB9XG4gIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxuICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcImluamVjdFxcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShpbmplY3QpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiQkMSA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmJCQxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmJCQxLCB1cGRhdGU6IGRlZiQkMSB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlIChuYW1lLCB2YWx1ZSwgdm0pIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiOiBleHBlY3RlZCBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUodmFsdWUpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuXG4gIC8vIEFwcGx5IGV4dGVuZHMgYW5kIG1peGlucyBvbiB0aGUgY2hpbGQgb3B0aW9ucyxcbiAgLy8gYnV0IG9ubHkgaWYgaXQgaXMgYSByYXcgb3B0aW9ucyBvYmplY3QgdGhhdCBpc24ndFxuICAvLyB0aGUgcmVzdWx0IG9mIGFub3RoZXIgbWVyZ2VPcHRpb25zIGNhbGwuXG4gIC8vIE9ubHkgbWVyZ2VkIG9wdGlvbnMgaGFzIHRoZSBfYmFzZSBwcm9wZXJ0eS5cbiAgaWYgKCFjaGlsZC5fYmFzZSkge1xuICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgfVxuICAgIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gYm9vbGVhbiBjYXN0aW5nXG4gIHZhciBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgaWYgKGJvb2xlYW5JbmRleCA+IC0xKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSB7XG4gICAgICAvLyBvbmx5IGNhc3QgZW1wdHkgc3RyaW5nIC8gc2FtZSBuYW1lIHRvIGJvb2xlYW4gaWZcbiAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgdmFyIHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xuICB9XG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgLy8gc2tpcCB2YWxpZGF0aW9uIGZvciB3ZWV4IHJlY3ljbGUtbGlzdCBjaGlsZCBjb21wb25lbnQgcHJvcHNcbiAgICAhKGZhbHNlKVxuICApIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcbiAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYilcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4ICh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZSAobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgdmFyIG1lc3NhZ2UgPSBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSk7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICB2YXIgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgdmFyIGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxuICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXG4gICAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gXCIgd2l0aCB2YWx1ZSBcIiArIGV4cGVjdGVkVmFsdWU7XG4gIH1cbiAgbWVzc2FnZSArPSBcIiwgZ290IFwiICsgcmVjZWl2ZWRUeXBlICsgXCIgXCI7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IFwid2l0aCB2YWx1ZSBcIiArIHJlY2VpdmVkVmFsdWUgKyBcIi5cIjtcbiAgfVxuICByZXR1cm4gbWVzc2FnZVxufVxuXG5mdW5jdGlvbiBzdHlsZVZhbHVlICh2YWx1ZSwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICByZXR1cm4gKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIilcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xuICAgIHJldHVybiAoXCJcIiArIChOdW1iZXIodmFsdWUpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUgKHZhbHVlKSB7XG4gIHZhciBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbiAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbTsgfSlcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuICgpIHtcbiAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICByZXR1cm4gYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJzsgfSlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIC8vIERlYWN0aXZhdGUgZGVwcyB0cmFja2luZyB3aGlsZSBwcm9jZXNzaW5nIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgcG9zc2libGUgaW5maW5pdGUgcmVuZGVyaW5nLlxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWV4L2lzc3Vlcy8xNTA1XG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICBpZiAodm0pIHtcbiAgICAgIHZhciBjdXIgPSB2bTtcbiAgICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICAgIHZhciBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xuICAgICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyAoXG4gIGhhbmRsZXIsXG4gIGNvbnRleHQsXG4gIGFyZ3MsXG4gIHZtLFxuICBpbmZvXG4pIHtcbiAgdmFyIHJlcztcbiAgdHJ5IHtcbiAgICByZXMgPSBhcmdzID8gaGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKSA6IGhhbmRsZXIuY2FsbChjb250ZXh0KTtcbiAgICBpZiAocmVzICYmICFyZXMuX2lzVnVlICYmIGlzUHJvbWlzZShyZXMpICYmICFyZXMuX2hhbmRsZWQpIHtcbiAgICAgIHJlcy5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBcIiAoUHJvbWlzZS9hc3luYylcIik7IH0pO1xuICAgICAgLy8gaXNzdWUgIzk1MTFcbiAgICAgIC8vIGF2b2lkIGNhdGNoIHRyaWdnZXJpbmcgbXVsdGlwbGUgdGltZXMgd2hlbiBuZXN0ZWQgY2FsbHNcbiAgICAgIHJlcy5faGFuZGxlZCA9IHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcbiAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcbiAgICAgIGlmIChlICE9PSBlcnIpIHtcbiAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgaXNVc2luZ01pY3JvVGFzayA9IGZhbHNlO1xuXG52YXIgY2FsbGJhY2tzID0gW107XG52YXIgcGVuZGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBtaWNyb3Rhc2tzLlxuLy8gSW4gMi41IHdlIHVzZWQgKG1hY3JvKSB0YXNrcyAoaW4gY29tYmluYXRpb24gd2l0aCBtaWNyb3Rhc2tzKS5cbi8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XG4vLyAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEFsc28sIHVzaW5nIChtYWNybykgdGFza3MgaW4gZXZlbnQgaGFuZGxlciB3b3VsZCBjYXVzZSBzb21lIHdlaXJkIGJlaGF2aW9yc1xuLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXG4vLyBTbyB3ZSBub3cgdXNlIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYWdhaW4uXG4vLyBBIG1ham9yIGRyYXdiYWNrIG9mIHRoaXMgdHJhZGVvZmYgaXMgdGhhdCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Ncbi8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwLCB3aGljaCBoYXZlIHdvcmthcm91bmRzKVxuLy8gb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lIGV2ZW50ICgjNjU2NikuXG52YXIgdGltZXJGdW5jO1xuXG4vLyBUaGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbi8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4vLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4vLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIEluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgfTtcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG59IGVsc2UgaWYgKCFpc0lFICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gIC8vIGUuZy4gUGhhbnRvbUpTLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAvLyAoIzY0NjYgTXV0YXRpb25PYnNlcnZlciBpcyB1bnJlbGlhYmxlIGluIElFMTEpXG4gIHZhciBjb3VudGVyID0gMTtcbiAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICB9KTtcbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICB9O1xuICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbn0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICAvLyBGYWxsYmFjayB0byBzZXRJbW1lZGlhdGUuXG4gIC8vIFRlY2huaWNhbGx5IGl0IGxldmVyYWdlcyB0aGUgKG1hY3JvKSB0YXNrIHF1ZXVlLFxuICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKCk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgLy8gcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpXG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXG4gICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIHdhcm5SZXNlcnZlZFByZWZpeCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBtdXN0IGJlIGFjY2Vzc2VkIHdpdGggXFxcIiRkYXRhLlwiICsga2V5ICsgXCJcXFwiIGJlY2F1c2UgXCIgK1xuICAgICAgJ3Byb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCBcIiRcIiBvciBcIl9cIiBhcmUgbm90IHByb3hpZWQgaW4gdGhlIFZ1ZSBpbnN0YW5jZSB0byAnICtcbiAgICAgICdwcmV2ZW50IGNvbmZsaWN0cyB3aXRoIFZ1ZSBpbnRlcm5hbHMuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvYXBpLyNkYXRhJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb3h5KTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fFxuICAgICAgICAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5LmNoYXJBdCgwKSA9PT0gJ18nICYmICEoa2V5IGluIHRhcmdldC4kZGF0YSkpO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKSB7IHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgZWxzZSB7IHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8IE9iamVjdC5pc0Zyb3plbih2YWwpIHx8IHZhbCBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucywgdm0pIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNsb25lZFtpXSwgbnVsbCwgYXJndW1lbnRzJDEsIHZtLCBcInYtb24gaGFuZGxlclwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhmbnMsIG51bGwsIGFyZ3VtZW50cywgdm0sIFwidi1vbiBoYW5kbGVyXCIpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICBjcmVhdGVPbmNlSGFuZGxlcixcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgZGVmJCQxLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGRlZiQkMSA9IGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzVHJ1ZShldmVudC5vbmNlKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgfVxuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgaGFzT3duKHNvdXJjZS5fcHJvdmlkZWQsIHByb3ZpZGVLZXkpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuICB2YXIgc2xvdHMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICB2YXIgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgIH1cbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIHZhciBuYW1lID0gZGF0YS5zbG90O1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXG4gIGZvciAodmFyIG5hbWUkMSBpbiBzbG90cykge1xuICAgIGlmIChzbG90c1tuYW1lJDFdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgIGRlbGV0ZSBzbG90c1tuYW1lJDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgbm9ybWFsU2xvdHMsXG4gIHByZXZTbG90c1xuKSB7XG4gIHZhciByZXM7XG4gIHZhciBoYXNOb3JtYWxTbG90cyA9IE9iamVjdC5rZXlzKG5vcm1hbFNsb3RzKS5sZW5ndGggPiAwO1xuICB2YXIgaXNTdGFibGUgPSBzbG90cyA/ICEhc2xvdHMuJHN0YWJsZSA6ICFoYXNOb3JtYWxTbG90cztcbiAgdmFyIGtleSA9IHNsb3RzICYmIHNsb3RzLiRrZXk7XG4gIGlmICghc2xvdHMpIHtcbiAgICByZXMgPSB7fTtcbiAgfSBlbHNlIGlmIChzbG90cy5fbm9ybWFsaXplZCkge1xuICAgIC8vIGZhc3QgcGF0aCAxOiBjaGlsZCBjb21wb25lbnQgcmUtcmVuZGVyIG9ubHksIHBhcmVudCBkaWQgbm90IGNoYW5nZVxuICAgIHJldHVybiBzbG90cy5fbm9ybWFsaXplZFxuICB9IGVsc2UgaWYgKFxuICAgIGlzU3RhYmxlICYmXG4gICAgcHJldlNsb3RzICYmXG4gICAgcHJldlNsb3RzICE9PSBlbXB0eU9iamVjdCAmJlxuICAgIGtleSA9PT0gcHJldlNsb3RzLiRrZXkgJiZcbiAgICAhaGFzTm9ybWFsU2xvdHMgJiZcbiAgICAhcHJldlNsb3RzLiRoYXNOb3JtYWxcbiAgKSB7XG4gICAgLy8gZmFzdCBwYXRoIDI6IHN0YWJsZSBzY29wZWQgc2xvdHMgdy8gbm8gbm9ybWFsIHNsb3RzIHRvIHByb3h5LFxuICAgIC8vIG9ubHkgbmVlZCB0byBub3JtYWxpemUgb25jZVxuICAgIHJldHVybiBwcmV2U2xvdHNcbiAgfSBlbHNlIHtcbiAgICByZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkkMSBpbiBzbG90cykge1xuICAgICAgaWYgKHNsb3RzW2tleSQxXSAmJiBrZXkkMVswXSAhPT0gJyQnKSB7XG4gICAgICAgIHJlc1trZXkkMV0gPSBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXkkMSwgc2xvdHNba2V5JDFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZXhwb3NlIG5vcm1hbCBzbG90cyBvbiBzY29wZWRTbG90c1xuICBmb3IgKHZhciBrZXkkMiBpbiBub3JtYWxTbG90cykge1xuICAgIGlmICghKGtleSQyIGluIHJlcykpIHtcbiAgICAgIHJlc1trZXkkMl0gPSBwcm94eU5vcm1hbFNsb3Qobm9ybWFsU2xvdHMsIGtleSQyKTtcbiAgICB9XG4gIH1cbiAgLy8gYXZvcmlheiBzZWVtcyB0byBtb2NrIGEgbm9uLWV4dGVuc2libGUgJHNjb3BlZFNsb3RzIG9iamVjdFxuICAvLyBhbmQgd2hlbiB0aGF0IGlzIHBhc3NlZCBkb3duIHRoaXMgd291bGQgY2F1c2UgYW4gZXJyb3JcbiAgaWYgKHNsb3RzICYmIE9iamVjdC5pc0V4dGVuc2libGUoc2xvdHMpKSB7XG4gICAgKHNsb3RzKS5fbm9ybWFsaXplZCA9IHJlcztcbiAgfVxuICBkZWYocmVzLCAnJHN0YWJsZScsIGlzU3RhYmxlKTtcbiAgZGVmKHJlcywgJyRrZXknLCBrZXkpO1xuICBkZWYocmVzLCAnJGhhc05vcm1hbCcsIGhhc05vcm1hbFNsb3RzKTtcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXksIGZuKSB7XG4gIHZhciBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID8gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKSA6IGZuKHt9KTtcbiAgICByZXMgPSByZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVzKVxuICAgICAgPyBbcmVzXSAvLyBzaW5nbGUgdm5vZGVcbiAgICAgIDogbm9ybWFsaXplQ2hpbGRyZW4ocmVzKTtcbiAgICByZXR1cm4gcmVzICYmIChcbiAgICAgIHJlcy5sZW5ndGggPT09IDAgfHxcbiAgICAgIChyZXMubGVuZ3RoID09PSAxICYmIHJlc1swXS5pc0NvbW1lbnQpIC8vICM5NjU4XG4gICAgKSA/IHVuZGVmaW5lZFxuICAgICAgOiByZXNcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXG4gIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgaWYgKGZuLnByb3h5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFxufVxuXG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2xvdHNba2V5XTsgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIHJldC5wdXNoKHJlbmRlcihyZXN1bHQudmFsdWUsIHJldC5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzRGVmKHJldCkpIHtcbiAgICByZXQgPSBbXTtcbiAgfVxuICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgdmFyIG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIG5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV0gfHwgZmFsbGJhY2s7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5LZXlDb2RlLFxuICBldmVudEtleU5hbWUsXG4gIGJ1aWx0SW5LZXlOYW1lXG4pIHtcbiAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIGlmICghKGNhbWVsaXplZEtleSBpbiBoYXNoKSAmJiAhKGh5cGhlbmF0ZWRLZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uWyhcInVwZGF0ZTpcIiArIGtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XG4gIHZhciB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiB0cmVlXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgIHRoaXMuX3JlbmRlclByb3h5LFxuICAgIG51bGwsXG4gICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICApO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlcyxcbiAgLy8gdGhlIGZvbGxvd2luZyBhcmUgYWRkZWQgaW4gMi42XG4gIGhhc0R5bmFtaWNLZXlzLFxuICBjb250ZW50SGFzaEtleVxuKSB7XG4gIHJlcyA9IHJlcyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzbG90ID0gZm5zW2ldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNsb3QpKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoc2xvdCwgcmVzLCBoYXNEeW5hbWljS2V5cyk7XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICAvLyBtYXJrZXIgZm9yIHJldmVyc2UgcHJveHlpbmcgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICAgIGlmIChzbG90LnByb3h5KSB7XG4gICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmVzW3Nsb3Qua2V5XSA9IHNsb3QuZm47XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50SGFzaEtleSkge1xuICAgIChyZXMpLiRrZXkgPSBjb250ZW50SGFzaEtleTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kRHluYW1pY0tleXMgKGJhc2VPYmosIHZhbHVlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBrZXkgPSB2YWx1ZXNbaV07XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleSkge1xuICAgICAgYmFzZU9ialt2YWx1ZXNbaV1dID0gdmFsdWVzW2kgKyAxXTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYga2V5ICE9PSAnJyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIC8vIG51bGwgaXMgYSBzcGVjaWFsIHZhbHVlIGZvciBleHBsaWNpdGx5IHJlbW92aW5nIGEgYmluZGluZ1xuICAgICAgd2FybihcbiAgICAgICAgKFwiSW52YWxpZCB2YWx1ZSBmb3IgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgKGV4cGVjdGVkIHN0cmluZyBvciBudWxsKTogXCIgKyBrZXkpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmFzZU9ialxufVxuXG4vLyBoZWxwZXIgdG8gZHluYW1pY2FsbHkgYXBwZW5kIG1vZGlmaWVyIHJ1bnRpbWUgbWFya2VycyB0byBldmVudCBuYW1lcy5cbi8vIGVuc3VyZSBvbmx5IGFwcGVuZCB3aGVuIHZhbHVlIGlzIGFscmVhZHkgc3RyaW5nLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjYXN0XG4vLyB0byBzdHJpbmcgYW5kIGNhdXNlIHRoZSB0eXBlIGNoZWNrIHRvIG1pc3MuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXIgKHZhbHVlLCBzeW1ib2wpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBzeW1ib2wgKyB2YWx1ZSA6IHZhbHVlXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyAodGFyZ2V0KSB7XG4gIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xuICB0YXJnZXQuX24gPSB0b051bWJlcjtcbiAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XG4gIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XG4gIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XG4gIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XG4gIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcbiAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xuICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xuICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xuICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xuICB0YXJnZXQuX2QgPSBiaW5kRHluYW1pY0tleXM7XG4gIHRhcmdldC5fcCA9IHByZXBlbmRNb2RpZmllcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgZGF0YSxcbiAgcHJvcHMsXG4gIGNoaWxkcmVuLFxuICBwYXJlbnQsXG4gIEN0b3Jcbikge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBjb250ZXh0Vm07XG4gIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XG4gICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNvbnRleHQgdm0gcGFzc2VkIGluIGlzIGEgZnVuY3Rpb25hbCBjb250ZXh0IGFzIHdlbGwuXG4gICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgLy8gcmVhbCBjb250ZXh0IGluc3RhbmNlLlxuICAgIGNvbnRleHRWbSA9IHBhcmVudDtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xuICB9XG4gIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG5cbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzJDEuJHNsb3RzKSB7XG4gICAgICBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgdGhpcyQxLiRzbG90cyA9IHJlc29sdmVTbG90cyhjaGlsZHJlbiwgcGFyZW50KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMkMS4kc2xvdHNcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Njb3BlZFNsb3RzJywgKHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLnNsb3RzKCkpXG4gICAgfVxuICB9KSk7XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuJHNsb3RzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICAgICAgaWYgKHZub2RlICYmICFBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgfVxufVxuXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0Vm0sXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG5cbiAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0ICh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zLCByZW5kZXJDb250ZXh0KSB7XG4gIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXG4gIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xuICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAoY2xvbmUuZGV2dG9vbHNNZXRhID0gY2xvbmUuZGV2dG9vbHNNZXRhIHx8IHt9KS5yZW5kZXJDb250ZXh0ID0gcmVuZGVyQ29udGV4dDtcbiAgfVxuICBpZiAoZGF0YS5zbG90KSB7XG4gICAgKGNsb25lLmRhdGEgfHwgKGNsb25lLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gIH1cbiAgcmV0dXJuIGNsb25lXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIGlmIChcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgdmFyIGFzeW5jRmFjdG9yeTtcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IpO1xuICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcbiAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXG4gICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhZ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgZGF0YSA9IHt9O1xuICAgIGlmIChzbG90KSB7XG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcblxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50IC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuKSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIHBhcmVudDogcGFyZW50XG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZXhpc3RpbmcgPSBob29rc1trZXldO1xuICAgIHZhciB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGlmIChleGlzdGluZyAhPT0gdG9NZXJnZSAmJiAhKGV4aXN0aW5nICYmIGV4aXN0aW5nLl9tZXJnZWQpKSB7XG4gICAgICBob29rc1trZXldID0gZXhpc3RpbmcgPyBtZXJnZUhvb2skMSh0b01lcmdlLCBleGlzdGluZykgOiB0b01lcmdlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAoZjEsIGYyKSB7XG4gIHZhciBtZXJnZWQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIGZsb3cgY29tcGxhaW5zIGFib3V0IGV4dHJhIGFyZ3Mgd2hpY2ggaXMgd2h5IHdlIHVzZSBhbnlcbiAgICBmMShhLCBiKTtcbiAgICBmMihhLCBiKTtcbiAgfTtcbiAgbWVyZ2VkLl9tZXJnZWQgPSB0cnVlO1xuICByZXR1cm4gbWVyZ2VkXG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCdcbiAgOyhkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIHZhciBleGlzdGluZyA9IG9uW2V2ZW50XTtcbiAgdmFyIGNhbGxiYWNrID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xuICAgIGlmIChcbiAgICAgIEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpXG4gICAgICAgID8gZXhpc3RpbmcuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xXG4gICAgICAgIDogZXhpc3RpbmcgIT09IGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEubmF0aXZlT24pKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiVGhlIC5uYXRpdmUgbW9kaWZpZXIgZm9yIHYtb24gaXMgb25seSB2YWxpZCBvbiBjb21wb25lbnRzIGJ1dCBpdCB3YXMgdXNlZCBvbiA8XCIgKyB0YWcgKyBcIj4uXCIpLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoKCFkYXRhIHx8ICFkYXRhLnByZSkgJiYgaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2UgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgIGlmIChpc0RlZihucykpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7IHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoXG4gICAgICAgIGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyByZWYgIzUzMThcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4vLyA6Y2xhc3MgYXJlIHVzZWQgb24gc2xvdCBub2Rlc1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MgKGRhdGEpIHtcbiAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5zdHlsZSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG52YXIgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xuICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcblxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICBpZiAoX3BhcmVudFZub2RlKSB7XG4gICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHZtLiRzbG90cyxcbiAgICAgICAgdm0uJHNjb3BlZFNsb3RzXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBtYWludGFpbiBhIHN0YWNrIGJlY2F1c2UgYWxsIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gc2VwYXJhdGVseSBmcm9tIG9uZSBhbm90aGVyLiBOZXN0ZWQgY29tcG9uZW50J3MgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAvLyB3aGVuIHBhcmVudCBjb21wb25lbnQgaXMgcGF0Y2hlZC5cbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IHZtO1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJFcnJvclwiKTtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICAgIC8vIGlmIHRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvbmx5IGEgc2luZ2xlIG5vZGUsIGFsbG93IGl0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpICYmIHZub2RlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICBpZiAoXG4gICAgY29tcC5fX2VzTW9kdWxlIHx8XG4gICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICApIHtcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvclxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgdmFyIG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAob3duZXIgJiYgaXNEZWYoZmFjdG9yeS5vd25lcnMpICYmIGZhY3Rvcnkub3duZXJzLmluZGV4T2Yob3duZXIpID09PSAtMSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3Rvcnkub3duZXJzLnB1c2gob3duZXIpO1xuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChvd25lciAmJiAhaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XG4gICAgdmFyIG93bmVycyA9IGZhY3Rvcnkub3duZXJzID0gW293bmVyXTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG4gICAgdmFyIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgdmFyIHRpbWVyVGltZW91dCA9IG51bGxcblxuICAgIDsob3duZXIpLiRvbignaG9vazpkZXN0cm95ZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1vdmUob3duZXJzLCBvd25lcik7IH0pO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIChvd25lcnNbaV0pLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgICBpZiAodGltZXJMb2FkaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyTG9hZGluZyk7XG4gICAgICAgICAgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyVGltZW91dCk7XG4gICAgICAgICAgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShyZXMuY29tcG9uZW50KSkge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcihmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICB0aW1lclRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChldmVudCwgZm4pIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQ7XG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgX3RhcmdldC4kb2ZmKGV2ZW50LCBvbmNlSGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIGNyZWF0ZU9uY2VIYW5kbGVyLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkkMSA8IGw7IGkkMSsrKSB7XG4gICAgICAgIHZtLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKCFmbikge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICB2YXIgaW5mbyA9IFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYnNbaV0sIHZtLCBhcmdzLCB2bSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gc2V0QWN0aXZlSW5zdGFuY2Uodm0pIHtcbiAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2Uodm0pO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCB7XG4gICAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUgKCkge1xuICAgICAgaWYgKHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbi5cblxuICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgZHluYW1pYyBzY29wZWRTbG90cyAoaGFuZC13cml0dGVuIG9yIGNvbXBpbGVkIGJ1dCB3aXRoXG4gIC8vIGR5bmFtaWMgc2xvdCBuYW1lcykuIFN0YXRpYyBzY29wZWQgc2xvdHMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBoYXMgdGhlXG4gIC8vIFwiJHN0YWJsZVwiIG1hcmtlci5cbiAgdmFyIG5ld1Njb3BlZFNsb3RzID0gcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cztcbiAgdmFyIG9sZFNjb3BlZFNsb3RzID0gdm0uJHNjb3BlZFNsb3RzO1xuICB2YXIgaGFzRHluYW1pY1Njb3BlZFNsb3QgPSAhIShcbiAgICAobmV3U2NvcGVkU2xvdHMgJiYgIW5ld1Njb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgKG9sZFNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJiAhb2xkU2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAobmV3U2NvcGVkU2xvdHMgJiYgdm0uJHNjb3BlZFNsb3RzLiRrZXkgIT09IG5ld1Njb3BlZFNsb3RzLiRrZXkpXG4gICk7XG5cbiAgLy8gQW55IHN0YXRpYyBzbG90IGNoaWxkcmVuIGZyb20gdGhlIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyBwYXJlbnQnc1xuICAvLyB1cGRhdGUuIER5bmFtaWMgc2NvcGVkIHNsb3RzIG1heSBhbHNvIGhhdmUgY2hhbmdlZC4gSW4gc3VjaCBjYXNlcywgYSBmb3JjZWRcbiAgLy8gdXBkYXRlIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgY29ycmVjdG5lc3MuXG4gIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBoYXNEeW5hbWljU2NvcGVkU2xvdFxuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHZhciBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAobmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICB2YXIgaW5mbyA9IGhvb2sgKyBcIiBob29rXCI7XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyc1tpXSwgdm0sIG51bGwsIHZtLCBpbmZvKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG59XG5cbi8qICAqL1xuXG52YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxudmFyIHF1ZXVlID0gW107XG52YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcbi8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xuLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG52YXIgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cbnZhciBnZXROb3cgPSBEYXRlLm5vdztcblxuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcbi8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXG4vLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcbi8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cbi8vIEFsbCBJRSB2ZXJzaW9ucyB1c2UgbG93LXJlcyBldmVudCB0aW1lc3RhbXBzLCBhbmQgaGF2ZSBwcm9ibGVtYXRpYyBjbG9ja1xuLy8gaW1wbGVtZW50YXRpb25zICgjOTYzMilcbmlmIChpbkJyb3dzZXIgJiYgIWlzSUUpIHtcbiAgdmFyIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlO1xuICBpZiAoXG4gICAgcGVyZm9ybWFuY2UgJiZcbiAgICB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nICYmXG4gICAgZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXBcbiAgKSB7XG4gICAgLy8gaWYgdGhlIGV2ZW50IHRpbWVzdGFtcCwgYWx0aG91Z2ggZXZhbHVhdGVkIEFGVEVSIHRoZSBEYXRlLm5vdygpLCBpc1xuICAgIC8vIHNtYWxsZXIgdGhhbiBpdCwgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lciB0aW1lc3RhbXBzIGFzXG4gICAgLy8gd2VsbC5cbiAgICBnZXROb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfTtcbiAgfVxufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgY3VycmVudEZsdXNoVGltZXN0YW1wID0gZ2V0Tm93KCk7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgIH1cbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25maWcuYXN5bmMpIHtcbiAgICAgICAgZmx1c2hTY2hlZHVsZXJRdWV1ZSgpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9ucyxcbiAgaXNSZW5kZXJXYXRjaGVyXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICBpZiAoaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xuICB9XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gICAgdGhpcy5iZWZvcmUgPSBvcHRpb25zLmJlZm9yZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IG5vb3A7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcy5kZXBzW2ldO1xuICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBpZiAoIWlzUm9vdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gIH1cbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxuICAgICAgICAgIGNvbmZpZy5pc1Jlc2VydmVkQXR0cihoeXBoZW5hdGVkS2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGh5cGhlbmF0ZWRLZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jvb3QgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG4gIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9IGZpbmFsbHkge1xuICAgIHBvcFRhcmdldCgpO1xuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXG4gIHZhciBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXR0ZXIgPT0gbnVsbCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNTU1IpIHtcbiAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIoXG4gICAgICAgIHZtLFxuICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcbiAgICAgICAgbm9vcCxcbiAgICAgICAgY29tcHV0ZWRXYXRjaGVyT3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXG4gIHRhcmdldCxcbiAga2V5LFxuICB1c2VyRGVmXG4pIHtcbiAgdmFyIHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZik7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZi5nZXQpXG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0IHx8IG5vb3A7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlR2V0dGVySW52b2tlcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIHRoaXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgdHlwZSBcXFwiXCIgKyAodHlwZW9mIG1ldGhvZHNba2V5XSkgKyBcIlxcXCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKChrZXkgaW4gdm0pICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXG4gICAgICAgICAgXCJBdm9pZCBkZWZpbmluZyBjb21wb25lbnQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZtW2tleV0gPSB0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBoYW5kbGVyLFxuICBvcHRpb25zXG4pIHtcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgcmV0dXJuIHZtLiR3YXRjaChleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnJvciwgdm0sIChcImNhbGxiYWNrIGZvciBpbW1lZGlhdGUgd2F0Y2hlciBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciB1aWQkMyA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDMrKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcblxuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgb3B0cy5wcm9wc0RhdGEgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZztcblxuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBsYXRlc3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIFZ1ZSAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUpO1xuc3RhdGVNaXhpbihWdWUpO1xuZXZlbnRzTWl4aW4oVnVlKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG5yZW5kZXJNaXhpbihWdWUpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUoa2V5cywga2V5KTtcbn1cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzLmNhY2hlLCBrZXksIHRoaXMua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIC8vIDIuNiBleHBsaWNpdCBvYnNlcnZhYmxlIEFQSVxuICBWdWUub2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBvYnNlcnZlKG9iaik7XG4gICAgcmV0dXJuIG9ialxuICB9O1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnRnVuY3Rpb25hbFJlbmRlckNvbnRleHQnLCB7XG4gIHZhbHVlOiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dFxufSk7XG5cblZ1ZS52ZXJzaW9uID0gJzIuNi4xMic7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUgPSBtYWtlTWFwKCdldmVudHMsY2FyZXQsdHlwaW5nLHBsYWludGV4dC1vbmx5Jyk7XG5cbnZhciBjb252ZXJ0RW51bWVyYXRlZFZhbHVlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnXG4gICAgPyAnZmFsc2UnXG4gICAgLy8gYWxsb3cgYXJiaXRyYXJ5IHN0cmluZyB2YWx1ZSBmb3IgY29udGVudGVkaXRhYmxlXG4gICAgOiBrZXkgPT09ICdjb250ZW50ZWRpdGFibGUnICYmIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSh2YWx1ZSlcbiAgICAgID8gdmFsdWVcbiAgICAgIDogJ3RydWUnXG59O1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlU2NvcGUgKG5vZGUsIHNjb3BlSWQpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoc2NvcGVJZCwgJycpO1xufVxuXG52YXIgbm9kZU9wcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcbiAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICBjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgcmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG4gIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgdGFnTmFtZTogdGFnTmFtZSxcbiAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuICBzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICghaXNEZWYoa2V5KSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIWluVlByZSAmJlxuICAgICAgIXZub2RlLm5zICYmXG4gICAgICAhKFxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYkJDEpID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIiArIGtleSArIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAoXG4gICAgb2xkVm5vZGUsXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXgsXG4gICAgcmVtb3ZlT25seVxuICApIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gY2xvbmUgcmV1c2VkIHZub2RlXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xuICAgICAgICAgIHJlbW92ZVZub2Rlcyhbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBkaXIub2xkQXJnID0gb2xkRGlyLmFyZztcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgKSB7XG4gICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICB9O1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZywgcmFuZ2UpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgdmFyIGF0dHJzID0gZHluYW1pY1xuICAgID8gKGVsLmR5bmFtaWNBdHRycyB8fCAoZWwuZHluYW1pY0F0dHJzID0gW10pKVxuICAgIDogKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSk7XG4gIGF0dHJzLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSwgcmFuZ2UpKTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIGlzRHluYW1pY0FyZyxcbiAgbW9kaWZpZXJzLFxuICByYW5nZVxuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7XG4gICAgbmFtZTogbmFtZSxcbiAgICByYXdOYW1lOiByYXdOYW1lLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBhcmc6IGFyZyxcbiAgICBpc0R5bmFtaWNBcmc6IGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnM6IG1vZGlmaWVyc1xuICB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXJNYXJrZXIgKHN5bWJvbCwgbmFtZSwgZHluYW1pYykge1xuICByZXR1cm4gZHluYW1pY1xuICAgID8gKFwiX3AoXCIgKyBuYW1lICsgXCIsXFxcIlwiICsgc3ltYm9sICsgXCJcXFwiKVwiKVxuICAgIDogc3ltYm9sICsgbmFtZSAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FybixcbiAgcmFuZ2UsXG4gIGR5bmFtaWNcbikge1xuICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG5cbiAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXG4gIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICBpZiAobW9kaWZpZXJzLnJpZ2h0KSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydjb250ZXh0bWVudSc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydtb3VzZXVwJzooXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBuYW1lID0gJ21vdXNldXAnO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyEnLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignficsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAobW9kaWZpZXJzLnBhc3NpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignJicsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG5cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuXG4gIHZhciBuZXdIYW5kbGVyID0gcmFuZ2VTZXRJdGVtKHsgdmFsdWU6IHZhbHVlLnRyaW0oKSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSk7XG4gIGlmIChtb2RpZmllcnMgIT09IGVtcHR5T2JqZWN0KSB7XG4gICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gIH1cblxuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cblxuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRSYXdCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lXG4pIHtcbiAgcmV0dXJuIGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICBlbC5yYXdBdHRyc01hcFtuYW1lXVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICByZW1vdmVGcm9tTWFwXG4pIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICB9XG4gIHJldHVybiB2YWxcbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXggKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBsaXN0W2ldO1xuICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm4gYXR0clxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByYW5nZVNldEl0ZW0gKFxuICBpdGVtLFxuICByYW5nZVxuKSB7XG4gIGlmIChyYW5nZSkge1xuICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICBpdGVtLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IEpTT04uc3RyaW5naWZ5KHZhbHVlKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cblxudmFyIGxlbiwgc3RyLCBjaHIsIGluZGV4JDEsIGV4cHJlc3Npb25Qb3MsIGV4cHJlc3Npb25FbmRQb3M7XG5cblxuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXG4gIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICB2YWwgPSB2YWwudHJpbSgpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGluZGV4JDEgPiAtMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXG4gICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCQxICsgMSkgKyAnXCInXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLFxuICAgICAgICBrZXk6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHIgPSB2YWw7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnNsaWNlKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRlbC5jaGVja2VkKXskJGk8MCYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLmNvbmNhdChbJCR2XSknKSkgKyBcIil9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSkgKyBcIil9XCIgK1xuICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAvLyB3YXJuIGlmIHYtYmluZDp2YWx1ZSBjb25mbGljdHMgd2l0aCB2LW1vZGVsXG4gIC8vIGV4Y2VwdCBmb3IgaW5wdXRzIHdpdGggdi1iaW5kOnR5cGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHZhbHVlJDEgJiYgIXR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGJpbmRpbmcgKyBcIj1cXFwiXCIgKyB2YWx1ZSQxICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBcIiArXG4gICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5JyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbYmluZGluZ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIkMSAoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbi8vICM5NDQ2OiBGaXJlZm94IDw9IDUzIChpbiBwYXJ0aWN1bGFyLCBFU1IgNTIpIGhhcyBpbmNvcnJlY3QgRXZlbnQudGltZVN0YW1wXG4vLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXG4vLyBzYWZlIHRvIGV4Y2x1ZGUuXG52YXIgdXNlTWljcm90YXNrRml4ID0gaXNVc2luZ01pY3JvVGFzayAmJiAhKGlzRkYgJiYgTnVtYmVyKGlzRkZbMV0pIDw9IDUzKTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBuYW1lLFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxuICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xuICAvLyBoYXBwZW5zIGJlY2F1c2UgYnJvd3NlcnMgZmlyZSBtaWNyb3Rhc2sgdGlja3MgYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbi5cbiAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxuICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXG4gIC8vIEFGVEVSIGl0IHdhcyBhdHRhY2hlZC5cbiAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xuICAgIHZhciBhdHRhY2hlZFRpbWVzdGFtcCA9IGN1cnJlbnRGbHVzaFRpbWVzdGFtcDtcbiAgICB2YXIgb3JpZ2luYWwgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBvcmlnaW5hbC5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vIGJ1YmJsaW5nLCBzaG91bGQgYWx3YXlzIGZpcmUuXG4gICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAvLyBjZXJ0YWluIHdlaXJkIGVudmlyb25tZW50cy4uLlxuICAgICAgICBlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0IHx8XG4gICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICBlLnRpbWVTdGFtcCA+PSBhdHRhY2hlZFRpbWVzdGFtcCB8fFxuICAgICAgICAvLyBiYWlsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBoYXZlIGJ1Z2d5IGV2ZW50LnRpbWVTdGFtcCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgLy8gIzk0NjIgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICAvLyAjOTY4MSBRdFdlYkVuZ2luZSBldmVudC50aW1lU3RhbXAgaXMgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgZS50aW1lU3RhbXAgPD0gMCB8fFxuICAgICAgICAvLyAjOTQ0OCBiYWlsIGlmIGV2ZW50IGlzIGZpcmVkIGluIGFub3RoZXIgZG9jdW1lbnQgaW4gYSBtdWx0aS1wYWdlXG4gICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgLy8gc3RhcnRpbmcgcmVmZXJlbmNlXG4gICAgICAgIGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlci5fd3JhcHBlciB8fCBoYW5kbGVyLFxuICAgIGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIGNyZWF0ZU9uY2VIYW5kbGVyJDEsIHZub2RlLmNvbnRleHQpO1xuICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxudmFyIHN2Z0NvbnRhaW5lcjtcblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cblxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmIGVsbS50YWdOYW1lICE9PSAnUFJPR1JFU1MnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgJiYgaXNTVkcoZWxtLnRhZ05hbWUpICYmIGlzVW5kZWYoZWxtLmlubmVySFRNTCkpIHtcbiAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xuICAgICAgc3ZnQ29udGFpbmVyID0gc3ZnQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3ZnQ29udGFpbmVyLmlubmVySFRNTCA9IFwiPHN2Zz5cIiArIGN1ciArIFwiPC9zdmc+XCI7XG4gICAgICB2YXIgc3ZnID0gc3ZnQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoZWxtLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChzdmcuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbG0uYXBwZW5kQ2hpbGQoc3ZnLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBza2lwIHRoZSB1cGRhdGUgaWYgb2xkIGFuZCBuZXcgVkRPTSBzdGF0ZSBpcyB0aGUgc2FtZS5cbiAgICAgIC8vIGB2YWx1ZWAgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGJlY2F1c2UgdGhlIERPTSB2YWx1ZSBtYXkgYmUgdGVtcG9yYXJpbHlcbiAgICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXG4gICAgICAvLyBUaGlzICAjNDUyMSBieSBza2lwcGluZyB0aGUgdW5uZWNlc3NhcnkgYGNoZWNrZWRgIHVwZGF0ZS5cbiAgICAgIGN1ciAhPT0gb2xkUHJvcHNba2V5XVxuICAgICkge1xuICAgICAgLy8gc29tZSBwcm9wZXJ0eSB1cGRhdGVzIGNhbiB0aHJvd1xuICAgICAgLy8gZS5nLiBgdmFsdWVgIG9uIDxwcm9ncmVzcz4gdy8gbm9uLWZpbml0ZSB2YWx1ZVxuICAgICAgdHJ5IHtcbiAgICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoZWxtLCBjaGVja1ZhbCkge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcbiAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShuYW1lKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG52YXIgd2hpdGVzcGFjZVJFID0gL1xccysvO1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyIG51bWJlcnNcbi8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbi8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd24gKGkuZS4gYWN0aW5nXG4vLyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vICM2OTAzXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIGlzTm90VGV4dE5vZGUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9O1xuXG52YXIgaXNWU2hvd0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfTtcblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihpc05vdFRleHROb2RlKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShpc1ZTaG93RGlyZWN0aXZlKSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXG4gICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIGJlZm9yZU1vdW50OiBmdW5jdGlvbiBiZWZvcmVNb3VudCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2UodGhpcyQxKTtcbiAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgIHRoaXMkMS5fX3BhdGNoX18oXG4gICAgICAgIHRoaXMkMS5fdm5vZGUsXG4gICAgICAgIHRoaXMkMS5rZXB0LFxuICAgICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICAgKTtcbiAgICAgIHRoaXMkMS5fdm5vZGUgPSB0aGlzJDEua2VwdDtcbiAgICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgICAgdXBkYXRlLmNhbGwodGhpcyQxLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaW5Ccm93c2VyKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0J1xuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgKTtcbiAgICB9XG4gIH0sIDApO1xufVxuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgcmF3VG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgdG9rZW5zOiByYXdUb2tlbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKHJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnY2xhc3MnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJyxcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsnc3R5bGUnXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbnZhciBkeW5hbWljQXJnQXR0cmlidXRlID0gL15cXHMqKCg/OnYtW1xcdy1dKzp8QHw6fCMpXFxbW149XStcXF1bXlxcc1wiJzw+XFwvPV0qKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xudmFyIG5jbmFtZSA9IFwiW2EtekEtWl9dW1xcXFwtXFxcXC4wLTlfYS16QS1aXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCJdKlwiO1xudmFyIHFuYW1lQ2FwdHVyZSA9IFwiKCg/OlwiICsgbmNuYW1lICsgXCJcXFxcOik/XCIgKyBuY25hbWUgKyBcIilcIjtcbnZhciBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKChcIl48XCIgKyBxbmFtZUNhcHR1cmUpKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgoXCJePFxcXFwvXCIgKyBxbmFtZUNhcHR1cmUgKyBcIltePl0qPlwiKSk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xuLy8gIzcyOTg6IGVzY2FwZSAtIHRvIGF2b2lkIGJlaW5nIHBhc3NlZCBhcyBIVE1MIGNvbW1lbnQgd2hlbiBpbmxpbmVkIGluIHBhZ2VcbnZhciBjb21tZW50ID0gL148IVxcLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJyxcbiAgJyYjOTsnOiAnXFx0JyxcbiAgJyYjMzk7JzogXCInXCJcbn07XG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOSk7L2c7XG52YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOXwjMTB8IzkpOy9nO1xuXG4vLyAjNTk5MlxudmFyIGlzSWdub3JlTmV3bGluZVRhZyA9IG1ha2VNYXAoJ3ByZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHNob3VsZElnbm9yZUZpcnN0TmV3bGluZSA9IGZ1bmN0aW9uICh0YWcsIGh0bWwpIHsgcmV0dXJuIHRhZyAmJiBpc0lnbm9yZU5ld2xpbmVUYWcodGFnKSAmJiBodG1sWzBdID09PSAnXFxuJzsgfTtcblxuZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gIHZhciByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gZGVjb2RpbmdNYXBbbWF0Y2hdOyB9KVxufVxuXG5mdW5jdGlvbiBwYXJzZUhUTUwgKGh0bWwsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICB2YXIgaXNVbmFyeVRhZyQkMSA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgdmFyIGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbW1lbnRFbmQgPSBodG1sLmluZGV4T2YoJy0tPicpO1xuXG4gICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50KGh0bWwuc3Vic3RyaW5nKDQsIGNvbW1lbnRFbmQpLCBpbmRleCwgaW5kZXggKyBjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFydFRhZ01hdGNoLnRhZ05hbWUsIGh0bWwpKSB7XG4gICAgICAgICAgICBhZHZhbmNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdC5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSB7IGJyZWFrIH1cbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEVuZCA8IDApIHtcbiAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGFkdmFuY2UodGV4dC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCwgaW5kZXggLSB0ZXh0Lmxlbmd0aCwgaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgdmFyIHJlc3QkMSA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJykgLy8gIzcyOThcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdCQxLmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0JDE7XG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChodG1sID09PSBsYXN0KSB7XG4gICAgICBvcHRpb25zLmNoYXJzICYmIG9wdGlvbnMuY2hhcnMoaHRtbCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpLCB7IHN0YXJ0OiBpbmRleCArIGh0bWwubGVuZ3RoIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goZHluYW1pY0FyZ0F0dHJpYnV0ZSkgfHwgaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICBhdHRyLnN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICBhdHRyLmVuZCA9IGluZGV4O1xuICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcblxuICAgIGlmIChleHBlY3RIVE1MKSB7XG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmFyeSA9IGlzVW5hcnlUYWckJDEodGFnTmFtZSkgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSB0YWdOYW1lID09PSAnYScgJiYgYXJnc1sxXSA9PT0gJ2hyZWYnXG4gICAgICAgID8gb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWZcbiAgICAgICAgOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgIH07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gYXJncy5zdGFydCArIGFyZ3NbMF0ubWF0Y2goL15cXHMqLykubGVuZ3RoO1xuICAgICAgICBhdHRyc1tpXS5lbmQgPSBhcmdzLmVuZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycywgc3RhcnQ6IG1hdGNoLnN0YXJ0LCBlbmQ6IG1hdGNoLmVuZCB9KTtcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7IGVuZCA9IGluZGV4OyB9XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxuICAgICAgICAgIG9wdGlvbnMud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpLFxuICAgICAgICAgICAgeyBzdGFydDogc3RhY2tbaV0uc3RhcnQsIGVuZDogc3RhY2tbaV0uZW5kIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBvblJFID0gL15AfF52LW9uOi87XG52YXIgZGlyUkUgPSAvXnYtfF5AfF46fF4jLztcbnZhciBmb3JBbGlhc1JFID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFtcXHNcXFNdKikvO1xudmFyIGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XG52YXIgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcbnZhciBkeW5hbWljQXJnUkUgPSAvXlxcWy4qXFxdJC87XG5cbnZhciBhcmdSRSA9IC86KC4qKSQvO1xudmFyIGJpbmRSRSA9IC9eOnxeXFwufF52LWJpbmQ6LztcbnZhciBtb2RpZmllclJFID0gL1xcLlteLlxcXV0rKD89W15cXF1dKiQpL2c7XG5cbnZhciBzbG90UkUgPSAvXnYtc2xvdCg6fCQpfF4jLztcblxudmFyIGxpbmVCcmVha1JFID0gL1tcXHJcXG5dLztcbnZhciB3aGl0ZXNwYWNlUkUkMSA9IC9cXHMrL2c7XG5cbnZhciBpbnZhbGlkQXR0cmlidXRlUkUgPSAvW1xcc1wiJzw+XFwvPV0vO1xuXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xuXG52YXIgZW1wdHlTbG90U2NvcGVUb2tlbiA9IFwiX2VtcHR5X1wiO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDI7XG52YXIgZGVsaW1pdGVycztcbnZhciB0cmFuc2Zvcm1zO1xudmFyIHByZVRyYW5zZm9ybXM7XG52YXIgcG9zdFRyYW5zZm9ybXM7XG52YXIgcGxhdGZvcm1Jc1ByZVRhZztcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xudmFyIG1heWJlQ29tcG9uZW50O1xuXG5mdW5jdGlvbiBjcmVhdGVBU1RFbGVtZW50IChcbiAgdGFnLFxuICBhdHRycyxcbiAgcGFyZW50XG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxLFxuICAgIHRhZzogdGFnLFxuICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgcmF3QXR0cnNNYXA6IHt9LFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIGNoaWxkcmVuOiBbXVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgbWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICEhZWwuY29tcG9uZW50IHx8ICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7IH07XG5cbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuXG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XG4gIHZhciB3aGl0ZXNwYWNlT3B0aW9uID0gb3B0aW9ucy53aGl0ZXNwYWNlO1xuICB2YXIgcm9vdDtcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBpblZQcmUgPSBmYWxzZTtcbiAgdmFyIGluUHJlID0gZmFsc2U7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3YXJuT25jZSAobXNnLCByYW5nZSkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgd2FybiQyKG1zZywgcmFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlRWxlbWVudCAoZWxlbWVudCkge1xuICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuICAgIGlmICghaW5WUHJlICYmICFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgZWxlbWVudCA9IHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICBpZiAoIXN0YWNrLmxlbmd0aCAmJiBlbGVtZW50ICE9PSByb290KSB7XG4gICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXG4gICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiLFxuICAgICAgICAgIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbGVtZW50LnNsb3RTY29wZSkge1xuICAgICAgICAgIC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgLy8ga2VlcCBpdCBpbiB0aGUgY2hpbGRyZW4gbGlzdCBzbyB0aGF0IHYtZWxzZSgtaWYpIGNvbmRpdGlvbnMgY2FuXG4gICAgICAgICAgLy8gZmluZCBpdCBhcyB0aGUgcHJldiBub2RlLlxuICAgICAgICAgIHZhciBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIidcbiAgICAgICAgICA7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaW5hbCBjaGlsZHJlbiBjbGVhbnVwXG4gICAgLy8gZmlsdGVyIG91dCBzY29wZWQgc2xvdHNcbiAgICBlbGVtZW50LmNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuICEoYykuc2xvdFNjb3BlOyB9KTtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlIGFnYWluXG4gICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XG5cbiAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvc3RUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaW1FbmRpbmdXaGl0ZXNwYWNlIChlbCkge1xuICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGVcbiAgICBpZiAoIWluUHJlKSB7XG4gICAgICB2YXIgbGFzdE5vZGU7XG4gICAgICB3aGlsZSAoXG4gICAgICAgIChsYXN0Tm9kZSA9IGVsLmNoaWxkcmVuW2VsLmNoaWxkcmVuLmxlbmd0aCAtIDFdKSAmJlxuICAgICAgICBsYXN0Tm9kZS50eXBlID09PSAzICYmXG4gICAgICAgIGxhc3ROb2RlLnRleHQgPT09ICcgJ1xuICAgICAgKSB7XG4gICAgICAgIGVsLmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLicsXG4gICAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgb3V0cHV0U291cmNlUmFuZ2U6IG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSwgc3RhcnQkMSwgZW5kKSB7XG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGVsZW1lbnQuc3RhcnQgPSBzdGFydCQxO1xuICAgICAgICAgIGVsZW1lbnQuZW5kID0gZW5kO1xuICAgICAgICAgIGVsZW1lbnQucmF3QXR0cnNNYXAgPSBlbGVtZW50LmF0dHJzTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKGN1bXVsYXRlZCwgYXR0cikge1xuICAgICAgICAgICAgY3VtdWxhdGVkW2F0dHIubmFtZV0gPSBhdHRyO1xuICAgICAgICAgICAgcmV0dXJuIGN1bXVsYXRlZFxuICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgaWYgKGludmFsaWRBdHRyaWJ1dGVSRS50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGR5bmFtaWMgYXJndW1lbnQgZXhwcmVzc2lvbjogYXR0cmlidXRlIG5hbWVzIGNhbm5vdCBjb250YWluIFwiICtcbiAgICAgICAgICAgICAgXCJzcGFjZXMsIHF1b3RlcywgPCwgPiwgLyBvciA9LlwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGF0dHIuc3RhcnQgKyBhdHRyLm5hbWUuaW5kZXhPZihcIltcIiksXG4gICAgICAgICAgICAgICAgZW5kOiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmxlbmd0aFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAgICdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJyxcbiAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKCFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gZW5kICh0YWcsIHN0YXJ0LCBlbmQkMSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgIGVsZW1lbnQuZW5kID0gZW5kJDE7XG4gICAgICB9XG4gICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LicsXG4gICAgICAgICAgICAgIHsgc3RhcnQ6IHN0YXJ0IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpLFxuICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgaWYgKGluUHJlIHx8IHRleHQudHJpbSgpKSB7XG4gICAgICAgIHRleHQgPSBpc1RleHRUYWcoY3VycmVudFBhcmVudCkgPyB0ZXh0IDogZGVjb2RlSFRNTENhY2hlZCh0ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAvLyByZW1vdmUgdGhlIHdoaXRlc3BhY2Utb25seSBub2RlIHJpZ2h0IGFmdGVyIGFuIG9wZW5pbmcgdGFnXG4gICAgICAgIHRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAod2hpdGVzcGFjZU9wdGlvbikge1xuICAgICAgICBpZiAod2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xuICAgICAgICAgIC8vIGluIGNvbmRlbnNlIG1vZGUsIHJlbW92ZSB0aGUgd2hpdGVzcGFjZSBub2RlIGlmIGl0IGNvbnRhaW5zXG4gICAgICAgICAgLy8gbGluZSBicmVhaywgb3RoZXJ3aXNlIGNvbmRlbnNlIHRvIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgICAgdGV4dCA9IGxpbmVCcmVha1JFLnRlc3QodGV4dCkgPyAnJyA6ICcgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gJyAnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gcHJlc2VydmVXaGl0ZXNwYWNlID8gJyAnIDogJyc7XG4gICAgICB9XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICBpZiAoIWluUHJlICYmIHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAvLyBjb25kZW5zZSBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlcyBpbnRvIHNpbmdsZSBzcGFjZVxuICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2Uod2hpdGVzcGFjZVJFJDEsICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKHJlcyA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiByZXMuZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHRva2VuczogcmVzLnRva2VucyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIGNoaWxkID0ge1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAvLyBhZGRpbmcgYW55dGhpbmcgYXMgYSBzaWJsaW5nIHRvIHRoZSByb290IG5vZGUgaXMgZm9yYmlkZGVuXG4gICAgICAvLyBjb21tZW50cyBzaG91bGQgc3RpbGwgYmUgYWxsb3dlZCwgYnV0IGlnbm9yZWRcbiAgICAgIGlmIChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHtcbiAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgaXNDb21tZW50OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIGlmIChsZW4pIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBsaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShsaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICAgIGlmIChsaXN0W2ldLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBsaXN0W2ldLnN0YXJ0O1xuICAgICAgICBhdHRyc1tpXS5lbmQgPSBsaXN0W2ldLmVuZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKFxuICBlbGVtZW50LFxuICBvcHRpb25zXG4pIHtcbiAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgZWxlbWVudC5wbGFpbiA9IChcbiAgICAhZWxlbWVudC5rZXkgJiZcbiAgICAhZWxlbWVudC5zY29wZWRTbG90cyAmJlxuICAgICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGhcbiAgKTtcblxuICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdENvbnRlbnQoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90T3V0bGV0KGVsZW1lbnQpO1xuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbGVtZW50ID0gdHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICB9XG4gIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnRcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIsXG4gICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGVsLmZvcikge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBlbC5pdGVyYXRvcjIgfHwgZWwuaXRlcmF0b3IxO1xuICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgICBpZiAoaXRlcmF0b3IgJiYgaXRlcmF0b3IgPT09IGV4cCAmJiBwYXJlbnQgJiYgcGFyZW50LnRhZyA9PT0gJ3RyYW5zaXRpb24tZ3JvdXAnKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgXCJEbyBub3QgdXNlIHYtZm9yIGluZGV4IGFzIGtleSBvbiA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4sIFwiICtcbiAgICAgICAgICAgIFwidGhpcyBpcyB0aGUgc2FtZSBhcyBub3QgdXNpbmcga2V5cy5cIixcbiAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksXG4gICAgICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICBpZiAocmVmKSB7XG4gICAgZWwucmVmID0gcmVmO1xuICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgdmFyIGV4cDtcbiAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VGb3IoZXhwKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICBleHRlbmQoZWwsIHJlcyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbmZ1bmN0aW9uIHBhcnNlRm9yIChleHApIHtcbiAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gIGlmICghaW5NYXRjaCkgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHJlcy5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgIHJlcy5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xuICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcztcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XG4gIGlmIChleHApIHtcbiAgICBlbC5pZiA9IGV4cDtcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgZXhwOiBleHAsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgIGlmIChlbHNlaWYpIHtcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQyKFxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIixcbiAgICAgIGVsLnJhd0F0dHJzTWFwW2VsLmVsc2VpZiA/ICd2LWVsc2UtaWYnIDogJ3YtZWxzZSddXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiLFxuICAgICAgICAgIGNoaWxkcmVuW2ldXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBoYW5kbGUgY29udGVudCBiZWluZyBwYXNzZWQgdG8gYSBjb21wb25lbnQgYXMgc2xvdCxcbi8vIGUuZy4gPHRlbXBsYXRlIHNsb3Q9XCJ4eHhcIj4sIDxkaXYgc2xvdC1zY29wZT1cInh4eFwiPlxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RDb250ZW50IChlbCkge1xuICB2YXIgc2xvdFNjb3BlO1xuICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdFNjb3BlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwidGhlIFxcXCJzY29wZVxcXCIgYXR0cmlidXRlIGZvciBzY29wZWQgc2xvdHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYW5kIFwiICtcbiAgICAgICAgXCJyZXBsYWNlZCBieSBcXFwic2xvdC1zY29wZVxcXCIgc2luY2UgMi41LiBUaGUgbmV3IFxcXCJzbG90LXNjb3BlXFxcIiBhdHRyaWJ1dGUgXCIgK1xuICAgICAgICBcImNhbiBhbHNvIGJlIHVzZWQgb24gcGxhaW4gZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gPHRlbXBsYXRlPiB0byBcIiArXG4gICAgICAgIFwiZGVub3RlIHNjb3BlZCBzbG90cy5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Njb3BlJ10sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xuICB9IGVsc2UgaWYgKChzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpKSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiQW1iaWd1b3VzIGNvbWJpbmVkIHVzYWdlIG9mIHNsb3Qtc2NvcGUgYW5kIHYtZm9yIG9uIDxcIiArIChlbC50YWcpICsgXCI+IFwiICtcbiAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xuICAgICAgICBcInNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICB9XG5cbiAgLy8gc2xvdD1cInh4eFwiXG4gIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gISEoZWwuYXR0cnNNYXBbJzpzbG90J10gfHwgZWwuYXR0cnNNYXBbJ3YtYmluZDpzbG90J10pO1xuICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcbiAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxuICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgYWRkQXR0cihlbCwgJ3Nsb3QnLCBzbG90VGFyZ2V0LCBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gMi42IHYtc2xvdCBzeW50YXhcbiAge1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIC8vIHYtc2xvdCBvbiA8dGVtcGxhdGU+XG4gICAgICB2YXIgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmIChlbC5zbG90VGFyZ2V0IHx8IGVsLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgbWl4ZWQgdXNhZ2Ugb2YgZGlmZmVyZW50IHNsb3Qgc3ludGF4ZXMuXCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwucGFyZW50ICYmICFtYXliZUNvbXBvbmVudChlbC5wYXJlbnQpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiPHRlbXBsYXRlIHYtc2xvdD4gY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSByb290IGxldmVsIGluc2lkZSBcIiArXG4gICAgICAgICAgICAgIFwidGhlIHJlY2VpdmluZyBjb21wb25lbnRcIixcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZWYgPSBnZXRTbG90TmFtZShzbG90QmluZGluZyk7XG4gICAgICAgIHZhciBuYW1lID0gcmVmLm5hbWU7XG4gICAgICAgIHZhciBkeW5hbWljID0gcmVmLmR5bmFtaWM7XG4gICAgICAgIGVsLnNsb3RUYXJnZXQgPSBuYW1lO1xuICAgICAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWM7XG4gICAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47IC8vIGZvcmNlIGl0IGludG8gYSBzY29wZWQgc2xvdCBmb3IgcGVyZlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB2LXNsb3Qgb24gY29tcG9uZW50LCBkZW5vdGVzIGRlZmF1bHQgc2xvdFxuICAgICAgdmFyIHNsb3RCaW5kaW5nJDEgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgIGlmIChzbG90QmluZGluZyQxKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFtYXliZUNvbXBvbmVudChlbCkpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJ2LXNsb3QgY2FuIG9ubHkgYmUgdXNlZCBvbiBjb21wb25lbnRzIG9yIDx0ZW1wbGF0ZT4uXCIsXG4gICAgICAgICAgICAgIHNsb3RCaW5kaW5nJDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5zbG90U2NvcGUgfHwgZWwuc2xvdFRhcmdldCkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgbWl4ZWQgdXNhZ2Ugb2YgZGlmZmVyZW50IHNsb3Qgc3ludGF4ZXMuXCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJUbyBhdm9pZCBzY29wZSBhbWJpZ3VpdHksIHRoZSBkZWZhdWx0IHNsb3Qgc2hvdWxkIGFsc28gdXNlIFwiICtcbiAgICAgICAgICAgICAgXCI8dGVtcGxhdGU+IHN5bnRheCB3aGVuIHRoZXJlIGFyZSBvdGhlciBuYW1lZCBzbG90cy5cIixcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmckMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHRoZSBjb21wb25lbnQncyBjaGlsZHJlbiB0byBpdHMgZGVmYXVsdCBzbG90XG4gICAgICAgIHZhciBzbG90cyA9IGVsLnNjb3BlZFNsb3RzIHx8IChlbC5zY29wZWRTbG90cyA9IHt9KTtcbiAgICAgICAgdmFyIHJlZiQxID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmckMSk7XG4gICAgICAgIHZhciBuYW1lJDEgPSByZWYkMS5uYW1lO1xuICAgICAgICB2YXIgZHluYW1pYyQxID0gcmVmJDEuZHluYW1pYztcbiAgICAgICAgdmFyIHNsb3RDb250YWluZXIgPSBzbG90c1tuYW1lJDFdID0gY3JlYXRlQVNURWxlbWVudCgndGVtcGxhdGUnLCBbXSwgZWwpO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXQgPSBuYW1lJDE7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljJDE7XG4gICAgICAgIHNsb3RDb250YWluZXIuY2hpbGRyZW4gPSBlbC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBpZiAoIWMuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICBjLnBhcmVudCA9IHNsb3RDb250YWluZXI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmckMS52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuO1xuICAgICAgICAvLyByZW1vdmUgY2hpbGRyZW4gYXMgdGhleSBhcmUgcmV0dXJuZWQgZnJvbSBzY29wZWRTbG90cyBub3dcbiAgICAgICAgZWwuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgLy8gbWFyayBlbCBub24tcGxhaW4gc28gZGF0YSBnZXRzIGdlbmVyYXRlZFxuICAgICAgICBlbC5wbGFpbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTbG90TmFtZSAoYmluZGluZykge1xuICB2YXIgbmFtZSA9IGJpbmRpbmcubmFtZS5yZXBsYWNlKHNsb3RSRSwgJycpO1xuICBpZiAoIW5hbWUpIHtcbiAgICBpZiAoYmluZGluZy5uYW1lWzBdICE9PSAnIycpIHtcbiAgICAgIG5hbWUgPSAnZGVmYXVsdCc7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwidi1zbG90IHNob3J0aGFuZCBzeW50YXggcmVxdWlyZXMgYSBzbG90IG5hbWUuXCIsXG4gICAgICAgIGJpbmRpbmdcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkeW5hbWljQXJnUkUudGVzdChuYW1lKVxuICAgIC8vIGR5bmFtaWMgW25hbWVdXG4gICAgPyB7IG5hbWU6IG5hbWUuc2xpY2UoMSwgLTEpLCBkeW5hbWljOiB0cnVlIH1cbiAgICAvLyBzdGF0aWMgbmFtZVxuICAgIDogeyBuYW1lOiAoXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIpLCBkeW5hbWljOiBmYWxzZSB9XG59XG5cbi8vIGhhbmRsZSA8c2xvdC8+IG91dGxldHNcbmZ1bmN0aW9uIHByb2Nlc3NTbG90T3V0bGV0IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmtleSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIixcbiAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgdmFyIGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgc3luY0dlbiwgaXNEeW5hbWljO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAvLyBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUucmVwbGFjZShkaXJSRSwgJycpKTtcbiAgICAgIC8vIHN1cHBvcnQgLmZvbyBzaG9ydGhhbmQgc3ludGF4IGZvciB0aGUgLnByb3AgbW9kaWZpZXJcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgaXNEeW5hbWljID0gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSk7XG4gICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICB2YWx1ZS50cmltKCkubGVuZ3RoID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIChcIlRoZSB2YWx1ZSBmb3IgYSB2LWJpbmQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgZW1wdHkuIEZvdW5kIGluIFxcXCJ2LWJpbmQ6XCIgKyBuYW1lICsgXCJcXFwiXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgeyBuYW1lID0gJ2lubmVySFRNTCc7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xuICAgICAgICAgICAgc3luY0dlbiA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBcIiRldmVudFwiKTtcbiAgICAgICAgICAgIGlmICghaXNEeW5hbWljKSB7XG4gICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGNhbWVsaXplKG5hbWUpKSksXG4gICAgICAgICAgICAgICAgc3luY0dlbixcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHdhcm4kMixcbiAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChoeXBoZW5hdGUobmFtZSkgIT09IGNhbWVsaXplKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGh5cGhlbmF0ZShuYW1lKSkpLFxuICAgICAgICAgICAgICAgICAgc3luY0dlbixcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIHdhcm4kMixcbiAgICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBoYW5kbGVyIHcvIGR5bmFtaWMgZXZlbnQgbmFtZVxuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIChcIlxcXCJ1cGRhdGU6XFxcIisoXCIgKyBuYW1lICsgXCIpXCIpLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgbGlzdFtpXSxcbiAgICAgICAgICAgICAgICB0cnVlIC8vIGR5bmFtaWNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnByb3ApIHx8IChcbiAgICAgICAgICAhZWwuY29tcG9uZW50ICYmIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKVxuICAgICAgICApKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuJDIsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICBpc0R5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgICBpZiAoZHluYW1pY0FyZ1JFLnRlc3QoYXJnKSkge1xuICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgIGlzRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgaXNEeW5hbWljLCBtb2RpZmllcnMsIGxpc3RbaV0pO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciByZXMgPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LicsXG4gICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpLCBsaXN0W2ldKTtcbiAgICAgIC8vICM2ODg3IGZpcmVmb3ggZG9lc24ndCB1cGRhdGUgbXV0ZWQgc3RhdGUgaWYgc2V0IHZpYSBhdHRyaWJ1dGVcbiAgICAgIC8vIGV2ZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgZWxlbWVudCBjcmVhdGlvblxuICAgICAgaWYgKCFlbC5jb21wb25lbnQgJiZcbiAgICAgICAgICBuYW1lID09PSAnbXV0ZWQnICYmXG4gICAgICAgICAgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgIGFkZFByb3AoZWwsIG5hbWUsICd0cnVlJywgbGlzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gIHZhciBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XG4gIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBtYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZVxuICAgICkge1xuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSwgYXR0cnNbaV0pO1xuICAgIH1cbiAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbi8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxuZnVuY3Rpb24gaXNUZXh0VGFnIChlbCkge1xuICByZXR1cm4gZWwudGFnID09PSAnc2NyaXB0JyB8fCBlbC50YWcgPT09ICdzdHlsZSdcbn1cblxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG4gIHJldHVybiAoXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgKSlcbiAgKVxufVxuXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgdmFyIF9lbCA9IGVsO1xuICB3aGlsZSAoX2VsKSB7XG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcbiAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXG4gICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHByZVRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcbiAgICB2YXIgbWFwID0gZWwuYXR0cnNNYXA7XG4gICAgaWYgKCFtYXBbJ3YtbW9kZWwnXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIHR5cGVCaW5kaW5nO1xuICAgIGlmIChtYXBbJzp0eXBlJ10gfHwgbWFwWyd2LWJpbmQ6dHlwZSddKSB7XG4gICAgICB0eXBlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHlwZScpO1xuICAgIH1cbiAgICBpZiAoIW1hcC50eXBlICYmICF0eXBlQmluZGluZyAmJiBtYXBbJ3YtYmluZCddKSB7XG4gICAgICB0eXBlQmluZGluZyA9IFwiKFwiICsgKG1hcFsndi1iaW5kJ10pICsgXCIpLnR5cGVcIjtcbiAgICB9XG5cbiAgICBpZiAodHlwZUJpbmRpbmcpIHtcbiAgICAgIHZhciBpZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJywgdHJ1ZSk7XG4gICAgICB2YXIgaWZDb25kaXRpb25FeHRyYSA9IGlmQ29uZGl0aW9uID8gKFwiJiYoXCIgKyBpZkNvbmRpdGlvbiArIFwiKVwiKSA6IFwiXCI7XG4gICAgICB2YXIgaGFzRWxzZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnLCB0cnVlKSAhPSBudWxsO1xuICAgICAgdmFyIGVsc2VJZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnLCB0cnVlKTtcbiAgICAgIC8vIDEuIGNoZWNrYm94XG4gICAgICB2YXIgYnJhbmNoMCA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAvLyBwcm9jZXNzIGZvciBvbiB0aGUgbWFpbiBub2RlXG4gICAgICBwcm9jZXNzRm9yKGJyYW5jaDApO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gwLCAndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMCwgb3B0aW9ucyk7XG4gICAgICBicmFuY2gwLnByb2Nlc3NlZCA9IHRydWU7IC8vIHByZXZlbnQgaXQgZnJvbSBkb3VibGUtcHJvY2Vzc2VkXG4gICAgICBicmFuY2gwLmlmID0gXCIoXCIgKyB0eXBlQmluZGluZyArIFwiKT09PSdjaGVja2JveCdcIiArIGlmQ29uZGl0aW9uRXh0cmE7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogYnJhbmNoMC5pZixcbiAgICAgICAgYmxvY2s6IGJyYW5jaDBcbiAgICAgIH0pO1xuICAgICAgLy8gMi4gYWRkIHJhZGlvIGVsc2UtaWYgY29uZGl0aW9uXG4gICAgICB2YXIgYnJhbmNoMSA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDEsICd2LWZvcicsIHRydWUpO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gxLCAndHlwZScsICdyYWRpbycpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMSwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogXCIoXCIgKyB0eXBlQmluZGluZyArIFwiKT09PSdyYWRpbydcIiArIGlmQ29uZGl0aW9uRXh0cmEsXG4gICAgICAgIGJsb2NrOiBicmFuY2gxXG4gICAgICB9KTtcbiAgICAgIC8vIDMuIG90aGVyXG4gICAgICB2YXIgYnJhbmNoMiA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDIsICd2LWZvcicsIHRydWUpO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gyLCAnOnR5cGUnLCB0eXBlQmluZGluZyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gyLCBvcHRpb25zKTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBpZkNvbmRpdGlvbixcbiAgICAgICAgYmxvY2s6IGJyYW5jaDJcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGFzRWxzZSkge1xuICAgICAgICBicmFuY2gwLmVsc2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbHNlSWZDb25kaXRpb24pIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlaWYgPSBlbHNlSWZDb25kaXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBicmFuY2gwXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lQVNURWxlbWVudCAoZWwpIHtcbiAgcmV0dXJuIGNyZWF0ZUFTVEVsZW1lbnQoZWwudGFnLCBlbC5hdHRyc0xpc3Quc2xpY2UoKSwgZWwucGFyZW50KVxufVxuXG52YXIgbW9kZWwkMSA9IHtcbiAgcHJlVHJhbnNmb3JtTm9kZTogcHJlVHJhbnNmb3JtTm9kZVxufTtcblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMSxcbiAgbW9kZWwkMVxuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIiksIGRpcik7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpLCBkaXIpO1xuICB9XG59XG5cbnZhciBkaXJlY3RpdmVzJDEgPSB7XG4gIG1vZGVsOiBtb2RlbCxcbiAgdGV4dDogdGV4dCxcbiAgaHRtbDogaHRtbFxufTtcblxuLyogICovXG5cbnZhciBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUHJlVGFnOiBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMsc3RhcnQsZW5kLHJhd0F0dHJzTWFwJyArXG4gICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG4gIClcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyQxIChub2RlKSB7XG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgIGlmIChcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG4gICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICB2YXIgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrO1xuICAgICAgICBtYXJrU3RhdGljJDEoYmxvY2spO1xuICAgICAgICBpZiAoIWJsb2NrLnN0YXRpYykge1xuICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzIChub2RlLCBpc0luRm9yKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG4gICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICB9XG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcbiAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxuICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcbiAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICApKSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2ssIGlzSW5Gb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiAhIShub2RlLnByZSB8fCAoXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG4gIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobm9kZS5mb3IpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIGZuRXhwUkUgPSAvXihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvbig/OlxccytbXFx3JF0rKT9cXHMqXFwoLztcbnZhciBmbkludm9rZVJFID0gL1xcKFteKV0qP1xcKTsqJC87XG52YXIgc2ltcGxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWydbXiddKj8nXXxcXFtcIlteXCJdKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSokLztcblxuLy8gS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcbnZhciBrZXlOYW1lcyA9IHtcbiAgLy8gIzc4ODA6IElFMTEgYW5kIEVkZ2UgdXNlIGBFc2NgIGZvciBFc2NhcGUga2V5IG5hbWUuXG4gIGVzYzogWydFc2MnLCAnRXNjYXBlJ10sXG4gIHRhYjogJ1RhYicsXG4gIGVudGVyOiAnRW50ZXInLFxuICAvLyAjOTExMjogSUUxMSB1c2VzIGBTcGFjZWJhcmAgZm9yIFNwYWNlIGtleSBuYW1lLlxuICBzcGFjZTogWycgJywgJ1NwYWNlYmFyJ10sXG4gIC8vICM3ODA2OiBJRTExIHVzZXMga2V5IG5hbWVzIHdpdGhvdXQgYEFycm93YCBwcmVmaXggZm9yIGFycm93IGtleXMuXG4gIHVwOiBbJ1VwJywgJ0Fycm93VXAnXSxcbiAgbGVmdDogWydMZWZ0JywgJ0Fycm93TGVmdCddLFxuICByaWdodDogWydSaWdodCcsICdBcnJvd1JpZ2h0J10sXG4gIGRvd246IFsnRG93bicsICdBcnJvd0Rvd24nXSxcbiAgLy8gIzkxMTI6IElFMTEgdXNlcyBgRGVsYCBmb3IgRGVsZXRlIGtleSBuYW1lLlxuICAnZGVsZXRlJzogWydCYWNrc3BhY2UnLCAnRGVsZXRlJywgJ0RlbCddXG59O1xuXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxudmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIik7IH07XG5cbnZhciBtb2RpZmllckNvZGUgPSB7XG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG4gIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxuICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxuICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoXG4gIGV2ZW50cyxcbiAgaXNOYXRpdmVcbikge1xuICB2YXIgcHJlZml4ID0gaXNOYXRpdmUgPyAnbmF0aXZlT246JyA6ICdvbjonO1xuICB2YXIgc3RhdGljSGFuZGxlcnMgPSBcIlwiO1xuICB2YXIgZHluYW1pY0hhbmRsZXJzID0gXCJcIjtcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICB2YXIgaGFuZGxlckNvZGUgPSBnZW5IYW5kbGVyKGV2ZW50c1tuYW1lXSk7XG4gICAgaWYgKGV2ZW50c1tuYW1lXSAmJiBldmVudHNbbmFtZV0uZHluYW1pYykge1xuICAgICAgZHluYW1pY0hhbmRsZXJzICs9IG5hbWUgKyBcIixcIiArIGhhbmRsZXJDb2RlICsgXCIsXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRpY0hhbmRsZXJzICs9IFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIjpcIiArIGhhbmRsZXJDb2RlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIHN0YXRpY0hhbmRsZXJzID0gXCJ7XCIgKyAoc3RhdGljSGFuZGxlcnMuc2xpY2UoMCwgLTEpKSArIFwifVwiO1xuICBpZiAoZHluYW1pY0hhbmRsZXJzKSB7XG4gICAgcmV0dXJuIHByZWZpeCArIFwiX2QoXCIgKyBzdGF0aWNIYW5kbGVycyArIFwiLFtcIiArIChkeW5hbWljSGFuZGxlcnMuc2xpY2UoMCwgLTEpKSArIFwiXSlcIlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmVmaXggKyBzdGF0aWNIYW5kbGVyc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIoaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgfVxuXG4gIHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICB2YXIgaXNGdW5jdGlvbkludm9jYXRpb24gPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlLnJlcGxhY2UoZm5JbnZva2VSRSwgJycpKTtcblxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgaWYgKGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIGhhbmRsZXIudmFsdWVcbiAgICB9XG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaXNGdW5jdGlvbkludm9jYXRpb24gPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkpIDogaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSAoaGFuZGxlci5tb2RpZmllcnMpO1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gZ2VuR3VhcmQoXG4gICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAhbW9kaWZpZXJzW2tleU1vZGlmaWVyXTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAoXCIkZXZlbnQuXCIgKyBrZXlNb2RpZmllciArIFwiS2V5XCIpOyB9KVxuICAgICAgICAgICAgLmpvaW4oJ3x8JylcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIoJGV2ZW50KVwiKVxuICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICA/IChcInJldHVybiAoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICA6IGlzRnVuY3Rpb25JbnZvY2F0aW9uXG4gICAgICAgICAgPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkpXG4gICAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgY29kZSArIGhhbmRsZXJDb2RlICsgXCJ9XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XG4gIHJldHVybiAoXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBrZXkgZmlsdGVycyBvbmx5IGFwcGx5IHRvIEtleWJvYXJkRXZlbnRzXG4gICAgLy8gIzk0NDE6IGNhbid0IHVzZSAna2V5Q29kZScgaW4gJGV2ZW50IGJlY2F1c2UgQ2hyb21lIGF1dG9maWxsIGZpcmVzIGZha2VcbiAgICAvLyBrZXkgZXZlbnRzIHRoYXQgZG8gbm90IGhhdmUga2V5Q29kZSBwcm9wZXJ0eS4uLlxuICAgIFwiaWYoISRldmVudC50eXBlLmluZGV4T2YoJ2tleScpJiZcIiArXG4gICAgKGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJykpICsgXCIpcmV0dXJuIG51bGw7XCJcbiAgKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIChcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWwpXG4gIH1cbiAgdmFyIGtleUNvZGUgPSBrZXlDb2Rlc1trZXldO1xuICB2YXIga2V5TmFtZSA9IGtleU5hbWVzW2tleV07XG4gIHJldHVybiAoXG4gICAgXCJfaygkZXZlbnQua2V5Q29kZSxcIiArXG4gICAgKEpTT04uc3RyaW5naWZ5KGtleSkpICsgXCIsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShrZXlDb2RlKSkgKyBcIixcIiArXG4gICAgXCIkZXZlbnQua2V5LFwiICtcbiAgICBcIlwiICsgKEpTT04uc3RyaW5naWZ5KGtleU5hbWUpKSArXG4gICAgXCIpXCJcbiAgKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGlyLm1vZGlmaWVycykge1xuICAgIHdhcm4oXCJ2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuXCIpO1xuICB9XG4gIGVsLndyYXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiX2coXCIgKyBjb2RlICsgXCIsXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKTsgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyBcIixcIiArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBvbjogb24sXG4gIGJpbmQ6IGJpbmQkMSxcbiAgY2xvYWs6IG5vb3Bcbn07XG5cbi8qICAqL1xuXG5cblxuXG5cbnZhciBDb2RlZ2VuU3RhdGUgPSBmdW5jdGlvbiBDb2RlZ2VuU3RhdGUgKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIHRoaXMubWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICEhZWwuY29tcG9uZW50IHx8ICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7IH07XG4gIHRoaXMub25jZUlkID0gMDtcbiAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgdGhpcy5wcmUgPSBmYWxzZTtcbn07XG5cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QsIHN0YXRlKSA6ICdfYyhcImRpdlwiKSc7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnBhcmVudCkge1xuICAgIGVsLnByZSA9IGVsLnByZSB8fCBlbC5wYXJlbnQucHJlO1xuICB9XG5cbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIGlmICghZWwucGxhaW4gfHwgKGVsLnByZSAmJiBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkpKSB7XG4gICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIC8vIFNvbWUgZWxlbWVudHMgKHRlbXBsYXRlcykgbmVlZCB0byBiZWhhdmUgZGlmZmVyZW50bHkgaW5zaWRlIG9mIGEgdi1wcmVcbiAgLy8gbm9kZS4gIEFsbCBwcmUgbm9kZXMgYXJlIHN0YXRpYyByb290cywgc28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgbG9jYXRpb24gdG9cbiAgLy8gd3JhcCBhIHN0YXRlIGNoYW5nZSBhbmQgcmVzZXQgaXQgdXBvbiBleGl0aW5nIHRoZSBwcmUgbm9kZS5cbiAgdmFyIG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gIGlmIChlbC5wcmUpIHtcbiAgICBzdGF0ZS5wcmUgPSBlbC5wcmU7XG4gIH1cbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gIHN0YXRlLnByZSA9IG9yaWdpbmFsUHJlU3RhdGU7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0ZS53YXJuKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIFwiLFwiICsga2V5ICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgY29uZGl0aW9ucyxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICA6IGVsLm9uY2VcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0SGVscGVyXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAhZWwua2V5XG4gICkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ10sXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIChhbHRIZWxwZXIgfHwgJ19sJykgKyBcIigoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczpcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCIsXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczpcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCIsXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UpKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUpKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLCBlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkeW5hbWljIGFyZ3VtZW50IHdyYXBcbiAgLy8gdi1iaW5kIHdpdGggZHluYW1pYyBhcmd1bWVudHMgbXVzdCBiZSBhcHBsaWVkIHVzaW5nIHRoZSBzYW1lIHYtYmluZCBvYmplY3RcbiAgLy8gbWVyZ2UgaGVscGVyIHNvIHRoYXQgY2xhc3Mvc3R5bGUvbXVzdFVzZVByb3AgYXR0cnMgYXJlIGhhbmRsZWQgY29ycmVjdGx5LlxuICBpZiAoZWwuZHluYW1pY0F0dHJzKSB7XG4gICAgZGF0YSA9IFwiX2IoXCIgKyBkYXRhICsgXCIsXFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCIgKyAoZ2VuUHJvcHMoZWwuZHluYW1pY0F0dHJzKSkgKyBcIilcIjtcbiAgfVxuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICAvLyB2LW9uIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcIiArIChkaXIuaXNEeW5hbWljQXJnID8gZGlyLmFyZyA6IChcIlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSkpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgICdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nLFxuICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICk7XG4gIH1cbiAgaWYgKGFzdCAmJiBhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBlbCxcbiAgc2xvdHMsXG4gIHN0YXRlXG4pIHtcbiAgLy8gYnkgZGVmYXVsdCBzY29wZWQgc2xvdHMgYXJlIGNvbnNpZGVyZWQgXCJzdGFibGVcIiwgdGhpcyBhbGxvd3MgY2hpbGRcbiAgLy8gY29tcG9uZW50cyB3aXRoIG9ubHkgc2NvcGVkIHNsb3RzIHRvIHNraXAgZm9yY2VkIHVwZGF0ZXMgZnJvbSBwYXJlbnQuXG4gIC8vIGJ1dCBpbiBzb21lIGNhc2VzIHdlIGhhdmUgdG8gYmFpbC1vdXQgb2YgdGhpcyBvcHRpbWl6YXRpb25cbiAgLy8gZm9yIGV4YW1wbGUgaWYgdGhlIHNsb3QgY29udGFpbnMgZHluYW1pYyBuYW1lcywgaGFzIHYtaWYgb3Igdi1mb3Igb24gdGhlbS4uLlxuICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9IGVsLmZvciB8fCBPYmplY3Qua2V5cyhzbG90cykuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHNsb3QgPSBzbG90c1trZXldO1xuICAgIHJldHVybiAoXG4gICAgICBzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8XG4gICAgICBzbG90LmlmIHx8XG4gICAgICBzbG90LmZvciB8fFxuICAgICAgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcbiAgICApXG4gIH0pO1xuXG4gIC8vICM5NTM0OiBpZiBhIGNvbXBvbmVudCB3aXRoIHNjb3BlZCBzbG90cyBpcyBpbnNpZGUgYSBjb25kaXRpb25hbCBicmFuY2gsXG4gIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBzYW1lIGNvbXBvbmVudCB0byBiZSByZXVzZWQgYnV0IHdpdGggZGlmZmVyZW50XG4gIC8vIGNvbXBpbGVkIHNsb3QgY29udGVudC4gVG8gYXZvaWQgdGhhdCwgd2UgZ2VuZXJhdGUgYSB1bmlxdWUga2V5IGJhc2VkIG9uXG4gIC8vIHRoZSBnZW5lcmF0ZWQgY29kZSBvZiBhbGwgdGhlIHNsb3QgY29udGVudHMuXG4gIHZhciBuZWVkc0tleSA9ICEhZWwuaWY7XG5cbiAgLy8gT1Igd2hlbiBpdCBpcyBpbnNpZGUgYW5vdGhlciBzY29wZWQgc2xvdCBvciB2LWZvciAodGhlIHJlYWN0aXZpdHkgbWF5IGJlXG4gIC8vIGRpc2Nvbm5lY3RlZCBkdWUgdG8gdGhlIGludGVybWVkaWF0ZSBzY29wZSB2YXJpYWJsZSlcbiAgLy8gIzk0MzgsICM5NTA2XG4gIC8vIFRPRE86IHRoaXMgY2FuIGJlIGZ1cnRoZXIgb3B0aW1pemVkIGJ5IHByb3Blcmx5IGFuYWx5emluZyBpbi1zY29wZSBiaW5kaW5nc1xuICAvLyBhbmQgc2tpcCBmb3JjZSB1cGRhdGluZyBvbmVzIHRoYXQgZG8gbm90IGFjdHVhbGx5IHVzZSBzY29wZSB2YXJpYWJsZXMuXG4gIGlmICghbmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKFxuICAgICAgICAocGFyZW50LnNsb3RTY29wZSAmJiBwYXJlbnQuc2xvdFNjb3BlICE9PSBlbXB0eVNsb3RTY29wZVRva2VuKSB8fFxuICAgICAgICBwYXJlbnQuZm9yXG4gICAgICApIHtcbiAgICAgICAgbmVlZHNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAocGFyZW50LmlmKSB7XG4gICAgICAgIG5lZWRzS2V5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGdlbmVyYXRlZFNsb3RzID0gT2JqZWN0LmtleXMoc2xvdHMpXG4gICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KHNsb3RzW2tleV0sIHN0YXRlKTsgfSlcbiAgICAuam9pbignLCcpO1xuXG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyBnZW5lcmF0ZWRTbG90cyArIFwiXVwiICsgKG5lZWRzRm9yY2VVcGRhdGUgPyBcIixudWxsLHRydWVcIiA6IFwiXCIpICsgKCFuZWVkc0ZvcmNlVXBkYXRlICYmIG5lZWRzS2V5ID8gKFwiLG51bGwsZmFsc2UsXCIgKyAoaGFzaChnZW5lcmF0ZWRTbG90cykpKSA6IFwiXCIpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gIHZhciBoYXNoID0gNTM4MTtcbiAgdmFyIGkgPSBzdHIubGVuZ3RoO1xuICB3aGlsZShpKSB7XG4gICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuICByZXR1cm4gaGFzaCA+Pj4gMFxufVxuXG5mdW5jdGlvbiBjb250YWluc1Nsb3RDaGlsZCAoZWwpIHtcbiAgaWYgKGVsLnR5cGUgPT09IDEpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBlbC5jaGlsZHJlbi5zb21lKGNvbnRhaW5zU2xvdENoaWxkKVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGlzTGVnYWN5U3ludGF4ID0gZWwuYXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCAmJiAhaXNMZWdhY3lTeW50YXgpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBcIm51bGxcIilcbiAgfVxuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdClcbiAgfVxuICB2YXIgc2xvdFNjb3BlID0gZWwuc2xvdFNjb3BlID09PSBlbXB0eVNsb3RTY29wZVRva2VuXG4gICAgPyBcIlwiXG4gICAgOiBTdHJpbmcoZWwuc2xvdFNjb3BlKTtcbiAgdmFyIGZuID0gXCJmdW5jdGlvbihcIiArIHNsb3RTY29wZSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGVsLmlmICYmIGlzTGVnYWN5U3ludGF4XG4gICAgICAgID8gKFwiKFwiICsgKGVsLmlmKSArIFwiKT9cIiArIChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnKSArIFwiOnVuZGVmaW5lZFwiKVxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiO1xuICAvLyByZXZlcnNlIHByb3h5IHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gIHZhciByZXZlcnNlUHJveHkgPSBzbG90U2NvcGUgPyBcIlwiIDogXCIscHJveHk6dHJ1ZVwiO1xuICByZXR1cm4gKFwie2tleTpcIiArIChlbC5zbG90VGFyZ2V0IHx8IFwiXFxcImRlZmF1bHRcXFwiXCIpICsgXCIsZm46XCIgKyBmbiArIHJldmVyc2VQcm94eSArIFwifVwiKVxufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgY2hlY2tTa2lwLFxuICBhbHRHZW5FbGVtZW50LFxuICBhbHRHZW5Ob2RlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsJDEuZm9yICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWwkMSkgPyBcIiwxXCIgOiBcIiwwXCJcbiAgICAgICAgOiBcIlwiO1xuICAgICAgcmV0dXJuIChcIlwiICsgKChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKSkgKyBub3JtYWxpemF0aW9uVHlwZSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlJDEgPSBjaGVja1NraXBcbiAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxuICAgICAgOiAwO1xuICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGdlbihjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSQxID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUkMSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgY2hpbGRyZW4sXG4gIG1heWJlQ29tcG9uZW50XG4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gIHJldHVybiAoXCJfZShcIiArIChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCwgc3RhdGUpIHtcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgfHwgZWwuZHluYW1pY0F0dHJzXG4gICAgPyBnZW5Qcm9wcygoZWwuYXR0cnMgfHwgW10pLmNvbmNhdChlbC5keW5hbWljQXR0cnMgfHwgW10pLm1hcChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gKHtcbiAgICAgICAgLy8gc2xvdCBwcm9wcyBhcmUgY2FtZWxpemVkXG4gICAgICAgIG5hbWU6IGNhbWVsaXplKGF0dHIubmFtZSksXG4gICAgICAgIHZhbHVlOiBhdHRyLnZhbHVlLFxuICAgICAgICBkeW5hbWljOiBhdHRyLmR5bmFtaWNcbiAgICAgIH0pOyB9KSlcbiAgICA6IG51bGw7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gIGNvbXBvbmVudE5hbWUsXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciBzdGF0aWNQcm9wcyA9IFwiXCI7XG4gIHZhciBkeW5hbWljUHJvcHMgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICB2YXIgdmFsdWUgPSB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSk7XG4gICAgaWYgKHByb3AuZHluYW1pYykge1xuICAgICAgZHluYW1pY1Byb3BzICs9IChwcm9wLm5hbWUpICsgXCIsXCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNQcm9wcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgdmFsdWUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgc3RhdGljUHJvcHMgPSBcIntcIiArIChzdGF0aWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXCJ9XCI7XG4gIGlmIChkeW5hbWljUHJvcHMpIHtcbiAgICByZXR1cm4gKFwiX2QoXCIgKyBzdGF0aWNQcm9wcyArIFwiLFtcIiArIChkeW5hbWljUHJvcHMuc2xpY2UoMCwgLTEpKSArIFwiXSlcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGljUHJvcHNcbiAgfVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbnZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCwgd2Fybikge1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgd2Fybik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCB3YXJuKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByYW5nZSA9IG5vZGUucmF3QXR0cnNNYXBbbmFtZV07XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAndi1zbG90JyB8fCBuYW1lWzBdID09PSAnIycpIHtcbiAgICAgICAgICAgIGNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIHdhcm4pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIHdhcm4sIG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgdmFyIHN0cmlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICB2YXIga2V5d29yZE1hdGNoID0gc3RyaXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RyaXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcbiAgICB3YXJuKFxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICByYW5nZVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChcbiAgaWRlbnQsXG4gIHR5cGUsXG4gIHRleHQsXG4gIHdhcm4sXG4gIHJhbmdlXG4pIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZ1bmN0aW9uKChcInZhciBcIiArIGlkZW50ICsgXCI9X1wiKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybigoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSksIHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCJcXG4gIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAoZS5tZXNzYWdlKSArIFwiIGluXFxuXFxuXCIgK1xuICAgICAgICBcIiAgICBcIiArIGV4cCArIFwiXFxuXFxuXCIgK1xuICAgICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCIsXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0Z1bmN0aW9uUGFyYW1ldGVyRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbihleHAsICcnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHdhcm4oXG4gICAgICBcImludmFsaWQgZnVuY3Rpb24gcGFyYW1ldGVyIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgIFwiICAgIFwiICsgZXhwICsgXCJcXG5cXG5cIiArXG4gICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCIsXG4gICAgICByYW5nZVxuICAgICk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciByYW5nZSA9IDI7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lIChcbiAgc291cmNlLFxuICBzdGFydCxcbiAgZW5kXG4pIHtcbiAgaWYgKCBzdGFydCA9PT0gdm9pZCAwICkgc3RhcnQgPSAwO1xuICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gc291cmNlLmxlbmd0aDtcblxuICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAodmFyIGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgcmVzLnB1c2goKFwiXCIgKyAoaiArIDEpICsgKHJlcGVhdCQxKFwiIFwiLCAzIC0gU3RyaW5nKGogKyAxKS5sZW5ndGgpKSArIFwifCAgXCIgKyAobGluZXNbal0pKSk7XG4gICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXG4gICAgICAgICAgdmFyIHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydDtcbiAgICAgICAgICByZXMucHVzaChcIiAgIHwgIFwiICsgcmVwZWF0JDEoXCIgXCIsIHBhZCkgKyByZXBlYXQkMShcIl5cIiwgbGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGgkMSA9IE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQkMShcIl5cIiwgbGVuZ3RoJDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiByZXMuam9pbignXFxuJylcbn1cblxuZnVuY3Rpb24gcmVwZWF0JDEgKHN0ciwgbikge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmIChuID4gMCkge1xuICAgIHdoaWxlICh0cnVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGlmIChuICYgMSkgeyByZXN1bHQgKz0gc3RyOyB9XG4gICAgICBuID4+Pj0gMTtcbiAgICAgIGlmIChuIDw9IDApIHsgYnJlYWsgfVxuICAgICAgc3RyICs9IHN0cjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIChjb21waWxlKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICB2YXIgd2FybiQkMSA9IG9wdGlvbnMud2FybiB8fCB3YXJuO1xuICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyAoZS5tc2cpICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlLnN0YXJ0LCBlLmVuZCksXG4gICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aXAoZS5tc2csIHZtKTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybiQkMShcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xuICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBjb21waWxlIChcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIHRpcHMgPSBbXTtcblxuICAgICAgdmFyIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgdmFyIGxlYWRpbmdTcGFjZUxlbmd0aCA9IHRlbXBsYXRlLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcblxuICAgICAgICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHsgbXNnOiBtc2cgfTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuc3RhcnQgPSByYW5nZS5zdGFydCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVuZCA9IHJhbmdlLmVuZCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2goZGF0YSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyB8fCBudWxsKSxcbiAgICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSB3YXJuO1xuXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZS50cmltKCksIGZpbmFsT3B0aW9ucyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0LCB3YXJuKTtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgcmV0dXJuIGNvbXBpbGVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGBjcmVhdGVDb21waWxlckNyZWF0b3JgIGFsbG93cyBjcmVhdGluZyBjb21waWxlcnMgdGhhdCB1c2UgYWx0ZXJuYXRpdmVcbi8vIHBhcnNlci9vcHRpbWl6ZXIvY29kZWdlbiwgZS5nIHRoZSBTU1Igb3B0aW1pemluZyBjb21waWxlci5cbi8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxudmFyIGNyZWF0ZUNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgfVxuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGUgPSByZWYkMS5jb21waWxlO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG52YXIgZGl2O1xuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBcIjxhIGhyZWY9XFxcIlxcblxcXCIvPlwiIDogXCI8ZGl2IGE9XFxcIlxcblxcXCIvPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxufVxuXG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xuLy8gIzY4Mjg6IGNocm9tZSBlbmNvZGVzIGNvbnRlbnQgaW4gYVtocmVmXVxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZSh0cnVlKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxudmFyIG1vdW50ID0gVnVlLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcbiAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue/dist/vue.esm.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./node_modules/bootstrap-vue/dist/bootstrap-vue.js");
/******/ 	
/******/ })()
;